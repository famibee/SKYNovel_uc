/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./core/app4webpack.js":
/*!*****************************!*\
  !*** ./core/app4webpack.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _plugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugin.js */ \"./core/plugin.js\");\n/* harmony import */ var _famibee_skynovel_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @famibee/skynovel/app */ \"./node_modules/@famibee/skynovel/dist/app.js\");\n\nObject.defineProperty(__webpack_exports__, \"__esModule\", ({ value: true }));\n// 変更後は「npm run webpack:dev」\n\nconst hPlg = {};\n\nfor (const nm in _plugin_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) hPlg[nm] = __webpack_require__(\"./core/plugin sync recursive ^\\\\.\\\\/.*$\")(`./${nm}`);\n\n\nnew _famibee_skynovel_app__WEBPACK_IMPORTED_MODULE_1__.SysApp(hPlg);\n\n\n//# sourceURL=webpack://uc/./core/app4webpack.js?");

/***/ }),

/***/ "./core/plugin.js":
/*!************************!*\
  !*** ./core/plugin.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\"humane\":0});\n\n//# sourceURL=webpack://uc/./core/plugin.js?");

/***/ }),

/***/ "./core/plugin/humane/index.js":
/*!*************************************!*\
  !*** ./core/plugin/humane/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst Humane = __webpack_require__(/*! humane-js */ \"./node_modules/humane-js/humane.js\");\n__webpack_require__(/*! !style-loader!css-loader!humane-js/themes/bigbox.css */ \"./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css\");\n\nexports.init = pia=> {\n\tHumane.baseCls = 'humane-bigbox';\n\tpia.addTag('notice', hArg=> {\n\t\tHumane.log(hArg.text);\n\t\treturn false;\n\t});\n};\n\n\n//# sourceURL=webpack://uc/./core/plugin/humane/index.js?");

/***/ }),

/***/ "./core/plugin sync recursive ^\\.\\/.*$":
/*!************************************!*\
  !*** ./core/plugin/ sync ^\.\/.*$ ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var map = {\n\t\"./humane\": \"./core/plugin/humane/index.js\",\n\t\"./humane/\": \"./core/plugin/humane/index.js\",\n\t\"./humane/index\": \"./core/plugin/humane/index.js\",\n\t\"./humane/index.js\": \"./core/plugin/humane/index.js\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./core/plugin sync recursive ^\\\\.\\\\/.*$\";\n\n//# sourceURL=webpack://uc/./core/plugin/_sync_^\\.\\/.*$?");

/***/ }),

/***/ "./node_modules/@famibee/skynovel/dist/app.js":
/*!****************************************************!*\
  !*** ./node_modules/@famibee/skynovel/dist/app.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CmnLib\": () => (/* binding */ Y),\n/* harmony export */   \"Layer\": () => (/* binding */ _r),\n/* harmony export */   \"SysApp\": () => (/* binding */ Y4),\n/* harmony export */   \"argChk_Boolean\": () => (/* binding */ vt),\n/* harmony export */   \"argChk_Num\": () => (/* binding */ tt)\n/* harmony export */ });\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ \"./node_modules/url/url.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\nvar $P = Object.defineProperty;\nvar VP = (i, t, e) => t in i ? $P(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;\nvar K = (i, t, e) => (VP(i, typeof t != \"symbol\" ? t + \"\" : t, e), e), S0 = (i, t, e) => {\n  if (!t.has(i))\n    throw TypeError(\"Cannot \" + e);\n};\nvar c = (i, t, e) => (S0(i, t, \"read from private field\"), e ? e.call(i) : t.get(i)), E = (i, t, e) => {\n  if (t.has(i))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  t instanceof WeakSet ? t.add(i) : t.set(i, e);\n}, P = (i, t, e, r) => (S0(i, t, \"write to private field\"), r ? r.call(i, e) : t.set(i, e), e), Ve = (i, t, e, r) => ({\n  set _(n) {\n    P(i, t, n, e);\n  },\n  get _() {\n    return c(i, t, r);\n  }\n}), O = (i, t, e) => (S0(i, t, \"access private method\"), e);\n\n\nvar Cp = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof __webpack_require__.g < \"u\" ? __webpack_require__.g : typeof self < \"u\" ? self : {}, bs = {}, qP = {\n  get exports() {\n    return bs;\n  },\n  set exports(i) {\n    bs = i;\n  }\n};\n/*!\n * Platform.js v1.3.6\n * Copyright 2014-2020 Benjamin Tan\n * Copyright 2011-2013 John-David Dalton\n * Available under MIT license\n */\n(function(i, t) {\n  (function() {\n    var e = {\n      function: !0,\n      object: !0\n    }, r = e[typeof window] && window || this, n = t, s = i && !i.nodeType && i, a = n && s && typeof Cp == \"object\" && Cp;\n    a && (a.global === a || a.window === a || a.self === a) && (r = a);\n    var o = Math.pow(2, 53) - 1, u = /\\bOpera/, l = Object.prototype, h = l.hasOwnProperty, d = l.toString;\n    function f(C) {\n      return C = String(C), C.charAt(0).toUpperCase() + C.slice(1);\n    }\n    function p(C, M, I) {\n      var R = {\n        \"10.0\": \"10\",\n        \"6.4\": \"10 Technical Preview\",\n        \"6.3\": \"8.1\",\n        \"6.2\": \"8\",\n        \"6.1\": \"Server 2008 R2 / 7\",\n        \"6.0\": \"Server 2008 / Vista\",\n        \"5.2\": \"Server 2003 / XP 64-bit\",\n        \"5.1\": \"XP\",\n        \"5.01\": \"2000 SP1\",\n        \"5.0\": \"2000\",\n        \"4.0\": \"NT\",\n        \"4.90\": \"ME\"\n      };\n      return M && I && /^Win/i.test(C) && !/^Windows Phone /i.test(C) && (R = R[/[\\d.]+$/.exec(C)]) && (C = \"Windows \" + R), C = String(C), M && I && (C = C.replace(RegExp(M, \"i\"), I)), C = g(\n        C.replace(/ ce$/i, \" CE\").replace(/\\bhpw/i, \"web\").replace(/\\bMacintosh\\b/, \"Mac OS\").replace(/_PowerPC\\b/i, \" OS\").replace(/\\b(OS X) [^ \\d]+/i, \"$1\").replace(/\\bMac (OS X)\\b/, \"$1\").replace(/\\/(\\d)/, \" $1\").replace(/_/g, \".\").replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, \"\").replace(/\\bx86\\.64\\b/gi, \"x86_64\").replace(/\\b(Windows Phone) OS\\b/, \"$1\").replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, \"$1\").split(\" on \")[0]\n      ), C;\n    }\n    function v(C, M) {\n      var I = -1, R = C ? C.length : 0;\n      if (typeof R == \"number\" && R > -1 && R <= o)\n        for (; ++I < R; )\n          M(C[I], I, C);\n      else\n        m(C, M);\n    }\n    function g(C) {\n      return C = T(C), /^(?:webOS|i(?:OS|P))/.test(C) ? C : f(C);\n    }\n    function m(C, M) {\n      for (var I in C)\n        h.call(C, I) && M(C[I], I, C);\n    }\n    function y(C) {\n      return C == null ? f(C) : d.call(C).slice(8, -1);\n    }\n    function _(C, M) {\n      var I = C != null ? typeof C[M] : \"number\";\n      return !/^(?:boolean|number|string|undefined)$/.test(I) && (I == \"object\" ? !!C[M] : !0);\n    }\n    function b(C) {\n      return String(C).replace(/([ -])(?!$)/g, \"$1?\");\n    }\n    function w(C, M) {\n      var I = null;\n      return v(C, function(R, N) {\n        I = M(I, R, N, C);\n      }), I;\n    }\n    function T(C) {\n      return String(C).replace(/^ +| +$/g, \"\");\n    }\n    function x(C) {\n      var M = r, I = C && typeof C == \"object\" && y(C) != \"String\";\n      I && (M = C, C = null);\n      var R = M.navigator || {}, N = R.userAgent || \"\";\n      C || (C = N);\n      var A = I ? !!R.likeChrome : /\\bChrome\\b/.test(C) && !/internal|\\n/i.test(d.toString()), U = \"Object\", B = I ? U : \"ScriptBridgingProxyObject\", G = I ? U : \"Environment\", $ = I && M.java ? \"JavaPackage\" : y(M.java), Z = I ? U : \"RuntimeObject\", H = /\\bJava/.test($) && M.java, z = H && y(M.environment) == G, X = H ? \"a\" : \"α\", ct = H ? \"b\" : \"β\", it = M.document || {}, lt = M.operamini || M.opera, et = u.test(et = I && lt ? lt[\"[[Class]]\"] : y(lt)) ? et : lt = null, k, ft = C, Q = [], St = null, at = C == N, q = at && lt && typeof lt.version == \"function\" && lt.version(), bt, st = xt([\n        { label: \"EdgeHTML\", pattern: \"Edge\" },\n        \"Trident\",\n        { label: \"WebKit\", pattern: \"AppleWebKit\" },\n        \"iCab\",\n        \"Presto\",\n        \"NetFront\",\n        \"Tasman\",\n        \"KHTML\",\n        \"Gecko\"\n      ]), W = Ct([\n        \"Adobe AIR\",\n        \"Arora\",\n        \"Avant Browser\",\n        \"Breach\",\n        \"Camino\",\n        \"Electron\",\n        \"Epiphany\",\n        \"Fennec\",\n        \"Flock\",\n        \"Galeon\",\n        \"GreenBrowser\",\n        \"iCab\",\n        \"Iceweasel\",\n        \"K-Meleon\",\n        \"Konqueror\",\n        \"Lunascape\",\n        \"Maxthon\",\n        { label: \"Microsoft Edge\", pattern: \"(?:Edge|Edg|EdgA|EdgiOS)\" },\n        \"Midori\",\n        \"Nook Browser\",\n        \"PaleMoon\",\n        \"PhantomJS\",\n        \"Raven\",\n        \"Rekonq\",\n        \"RockMelt\",\n        { label: \"Samsung Internet\", pattern: \"SamsungBrowser\" },\n        \"SeaMonkey\",\n        { label: \"Silk\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Sleipnir\",\n        \"SlimBrowser\",\n        { label: \"SRWare Iron\", pattern: \"Iron\" },\n        \"Sunrise\",\n        \"Swiftfox\",\n        \"Vivaldi\",\n        \"Waterfox\",\n        \"WebPositive\",\n        { label: \"Yandex Browser\", pattern: \"YaBrowser\" },\n        { label: \"UC Browser\", pattern: \"UCBrowser\" },\n        \"Opera Mini\",\n        { label: \"Opera Mini\", pattern: \"OPiOS\" },\n        \"Opera\",\n        { label: \"Opera\", pattern: \"OPR\" },\n        \"Chromium\",\n        \"Chrome\",\n        { label: \"Chrome\", pattern: \"(?:HeadlessChrome)\" },\n        { label: \"Chrome Mobile\", pattern: \"(?:CriOS|CrMo)\" },\n        { label: \"Firefox\", pattern: \"(?:Firefox|Minefield)\" },\n        { label: \"Firefox for iOS\", pattern: \"FxiOS\" },\n        { label: \"IE\", pattern: \"IEMobile\" },\n        { label: \"IE\", pattern: \"MSIE\" },\n        \"Safari\"\n      ]), nt = je([\n        { label: \"BlackBerry\", pattern: \"BB10\" },\n        \"BlackBerry\",\n        { label: \"Galaxy S\", pattern: \"GT-I9000\" },\n        { label: \"Galaxy S2\", pattern: \"GT-I9100\" },\n        { label: \"Galaxy S3\", pattern: \"GT-I9300\" },\n        { label: \"Galaxy S4\", pattern: \"GT-I9500\" },\n        { label: \"Galaxy S5\", pattern: \"SM-G900\" },\n        { label: \"Galaxy S6\", pattern: \"SM-G920\" },\n        { label: \"Galaxy S6 Edge\", pattern: \"SM-G925\" },\n        { label: \"Galaxy S7\", pattern: \"SM-G930\" },\n        { label: \"Galaxy S7 Edge\", pattern: \"SM-G935\" },\n        \"Google TV\",\n        \"Lumia\",\n        \"iPad\",\n        \"iPod\",\n        \"iPhone\",\n        \"Kindle\",\n        { label: \"Kindle Fire\", pattern: \"(?:Cloud9|Silk-Accelerated)\" },\n        \"Nexus\",\n        \"Nook\",\n        \"PlayBook\",\n        \"PlayStation Vita\",\n        \"PlayStation\",\n        \"TouchPad\",\n        \"Transformer\",\n        { label: \"Wii U\", pattern: \"WiiU\" },\n        \"Wii\",\n        \"Xbox One\",\n        { label: \"Xbox 360\", pattern: \"Xbox\" },\n        \"Xoom\"\n      ]), dt = Dt({\n        Apple: { iPad: 1, iPhone: 1, iPod: 1 },\n        Alcatel: {},\n        Archos: {},\n        Amazon: { Kindle: 1, \"Kindle Fire\": 1 },\n        Asus: { Transformer: 1 },\n        \"Barnes & Noble\": { Nook: 1 },\n        BlackBerry: { PlayBook: 1 },\n        Google: { \"Google TV\": 1, Nexus: 1 },\n        HP: { TouchPad: 1 },\n        HTC: {},\n        Huawei: {},\n        Lenovo: {},\n        LG: {},\n        Microsoft: { Xbox: 1, \"Xbox One\": 1 },\n        Motorola: { Xoom: 1 },\n        Nintendo: { \"Wii U\": 1, Wii: 1 },\n        Nokia: { Lumia: 1 },\n        Oppo: {},\n        Samsung: { \"Galaxy S\": 1, \"Galaxy S2\": 1, \"Galaxy S3\": 1, \"Galaxy S4\": 1 },\n        Sony: { PlayStation: 1, \"PlayStation Vita\": 1 },\n        Xiaomi: { Mi: 1, Redmi: 1 }\n      }), V = be([\n        \"Windows Phone\",\n        \"KaiOS\",\n        \"Android\",\n        \"CentOS\",\n        { label: \"Chrome OS\", pattern: \"CrOS\" },\n        \"Debian\",\n        { label: \"DragonFly BSD\", pattern: \"DragonFly\" },\n        \"Fedora\",\n        \"FreeBSD\",\n        \"Gentoo\",\n        \"Haiku\",\n        \"Kubuntu\",\n        \"Linux Mint\",\n        \"OpenBSD\",\n        \"Red Hat\",\n        \"SuSE\",\n        \"Ubuntu\",\n        \"Xubuntu\",\n        \"Cygwin\",\n        \"Symbian OS\",\n        \"hpwOS\",\n        \"webOS \",\n        \"webOS\",\n        \"Tablet OS\",\n        \"Tizen\",\n        \"Linux\",\n        \"Mac OS X\",\n        \"Macintosh\",\n        \"Mac\",\n        \"Windows 98;\",\n        \"Windows \"\n      ]);\n      function xt(se) {\n        return w(se, function(ne, Ht) {\n          return ne || RegExp(\"\\\\b\" + (Ht.pattern || b(Ht)) + \"\\\\b\", \"i\").exec(C) && (Ht.label || Ht);\n        });\n      }\n      function Dt(se) {\n        return w(se, function(ne, Ht, xr) {\n          return ne || (Ht[nt] || Ht[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(nt)] || RegExp(\"\\\\b\" + b(xr) + \"(?:\\\\b|\\\\w*\\\\d)\", \"i\").exec(C)) && xr;\n        });\n      }\n      function Ct(se) {\n        return w(se, function(ne, Ht) {\n          return ne || RegExp(\"\\\\b\" + (Ht.pattern || b(Ht)) + \"\\\\b\", \"i\").exec(C) && (Ht.label || Ht);\n        });\n      }\n      function be(se) {\n        return w(se, function(ne, Ht) {\n          var xr = Ht.pattern || b(Ht);\n          return !ne && (ne = RegExp(\"\\\\b\" + xr + \"(?:/[\\\\d.]+|[ \\\\w.]*)\", \"i\").exec(C)) && (ne = p(ne, xr, Ht.label || Ht)), ne;\n        });\n      }\n      function je(se) {\n        return w(se, function(ne, Ht) {\n          var xr = Ht.pattern || b(Ht);\n          return !ne && (ne = RegExp(\"\\\\b\" + xr + \" *\\\\d+[.\\\\w_]*\", \"i\").exec(C) || RegExp(\"\\\\b\" + xr + \" *\\\\w+-[\\\\w]*\", \"i\").exec(C) || RegExp(\"\\\\b\" + xr + \"(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)\", \"i\").exec(C)) && ((ne = String(Ht.label && !RegExp(xr, \"i\").test(Ht.label) ? Ht.label : ne).split(\"/\"))[1] && !/[\\d.]+/.test(ne[0]) && (ne[0] += \" \" + ne[1]), Ht = Ht.label || Ht, ne = g(ne[0].replace(RegExp(xr, \"i\"), Ht).replace(RegExp(\"; *(?:\" + Ht + \"[_-])?\", \"i\"), \" \").replace(RegExp(\"(\" + Ht + \")[-_.]?(\\\\w)\", \"i\"), \"$1 $2\"))), ne;\n        });\n      }\n      function ee(se) {\n        return w(se, function(ne, Ht) {\n          return ne || (RegExp(Ht + \"(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)\", \"i\").exec(C) || 0)[1] || null;\n        });\n      }\n      function de() {\n        return this.description || \"\";\n      }\n      if (st && (st = [st]), /\\bAndroid\\b/.test(V) && !nt && (k = /\\bAndroid[^;]*;(.*?)(?:Build|\\) AppleWebKit)\\b/i.exec(C)) && (nt = T(k[1]).replace(/^[a-z]{2}-[a-z]{2};\\s*/i, \"\") || null), dt && !nt ? nt = je([dt]) : dt && nt && (nt = nt.replace(RegExp(\"^(\" + b(dt) + \")[-_.\\\\s]\", \"i\"), dt + \" \").replace(RegExp(\"^(\" + b(dt) + \")[-_.]?(\\\\w)\", \"i\"), dt + \" $2\")), (k = /\\bGoogle TV\\b/.exec(nt)) && (nt = k[0]), /\\bSimulator\\b/i.test(C) && (nt = (nt ? nt + \" \" : \"\") + \"Simulator\"), W == \"Opera Mini\" && /\\bOPiOS\\b/.test(C) && Q.push(\"running in Turbo/Uncompressed mode\"), W == \"IE\" && /\\blike iPhone OS\\b/.test(C) ? (k = x(C.replace(/like iPhone OS/, \"\")), dt = k.manufacturer, nt = k.product) : /^iP/.test(nt) ? (W || (W = \"Safari\"), V = \"iOS\" + ((k = / OS ([\\d_]+)/i.exec(C)) ? \" \" + k[1].replace(/_/g, \".\") : \"\")) : W == \"Konqueror\" && /^Linux\\b/i.test(V) ? V = \"Kubuntu\" : dt && dt != \"Google\" && (/Chrome/.test(W) && !/\\bMobile Safari\\b/i.test(C) || /\\bVita\\b/.test(nt)) || /\\bAndroid\\b/.test(V) && /^Chrome/.test(W) && /\\bVersion\\//i.test(C) ? (W = \"Android Browser\", V = /\\bAndroid\\b/.test(V) ? V : \"Android\") : W == \"Silk\" ? (/\\bMobi/i.test(C) || (V = \"Android\", Q.unshift(\"desktop mode\")), /Accelerated *= *true/i.test(C) && Q.unshift(\"accelerated\")) : W == \"UC Browser\" && /\\bUCWEB\\b/.test(C) ? Q.push(\"speed mode\") : W == \"PaleMoon\" && (k = /\\bFirefox\\/([\\d.]+)\\b/.exec(C)) ? Q.push(\"identifying as Firefox \" + k[1]) : W == \"Firefox\" && (k = /\\b(Mobile|Tablet|TV)\\b/i.exec(C)) ? (V || (V = \"Firefox OS\"), nt || (nt = k[1])) : !W || (k = !/\\bMinefield\\b/i.test(C) && /\\b(?:Firefox|Safari)\\b/.exec(W)) ? (W && !nt && /[\\/,]|^[^(]+?\\)/.test(C.slice(C.indexOf(k + \"/\") + 8)) && (W = null), (k = nt || dt || V) && (nt || dt || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(V)) && (W = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(V) ? V : k) + \" Browser\")) : W == \"Electron\" && (k = (/\\bChrome\\/([\\d.]+)\\b/.exec(C) || 0)[1]) && Q.push(\"Chromium \" + k), q || (q = ee([\n        \"(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$)|UCBrowser|YaBrowser)\",\n        \"Version\",\n        b(W),\n        \"(?:Firefox|Minefield|NetFront)\"\n      ])), (k = st == \"iCab\" && parseFloat(q) > 3 && \"WebKit\" || /\\bOpera\\b/.test(W) && (/\\bOPR\\b/.test(C) ? \"Blink\" : \"Presto\") || /\\b(?:Midori|Nook|Safari)\\b/i.test(C) && !/^(?:Trident|EdgeHTML)$/.test(st) && \"WebKit\" || !st && /\\bMSIE\\b/i.test(C) && (V == \"Mac OS\" ? \"Tasman\" : \"Trident\") || st == \"WebKit\" && /\\bPlayStation\\b(?! Vita\\b)/i.test(W) && \"NetFront\") && (st = [k]), W == \"IE\" && (k = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(C) || 0)[1]) ? (W += \" Mobile\", V = \"Windows Phone \" + (/\\+$/.test(k) ? k : k + \".x\"), Q.unshift(\"desktop mode\")) : /\\bWPDesktop\\b/i.test(C) ? (W = \"IE Mobile\", V = \"Windows Phone 8.x\", Q.unshift(\"desktop mode\"), q || (q = (/\\brv:([\\d.]+)/.exec(C) || 0)[1])) : W != \"IE\" && st == \"Trident\" && (k = /\\brv:([\\d.]+)/.exec(C)) && (W && Q.push(\"identifying as \" + W + (q ? \" \" + q : \"\")), W = \"IE\", q = k[1]), at) {\n        if (_(M, \"global\"))\n          if (H && (k = H.lang.System, ft = k.getProperty(\"os.arch\"), V = V || k.getProperty(\"os.name\") + \" \" + k.getProperty(\"os.version\")), z) {\n            try {\n              q = M.require(\"ringo/engine\").version.join(\".\"), W = \"RingoJS\";\n            } catch {\n              (k = M.system) && k.global.system == M.system && (W = \"Narwhal\", V || (V = k[0].os || null));\n            }\n            W || (W = \"Rhino\");\n          } else\n            typeof M.process == \"object\" && !M.process.browser && (k = M.process) && (typeof k.versions == \"object\" && (typeof k.versions.electron == \"string\" ? (Q.push(\"Node \" + k.versions.node), W = \"Electron\", q = k.versions.electron) : typeof k.versions.nw == \"string\" && (Q.push(\"Chromium \" + q, \"Node \" + k.versions.node), W = \"NW.js\", q = k.versions.nw)), W || (W = \"Node.js\", ft = k.arch, V = k.platform, q = /[\\d.]+/.exec(k.version), q = q ? q[0] : null));\n        else\n          y(k = M.runtime) == B ? (W = \"Adobe AIR\", V = k.flash.system.Capabilities.os) : y(k = M.phantom) == Z ? (W = \"PhantomJS\", q = (k = k.version || null) && k.major + \".\" + k.minor + \".\" + k.patch) : typeof it.documentMode == \"number\" && (k = /\\bTrident\\/(\\d+)/i.exec(C)) ? (q = [q, it.documentMode], (k = +k[1] + 4) != q[1] && (Q.push(\"IE \" + q[1] + \" mode\"), st && (st[1] = \"\"), q[1] = k), q = W == \"IE\" ? String(q[1].toFixed(1)) : q[0]) : typeof it.documentMode == \"number\" && /^(?:Chrome|Firefox)\\b/.test(W) && (Q.push(\"masking as \" + W + \" \" + q), W = \"IE\", q = \"11.0\", st = [\"Trident\"], V = \"Windows\");\n        V = V && g(V);\n      }\n      if (q && (k = /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(q) || /(?:alpha|beta)(?: ?\\d)?/i.exec(C + \";\" + (at && R.appMinorVersion)) || /\\bMinefield\\b/i.test(C) && \"a\") && (St = /b/i.test(k) ? \"beta\" : \"alpha\", q = q.replace(RegExp(k + \"\\\\+?$\"), \"\") + (St == \"beta\" ? ct : X) + (/\\d+\\+?/.exec(k) || \"\")), W == \"Fennec\" || W == \"Firefox\" && /\\b(?:Android|Firefox OS|KaiOS)\\b/.test(V))\n        W = \"Firefox Mobile\";\n      else if (W == \"Maxthon\" && q)\n        q = q.replace(/\\.[\\d.]+/, \".x\");\n      else if (/\\bXbox\\b/i.test(nt))\n        nt == \"Xbox 360\" && (V = null), nt == \"Xbox 360\" && /\\bIEMobile\\b/.test(C) && Q.unshift(\"mobile mode\");\n      else if ((/^(?:Chrome|IE|Opera)$/.test(W) || W && !nt && !/Browser|Mobi/.test(W)) && (V == \"Windows CE\" || /Mobi/i.test(C)))\n        W += \" Mobile\";\n      else if (W == \"IE\" && at)\n        try {\n          M.external === null && Q.unshift(\"platform preview\");\n        } catch {\n          Q.unshift(\"embedded\");\n        }\n      else\n        (/\\bBlackBerry\\b/.test(nt) || /\\bBB10\\b/.test(C)) && (k = (RegExp(nt.replace(/ +/g, \" *\") + \"/([.\\\\d]+)\", \"i\").exec(C) || 0)[1] || q) ? (k = [k, /BB10/.test(C)], V = (k[1] ? (nt = null, dt = \"BlackBerry\") : \"Device Software\") + \" \" + k[0], q = null) : this != m && nt != \"Wii\" && (at && lt || /Opera/.test(W) && /\\b(?:MSIE|Firefox)\\b/i.test(C) || W == \"Firefox\" && /\\bOS X (?:\\d+\\.){2,}/.test(V) || W == \"IE\" && (V && !/^Win/.test(V) && q > 5.5 || /\\bWindows XP\\b/.test(V) && q > 8 || q == 8 && !/\\bTrident\\b/.test(C))) && !u.test(k = x.call(m, C.replace(u, \"\") + \";\")) && k.name && (k = \"ing as \" + k.name + ((k = k.version) ? \" \" + k : \"\"), u.test(W) ? (/\\bIE\\b/.test(k) && V == \"Mac OS\" && (V = null), k = \"identify\" + k) : (k = \"mask\" + k, et ? W = g(et.replace(/([a-z])([A-Z])/g, \"$1 $2\")) : W = \"Opera\", /\\bIE\\b/.test(k) && (V = null), at || (q = null)), st = [\"Presto\"], Q.push(k));\n      (k = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(C) || 0)[1]) && (k = [parseFloat(k.replace(/\\.(\\d)$/, \".0$1\")), k], W == \"Safari\" && k[1].slice(-1) == \"+\" ? (W = \"WebKit Nightly\", St = \"alpha\", q = k[1].slice(0, -1)) : (q == k[1] || q == (k[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(C) || 0)[1])) && (q = null), k[1] = (/\\b(?:Headless)?Chrome\\/([\\d.]+)/i.exec(C) || 0)[1], k[0] == 537.36 && k[2] == 537.36 && parseFloat(k[1]) >= 28 && st == \"WebKit\" && (st = [\"Blink\"]), !at || !A && !k[1] ? (st && (st[1] = \"like Safari\"), k = (k = k[0], k < 400 ? 1 : k < 500 ? 2 : k < 526 ? 3 : k < 533 ? 4 : k < 534 ? \"4+\" : k < 535 ? 5 : k < 537 ? 6 : k < 538 ? 7 : k < 601 ? 8 : k < 602 ? 9 : k < 604 ? 10 : k < 606 ? 11 : k < 608 ? 12 : \"12\")) : (st && (st[1] = \"like Chrome\"), k = k[1] || (k = k[0], k < 530 ? 1 : k < 532 ? 2 : k < 532.05 ? 3 : k < 533 ? 4 : k < 534.03 ? 5 : k < 534.07 ? 6 : k < 534.1 ? 7 : k < 534.13 ? 8 : k < 534.16 ? 9 : k < 534.24 ? 10 : k < 534.3 ? 11 : k < 535.01 ? 12 : k < 535.02 ? \"13+\" : k < 535.07 ? 15 : k < 535.11 ? 16 : k < 535.19 ? 17 : k < 536.05 ? 18 : k < 536.1 ? 19 : k < 537.01 ? 20 : k < 537.11 ? \"21+\" : k < 537.13 ? 23 : k < 537.18 ? 24 : k < 537.24 ? 25 : k < 537.36 ? 26 : st != \"Blink\" ? \"27\" : \"28\")), st && (st[1] += \" \" + (k += typeof k == \"number\" ? \".x\" : /[.+]/.test(k) ? \"\" : \"+\")), W == \"Safari\" && (!q || parseInt(q) > 45) ? q = k : W == \"Chrome\" && /\\bHeadlessChrome/i.test(C) && Q.unshift(\"headless\")), W == \"Opera\" && (k = /\\bzbov|zvav$/.exec(V)) ? (W += \" \", Q.unshift(\"desktop mode\"), k == \"zvav\" ? (W += \"Mini\", q = null) : W += \"Mobile\", V = V.replace(RegExp(\" *\" + k + \"$\"), \"\")) : W == \"Safari\" && /\\bChrome\\b/.exec(st && st[1]) ? (Q.unshift(\"desktop mode\"), W = \"Chrome Mobile\", q = null, /\\bOS X\\b/.test(V) ? (dt = \"Apple\", V = \"iOS 4.3+\") : V = null) : /\\bSRWare Iron\\b/.test(W) && !q && (q = ee(\"Chrome\")), q && q.indexOf(k = /[\\d.]+$/.exec(V)) == 0 && C.indexOf(\"/\" + k + \"-\") > -1 && (V = T(V.replace(k, \"\"))), V && V.indexOf(W) != -1 && !RegExp(W + \" OS\").test(V) && (V = V.replace(RegExp(\" *\" + b(W) + \" *\"), \"\")), st && !/\\b(?:Avant|Nook)\\b/.test(W) && (/Browser|Lunascape|Maxthon/.test(W) || W != \"Safari\" && /^iOS/.test(V) && /\\bSafari\\b/.test(st[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(W) && st[1]) && (k = st[st.length - 1]) && Q.push(k), Q.length && (Q = [\"(\" + Q.join(\"; \") + \")\"]), dt && nt && nt.indexOf(dt) < 0 && Q.push(\"on \" + dt), nt && Q.push((/^on /.test(Q[Q.length - 1]) ? \"\" : \"on \") + nt), V && (k = / ([\\d.+]+)$/.exec(V), bt = k && V.charAt(V.length - k[0].length - 1) == \"/\", V = {\n        architecture: 32,\n        family: k && !bt ? V.replace(k[0], \"\") : V,\n        version: k ? k[1] : null,\n        toString: function() {\n          var se = this.version;\n          return this.family + (se && !bt ? \" \" + se : \"\") + (this.architecture == 64 ? \" 64-bit\" : \"\");\n        }\n      }), (k = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec(ft)) && !/\\bi686\\b/i.test(ft) ? (V && (V.architecture = 64, V.family = V.family.replace(RegExp(\" *\" + k), \"\")), W && (/\\bWOW64\\b/i.test(C) || at && /\\w(?:86|32)$/.test(R.cpuClass || R.platform) && !/\\bWin64; x64\\b/i.test(C)) && Q.unshift(\"32-bit\")) : V && /^OS X/.test(V.family) && W == \"Chrome\" && parseFloat(q) >= 39 && (V.architecture = 64), C || (C = null);\n      var ue = {};\n      return ue.description = C, ue.layout = st && st[0], ue.manufacturer = dt, ue.name = W, ue.prerelease = St, ue.product = nt, ue.ua = C, ue.version = W && q, ue.os = V || {\n        /**\n         * The CPU architecture the OS is built for.\n         *\n         * @memberOf platform.os\n         * @type number|null\n         */\n        architecture: null,\n        /**\n         * The family of the OS.\n         *\n         * Common values include:\n         * \"Windows\", \"Windows Server 2008 R2 / 7\", \"Windows Server 2008 / Vista\",\n         * \"Windows XP\", \"OS X\", \"Linux\", \"Ubuntu\", \"Debian\", \"Fedora\", \"Red Hat\",\n         * \"SuSE\", \"Android\", \"iOS\" and \"Windows Phone\"\n         *\n         * @memberOf platform.os\n         * @type string|null\n         */\n        family: null,\n        /**\n         * The version of the OS.\n         *\n         * @memberOf platform.os\n         * @type string|null\n         */\n        version: null,\n        /**\n         * Returns the OS string.\n         *\n         * @memberOf platform.os\n         * @returns {string} The OS string.\n         */\n        toString: function() {\n          return \"null\";\n        }\n      }, ue.parse = x, ue.toString = de, ue.version && Q.unshift(q), ue.name && Q.unshift(W), V && W && !(V == String(V).split(\" \")[0] && (V == W.split(\" \")[0] || nt)) && Q.push(nt ? \"(\" + V + \")\" : \"on \" + V), Q.length && (ue.description = Q.join(\" \")), ue;\n    }\n    var S = x();\n    n && s ? m(S, function(C, M) {\n      n[M] = C;\n    }) : r.platform = S;\n  }).call(Cp);\n})(qP, bs);\nfunction $t(i) {\n  return parseInt(String(i), 10);\n}\nfunction ni(i) {\n  const t = parseInt(String(i), 10);\n  return t < 0 ? -t : t;\n}\n\"toInt\" in String.prototype || (String.prototype.toInt = function() {\n  return $t(this);\n});\n\"toUint\" in String.prototype || (String.prototype.toUint = function() {\n  const i = $t(this);\n  return i < 0 ? -i : i;\n});\nfunction rc(i = \"/\", t = \" \", e = \":\", r = \"\") {\n  const n = /* @__PURE__ */ new Date();\n  return n.getFullYear() + i + String(100 + n.getMonth() + 1).slice(1, 3) + i + String(100 + n.getDate()).slice(1, 3) + t + String(100 + n.getHours()).slice(1, 3) + e + String(100 + n.getMinutes()).slice(1, 3) + (r === \"\" ? \"\" : r + String(n.getMilliseconds()));\n}\nconst bE = {\n  alpha: 0,\n  height: 0,\n  rotation: 0,\n  scale_x: 0,\n  scale_y: 0,\n  pivot_x: 0,\n  pivot_y: 0,\n  width: 0,\n  x: 0,\n  y: 0\n};\nfunction ov(i, t) {\n  const e = {};\n  for (const r of Object.keys(bE)) {\n    if (!(r in i))\n      continue;\n    const n = String(i[r]), s = (n.at(0) === \"=\" ? n.slice(1) : n).split(\",\"), a = e[r] = parseFloat(s[0]);\n    s.length > 1 && (e[r] += Math.round(Math.random() * (parseFloat(s[1]) - a + 1))), n.at(0) === \"=\" && (e[r] += parseFloat(t[r]));\n  }\n  return e;\n}\nconst xE = \"/* SKYNovel */\";\nfunction ZP() {\n  const i = document.getElementsByTagName(\"head\")[0], t = i.children.length;\n  for (let e = t - 1; e >= 0; --e) {\n    const r = i.children[e];\n    r instanceof HTMLStyleElement && r.innerText.slice(0, 14) === xE && i.removeChild(r);\n  }\n}\nfunction Lu(i) {\n  const t = document.createElement(\"style\");\n  t.innerHTML = xE + i, document.getElementsByTagName(\"head\")[0].appendChild(t);\n}\nfunction tt(i, t, e) {\n  const r = i[t];\n  if (!(t in i)) {\n    if (isNaN(e))\n      throw `[${i[\":タグ名\"]}]属性 ${t} は必須です`;\n    return i[t] = e, e;\n  }\n  const n = String(r).slice(0, 2) === \"0x\" ? parseInt(r) : parseFloat(r);\n  if (isNaN(n))\n    throw `[${i[\":タグ名\"]}]属性 ${t} の値【${r}】が数値ではありません`;\n  return i[t] = n;\n}\nfunction vt(i, t, e) {\n  if (!(t in i))\n    return i[t] = e;\n  const r = i[t];\n  if (r === null)\n    return !1;\n  const n = String(r);\n  return i[t] = n === \"false\" ? !1 : !!n;\n}\nfunction xb(i) {\n  if (i.at(0) === \"#\")\n    return parseInt(i.slice(1), 16);\n  const t = Number(i);\n  if (!isNaN(t))\n    return t;\n  if (i === \"black\")\n    return 0;\n  Y.cc4ColorName.fillStyle = i;\n  const e = Y.cc4ColorName.fillStyle;\n  if (e === \"#000000\")\n    throw `色名前 ${i} が異常です`;\n  return parseInt(e.slice(1), 16);\n}\nfunction wE(i, t, e) {\n  const r = i[t];\n  return r ? i[t] = xb(String(r)) : i[t] = e;\n}\nconst KP = /JSON at position (\\d+)$/;\nfunction Mp(i, t = \"\", e = \"\") {\n  const r = (e.match(KP) ?? [\"\", \"\"])[1];\n  return `[${i[\":タグ名\"]}] ${t} 属性の解析エラー : ${e}\n${i[t]}${r ? `\n${\"^\".padStart(Number(r))}` : \"\"}`;\n}\nconst JP = /^[^\\/\\.]+$|[^\\/]+(?=\\.)/;\nfunction Xh(i) {\n  return (i.match(JP) ?? [\"\"])[0];\n}\nconst QP = /\\.([^\\.]+)$/;\nfunction uv(i) {\n  return (i.match(QP) ?? [\"\", \"\"])[1];\n}\nvar mE, yE;\nclass Y {\n}\nK(Y, \"stageW\", 0), K(Y, \"stageH\", 0), K(Y, \"debugLog\", !1), K(Y, \"isSafari\", bs.name === \"Safari\"), K(Y, \"isFirefox\", bs.name === \"Firefox\"), K(Y, \"isMac\", new RegExp(\"OS X\").test(((mE = bs.os) == null ? void 0 : mE.family) ?? \"\")), K(Y, \"isMobile\", !new RegExp(\"(Windows|OS X)\").test(((yE = bs.os) == null ? void 0 : yE.family) ?? \"\")), K(Y, \"hDip\", {}), K(Y, \"isDbg\", !1), K(Y, \"isPackaged\", !1), K(Y, \"isDarkMode\", !1), K(Y, \"cc4ColorName\");\nfunction tO(i) {\n  var t = this.constructor;\n  return this.then(\n    function(e) {\n      return t.resolve(i()).then(function() {\n        return e;\n      });\n    },\n    function(e) {\n      return t.resolve(i()).then(function() {\n        return t.reject(e);\n      });\n    }\n  );\n}\nfunction eO(i) {\n  var t = this;\n  return new t(function(e, r) {\n    if (!(i && typeof i.length < \"u\"))\n      return r(\n        new TypeError(\n          typeof i + \" \" + i + \" is not iterable(cannot read property Symbol(Symbol.iterator))\"\n        )\n      );\n    var n = Array.prototype.slice.call(i);\n    if (n.length === 0)\n      return e([]);\n    var s = n.length;\n    function a(u, l) {\n      if (l && (typeof l == \"object\" || typeof l == \"function\")) {\n        var h = l.then;\n        if (typeof h == \"function\") {\n          h.call(\n            l,\n            function(d) {\n              a(u, d);\n            },\n            function(d) {\n              n[u] = { status: \"rejected\", reason: d }, --s === 0 && e(n);\n            }\n          );\n          return;\n        }\n      }\n      n[u] = { status: \"fulfilled\", value: l }, --s === 0 && e(n);\n    }\n    for (var o = 0; o < n.length; o++)\n      a(o, n[o]);\n  });\n}\nfunction EE(i, t) {\n  this.name = \"AggregateError\", this.errors = i, this.message = t || \"\";\n}\nEE.prototype = Error.prototype;\nfunction rO(i) {\n  var t = this;\n  return new t(function(e, r) {\n    if (!(i && typeof i.length < \"u\"))\n      return r(new TypeError(\"Promise.any accepts an array\"));\n    var n = Array.prototype.slice.call(i);\n    if (n.length === 0)\n      return r();\n    for (var s = [], a = 0; a < n.length; a++)\n      try {\n        t.resolve(n[a]).then(e).catch(function(o) {\n          s.push(o), s.length === n.length && r(\n            new EE(\n              s,\n              \"All promises were rejected\"\n            )\n          );\n        });\n      } catch (o) {\n        r(o);\n      }\n  });\n}\nvar iO = setTimeout;\nfunction SE(i) {\n  return !!(i && typeof i.length < \"u\");\n}\nfunction nO() {\n}\nfunction sO(i, t) {\n  return function() {\n    i.apply(t, arguments);\n  };\n}\nfunction Fe(i) {\n  if (!(this instanceof Fe))\n    throw new TypeError(\"Promises must be constructed via new\");\n  if (typeof i != \"function\")\n    throw new TypeError(\"not a function\");\n  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], CE(i, this);\n}\nfunction TE(i, t) {\n  for (; i._state === 3; )\n    i = i._value;\n  if (i._state === 0) {\n    i._deferreds.push(t);\n    return;\n  }\n  i._handled = !0, Fe._immediateFn(function() {\n    var e = i._state === 1 ? t.onFulfilled : t.onRejected;\n    if (e === null) {\n      (i._state === 1 ? dy : ic)(t.promise, i._value);\n      return;\n    }\n    var r;\n    try {\n      r = e(i._value);\n    } catch (n) {\n      ic(t.promise, n);\n      return;\n    }\n    dy(t.promise, r);\n  });\n}\nfunction dy(i, t) {\n  try {\n    if (t === i)\n      throw new TypeError(\"A promise cannot be resolved with itself.\");\n    if (t && (typeof t == \"object\" || typeof t == \"function\")) {\n      var e = t.then;\n      if (t instanceof Fe) {\n        i._state = 3, i._value = t, py(i);\n        return;\n      } else if (typeof e == \"function\") {\n        CE(sO(e, t), i);\n        return;\n      }\n    }\n    i._state = 1, i._value = t, py(i);\n  } catch (r) {\n    ic(i, r);\n  }\n}\nfunction ic(i, t) {\n  i._state = 2, i._value = t, py(i);\n}\nfunction py(i) {\n  i._state === 2 && i._deferreds.length === 0 && Fe._immediateFn(function() {\n    i._handled || Fe._unhandledRejectionFn(i._value);\n  });\n  for (var t = 0, e = i._deferreds.length; t < e; t++)\n    TE(i, i._deferreds[t]);\n  i._deferreds = null;\n}\nfunction aO(i, t, e) {\n  this.onFulfilled = typeof i == \"function\" ? i : null, this.onRejected = typeof t == \"function\" ? t : null, this.promise = e;\n}\nfunction CE(i, t) {\n  var e = !1;\n  try {\n    i(\n      function(r) {\n        e || (e = !0, dy(t, r));\n      },\n      function(r) {\n        e || (e = !0, ic(t, r));\n      }\n    );\n  } catch (r) {\n    if (e)\n      return;\n    e = !0, ic(t, r);\n  }\n}\nFe.prototype.catch = function(i) {\n  return this.then(null, i);\n};\nFe.prototype.then = function(i, t) {\n  var e = new this.constructor(nO);\n  return TE(this, new aO(i, t, e)), e;\n};\nFe.prototype.finally = tO;\nFe.all = function(i) {\n  return new Fe(function(t, e) {\n    if (!SE(i))\n      return e(new TypeError(\"Promise.all accepts an array\"));\n    var r = Array.prototype.slice.call(i);\n    if (r.length === 0)\n      return t([]);\n    var n = r.length;\n    function s(o, u) {\n      try {\n        if (u && (typeof u == \"object\" || typeof u == \"function\")) {\n          var l = u.then;\n          if (typeof l == \"function\") {\n            l.call(\n              u,\n              function(h) {\n                s(o, h);\n              },\n              e\n            );\n            return;\n          }\n        }\n        r[o] = u, --n === 0 && t(r);\n      } catch (h) {\n        e(h);\n      }\n    }\n    for (var a = 0; a < r.length; a++)\n      s(a, r[a]);\n  });\n};\nFe.any = rO;\nFe.allSettled = eO;\nFe.resolve = function(i) {\n  return i && typeof i == \"object\" && i.constructor === Fe ? i : new Fe(function(t) {\n    t(i);\n  });\n};\nFe.reject = function(i) {\n  return new Fe(function(t, e) {\n    e(i);\n  });\n};\nFe.race = function(i) {\n  return new Fe(function(t, e) {\n    if (!SE(i))\n      return e(new TypeError(\"Promise.race accepts an array\"));\n    for (var r = 0, n = i.length; r < n; r++)\n      Fe.resolve(i[r]).then(t, e);\n  });\n};\nFe._immediateFn = // @ts-ignore\ntypeof setImmediate == \"function\" && function(i) {\n  setImmediate(i);\n} || function(i) {\n  iO(i, 0);\n};\nFe._unhandledRejectionFn = function(t) {\n  typeof console < \"u\" && console && console.warn(\"Possible Unhandled Promise Rejection:\", t);\n};\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\nvar Jx = Object.getOwnPropertySymbols, oO = Object.prototype.hasOwnProperty, uO = Object.prototype.propertyIsEnumerable;\nfunction lO(i) {\n  if (i == null)\n    throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(i);\n}\nfunction hO() {\n  try {\n    if (!Object.assign)\n      return !1;\n    var i = new String(\"abc\");\n    if (i[5] = \"de\", Object.getOwnPropertyNames(i)[0] === \"5\")\n      return !1;\n    for (var t = {}, e = 0; e < 10; e++)\n      t[\"_\" + String.fromCharCode(e)] = e;\n    var r = Object.getOwnPropertyNames(t).map(function(s) {\n      return t[s];\n    });\n    if (r.join(\"\") !== \"0123456789\")\n      return !1;\n    var n = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function(s) {\n      n[s] = s;\n    }), Object.keys(Object.assign({}, n)).join(\"\") === \"abcdefghijklmnopqrst\";\n  } catch {\n    return !1;\n  }\n}\nvar cO = hO() ? Object.assign : function(i, t) {\n  for (var e, r = lO(i), n, s = 1; s < arguments.length; s++) {\n    e = Object(arguments[s]);\n    for (var a in e)\n      oO.call(e, a) && (r[a] = e[a]);\n    if (Jx) {\n      n = Jx(e);\n      for (var o = 0; o < n.length; o++)\n        uO.call(e, n[o]) && (r[n[o]] = e[n[o]]);\n    }\n  }\n  return r;\n};\n/*!\n * @pixi/polyfill - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/polyfill is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ntypeof globalThis > \"u\" && (typeof self < \"u\" ? self.globalThis = self : typeof __webpack_require__.g < \"u\" && (__webpack_require__.g.globalThis = __webpack_require__.g));\nglobalThis.Promise || (globalThis.Promise = Fe);\nObject.assign || (Object.assign = cO);\nvar fO = 16;\nDate.now && Date.prototype.getTime || (Date.now = function() {\n  return (/* @__PURE__ */ new Date()).getTime();\n});\nif (!(globalThis.performance && globalThis.performance.now)) {\n  var dO = Date.now();\n  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {\n    return Date.now() - dO;\n  };\n}\nvar T0 = Date.now(), Qx = [\"ms\", \"moz\", \"webkit\", \"o\"];\nfor (var C0 = 0; C0 < Qx.length && !globalThis.requestAnimationFrame; ++C0) {\n  var M0 = Qx[C0];\n  globalThis.requestAnimationFrame = globalThis[M0 + \"RequestAnimationFrame\"], globalThis.cancelAnimationFrame = globalThis[M0 + \"CancelAnimationFrame\"] || globalThis[M0 + \"CancelRequestAnimationFrame\"];\n}\nglobalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(i) {\n  if (typeof i != \"function\")\n    throw new TypeError(i + \"is not a function\");\n  var t = Date.now(), e = fO + T0 - t;\n  return e < 0 && (e = 0), T0 = t, globalThis.self.setTimeout(function() {\n    T0 = Date.now(), i(performance.now());\n  }, e);\n});\nglobalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(i) {\n  return clearTimeout(i);\n});\nMath.sign || (Math.sign = function(t) {\n  return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;\n});\nNumber.isInteger || (Number.isInteger = function(t) {\n  return typeof t == \"number\" && isFinite(t) && Math.floor(t) === t;\n});\nglobalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);\nglobalThis.Float32Array || (globalThis.Float32Array = Array);\nglobalThis.Uint32Array || (globalThis.Uint32Array = Array);\nglobalThis.Uint16Array || (globalThis.Uint16Array = Array);\nglobalThis.Uint8Array || (globalThis.Uint8Array = Array);\nglobalThis.Int32Array || (globalThis.Int32Array = Array);\n/*!\n * @pixi/constants - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/constants is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Ts;\n(function(i) {\n  i[i.WEBGL_LEGACY = 0] = \"WEBGL_LEGACY\", i[i.WEBGL = 1] = \"WEBGL\", i[i.WEBGL2 = 2] = \"WEBGL2\";\n})(Ts || (Ts = {}));\nvar nc;\n(function(i) {\n  i[i.UNKNOWN = 0] = \"UNKNOWN\", i[i.WEBGL = 1] = \"WEBGL\", i[i.CANVAS = 2] = \"CANVAS\";\n})(nc || (nc = {}));\nvar lv;\n(function(i) {\n  i[i.COLOR = 16384] = \"COLOR\", i[i.DEPTH = 256] = \"DEPTH\", i[i.STENCIL = 1024] = \"STENCIL\";\n})(lv || (lv = {}));\nvar Et;\n(function(i) {\n  i[i.NORMAL = 0] = \"NORMAL\", i[i.ADD = 1] = \"ADD\", i[i.MULTIPLY = 2] = \"MULTIPLY\", i[i.SCREEN = 3] = \"SCREEN\", i[i.OVERLAY = 4] = \"OVERLAY\", i[i.DARKEN = 5] = \"DARKEN\", i[i.LIGHTEN = 6] = \"LIGHTEN\", i[i.COLOR_DODGE = 7] = \"COLOR_DODGE\", i[i.COLOR_BURN = 8] = \"COLOR_BURN\", i[i.HARD_LIGHT = 9] = \"HARD_LIGHT\", i[i.SOFT_LIGHT = 10] = \"SOFT_LIGHT\", i[i.DIFFERENCE = 11] = \"DIFFERENCE\", i[i.EXCLUSION = 12] = \"EXCLUSION\", i[i.HUE = 13] = \"HUE\", i[i.SATURATION = 14] = \"SATURATION\", i[i.COLOR = 15] = \"COLOR\", i[i.LUMINOSITY = 16] = \"LUMINOSITY\", i[i.NORMAL_NPM = 17] = \"NORMAL_NPM\", i[i.ADD_NPM = 18] = \"ADD_NPM\", i[i.SCREEN_NPM = 19] = \"SCREEN_NPM\", i[i.NONE = 20] = \"NONE\", i[i.SRC_OVER = 0] = \"SRC_OVER\", i[i.SRC_IN = 21] = \"SRC_IN\", i[i.SRC_OUT = 22] = \"SRC_OUT\", i[i.SRC_ATOP = 23] = \"SRC_ATOP\", i[i.DST_OVER = 24] = \"DST_OVER\", i[i.DST_IN = 25] = \"DST_IN\", i[i.DST_OUT = 26] = \"DST_OUT\", i[i.DST_ATOP = 27] = \"DST_ATOP\", i[i.ERASE = 26] = \"ERASE\", i[i.SUBTRACT = 28] = \"SUBTRACT\", i[i.XOR = 29] = \"XOR\";\n})(Et || (Et = {}));\nvar qi;\n(function(i) {\n  i[i.POINTS = 0] = \"POINTS\", i[i.LINES = 1] = \"LINES\", i[i.LINE_LOOP = 2] = \"LINE_LOOP\", i[i.LINE_STRIP = 3] = \"LINE_STRIP\", i[i.TRIANGLES = 4] = \"TRIANGLES\", i[i.TRIANGLE_STRIP = 5] = \"TRIANGLE_STRIP\", i[i.TRIANGLE_FAN = 6] = \"TRIANGLE_FAN\";\n})(qi || (qi = {}));\nvar ht;\n(function(i) {\n  i[i.RGBA = 6408] = \"RGBA\", i[i.RGB = 6407] = \"RGB\", i[i.RG = 33319] = \"RG\", i[i.RED = 6403] = \"RED\", i[i.RGBA_INTEGER = 36249] = \"RGBA_INTEGER\", i[i.RGB_INTEGER = 36248] = \"RGB_INTEGER\", i[i.RG_INTEGER = 33320] = \"RG_INTEGER\", i[i.RED_INTEGER = 36244] = \"RED_INTEGER\", i[i.ALPHA = 6406] = \"ALPHA\", i[i.LUMINANCE = 6409] = \"LUMINANCE\", i[i.LUMINANCE_ALPHA = 6410] = \"LUMINANCE_ALPHA\", i[i.DEPTH_COMPONENT = 6402] = \"DEPTH_COMPONENT\", i[i.DEPTH_STENCIL = 34041] = \"DEPTH_STENCIL\";\n})(ht || (ht = {}));\nvar Wo;\n(function(i) {\n  i[i.TEXTURE_2D = 3553] = \"TEXTURE_2D\", i[i.TEXTURE_CUBE_MAP = 34067] = \"TEXTURE_CUBE_MAP\", i[i.TEXTURE_2D_ARRAY = 35866] = \"TEXTURE_2D_ARRAY\", i[i.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = \"TEXTURE_CUBE_MAP_POSITIVE_X\", i[i.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = \"TEXTURE_CUBE_MAP_NEGATIVE_X\", i[i.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = \"TEXTURE_CUBE_MAP_POSITIVE_Y\", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = \"TEXTURE_CUBE_MAP_NEGATIVE_Y\", i[i.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = \"TEXTURE_CUBE_MAP_POSITIVE_Z\", i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = \"TEXTURE_CUBE_MAP_NEGATIVE_Z\";\n})(Wo || (Wo = {}));\nvar It;\n(function(i) {\n  i[i.UNSIGNED_BYTE = 5121] = \"UNSIGNED_BYTE\", i[i.UNSIGNED_SHORT = 5123] = \"UNSIGNED_SHORT\", i[i.UNSIGNED_SHORT_5_6_5 = 33635] = \"UNSIGNED_SHORT_5_6_5\", i[i.UNSIGNED_SHORT_4_4_4_4 = 32819] = \"UNSIGNED_SHORT_4_4_4_4\", i[i.UNSIGNED_SHORT_5_5_5_1 = 32820] = \"UNSIGNED_SHORT_5_5_5_1\", i[i.UNSIGNED_INT = 5125] = \"UNSIGNED_INT\", i[i.UNSIGNED_INT_10F_11F_11F_REV = 35899] = \"UNSIGNED_INT_10F_11F_11F_REV\", i[i.UNSIGNED_INT_2_10_10_10_REV = 33640] = \"UNSIGNED_INT_2_10_10_10_REV\", i[i.UNSIGNED_INT_24_8 = 34042] = \"UNSIGNED_INT_24_8\", i[i.UNSIGNED_INT_5_9_9_9_REV = 35902] = \"UNSIGNED_INT_5_9_9_9_REV\", i[i.BYTE = 5120] = \"BYTE\", i[i.SHORT = 5122] = \"SHORT\", i[i.INT = 5124] = \"INT\", i[i.FLOAT = 5126] = \"FLOAT\", i[i.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = \"FLOAT_32_UNSIGNED_INT_24_8_REV\", i[i.HALF_FLOAT = 36193] = \"HALF_FLOAT\";\n})(It || (It = {}));\nvar hv;\n(function(i) {\n  i[i.FLOAT = 0] = \"FLOAT\", i[i.INT = 1] = \"INT\", i[i.UINT = 2] = \"UINT\";\n})(hv || (hv = {}));\nvar Cn;\n(function(i) {\n  i[i.NEAREST = 0] = \"NEAREST\", i[i.LINEAR = 1] = \"LINEAR\";\n})(Cn || (Cn = {}));\nvar On;\n(function(i) {\n  i[i.CLAMP = 33071] = \"CLAMP\", i[i.REPEAT = 10497] = \"REPEAT\", i[i.MIRRORED_REPEAT = 33648] = \"MIRRORED_REPEAT\";\n})(On || (On = {}));\nvar tn;\n(function(i) {\n  i[i.OFF = 0] = \"OFF\", i[i.POW2 = 1] = \"POW2\", i[i.ON = 2] = \"ON\", i[i.ON_MANUAL = 3] = \"ON_MANUAL\";\n})(tn || (tn = {}));\nvar en;\n(function(i) {\n  i[i.NPM = 0] = \"NPM\", i[i.UNPACK = 1] = \"UNPACK\", i[i.PMA = 2] = \"PMA\", i[i.NO_PREMULTIPLIED_ALPHA = 0] = \"NO_PREMULTIPLIED_ALPHA\", i[i.PREMULTIPLY_ON_UPLOAD = 1] = \"PREMULTIPLY_ON_UPLOAD\", i[i.PREMULTIPLY_ALPHA = 2] = \"PREMULTIPLY_ALPHA\", i[i.PREMULTIPLIED_ALPHA = 2] = \"PREMULTIPLIED_ALPHA\";\n})(en || (en = {}));\nvar Wi;\n(function(i) {\n  i[i.NO = 0] = \"NO\", i[i.YES = 1] = \"YES\", i[i.AUTO = 2] = \"AUTO\", i[i.BLEND = 0] = \"BLEND\", i[i.CLEAR = 1] = \"CLEAR\", i[i.BLIT = 2] = \"BLIT\";\n})(Wi || (Wi = {}));\nvar cv;\n(function(i) {\n  i[i.AUTO = 0] = \"AUTO\", i[i.MANUAL = 1] = \"MANUAL\";\n})(cv || (cv = {}));\nvar si;\n(function(i) {\n  i.LOW = \"lowp\", i.MEDIUM = \"mediump\", i.HIGH = \"highp\";\n})(si || (si = {}));\nvar Ze;\n(function(i) {\n  i[i.NONE = 0] = \"NONE\", i[i.SCISSOR = 1] = \"SCISSOR\", i[i.STENCIL = 2] = \"STENCIL\", i[i.SPRITE = 3] = \"SPRITE\", i[i.COLOR = 4] = \"COLOR\";\n})(Ze || (Ze = {}));\nvar t1;\n(function(i) {\n  i[i.RED = 1] = \"RED\", i[i.GREEN = 2] = \"GREEN\", i[i.BLUE = 4] = \"BLUE\", i[i.ALPHA = 8] = \"ALPHA\";\n})(t1 || (t1 = {}));\nvar ke;\n(function(i) {\n  i[i.NONE = 0] = \"NONE\", i[i.LOW = 2] = \"LOW\", i[i.MEDIUM = 4] = \"MEDIUM\", i[i.HIGH = 8] = \"HIGH\";\n})(ke || (ke = {}));\nvar In;\n(function(i) {\n  i[i.ELEMENT_ARRAY_BUFFER = 34963] = \"ELEMENT_ARRAY_BUFFER\", i[i.ARRAY_BUFFER = 34962] = \"ARRAY_BUFFER\", i[i.UNIFORM_BUFFER = 35345] = \"UNIFORM_BUFFER\";\n})(In || (In = {}));\n/*!\n * @pixi/settings - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/settings is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar pO = {\n  /**\n   * Creates a canvas element of the given size.\n   * This canvas is created using the browser's native canvas element.\n   * @param width - width of the canvas\n   * @param height - height of the canvas\n   */\n  createCanvas: function(i, t) {\n    var e = document.createElement(\"canvas\");\n    return e.width = i, e.height = t, e;\n  },\n  getWebGLRenderingContext: function() {\n    return WebGLRenderingContext;\n  },\n  getNavigator: function() {\n    return navigator;\n  },\n  getBaseUrl: function() {\n    var i;\n    return (i = document.baseURI) !== null && i !== void 0 ? i : window.location.href;\n  },\n  fetch: function(i, t) {\n    return fetch(i, t);\n  }\n}, P0 = /iPhone/i, e1 = /iPod/i, r1 = /iPad/i, i1 = /\\biOS-universal(?:.+)Mac\\b/i, O0 = /\\bAndroid(?:.+)Mobile\\b/i, n1 = /Android/i, vu = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i, Bd = /Silk/i, Hn = /Windows Phone/i, s1 = /\\bWindows(?:.+)ARM\\b/i, a1 = /BlackBerry/i, o1 = /BB10/i, u1 = /Opera Mini/i, l1 = /\\b(CriOS|Chrome)(?:.+)Mobile/i, h1 = /Mobile(?:.+)Firefox\\b/i, c1 = function(i) {\n  return typeof i < \"u\" && i.platform === \"MacIntel\" && typeof i.maxTouchPoints == \"number\" && i.maxTouchPoints > 1 && typeof MSStream > \"u\";\n};\nfunction vO(i) {\n  return function(t) {\n    return t.test(i);\n  };\n}\nfunction gO(i) {\n  var t = {\n    userAgent: \"\",\n    platform: \"\",\n    maxTouchPoints: 0\n  };\n  !i && typeof navigator < \"u\" ? t = {\n    userAgent: navigator.userAgent,\n    platform: navigator.platform,\n    maxTouchPoints: navigator.maxTouchPoints || 0\n  } : typeof i == \"string\" ? t.userAgent = i : i && i.userAgent && (t = {\n    userAgent: i.userAgent,\n    platform: i.platform,\n    maxTouchPoints: i.maxTouchPoints || 0\n  });\n  var e = t.userAgent, r = e.split(\"[FBAN\");\n  typeof r[1] < \"u\" && (e = r[0]), r = e.split(\"Twitter\"), typeof r[1] < \"u\" && (e = r[0]);\n  var n = vO(e), s = {\n    apple: {\n      phone: n(P0) && !n(Hn),\n      ipod: n(e1),\n      tablet: !n(P0) && (n(r1) || c1(t)) && !n(Hn),\n      universal: n(i1),\n      device: (n(P0) || n(e1) || n(r1) || n(i1) || c1(t)) && !n(Hn)\n    },\n    amazon: {\n      phone: n(vu),\n      tablet: !n(vu) && n(Bd),\n      device: n(vu) || n(Bd)\n    },\n    android: {\n      phone: !n(Hn) && n(vu) || !n(Hn) && n(O0),\n      tablet: !n(Hn) && !n(vu) && !n(O0) && (n(Bd) || n(n1)),\n      device: !n(Hn) && (n(vu) || n(Bd) || n(O0) || n(n1)) || n(/\\bokhttp\\b/i)\n    },\n    windows: {\n      phone: n(Hn),\n      tablet: n(s1),\n      device: n(Hn) || n(s1)\n    },\n    other: {\n      blackberry: n(a1),\n      blackberry10: n(o1),\n      opera: n(u1),\n      firefox: n(h1),\n      chrome: n(l1),\n      device: n(a1) || n(o1) || n(u1) || n(h1) || n(l1)\n    },\n    any: !1,\n    phone: !1,\n    tablet: !1\n  };\n  return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;\n}\nvar Mn = gO(globalThis.navigator);\nfunction mO() {\n  return !Mn.apple.device;\n}\nfunction yO(i) {\n  var t = !0;\n  if (Mn.tablet || Mn.phone) {\n    if (Mn.apple.device) {\n      var e = navigator.userAgent.match(/OS (\\d+)_(\\d+)?/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 11 && (t = !1);\n      }\n    }\n    if (Mn.android.device) {\n      var e = navigator.userAgent.match(/Android\\s([0-9.]*)/);\n      if (e) {\n        var r = parseInt(e[1], 10);\n        r < 7 && (t = !1);\n      }\n    }\n  }\n  return t ? i : 4;\n}\nvar gt = {\n  /**\n   * This adapter is used to call methods that are platform dependent.\n   * For example `document.createElement` only runs on the web but fails in node environments.\n   * This allows us to support more platforms by abstracting away specific implementations per platform.\n   *\n   * By default the adapter is set to work in the browser. However you can create your own\n   * by implementing the `IAdapter` interface. See `IAdapter` for more information.\n   * @name ADAPTER\n   * @memberof PIXI.settings\n   * @type {PIXI.IAdapter}\n   * @default PIXI.BrowserAdapter\n   */\n  ADAPTER: pO,\n  /**\n   * If set to true WebGL will attempt make textures mimpaped by default.\n   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.\n   * @static\n   * @name MIPMAP_TEXTURES\n   * @memberof PIXI.settings\n   * @type {PIXI.MIPMAP_MODES}\n   * @default PIXI.MIPMAP_MODES.POW2\n   */\n  MIPMAP_TEXTURES: tn.POW2,\n  /**\n   * Default anisotropic filtering level of textures.\n   * Usually from 0 to 16\n   * @static\n   * @name ANISOTROPIC_LEVEL\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 0\n   */\n  ANISOTROPIC_LEVEL: 0,\n  /**\n   * Default resolution / device pixel ratio of the renderer.\n   * @static\n   * @name RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  RESOLUTION: 1,\n  /**\n   * Default filter resolution.\n   * @static\n   * @name FILTER_RESOLUTION\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 1\n   */\n  FILTER_RESOLUTION: 1,\n  /**\n   * Default filter samples.\n   * @static\n   * @name FILTER_MULTISAMPLE\n   * @memberof PIXI.settings\n   * @type {PIXI.MSAA_QUALITY}\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  FILTER_MULTISAMPLE: ke.NONE,\n  /**\n   * The maximum textures that this device supports.\n   * @static\n   * @name SPRITE_MAX_TEXTURES\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 32\n   */\n  SPRITE_MAX_TEXTURES: yO(32),\n  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000\n  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000\n  /**\n   * The default sprite batch size.\n   *\n   * The default aims to balance desktop and mobile devices.\n   * @static\n   * @name SPRITE_BATCH_SIZE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 4096\n   */\n  SPRITE_BATCH_SIZE: 4096,\n  /**\n   * The default render options if none are supplied to {@link PIXI.Renderer}\n   * or {@link PIXI.CanvasRenderer}.\n   * @static\n   * @name RENDER_OPTIONS\n   * @memberof PIXI.settings\n   * @type {object}\n   * @property {HTMLCanvasElement} [view=null] -\n   * @property {boolean} [antialias=false] -\n   * @property {boolean} [autoDensity=false] -\n   * @property {boolean} [useContextAlpha=true]  -\n   * @property {number} [backgroundColor=0x000000] -\n   * @property {number} [backgroundAlpha=1] -\n   * @property {boolean} [clearBeforeRender=true] -\n   * @property {boolean} [preserveDrawingBuffer=false] -\n   * @property {number} [width=800] -\n   * @property {number} [height=600] -\n   * @property {boolean} [legacy=false] -\n   */\n  RENDER_OPTIONS: {\n    view: null,\n    antialias: !1,\n    autoDensity: !1,\n    backgroundColor: 0,\n    backgroundAlpha: 1,\n    useContextAlpha: !0,\n    clearBeforeRender: !0,\n    preserveDrawingBuffer: !1,\n    width: 800,\n    height: 600,\n    legacy: !1\n  },\n  /**\n   * Default Garbage Collection mode.\n   * @static\n   * @name GC_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.GC_MODES}\n   * @default PIXI.GC_MODES.AUTO\n   */\n  GC_MODE: cv.AUTO,\n  /**\n   * Default Garbage Collection max idle.\n   * @static\n   * @name GC_MAX_IDLE\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 3600\n   */\n  GC_MAX_IDLE: 60 * 60,\n  /**\n   * Default Garbage Collection maximum check count.\n   * @static\n   * @name GC_MAX_CHECK_COUNT\n   * @memberof PIXI.settings\n   * @type {number}\n   * @default 600\n   */\n  GC_MAX_CHECK_COUNT: 60 * 10,\n  /**\n   * Default wrap modes that are supported by pixi.\n   * @static\n   * @name WRAP_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.WRAP_MODES}\n   * @default PIXI.WRAP_MODES.CLAMP\n   */\n  WRAP_MODE: On.CLAMP,\n  /**\n   * Default scale mode for textures.\n   * @static\n   * @name SCALE_MODE\n   * @memberof PIXI.settings\n   * @type {PIXI.SCALE_MODES}\n   * @default PIXI.SCALE_MODES.LINEAR\n   */\n  SCALE_MODE: Cn.LINEAR,\n  /**\n   * Default specify float precision in vertex shader.\n   * @static\n   * @name PRECISION_VERTEX\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @default PIXI.PRECISION.HIGH\n   */\n  PRECISION_VERTEX: si.HIGH,\n  /**\n   * Default specify float precision in fragment shader.\n   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742\n   * @static\n   * @name PRECISION_FRAGMENT\n   * @memberof PIXI.settings\n   * @type {PIXI.PRECISION}\n   * @default PIXI.PRECISION.MEDIUM\n   */\n  PRECISION_FRAGMENT: Mn.apple.device ? si.HIGH : si.MEDIUM,\n  /**\n   * Can we upload the same buffer in a single frame?\n   * @static\n   * @name CAN_UPLOAD_SAME_BUFFER\n   * @memberof PIXI.settings\n   * @type {boolean}\n   */\n  CAN_UPLOAD_SAME_BUFFER: mO(),\n  /**\n   * Enables bitmap creation before image load. This feature is experimental.\n   * @static\n   * @name CREATE_IMAGE_BITMAP\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  CREATE_IMAGE_BITMAP: !1,\n  /**\n   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n   * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n   * The main disadvantage is movement of objects may appear less smooth.\n   * @static\n   * @constant\n   * @memberof PIXI.settings\n   * @type {boolean}\n   * @default false\n   */\n  ROUND_PIXELS: !1\n}, $r = {}, _O = {\n  get exports() {\n    return $r;\n  },\n  set exports(i) {\n    $r = i;\n  }\n};\n(function(i) {\n  var t = Object.prototype.hasOwnProperty, e = \"~\";\n  function r() {\n  }\n  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (e = !1));\n  function n(u, l, h) {\n    this.fn = u, this.context = l, this.once = h || !1;\n  }\n  function s(u, l, h, d, f) {\n    if (typeof h != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var p = new n(h, d || u, f), v = e ? e + l : l;\n    return u._events[v] ? u._events[v].fn ? u._events[v] = [u._events[v], p] : u._events[v].push(p) : (u._events[v] = p, u._eventsCount++), u;\n  }\n  function a(u, l) {\n    --u._eventsCount === 0 ? u._events = new r() : delete u._events[l];\n  }\n  function o() {\n    this._events = new r(), this._eventsCount = 0;\n  }\n  o.prototype.eventNames = function() {\n    var l = [], h, d;\n    if (this._eventsCount === 0)\n      return l;\n    for (d in h = this._events)\n      t.call(h, d) && l.push(e ? d.slice(1) : d);\n    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(h)) : l;\n  }, o.prototype.listeners = function(l) {\n    var h = e ? e + l : l, d = this._events[h];\n    if (!d)\n      return [];\n    if (d.fn)\n      return [d.fn];\n    for (var f = 0, p = d.length, v = new Array(p); f < p; f++)\n      v[f] = d[f].fn;\n    return v;\n  }, o.prototype.listenerCount = function(l) {\n    var h = e ? e + l : l, d = this._events[h];\n    return d ? d.fn ? 1 : d.length : 0;\n  }, o.prototype.emit = function(l, h, d, f, p, v) {\n    var g = e ? e + l : l;\n    if (!this._events[g])\n      return !1;\n    var m = this._events[g], y = arguments.length, _, b;\n    if (m.fn) {\n      switch (m.once && this.removeListener(l, m.fn, void 0, !0), y) {\n        case 1:\n          return m.fn.call(m.context), !0;\n        case 2:\n          return m.fn.call(m.context, h), !0;\n        case 3:\n          return m.fn.call(m.context, h, d), !0;\n        case 4:\n          return m.fn.call(m.context, h, d, f), !0;\n        case 5:\n          return m.fn.call(m.context, h, d, f, p), !0;\n        case 6:\n          return m.fn.call(m.context, h, d, f, p, v), !0;\n      }\n      for (b = 1, _ = new Array(y - 1); b < y; b++)\n        _[b - 1] = arguments[b];\n      m.fn.apply(m.context, _);\n    } else {\n      var w = m.length, T;\n      for (b = 0; b < w; b++)\n        switch (m[b].once && this.removeListener(l, m[b].fn, void 0, !0), y) {\n          case 1:\n            m[b].fn.call(m[b].context);\n            break;\n          case 2:\n            m[b].fn.call(m[b].context, h);\n            break;\n          case 3:\n            m[b].fn.call(m[b].context, h, d);\n            break;\n          case 4:\n            m[b].fn.call(m[b].context, h, d, f);\n            break;\n          default:\n            if (!_)\n              for (T = 1, _ = new Array(y - 1); T < y; T++)\n                _[T - 1] = arguments[T];\n            m[b].fn.apply(m[b].context, _);\n        }\n    }\n    return !0;\n  }, o.prototype.on = function(l, h, d) {\n    return s(this, l, h, d, !1);\n  }, o.prototype.once = function(l, h, d) {\n    return s(this, l, h, d, !0);\n  }, o.prototype.removeListener = function(l, h, d, f) {\n    var p = e ? e + l : l;\n    if (!this._events[p])\n      return this;\n    if (!h)\n      return a(this, p), this;\n    var v = this._events[p];\n    if (v.fn)\n      v.fn === h && (!f || v.once) && (!d || v.context === d) && a(this, p);\n    else {\n      for (var g = 0, m = [], y = v.length; g < y; g++)\n        (v[g].fn !== h || f && !v[g].once || d && v[g].context !== d) && m.push(v[g]);\n      m.length ? this._events[p] = m.length === 1 ? m[0] : m : a(this, p);\n    }\n    return this;\n  }, o.prototype.removeAllListeners = function(l) {\n    var h;\n    return l ? (h = e ? e + l : l, this._events[h] && a(this, h)) : (this._events = new r(), this._eventsCount = 0), this;\n  }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = e, o.EventEmitter = o, i.exports = o;\n})(_O);\nvar sc = {}, bO = {\n  get exports() {\n    return sc;\n  },\n  set exports(i) {\n    sc = i;\n  }\n};\nbO.exports = Qm;\nsc.default = Qm;\nfunction Qm(i, t, e) {\n  e = e || 2;\n  var r = t && t.length, n = r ? t[0] * e : i.length, s = ME(i, 0, n, e, !0), a = [];\n  if (!s || s.next === s.prev)\n    return a;\n  var o, u, l, h, d, f, p;\n  if (r && (s = TO(i, t, s, e)), i.length > 80 * e) {\n    o = l = i[0], u = h = i[1];\n    for (var v = e; v < n; v += e)\n      d = i[v], f = i[v + 1], d < o && (o = d), f < u && (u = f), d > l && (l = d), f > h && (h = f);\n    p = Math.max(l - o, h - u), p = p !== 0 ? 32767 / p : 0;\n  }\n  return ac(s, a, e, o, u, p, 0), a;\n}\nfunction ME(i, t, e, r, n) {\n  var s, a;\n  if (n === my(i, t, e, r) > 0)\n    for (s = t; s < e; s += r)\n      a = f1(s, i[s], i[s + 1], a);\n  else\n    for (s = e - r; s >= t; s -= r)\n      a = f1(s, i[s], i[s + 1], a);\n  return a && t0(a, a.next) && (uc(a), a = a.next), a;\n}\nfunction Zo(i, t) {\n  if (!i)\n    return i;\n  t || (t = i);\n  var e = i, r;\n  do\n    if (r = !1, !e.steiner && (t0(e, e.next) || Be(e.prev, e, e.next) === 0)) {\n      if (uc(e), e = t = e.prev, e === e.next)\n        break;\n      r = !0;\n    } else\n      e = e.next;\n  while (r || e !== t);\n  return t;\n}\nfunction ac(i, t, e, r, n, s, a) {\n  if (i) {\n    !a && s && IO(i, r, n, s);\n    for (var o = i, u, l; i.prev !== i.next; ) {\n      if (u = i.prev, l = i.next, s ? wO(i, r, n, s) : xO(i)) {\n        t.push(u.i / e | 0), t.push(i.i / e | 0), t.push(l.i / e | 0), uc(i), i = l.next, o = l.next;\n        continue;\n      }\n      if (i = l, i === o) {\n        a ? a === 1 ? (i = EO(Zo(i), t, e), ac(i, t, e, r, n, s, 2)) : a === 2 && SO(i, t, e, r, n, s) : ac(Zo(i), t, e, r, n, s, 1);\n        break;\n      }\n    }\n  }\n}\nfunction xO(i) {\n  var t = i.prev, e = i, r = i.next;\n  if (Be(t, e, r) >= 0)\n    return !1;\n  for (var n = t.x, s = e.x, a = r.x, o = t.y, u = e.y, l = r.y, h = n < s ? n < a ? n : a : s < a ? s : a, d = o < u ? o < l ? o : l : u < l ? u : l, f = n > s ? n > a ? n : a : s > a ? s : a, p = o > u ? o > l ? o : l : u > l ? u : l, v = r.next; v !== t; ) {\n    if (v.x >= h && v.x <= f && v.y >= d && v.y <= p && Cu(n, o, s, u, a, l, v.x, v.y) && Be(v.prev, v, v.next) >= 0)\n      return !1;\n    v = v.next;\n  }\n  return !0;\n}\nfunction wO(i, t, e, r) {\n  var n = i.prev, s = i, a = i.next;\n  if (Be(n, s, a) >= 0)\n    return !1;\n  for (var o = n.x, u = s.x, l = a.x, h = n.y, d = s.y, f = a.y, p = o < u ? o < l ? o : l : u < l ? u : l, v = h < d ? h < f ? h : f : d < f ? d : f, g = o > u ? o > l ? o : l : u > l ? u : l, m = h > d ? h > f ? h : f : d > f ? d : f, y = vy(p, v, t, e, r), _ = vy(g, m, t, e, r), b = i.prevZ, w = i.nextZ; b && b.z >= y && w && w.z <= _; ) {\n    if (b.x >= p && b.x <= g && b.y >= v && b.y <= m && b !== n && b !== a && Cu(o, h, u, d, l, f, b.x, b.y) && Be(b.prev, b, b.next) >= 0 || (b = b.prevZ, w.x >= p && w.x <= g && w.y >= v && w.y <= m && w !== n && w !== a && Cu(o, h, u, d, l, f, w.x, w.y) && Be(w.prev, w, w.next) >= 0))\n      return !1;\n    w = w.nextZ;\n  }\n  for (; b && b.z >= y; ) {\n    if (b.x >= p && b.x <= g && b.y >= v && b.y <= m && b !== n && b !== a && Cu(o, h, u, d, l, f, b.x, b.y) && Be(b.prev, b, b.next) >= 0)\n      return !1;\n    b = b.prevZ;\n  }\n  for (; w && w.z <= _; ) {\n    if (w.x >= p && w.x <= g && w.y >= v && w.y <= m && w !== n && w !== a && Cu(o, h, u, d, l, f, w.x, w.y) && Be(w.prev, w, w.next) >= 0)\n      return !1;\n    w = w.nextZ;\n  }\n  return !0;\n}\nfunction EO(i, t, e) {\n  var r = i;\n  do {\n    var n = r.prev, s = r.next.next;\n    !t0(n, s) && PE(n, r, r.next, s) && oc(n, s) && oc(s, n) && (t.push(n.i / e | 0), t.push(r.i / e | 0), t.push(s.i / e | 0), uc(r), uc(r.next), r = i = s), r = r.next;\n  } while (r !== i);\n  return Zo(r);\n}\nfunction SO(i, t, e, r, n, s) {\n  var a = i;\n  do {\n    for (var o = a.next.next; o !== a.prev; ) {\n      if (a.i !== o.i && kO(a, o)) {\n        var u = OE(a, o);\n        a = Zo(a, a.next), u = Zo(u, u.next), ac(a, t, e, r, n, s, 0), ac(u, t, e, r, n, s, 0);\n        return;\n      }\n      o = o.next;\n    }\n    a = a.next;\n  } while (a !== i);\n}\nfunction TO(i, t, e, r) {\n  var n = [], s, a, o, u, l;\n  for (s = 0, a = t.length; s < a; s++)\n    o = t[s] * r, u = s < a - 1 ? t[s + 1] * r : i.length, l = ME(i, o, u, r, !1), l === l.next && (l.steiner = !0), n.push(DO(l));\n  for (n.sort(CO), s = 0; s < n.length; s++)\n    e = MO(n[s], e);\n  return e;\n}\nfunction CO(i, t) {\n  return i.x - t.x;\n}\nfunction MO(i, t) {\n  var e = PO(i, t);\n  if (!e)\n    return t;\n  var r = OE(e, i);\n  return Zo(r, r.next), Zo(e, e.next);\n}\nfunction PO(i, t) {\n  var e = t, r = i.x, n = i.y, s = -1 / 0, a;\n  do {\n    if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {\n      var o = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);\n      if (o <= r && o > s && (s = o, a = e.x < e.next.x ? e : e.next, o === r))\n        return a;\n    }\n    e = e.next;\n  } while (e !== t);\n  if (!a)\n    return null;\n  var u = a, l = a.x, h = a.y, d = 1 / 0, f;\n  e = a;\n  do\n    r >= e.x && e.x >= l && r !== e.x && Cu(n < h ? r : s, n, l, h, n < h ? s : r, n, e.x, e.y) && (f = Math.abs(n - e.y) / (r - e.x), oc(e, i) && (f < d || f === d && (e.x > a.x || e.x === a.x && OO(a, e))) && (a = e, d = f)), e = e.next;\n  while (e !== u);\n  return a;\n}\nfunction OO(i, t) {\n  return Be(i.prev, i, t.prev) < 0 && Be(t.next, i, i.next) < 0;\n}\nfunction IO(i, t, e, r) {\n  var n = i;\n  do\n    n.z === 0 && (n.z = vy(n.x, n.y, t, e, r)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;\n  while (n !== i);\n  n.prevZ.nextZ = null, n.prevZ = null, RO(n);\n}\nfunction RO(i) {\n  var t, e, r, n, s, a, o, u, l = 1;\n  do {\n    for (e = i, i = null, s = null, a = 0; e; ) {\n      for (a++, r = e, o = 0, t = 0; t < l && (o++, r = r.nextZ, !!r); t++)\n        ;\n      for (u = l; o > 0 || u > 0 && r; )\n        o !== 0 && (u === 0 || !r || e.z <= r.z) ? (n = e, e = e.nextZ, o--) : (n = r, r = r.nextZ, u--), s ? s.nextZ = n : i = n, n.prevZ = s, s = n;\n      e = r;\n    }\n    s.nextZ = null, l *= 2;\n  } while (a > 1);\n  return i;\n}\nfunction vy(i, t, e, r, n) {\n  return i = (i - e) * n | 0, t = (t - r) * n | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1;\n}\nfunction DO(i) {\n  var t = i, e = i;\n  do\n    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;\n  while (t !== i);\n  return e;\n}\nfunction Cu(i, t, e, r, n, s, a, o) {\n  return (n - a) * (t - o) >= (i - a) * (s - o) && (i - a) * (r - o) >= (e - a) * (t - o) && (e - a) * (s - o) >= (n - a) * (r - o);\n}\nfunction kO(i, t) {\n  return i.next.i !== t.i && i.prev.i !== t.i && !NO(i, t) && // dones't intersect other edges\n  (oc(i, t) && oc(t, i) && AO(i, t) && // locally visible\n  (Be(i.prev, i, t.prev) || Be(i, t.prev, t)) || // does not create opposite-facing sectors\n  t0(i, t) && Be(i.prev, i, i.next) > 0 && Be(t.prev, t, t.next) > 0);\n}\nfunction Be(i, t, e) {\n  return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y);\n}\nfunction t0(i, t) {\n  return i.x === t.x && i.y === t.y;\n}\nfunction PE(i, t, e, r) {\n  var n = Gd(Be(i, t, e)), s = Gd(Be(i, t, r)), a = Gd(Be(e, r, i)), o = Gd(Be(e, r, t));\n  return !!(n !== s && a !== o || n === 0 && Fd(i, e, t) || s === 0 && Fd(i, r, t) || a === 0 && Fd(e, i, r) || o === 0 && Fd(e, t, r));\n}\nfunction Fd(i, t, e) {\n  return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y);\n}\nfunction Gd(i) {\n  return i > 0 ? 1 : i < 0 ? -1 : 0;\n}\nfunction NO(i, t) {\n  var e = i;\n  do {\n    if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && PE(e, e.next, i, t))\n      return !0;\n    e = e.next;\n  } while (e !== i);\n  return !1;\n}\nfunction oc(i, t) {\n  return Be(i.prev, i, i.next) < 0 ? Be(i, t, i.next) >= 0 && Be(i, i.prev, t) >= 0 : Be(i, t, i.prev) < 0 || Be(i, i.next, t) < 0;\n}\nfunction AO(i, t) {\n  var e = i, r = !1, n = (i.x + t.x) / 2, s = (i.y + t.y) / 2;\n  do\n    e.y > s != e.next.y > s && e.next.y !== e.y && n < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (r = !r), e = e.next;\n  while (e !== i);\n  return r;\n}\nfunction OE(i, t) {\n  var e = new gy(i.i, i.x, i.y), r = new gy(t.i, t.x, t.y), n = i.next, s = t.prev;\n  return i.next = t, t.prev = i, e.next = n, n.prev = e, r.next = e, e.prev = r, s.next = r, r.prev = s, r;\n}\nfunction f1(i, t, e, r) {\n  var n = new gy(i, t, e);\n  return r ? (n.next = r.next, n.prev = r, r.next.prev = n, r.next = n) : (n.prev = n, n.next = n), n;\n}\nfunction uc(i) {\n  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);\n}\nfunction gy(i, t, e) {\n  this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;\n}\nQm.deviation = function(i, t, e, r) {\n  var n = t && t.length, s = n ? t[0] * e : i.length, a = Math.abs(my(i, 0, s, e));\n  if (n)\n    for (var o = 0, u = t.length; o < u; o++) {\n      var l = t[o] * e, h = o < u - 1 ? t[o + 1] * e : i.length;\n      a -= Math.abs(my(i, l, h, e));\n    }\n  var d = 0;\n  for (o = 0; o < r.length; o += 3) {\n    var f = r[o] * e, p = r[o + 1] * e, v = r[o + 2] * e;\n    d += Math.abs(\n      (i[f] - i[v]) * (i[p + 1] - i[f + 1]) - (i[f] - i[p]) * (i[v + 1] - i[f + 1])\n    );\n  }\n  return a === 0 && d === 0 ? 0 : Math.abs((d - a) / a);\n};\nfunction my(i, t, e, r) {\n  for (var n = 0, s = t, a = e - r; s < e; s += r)\n    n += (i[a] - i[s]) * (i[s + 1] + i[a + 1]), a = s;\n  return n;\n}\nQm.flatten = function(i) {\n  for (var t = i[0][0].length, e = { vertices: [], holes: [], dimensions: t }, r = 0, n = 0; n < i.length; n++) {\n    for (var s = 0; s < i[n].length; s++)\n      for (var a = 0; a < t; a++)\n        e.vertices.push(i[n][s][a]);\n    n > 0 && (r += i[n - 1].length, e.holes.push(r));\n  }\n  return e;\n};\n/*!\n * @pixi/utils - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/utils is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Mu = {\n  parse: url__WEBPACK_IMPORTED_MODULE_0__.parse,\n  format: url__WEBPACK_IMPORTED_MODULE_0__.format,\n  resolve: url__WEBPACK_IMPORTED_MODULE_0__.resolve\n};\ngt.RETINA_PREFIX = /@([0-9\\.]+)x/;\ngt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;\nvar yy = !1, d1 = \"6.5.9\";\nfunction LO() {\n  yy = !0;\n}\nfunction BO(i) {\n  var t;\n  if (!yy) {\n    if (gt.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n      var e = [\n        `\n %c %c %c PixiJS ` + d1 + \" - ✰ \" + i + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ \n\n`,\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff66a5; background: #030307; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"background: #ffc3dc; padding:5px 0;\",\n        \"background: #ff66a5; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\",\n        \"color: #ff2424; background: #fff; padding:5px 0;\"\n      ];\n      (t = globalThis.console).log.apply(t, e);\n    } else\n      globalThis.console && globalThis.console.log(\"PixiJS \" + d1 + \" - \" + i + \" - http://www.pixijs.com/\");\n    yy = !0;\n  }\n}\nvar I0;\nfunction FO() {\n  return typeof I0 > \"u\" && (I0 = function() {\n    var t = {\n      stencil: !0,\n      failIfMajorPerformanceCaveat: gt.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT\n    };\n    try {\n      if (!gt.ADAPTER.getWebGLRenderingContext())\n        return !1;\n      var e = gt.ADAPTER.createCanvas(), r = e.getContext(\"webgl\", t) || e.getContext(\"experimental-webgl\", t), n = !!(r && r.getContextAttributes().stencil);\n      if (r) {\n        var s = r.getExtension(\"WEBGL_lose_context\");\n        s && s.loseContext();\n      }\n      return r = null, n;\n    } catch {\n      return !1;\n    }\n  }()), I0;\n}\nvar GO = \"#f0f8ff\", UO = \"#faebd7\", jO = \"#00ffff\", zO = \"#7fffd4\", HO = \"#f0ffff\", $O = \"#f5f5dc\", VO = \"#ffe4c4\", XO = \"#000000\", WO = \"#ffebcd\", YO = \"#0000ff\", qO = \"#8a2be2\", ZO = \"#a52a2a\", KO = \"#deb887\", JO = \"#5f9ea0\", QO = \"#7fff00\", tI = \"#d2691e\", eI = \"#ff7f50\", rI = \"#6495ed\", iI = \"#fff8dc\", nI = \"#dc143c\", sI = \"#00ffff\", aI = \"#00008b\", oI = \"#008b8b\", uI = \"#b8860b\", lI = \"#a9a9a9\", hI = \"#006400\", cI = \"#a9a9a9\", fI = \"#bdb76b\", dI = \"#8b008b\", pI = \"#556b2f\", vI = \"#ff8c00\", gI = \"#9932cc\", mI = \"#8b0000\", yI = \"#e9967a\", _I = \"#8fbc8f\", bI = \"#483d8b\", xI = \"#2f4f4f\", wI = \"#2f4f4f\", EI = \"#00ced1\", SI = \"#9400d3\", TI = \"#ff1493\", CI = \"#00bfff\", MI = \"#696969\", PI = \"#696969\", OI = \"#1e90ff\", II = \"#b22222\", RI = \"#fffaf0\", DI = \"#228b22\", kI = \"#ff00ff\", NI = \"#dcdcdc\", AI = \"#f8f8ff\", LI = \"#daa520\", BI = \"#ffd700\", FI = \"#808080\", GI = \"#008000\", UI = \"#adff2f\", jI = \"#808080\", zI = \"#f0fff0\", HI = \"#ff69b4\", $I = \"#cd5c5c\", VI = \"#4b0082\", XI = \"#fffff0\", WI = \"#f0e68c\", YI = \"#fff0f5\", qI = \"#e6e6fa\", ZI = \"#7cfc00\", KI = \"#fffacd\", JI = \"#add8e6\", QI = \"#f08080\", tR = \"#e0ffff\", eR = \"#fafad2\", rR = \"#d3d3d3\", iR = \"#90ee90\", nR = \"#d3d3d3\", sR = \"#ffb6c1\", aR = \"#ffa07a\", oR = \"#20b2aa\", uR = \"#87cefa\", lR = \"#778899\", hR = \"#778899\", cR = \"#b0c4de\", fR = \"#ffffe0\", dR = \"#00ff00\", pR = \"#32cd32\", vR = \"#faf0e6\", gR = \"#ff00ff\", mR = \"#800000\", yR = \"#66cdaa\", _R = \"#0000cd\", bR = \"#ba55d3\", xR = \"#9370db\", wR = \"#3cb371\", ER = \"#7b68ee\", SR = \"#00fa9a\", TR = \"#48d1cc\", CR = \"#c71585\", MR = \"#191970\", PR = \"#f5fffa\", OR = \"#ffe4e1\", IR = \"#ffe4b5\", RR = \"#ffdead\", DR = \"#000080\", kR = \"#fdf5e6\", NR = \"#808000\", AR = \"#6b8e23\", LR = \"#ffa500\", BR = \"#ff4500\", FR = \"#da70d6\", GR = \"#eee8aa\", UR = \"#98fb98\", jR = \"#afeeee\", zR = \"#db7093\", HR = \"#ffefd5\", $R = \"#ffdab9\", VR = \"#cd853f\", XR = \"#ffc0cb\", WR = \"#dda0dd\", YR = \"#b0e0e6\", qR = \"#800080\", ZR = \"#663399\", KR = \"#ff0000\", JR = \"#bc8f8f\", QR = \"#4169e1\", tD = \"#8b4513\", eD = \"#fa8072\", rD = \"#f4a460\", iD = \"#2e8b57\", nD = \"#fff5ee\", sD = \"#a0522d\", aD = \"#c0c0c0\", oD = \"#87ceeb\", uD = \"#6a5acd\", lD = \"#708090\", hD = \"#708090\", cD = \"#fffafa\", fD = \"#00ff7f\", dD = \"#4682b4\", pD = \"#d2b48c\", vD = \"#008080\", gD = \"#d8bfd8\", mD = \"#ff6347\", yD = \"#40e0d0\", _D = \"#ee82ee\", bD = \"#f5deb3\", xD = \"#ffffff\", wD = \"#f5f5f5\", ED = \"#ffff00\", SD = \"#9acd32\", TD = {\n  aliceblue: GO,\n  antiquewhite: UO,\n  aqua: jO,\n  aquamarine: zO,\n  azure: HO,\n  beige: $O,\n  bisque: VO,\n  black: XO,\n  blanchedalmond: WO,\n  blue: YO,\n  blueviolet: qO,\n  brown: ZO,\n  burlywood: KO,\n  cadetblue: JO,\n  chartreuse: QO,\n  chocolate: tI,\n  coral: eI,\n  cornflowerblue: rI,\n  cornsilk: iI,\n  crimson: nI,\n  cyan: sI,\n  darkblue: aI,\n  darkcyan: oI,\n  darkgoldenrod: uI,\n  darkgray: lI,\n  darkgreen: hI,\n  darkgrey: cI,\n  darkkhaki: fI,\n  darkmagenta: dI,\n  darkolivegreen: pI,\n  darkorange: vI,\n  darkorchid: gI,\n  darkred: mI,\n  darksalmon: yI,\n  darkseagreen: _I,\n  darkslateblue: bI,\n  darkslategray: xI,\n  darkslategrey: wI,\n  darkturquoise: EI,\n  darkviolet: SI,\n  deeppink: TI,\n  deepskyblue: CI,\n  dimgray: MI,\n  dimgrey: PI,\n  dodgerblue: OI,\n  firebrick: II,\n  floralwhite: RI,\n  forestgreen: DI,\n  fuchsia: kI,\n  gainsboro: NI,\n  ghostwhite: AI,\n  goldenrod: LI,\n  gold: BI,\n  gray: FI,\n  green: GI,\n  greenyellow: UI,\n  grey: jI,\n  honeydew: zI,\n  hotpink: HI,\n  indianred: $I,\n  indigo: VI,\n  ivory: XI,\n  khaki: WI,\n  lavenderblush: YI,\n  lavender: qI,\n  lawngreen: ZI,\n  lemonchiffon: KI,\n  lightblue: JI,\n  lightcoral: QI,\n  lightcyan: tR,\n  lightgoldenrodyellow: eR,\n  lightgray: rR,\n  lightgreen: iR,\n  lightgrey: nR,\n  lightpink: sR,\n  lightsalmon: aR,\n  lightseagreen: oR,\n  lightskyblue: uR,\n  lightslategray: lR,\n  lightslategrey: hR,\n  lightsteelblue: cR,\n  lightyellow: fR,\n  lime: dR,\n  limegreen: pR,\n  linen: vR,\n  magenta: gR,\n  maroon: mR,\n  mediumaquamarine: yR,\n  mediumblue: _R,\n  mediumorchid: bR,\n  mediumpurple: xR,\n  mediumseagreen: wR,\n  mediumslateblue: ER,\n  mediumspringgreen: SR,\n  mediumturquoise: TR,\n  mediumvioletred: CR,\n  midnightblue: MR,\n  mintcream: PR,\n  mistyrose: OR,\n  moccasin: IR,\n  navajowhite: RR,\n  navy: DR,\n  oldlace: kR,\n  olive: NR,\n  olivedrab: AR,\n  orange: LR,\n  orangered: BR,\n  orchid: FR,\n  palegoldenrod: GR,\n  palegreen: UR,\n  paleturquoise: jR,\n  palevioletred: zR,\n  papayawhip: HR,\n  peachpuff: $R,\n  peru: VR,\n  pink: XR,\n  plum: WR,\n  powderblue: YR,\n  purple: qR,\n  rebeccapurple: ZR,\n  red: KR,\n  rosybrown: JR,\n  royalblue: QR,\n  saddlebrown: tD,\n  salmon: eD,\n  sandybrown: rD,\n  seagreen: iD,\n  seashell: nD,\n  sienna: sD,\n  silver: aD,\n  skyblue: oD,\n  slateblue: uD,\n  slategray: lD,\n  slategrey: hD,\n  snow: cD,\n  springgreen: fD,\n  steelblue: dD,\n  tan: pD,\n  teal: vD,\n  thistle: gD,\n  tomato: mD,\n  turquoise: yD,\n  violet: _D,\n  wheat: bD,\n  white: xD,\n  whitesmoke: wD,\n  yellow: ED,\n  yellowgreen: SD\n};\nfunction Jl(i, t) {\n  return t === void 0 && (t = []), t[0] = (i >> 16 & 255) / 255, t[1] = (i >> 8 & 255) / 255, t[2] = (i & 255) / 255, t;\n}\nfunction IE(i) {\n  var t = i.toString(16);\n  return t = \"000000\".substring(0, 6 - t.length) + t, \"#\" + t;\n}\nfunction RE(i) {\n  return typeof i == \"string\" && (i = TD[i.toLowerCase()] || i, i[0] === \"#\" && (i = i.slice(1))), parseInt(i, 16);\n}\nfunction CD() {\n  for (var i = [], t = [], e = 0; e < 32; e++)\n    i[e] = e, t[e] = e;\n  i[Et.NORMAL_NPM] = Et.NORMAL, i[Et.ADD_NPM] = Et.ADD, i[Et.SCREEN_NPM] = Et.SCREEN, t[Et.NORMAL] = Et.NORMAL_NPM, t[Et.ADD] = Et.ADD_NPM, t[Et.SCREEN] = Et.SCREEN_NPM;\n  var r = [];\n  return r.push(t), r.push(i), r;\n}\nvar DE = CD();\nfunction kE(i, t) {\n  return DE[t ? 1 : 0][i];\n}\nfunction MD(i, t, e, r) {\n  return e = e || new Float32Array(4), r || r === void 0 ? (e[0] = i[0] * t, e[1] = i[1] * t, e[2] = i[2] * t) : (e[0] = i[0], e[1] = i[1], e[2] = i[2]), e[3] = t, e;\n}\nfunction wb(i, t) {\n  if (t === 1)\n    return (t * 255 << 24) + i;\n  if (t === 0)\n    return 0;\n  var e = i >> 16 & 255, r = i >> 8 & 255, n = i & 255;\n  return e = e * t + 0.5 | 0, r = r * t + 0.5 | 0, n = n * t + 0.5 | 0, (t * 255 << 24) + (e << 16) + (r << 8) + n;\n}\nfunction NE(i, t, e, r) {\n  return e = e || new Float32Array(4), e[0] = (i >> 16 & 255) / 255, e[1] = (i >> 8 & 255) / 255, e[2] = (i & 255) / 255, (r || r === void 0) && (e[0] *= t, e[1] *= t, e[2] *= t), e[3] = t, e;\n}\nfunction PD(i, t) {\n  t === void 0 && (t = null);\n  var e = i * 6;\n  if (t = t || new Uint16Array(e), t.length !== e)\n    throw new Error(\"Out buffer length is incorrect, got \" + t.length + \" and expected \" + e);\n  for (var r = 0, n = 0; r < e; r += 6, n += 4)\n    t[r + 0] = n + 0, t[r + 1] = n + 1, t[r + 2] = n + 2, t[r + 3] = n + 0, t[r + 4] = n + 2, t[r + 5] = n + 3;\n  return t;\n}\nfunction AE(i) {\n  if (i.BYTES_PER_ELEMENT === 4)\n    return i instanceof Float32Array ? \"Float32Array\" : i instanceof Uint32Array ? \"Uint32Array\" : \"Int32Array\";\n  if (i.BYTES_PER_ELEMENT === 2) {\n    if (i instanceof Uint16Array)\n      return \"Uint16Array\";\n  } else if (i.BYTES_PER_ELEMENT === 1 && i instanceof Uint8Array)\n    return \"Uint8Array\";\n  return null;\n}\nfunction fv(i) {\n  return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;\n}\nfunction p1(i) {\n  return !(i & i - 1) && !!i;\n}\nfunction v1(i) {\n  var t = (i > 65535 ? 1 : 0) << 4;\n  i >>>= t;\n  var e = (i > 255 ? 1 : 0) << 3;\n  return i >>>= e, t |= e, e = (i > 15 ? 1 : 0) << 2, i >>>= e, t |= e, e = (i > 3 ? 1 : 0) << 1, i >>>= e, t |= e, t | i >> 1;\n}\nfunction Bu(i, t, e) {\n  var r = i.length, n;\n  if (!(t >= r || e === 0)) {\n    e = t + e > r ? r - t : e;\n    var s = r - e;\n    for (n = t; n < s; ++n)\n      i[n] = i[n + e];\n    i.length = s;\n  }\n}\nfunction Pu(i) {\n  return i === 0 ? 0 : i < 0 ? -1 : 1;\n}\nvar OD = 0;\nfunction Ko() {\n  return ++OD;\n}\nvar g1 = {};\nfunction jr(i, t, e) {\n  if (e === void 0 && (e = 3), !g1[t]) {\n    var r = new Error().stack;\n    typeof r > \"u\" ? console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + i) : (r = r.split(`\n`).splice(e).join(`\n`), console.groupCollapsed ? (console.groupCollapsed(\"%cPixiJS Deprecation Warning: %c%s\", \"color:#614108;background:#fffbe6\", \"font-weight:normal;color:#614108;background:#fffbe6\", t + `\nDeprecated since v` + i), console.warn(r), console.groupEnd()) : (console.warn(\"PixiJS Deprecation Warning: \", t + `\nDeprecated since v` + i), console.warn(r))), g1[t] = !0;\n  }\n}\nvar m1 = {}, Gr = /* @__PURE__ */ Object.create(null), Xn = /* @__PURE__ */ Object.create(null);\nfunction LE() {\n  var i;\n  for (i in Gr)\n    delete Gr[i];\n  for (i in Xn)\n    delete Xn[i];\n}\nvar y1 = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      this.canvas = gt.ADAPTER.createCanvas(), this.context = this.canvas.getContext(\"2d\"), this.resolution = r || gt.RESOLUTION, this.resize(t, e);\n    }\n    return i.prototype.clear = function() {\n      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }, i.prototype.resize = function(t, e) {\n      this.canvas.width = Math.round(t * this.resolution), this.canvas.height = Math.round(e * this.resolution);\n    }, i.prototype.destroy = function() {\n      this.context = null, this.canvas = null;\n    }, Object.defineProperty(i.prototype, \"width\", {\n      /**\n       * The width of the canvas buffer in pixels.\n       * @member {number}\n       */\n      get: function() {\n        return this.canvas.width;\n      },\n      set: function(t) {\n        this.canvas.width = Math.round(t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"height\", {\n      /**\n       * The height of the canvas buffer in pixels.\n       * @member {number}\n       */\n      get: function() {\n        return this.canvas.height;\n      },\n      set: function(t) {\n        this.canvas.height = Math.round(t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n);\nfunction ID(i) {\n  var t = i.width, e = i.height, r = i.getContext(\"2d\", {\n    willReadFrequently: !0\n  }), n = r.getImageData(0, 0, t, e), s = n.data, a = s.length, o = {\n    top: null,\n    left: null,\n    right: null,\n    bottom: null\n  }, u = null, l, h, d;\n  for (l = 0; l < a; l += 4)\n    s[l + 3] !== 0 && (h = l / 4 % t, d = ~~(l / 4 / t), o.top === null && (o.top = d), (o.left === null || h < o.left) && (o.left = h), (o.right === null || o.right < h) && (o.right = h + 1), (o.bottom === null || o.bottom < d) && (o.bottom = d));\n  return o.top !== null && (t = o.right - o.left, e = o.bottom - o.top + 1, u = r.getImageData(o.left, o.top, t, e)), {\n    height: e,\n    width: t,\n    data: u\n  };\n}\nvar Ud;\nfunction RD(i, t) {\n  if (t === void 0 && (t = globalThis.location), i.indexOf(\"data:\") === 0)\n    return \"\";\n  t = t || globalThis.location, Ud || (Ud = document.createElement(\"a\")), Ud.href = i;\n  var e = Mu.parse(Ud.href), r = !e.port && t.port === \"\" || e.port === t.port;\n  return e.hostname !== t.hostname || !r || e.protocol !== t.protocol ? \"anonymous\" : \"\";\n}\nfunction dv(i, t) {\n  var e = gt.RETINA_PREFIX.exec(i);\n  return e ? parseFloat(e[1]) : t !== void 0 ? t : 1;\n}\n/*!\n * @pixi/math - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/math is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar pv = Math.PI * 2, DD = 180 / Math.PI, kD = Math.PI / 180, ur;\n(function(i) {\n  i[i.POLY = 0] = \"POLY\", i[i.RECT = 1] = \"RECT\", i[i.CIRC = 2] = \"CIRC\", i[i.ELIP = 3] = \"ELIP\", i[i.RREC = 4] = \"RREC\";\n})(ur || (ur = {}));\nvar xe = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), this.x = 0, this.y = 0, this.x = t, this.y = e;\n    }\n    return i.prototype.clone = function() {\n      return new i(this.x, this.y);\n    }, i.prototype.copyFrom = function(t) {\n      return this.set(t.x, t.y), this;\n    }, i.prototype.copyTo = function(t) {\n      return t.set(this.x, this.y), t;\n    }, i.prototype.equals = function(t) {\n      return t.x === this.x && t.y === this.y;\n    }, i.prototype.set = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x = t, this.y = e, this;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Point x=\" + this.x + \" y=\" + this.y + \"]\";\n    }, i;\n  }()\n), jd = [new xe(), new xe(), new xe(), new xe()], Nt = (\n  /** @class */\n  function() {\n    function i(t, e, r, n) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(r), this.height = Number(n), this.type = ur.RECT;\n    }\n    return Object.defineProperty(i.prototype, \"left\", {\n      /** Returns the left edge of the rectangle. */\n      get: function() {\n        return this.x;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"right\", {\n      /** Returns the right edge of the rectangle. */\n      get: function() {\n        return this.x + this.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"top\", {\n      /** Returns the top edge of the rectangle. */\n      get: function() {\n        return this.y;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"bottom\", {\n      /** Returns the bottom edge of the rectangle. */\n      get: function() {\n        return this.y + this.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"EMPTY\", {\n      /** A constant empty rectangle. */\n      get: function() {\n        return new i(0, 0, 0, 0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.clone = function() {\n      return new i(this.x, this.y, this.width, this.height);\n    }, i.prototype.copyFrom = function(t) {\n      return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this;\n    }, i.prototype.copyTo = function(t) {\n      return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t;\n    }, i.prototype.contains = function(t, e) {\n      return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height;\n    }, i.prototype.intersects = function(t, e) {\n      if (!e) {\n        var r = this.x < t.x ? t.x : this.x, n = this.right > t.right ? t.right : this.right;\n        if (n <= r)\n          return !1;\n        var s = this.y < t.y ? t.y : this.y, a = this.bottom > t.bottom ? t.bottom : this.bottom;\n        return a > s;\n      }\n      var o = this.left, u = this.right, l = this.top, h = this.bottom;\n      if (u <= o || h <= l)\n        return !1;\n      var d = jd[0].set(t.left, t.top), f = jd[1].set(t.left, t.bottom), p = jd[2].set(t.right, t.top), v = jd[3].set(t.right, t.bottom);\n      if (p.x <= d.x || f.y <= d.y)\n        return !1;\n      var g = Math.sign(e.a * e.d - e.b * e.c);\n      if (g === 0 || (e.apply(d, d), e.apply(f, f), e.apply(p, p), e.apply(v, v), Math.max(d.x, f.x, p.x, v.x) <= o || Math.min(d.x, f.x, p.x, v.x) >= u || Math.max(d.y, f.y, p.y, v.y) <= l || Math.min(d.y, f.y, p.y, v.y) >= h))\n        return !1;\n      var m = g * (f.y - d.y), y = g * (d.x - f.x), _ = m * o + y * l, b = m * u + y * l, w = m * o + y * h, T = m * u + y * h;\n      if (Math.max(_, b, w, T) <= m * d.x + y * d.y || Math.min(_, b, w, T) >= m * v.x + y * v.y)\n        return !1;\n      var x = g * (d.y - p.y), S = g * (p.x - d.x), C = x * o + S * l, M = x * u + S * l, I = x * o + S * h, R = x * u + S * h;\n      return !(Math.max(C, M, I, R) <= x * d.x + S * d.y || Math.min(C, M, I, R) >= x * v.x + S * v.y);\n    }, i.prototype.pad = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), this.x -= t, this.y -= e, this.width += t * 2, this.height += e * 2, this;\n    }, i.prototype.fit = function(t) {\n      var e = Math.max(this.x, t.x), r = Math.min(this.x + this.width, t.x + t.width), n = Math.max(this.y, t.y), s = Math.min(this.y + this.height, t.y + t.height);\n      return this.x = e, this.width = Math.max(r - e, 0), this.y = n, this.height = Math.max(s - n, 0), this;\n    }, i.prototype.ceil = function(t, e) {\n      t === void 0 && (t = 1), e === void 0 && (e = 1e-3);\n      var r = Math.ceil((this.x + this.width - e) * t) / t, n = Math.ceil((this.y + this.height - e) * t) / t;\n      return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = r - this.x, this.height = n - this.y, this;\n    }, i.prototype.enlarge = function(t) {\n      var e = Math.min(this.x, t.x), r = Math.max(this.x + this.width, t.x + t.width), n = Math.min(this.y, t.y), s = Math.max(this.y + this.height, t.y + t.height);\n      return this.x = e, this.width = r - e, this.y = n, this.height = s - n, this;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Rectangle x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    }, i;\n  }()\n), ND = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), this.x = t, this.y = e, this.radius = r, this.type = ur.CIRC;\n    }\n    return i.prototype.clone = function() {\n      return new i(this.x, this.y, this.radius);\n    }, i.prototype.contains = function(t, e) {\n      if (this.radius <= 0)\n        return !1;\n      var r = this.radius * this.radius, n = this.x - t, s = this.y - e;\n      return n *= n, s *= s, n + s <= r;\n    }, i.prototype.getBounds = function() {\n      return new Nt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Circle x=\" + this.x + \" y=\" + this.y + \" radius=\" + this.radius + \"]\";\n    }, i;\n  }()\n), AD = (\n  /** @class */\n  function() {\n    function i(t, e, r, n) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), this.x = t, this.y = e, this.width = r, this.height = n, this.type = ur.ELIP;\n    }\n    return i.prototype.clone = function() {\n      return new i(this.x, this.y, this.width, this.height);\n    }, i.prototype.contains = function(t, e) {\n      if (this.width <= 0 || this.height <= 0)\n        return !1;\n      var r = (t - this.x) / this.width, n = (e - this.y) / this.height;\n      return r *= r, n *= n, r + n <= 1;\n    }, i.prototype.getBounds = function() {\n      return new Nt(this.x - this.width, this.y - this.height, this.width, this.height);\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Ellipse x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \"]\";\n    }, i;\n  }()\n), Pp = (\n  /** @class */\n  function() {\n    function i() {\n      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n        e[r] = t[r];\n      var n = Array.isArray(e[0]) ? e[0] : e;\n      if (typeof n[0] != \"number\") {\n        for (var s = [], a = 0, o = n.length; a < o; a++)\n          s.push(n[a].x, n[a].y);\n        n = s;\n      }\n      this.points = n, this.type = ur.POLY, this.closeStroke = !0;\n    }\n    return i.prototype.clone = function() {\n      var t = this.points.slice(), e = new i(t);\n      return e.closeStroke = this.closeStroke, e;\n    }, i.prototype.contains = function(t, e) {\n      for (var r = !1, n = this.points.length / 2, s = 0, a = n - 1; s < n; a = s++) {\n        var o = this.points[s * 2], u = this.points[s * 2 + 1], l = this.points[a * 2], h = this.points[a * 2 + 1], d = u > e != h > e && t < (l - o) * ((e - u) / (h - u)) + o;\n        d && (r = !r);\n      }\n      return r;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Polygon\" + (\"closeStroke=\" + this.closeStroke) + (\"points=\" + this.points.reduce(function(t, e) {\n        return t + \", \" + e;\n      }, \"\") + \"]\");\n    }, i;\n  }()\n), LD = (\n  /** @class */\n  function() {\n    function i(t, e, r, n, s) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), s === void 0 && (s = 20), this.x = t, this.y = e, this.width = r, this.height = n, this.radius = s, this.type = ur.RREC;\n    }\n    return i.prototype.clone = function() {\n      return new i(this.x, this.y, this.width, this.height, this.radius);\n    }, i.prototype.contains = function(t, e) {\n      if (this.width <= 0 || this.height <= 0)\n        return !1;\n      if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {\n        var r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));\n        if (e >= this.y + r && e <= this.y + this.height - r || t >= this.x + r && t <= this.x + this.width - r)\n          return !0;\n        var n = t - (this.x + r), s = e - (this.y + r), a = r * r;\n        if (n * n + s * s <= a || (n = t - (this.x + this.width - r), n * n + s * s <= a) || (s = e - (this.y + this.height - r), n * n + s * s <= a) || (n = t - (this.x + r), n * n + s * s <= a))\n          return !0;\n      }\n      return !1;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:RoundedRectangle x=\" + this.x + \" y=\" + this.y + (\"width=\" + this.width + \" height=\" + this.height + \" radius=\" + this.radius + \"]\");\n    }, i;\n  }()\n), Ou = (\n  /** @class */\n  function() {\n    function i(t, e, r, n) {\n      r === void 0 && (r = 0), n === void 0 && (n = 0), this._x = r, this._y = n, this.cb = t, this.scope = e;\n    }\n    return i.prototype.clone = function(t, e) {\n      return t === void 0 && (t = this.cb), e === void 0 && (e = this.scope), new i(t, e, this._x, this._y);\n    }, i.prototype.set = function(t, e) {\n      return t === void 0 && (t = 0), e === void 0 && (e = t), (this._x !== t || this._y !== e) && (this._x = t, this._y = e, this.cb.call(this.scope)), this;\n    }, i.prototype.copyFrom = function(t) {\n      return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this;\n    }, i.prototype.copyTo = function(t) {\n      return t.set(this._x, this._y), t;\n    }, i.prototype.equals = function(t) {\n      return t.x === this._x && t.y === this._y;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:ObservablePoint x=0 y=0 scope=\" + this.scope + \"]\";\n    }, Object.defineProperty(i.prototype, \"x\", {\n      /** Position of the observable point on the x axis. */\n      get: function() {\n        return this._x;\n      },\n      set: function(t) {\n        this._x !== t && (this._x = t, this.cb.call(this.scope));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"y\", {\n      /** Position of the observable point on the y axis. */\n      get: function() {\n        return this._y;\n      },\n      set: function(t) {\n        this._y !== t && (this._y = t, this.cb.call(this.scope));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n), ar = (\n  /** @class */\n  function() {\n    function i(t, e, r, n, s, a) {\n      t === void 0 && (t = 1), e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 0), a === void 0 && (a = 0), this.array = null, this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = a;\n    }\n    return i.prototype.fromArray = function(t) {\n      this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5];\n    }, i.prototype.set = function(t, e, r, n, s, a) {\n      return this.a = t, this.b = e, this.c = r, this.d = n, this.tx = s, this.ty = a, this;\n    }, i.prototype.toArray = function(t, e) {\n      this.array || (this.array = new Float32Array(9));\n      var r = e || this.array;\n      return t ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;\n    }, i.prototype.apply = function(t, e) {\n      e = e || new xe();\n      var r = t.x, n = t.y;\n      return e.x = this.a * r + this.c * n + this.tx, e.y = this.b * r + this.d * n + this.ty, e;\n    }, i.prototype.applyInverse = function(t, e) {\n      e = e || new xe();\n      var r = 1 / (this.a * this.d + this.c * -this.b), n = t.x, s = t.y;\n      return e.x = this.d * r * n + -this.c * r * s + (this.ty * this.c - this.tx * this.d) * r, e.y = this.a * r * s + -this.b * r * n + (-this.ty * this.a + this.tx * this.b) * r, e;\n    }, i.prototype.translate = function(t, e) {\n      return this.tx += t, this.ty += e, this;\n    }, i.prototype.scale = function(t, e) {\n      return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this;\n    }, i.prototype.rotate = function(t) {\n      var e = Math.cos(t), r = Math.sin(t), n = this.a, s = this.c, a = this.tx;\n      return this.a = n * e - this.b * r, this.b = n * r + this.b * e, this.c = s * e - this.d * r, this.d = s * r + this.d * e, this.tx = a * e - this.ty * r, this.ty = a * r + this.ty * e, this;\n    }, i.prototype.append = function(t) {\n      var e = this.a, r = this.b, n = this.c, s = this.d;\n      return this.a = t.a * e + t.b * n, this.b = t.a * r + t.b * s, this.c = t.c * e + t.d * n, this.d = t.c * r + t.d * s, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * r + t.ty * s + this.ty, this;\n    }, i.prototype.setTransform = function(t, e, r, n, s, a, o, u, l) {\n      return this.a = Math.cos(o + l) * s, this.b = Math.sin(o + l) * s, this.c = -Math.sin(o - u) * a, this.d = Math.cos(o - u) * a, this.tx = t - (r * this.a + n * this.c), this.ty = e - (r * this.b + n * this.d), this;\n    }, i.prototype.prepend = function(t) {\n      var e = this.tx;\n      if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {\n        var r = this.a, n = this.c;\n        this.a = r * t.a + this.b * t.c, this.b = r * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d;\n      }\n      return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this;\n    }, i.prototype.decompose = function(t) {\n      var e = this.a, r = this.b, n = this.c, s = this.d, a = t.pivot, o = -Math.atan2(-n, s), u = Math.atan2(r, e), l = Math.abs(o + u);\n      return l < 1e-5 || Math.abs(pv - l) < 1e-5 ? (t.rotation = u, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = u), t.scale.x = Math.sqrt(e * e + r * r), t.scale.y = Math.sqrt(n * n + s * s), t.position.x = this.tx + (a.x * e + a.y * n), t.position.y = this.ty + (a.x * r + a.y * s), t;\n    }, i.prototype.invert = function() {\n      var t = this.a, e = this.b, r = this.c, n = this.d, s = this.tx, a = t * n - e * r;\n      return this.a = n / a, this.b = -e / a, this.c = -r / a, this.d = t / a, this.tx = (r * this.ty - n * s) / a, this.ty = -(t * this.ty - e * s) / a, this;\n    }, i.prototype.identity = function() {\n      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;\n    }, i.prototype.clone = function() {\n      var t = new i();\n      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n    }, i.prototype.copyTo = function(t) {\n      return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t;\n    }, i.prototype.copyFrom = function(t) {\n      return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Matrix a=\" + this.a + \" b=\" + this.b + \" c=\" + this.c + \" d=\" + this.d + \" tx=\" + this.tx + \" ty=\" + this.ty + \"]\";\n    }, Object.defineProperty(i, \"IDENTITY\", {\n      /**\n       * A default (identity) matrix\n       * @readonly\n       */\n      get: function() {\n        return new i();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"TEMP_MATRIX\", {\n      /**\n       * A temp matrix\n       * @readonly\n       */\n      get: function() {\n        return new i();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n), Sa = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Ta = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Ca = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Ma = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], _y = [], BE = [], zd = Math.sign;\nfunction BD() {\n  for (var i = 0; i < 16; i++) {\n    var t = [];\n    _y.push(t);\n    for (var e = 0; e < 16; e++)\n      for (var r = zd(Sa[i] * Sa[e] + Ca[i] * Ta[e]), n = zd(Ta[i] * Sa[e] + Ma[i] * Ta[e]), s = zd(Sa[i] * Ca[e] + Ca[i] * Ma[e]), a = zd(Ta[i] * Ca[e] + Ma[i] * Ma[e]), o = 0; o < 16; o++)\n        if (Sa[o] === r && Ta[o] === n && Ca[o] === s && Ma[o] === a) {\n          t.push(o);\n          break;\n        }\n  }\n  for (var i = 0; i < 16; i++) {\n    var u = new ar();\n    u.set(Sa[i], Ta[i], Ca[i], Ma[i], 0, 0), BE.push(u);\n  }\n}\nBD();\nvar Le = {\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 0°       | East      |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  E: 0,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 45°↻     | Southeast |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  SE: 1,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 90°↻     | South     |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  S: 2,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 135°↻    | Southwest |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  SW: 3,\n  /**\n   * | Rotation | Direction |\n   * |----------|-----------|\n   * | 180°     | West      |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  W: 4,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -135°/225°↻ | Northwest    |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  NW: 5,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -90°/270°↻  | North        |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  N: 6,\n  /**\n   * | Rotation    | Direction    |\n   * |-------------|--------------|\n   * | -45°/315°↻  | Northeast    |\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  NE: 7,\n  /**\n   * Reflection about Y-axis.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MIRROR_VERTICAL: 8,\n  /**\n   * Reflection about the main diagonal.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MAIN_DIAGONAL: 10,\n  /**\n   * Reflection about X-axis.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  MIRROR_HORIZONTAL: 12,\n  /**\n   * Reflection about reverse diagonal.\n   * @memberof PIXI.groupD8\n   * @constant {PIXI.GD8Symmetry}\n   */\n  REVERSE_DIAGONAL: 14,\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis\n   *    after rotating the axes.\n   */\n  uX: function(i) {\n    return Sa[i];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis\n   *    after rotating the axes.\n   */\n  uY: function(i) {\n    return Ta[i];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis\n   *    after rotating the axes.\n   */\n  vX: function(i) {\n    return Ca[i];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.\n   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis\n   *    after rotating the axes.\n   */\n  vY: function(i) {\n    return Ma[i];\n  },\n  /**\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite\n   *   is needed. Only rotations have opposite symmetries while\n   *   reflections don't.\n   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`\n   */\n  inv: function(i) {\n    return i & 8 ? i & 15 : -i & 7;\n  },\n  /**\n   * Composes the two D8 operations.\n   *\n   * Taking `^` as reflection:\n   *\n   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n   * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n   *\n   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which\n   *   is the row in the above cayley table.\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which\n   *   is the column in the above cayley table.\n   * @returns {PIXI.GD8Symmetry} Composed operation\n   */\n  add: function(i, t) {\n    return _y[i][t];\n  },\n  /**\n   * Reverse of `add`.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation\n   * @param {PIXI.GD8Symmetry} rotationFirst - First operation\n   * @returns {PIXI.GD8Symmetry} Result\n   */\n  sub: function(i, t) {\n    return _y[i][Le.inv(t)];\n  },\n  /**\n   * Adds 180 degrees to rotation, which is a commutative\n   * operation.\n   * @memberof PIXI.groupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} Rotated number\n   */\n  rotate180: function(i) {\n    return i ^ 4;\n  },\n  /**\n   * Checks if the rotation angle is vertical, i.e. south\n   * or north. It doesn't work for reflections.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.GD8Symmetry} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: function(i) {\n    return (i & 3) === 2;\n  },\n  /**\n   * Approximates the vector `V(dx,dy)` into one of the\n   * eight directions provided by `groupD8`.\n   * @memberof PIXI.groupD8\n   * @param {number} dx - X-component of the vector\n   * @param {number} dy - Y-component of the vector\n   * @returns {PIXI.GD8Symmetry} Approximation of the vector into\n   *  one of the eight symmetries.\n   */\n  byDirection: function(i, t) {\n    return Math.abs(i) * 2 <= Math.abs(t) ? t >= 0 ? Le.S : Le.N : Math.abs(t) * 2 <= Math.abs(i) ? i > 0 ? Le.E : Le.W : t > 0 ? i > 0 ? Le.SE : Le.SW : i > 0 ? Le.NE : Le.NW;\n  },\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   * @memberof PIXI.groupD8\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: function(i, t, e, r) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0);\n    var n = BE[Le.inv(t)];\n    n.tx = e, n.ty = r, i.append(n);\n  }\n}, FE = (\n  /** @class */\n  function() {\n    function i() {\n      this.worldTransform = new ar(), this.localTransform = new ar(), this.position = new Ou(this.onChange, this, 0, 0), this.scale = new Ou(this.onChange, this, 1, 1), this.pivot = new Ou(this.onChange, this, 0, 0), this.skew = new Ou(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;\n    }\n    return i.prototype.onChange = function() {\n      this._localID++;\n    }, i.prototype.updateSkew = function() {\n      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/math:Transform \" + (\"position=(\" + this.position.x + \", \" + this.position.y + \") \") + (\"rotation=\" + this.rotation + \" \") + (\"scale=(\" + this.scale.x + \", \" + this.scale.y + \") \") + (\"skew=(\" + this.skew.x + \", \" + this.skew.y + \") \") + \"]\";\n    }, i.prototype.updateLocalTransform = function() {\n      var t = this.localTransform;\n      this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1);\n    }, i.prototype.updateTransform = function(t) {\n      var e = this.localTransform;\n      if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {\n        var r = t.worldTransform, n = this.worldTransform;\n        n.a = e.a * r.a + e.b * r.c, n.b = e.a * r.b + e.b * r.d, n.c = e.c * r.a + e.d * r.c, n.d = e.c * r.b + e.d * r.d, n.tx = e.tx * r.a + e.ty * r.c + r.tx, n.ty = e.tx * r.b + e.ty * r.d + r.ty, this._parentID = t._worldID, this._worldID++;\n      }\n    }, i.prototype.setFromMatrix = function(t) {\n      t.decompose(this), this._localID++;\n    }, Object.defineProperty(i.prototype, \"rotation\", {\n      /** The rotation of the object in radians. */\n      get: function() {\n        return this._rotation;\n      },\n      set: function(t) {\n        this._rotation !== t && (this._rotation = t, this.updateSkew());\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.IDENTITY = new i(), i;\n  }()\n);\n/*!\n * @pixi/display - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/display is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ngt.SORTABLE_CHILDREN = !1;\nvar vv = (\n  /** @class */\n  function() {\n    function i() {\n      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;\n    }\n    return i.prototype.isEmpty = function() {\n      return this.minX > this.maxX || this.minY > this.maxY;\n    }, i.prototype.clear = function() {\n      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;\n    }, i.prototype.getRectangle = function(t) {\n      return this.minX > this.maxX || this.minY > this.maxY ? Nt.EMPTY : (t = t || new Nt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);\n    }, i.prototype.addPoint = function(t) {\n      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);\n    }, i.prototype.addPointMatrix = function(t, e) {\n      var r = t.a, n = t.b, s = t.c, a = t.d, o = t.tx, u = t.ty, l = r * e.x + s * e.y + o, h = n * e.x + a * e.y + u;\n      this.minX = Math.min(this.minX, l), this.maxX = Math.max(this.maxX, l), this.minY = Math.min(this.minY, h), this.maxY = Math.max(this.maxY, h);\n    }, i.prototype.addQuad = function(t) {\n      var e = this.minX, r = this.minY, n = this.maxX, s = this.maxY, a = t[0], o = t[1];\n      e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[2], o = t[3], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[4], o = t[5], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, a = t[6], o = t[7], e = a < e ? a : e, r = o < r ? o : r, n = a > n ? a : n, s = o > s ? o : s, this.minX = e, this.minY = r, this.maxX = n, this.maxY = s;\n    }, i.prototype.addFrame = function(t, e, r, n, s) {\n      this.addFrameMatrix(t.worldTransform, e, r, n, s);\n    }, i.prototype.addFrameMatrix = function(t, e, r, n, s) {\n      var a = t.a, o = t.b, u = t.c, l = t.d, h = t.tx, d = t.ty, f = this.minX, p = this.minY, v = this.maxX, g = this.maxY, m = a * e + u * r + h, y = o * e + l * r + d;\n      f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * n + u * r + h, y = o * n + l * r + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * e + u * s + h, y = o * e + l * s + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, m = a * n + u * s + h, y = o * n + l * s + d, f = m < f ? m : f, p = y < p ? y : p, v = m > v ? m : v, g = y > g ? y : g, this.minX = f, this.minY = p, this.maxX = v, this.maxY = g;\n    }, i.prototype.addVertexData = function(t, e, r) {\n      for (var n = this.minX, s = this.minY, a = this.maxX, o = this.maxY, u = e; u < r; u += 2) {\n        var l = t[u], h = t[u + 1];\n        n = l < n ? l : n, s = h < s ? h : s, a = l > a ? l : a, o = h > o ? h : o;\n      }\n      this.minX = n, this.minY = s, this.maxX = a, this.maxY = o;\n    }, i.prototype.addVertices = function(t, e, r, n) {\n      this.addVerticesMatrix(t.worldTransform, e, r, n);\n    }, i.prototype.addVerticesMatrix = function(t, e, r, n, s, a) {\n      s === void 0 && (s = 0), a === void 0 && (a = s);\n      for (var o = t.a, u = t.b, l = t.c, h = t.d, d = t.tx, f = t.ty, p = this.minX, v = this.minY, g = this.maxX, m = this.maxY, y = r; y < n; y += 2) {\n        var _ = e[y], b = e[y + 1], w = o * _ + l * b + d, T = h * b + u * _ + f;\n        p = Math.min(p, w - s), g = Math.max(g, w + s), v = Math.min(v, T - a), m = Math.max(m, T + a);\n      }\n      this.minX = p, this.minY = v, this.maxX = g, this.maxY = m;\n    }, i.prototype.addBounds = function(t) {\n      var e = this.minX, r = this.minY, n = this.maxX, s = this.maxY;\n      this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < r ? t.minY : r, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > s ? t.maxY : s;\n    }, i.prototype.addBoundsMask = function(t, e) {\n      var r = t.minX > e.minX ? t.minX : e.minX, n = t.minY > e.minY ? t.minY : e.minY, s = t.maxX < e.maxX ? t.maxX : e.maxX, a = t.maxY < e.maxY ? t.maxY : e.maxY;\n      if (r <= s && n <= a) {\n        var o = this.minX, u = this.minY, l = this.maxX, h = this.maxY;\n        this.minX = r < o ? r : o, this.minY = n < u ? n : u, this.maxX = s > l ? s : l, this.maxY = a > h ? a : h;\n      }\n    }, i.prototype.addBoundsMatrix = function(t, e) {\n      this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY);\n    }, i.prototype.addBoundsArea = function(t, e) {\n      var r = t.minX > e.x ? t.minX : e.x, n = t.minY > e.y ? t.minY : e.y, s = t.maxX < e.x + e.width ? t.maxX : e.x + e.width, a = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;\n      if (r <= s && n <= a) {\n        var o = this.minX, u = this.minY, l = this.maxX, h = this.maxY;\n        this.minX = r < o ? r : o, this.minY = n < u ? n : u, this.maxX = s > l ? s : l, this.maxY = a > h ? a : h;\n      }\n    }, i.prototype.pad = function(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e);\n    }, i.prototype.addFramePad = function(t, e, r, n, s, a) {\n      t -= s, e -= a, r += s, n += a, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n;\n    }, i;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar by = function(i, t) {\n  return by = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, by(i, t);\n};\nfunction Eb(i, t) {\n  by(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar He = (\n  /** @class */\n  function(i) {\n    Eb(t, i);\n    function t() {\n      var e = i.call(this) || this;\n      return e.tempDisplayObjectParent = null, e.transform = new FE(), e.alpha = 1, e.visible = !0, e.renderable = !0, e.cullable = !1, e.cullArea = null, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new vv(), e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._maskRefCount = 0, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e;\n    }\n    return t.mixin = function(e) {\n      for (var r = Object.keys(e), n = 0; n < r.length; ++n) {\n        var s = r[n];\n        Object.defineProperty(t.prototype, s, Object.getOwnPropertyDescriptor(e, s));\n      }\n    }, Object.defineProperty(t.prototype, \"destroyed\", {\n      /**\n       * Fired when this DisplayObject is added to a Container.\n       * @instance\n       * @event added\n       * @param {PIXI.Container} container - The container added to.\n       */\n      /**\n       * Fired when this DisplayObject is removed from a Container.\n       * @instance\n       * @event removed\n       * @param {PIXI.Container} container - The container removed from.\n       */\n      /**\n       * Fired when this DisplayObject is destroyed. This event is emitted once\n       * destroy is finished.\n       * @instance\n       * @event destroyed\n       */\n      /** Readonly flag for destroyed display objects. */\n      get: function() {\n        return this._destroyed;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._recursivePostUpdateTransform = function() {\n      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }, t.prototype.updateTransform = function() {\n      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    }, t.prototype.getBounds = function(e, r) {\n      return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Nt()), r = this._boundsRect), this._bounds.getRectangle(r);\n    }, t.prototype.getLocalBounds = function(e) {\n      e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._localBounds || (this._localBounds = new vv());\n      var r = this.transform, n = this.parent;\n      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;\n      var s = this._bounds, a = this._boundsID;\n      this._bounds = this._localBounds;\n      var o = this.getBounds(!1, e);\n      return this.parent = n, this.transform = r, this._bounds = s, this._bounds.updateID += this._boundsID - a, o;\n    }, t.prototype.toGlobal = function(e, r, n) {\n      return n === void 0 && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, r);\n    }, t.prototype.toLocal = function(e, r, n, s) {\n      return r && (e = r.toGlobal(e, n, s)), s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, n);\n    }, t.prototype.setParent = function(e) {\n      if (!e || !e.addChild)\n        throw new Error(\"setParent: Argument must be a Container\");\n      return e.addChild(this), e;\n    }, t.prototype.setTransform = function(e, r, n, s, a, o, u, l, h) {\n      return e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 1), a === void 0 && (a = 0), o === void 0 && (o = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), this.position.x = e, this.position.y = r, this.scale.x = n || 1, this.scale.y = s || 1, this.rotation = a, this.skew.x = o, this.skew.y = u, this.pivot.x = l, this.pivot.y = h, this;\n    }, t.prototype.destroy = function(e) {\n      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit(\"destroyed\"), this.removeAllListeners();\n    }, Object.defineProperty(t.prototype, \"_tempDisplayObjectParent\", {\n      /**\n       * @protected\n       * @member {PIXI.Container}\n       */\n      get: function() {\n        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new GE()), this.tempDisplayObjectParent;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.enableTempParent = function() {\n      var e = this.parent;\n      return this.parent = this._tempDisplayObjectParent, e;\n    }, t.prototype.disableTempParent = function(e) {\n      this.parent = e;\n    }, Object.defineProperty(t.prototype, \"x\", {\n      /**\n       * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n       * An alias to position.x\n       */\n      get: function() {\n        return this.position.x;\n      },\n      set: function(e) {\n        this.transform.position.x = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"y\", {\n      /**\n       * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n       * An alias to position.y\n       */\n      get: function() {\n        return this.position.y;\n      },\n      set: function(e) {\n        this.transform.position.y = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"worldTransform\", {\n      /**\n       * Current transform of the object based on world (parent) factors.\n       * @readonly\n       */\n      get: function() {\n        return this.transform.worldTransform;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"localTransform\", {\n      /**\n       * Current transform of the object based on local factors: position, scale, other stuff.\n       * @readonly\n       */\n      get: function() {\n        return this.transform.localTransform;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"position\", {\n      /**\n       * The coordinate of the object relative to the local coordinates of the parent.\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.position;\n      },\n      set: function(e) {\n        this.transform.position.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"scale\", {\n      /**\n       * The scale factors of this object along the local coordinate axes.\n       *\n       * The default scale is (1, 1).\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.scale;\n      },\n      set: function(e) {\n        this.transform.scale.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"pivot\", {\n      /**\n       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n       * is the projection of `pivot` in the parent's local space.\n       *\n       * By default, the pivot is the origin (0, 0).\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.pivot;\n      },\n      set: function(e) {\n        this.transform.pivot.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"skew\", {\n      /**\n       * The skew factor for the object in radians.\n       * @since 4.0.0\n       */\n      get: function() {\n        return this.transform.skew;\n      },\n      set: function(e) {\n        this.transform.skew.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rotation\", {\n      /**\n       * The rotation of the object in radians.\n       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n       */\n      get: function() {\n        return this.transform.rotation;\n      },\n      set: function(e) {\n        this.transform.rotation = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"angle\", {\n      /**\n       * The angle of the object in degrees.\n       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n       */\n      get: function() {\n        return this.transform.rotation * DD;\n      },\n      set: function(e) {\n        this.transform.rotation = e * kD;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"zIndex\", {\n      /**\n       * The zIndex of the displayObject.\n       *\n       * If a container has the sortableChildren property set to true, children will be automatically\n       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n       * and thus rendered on top of other display objects within the same container.\n       * @see PIXI.Container#sortableChildren\n       */\n      get: function() {\n        return this._zIndex;\n      },\n      set: function(e) {\n        this._zIndex = e, this.parent && (this.parent.sortDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"worldVisible\", {\n      /**\n       * Indicates if the object is globally visible.\n       * @readonly\n       */\n      get: function() {\n        var e = this;\n        do {\n          if (!e.visible)\n            return !1;\n          e = e.parent;\n        } while (e);\n        return !0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"mask\", {\n      /**\n       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it\n       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n       * To remove a mask, set this property to `null`.\n       *\n       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n       * @example\n       * const graphics = new PIXI.Graphics();\n       * graphics.beginFill(0xFF3300);\n       * graphics.drawRect(50, 250, 100, 100);\n       * graphics.endFill();\n       *\n       * const sprite = new PIXI.Sprite(texture);\n       * sprite.mask = graphics;\n       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n       */\n      get: function() {\n        return this._mask;\n      },\n      set: function(e) {\n        if (this._mask !== e) {\n          if (this._mask) {\n            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n            r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = !0, r.isMask = !1));\n          }\n          if (this._mask = e, this._mask) {\n            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;\n            r && (r._maskRefCount === 0 && (r.renderable = !1, r.isMask = !0), r._maskRefCount++);\n          }\n        }\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }($r)\n), GE = (\n  /** @class */\n  function(i) {\n    Eb(t, i);\n    function t() {\n      var e = i !== null && i.apply(this, arguments) || this;\n      return e.sortDirty = null, e;\n    }\n    return t;\n  }(He)\n);\nHe.prototype.displayObjectUpdateTransform = He.prototype.updateTransform;\nfunction FD(i, t) {\n  return i.zIndex === t.zIndex ? i._lastSortedIndex - t._lastSortedIndex : i.zIndex - t.zIndex;\n}\nvar ye = (\n  /** @class */\n  function(i) {\n    Eb(t, i);\n    function t() {\n      var e = i.call(this) || this;\n      return e.children = [], e.sortableChildren = gt.SORTABLE_CHILDREN, e.sortDirty = !1, e;\n    }\n    return t.prototype.onChildrenChange = function(e) {\n    }, t.prototype.addChild = function() {\n      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)\n        r[n] = e[n];\n      if (r.length > 1)\n        for (var s = 0; s < r.length; s++)\n          this.addChild(r[s]);\n      else {\n        var a = r[0];\n        a.parent && a.parent.removeChild(a), a.parent = this, this.sortDirty = !0, a.transform._parentID = -1, this.children.push(a), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit(\"childAdded\", a, this, this.children.length - 1), a.emit(\"added\", this);\n      }\n      return r[0];\n    }, t.prototype.addChildAt = function(e, r) {\n      if (r < 0 || r > this.children.length)\n        throw new Error(e + \"addChildAt: The index \" + r + \" supplied is out of bounds \" + this.children.length);\n      return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(r, 0, e), this._boundsID++, this.onChildrenChange(r), e.emit(\"added\", this), this.emit(\"childAdded\", e, this, r), e;\n    }, t.prototype.swapChildren = function(e, r) {\n      if (e !== r) {\n        var n = this.getChildIndex(e), s = this.getChildIndex(r);\n        this.children[n] = r, this.children[s] = e, this.onChildrenChange(n < s ? n : s);\n      }\n    }, t.prototype.getChildIndex = function(e) {\n      var r = this.children.indexOf(e);\n      if (r === -1)\n        throw new Error(\"The supplied DisplayObject must be a child of the caller\");\n      return r;\n    }, t.prototype.setChildIndex = function(e, r) {\n      if (r < 0 || r >= this.children.length)\n        throw new Error(\"The index \" + r + \" supplied is out of bounds \" + this.children.length);\n      var n = this.getChildIndex(e);\n      Bu(this.children, n, 1), this.children.splice(r, 0, e), this.onChildrenChange(r);\n    }, t.prototype.getChildAt = function(e) {\n      if (e < 0 || e >= this.children.length)\n        throw new Error(\"getChildAt: Index (\" + e + \") does not exist.\");\n      return this.children[e];\n    }, t.prototype.removeChild = function() {\n      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)\n        r[n] = e[n];\n      if (r.length > 1)\n        for (var s = 0; s < r.length; s++)\n          this.removeChild(r[s]);\n      else {\n        var a = r[0], o = this.children.indexOf(a);\n        if (o === -1)\n          return null;\n        a.parent = null, a.transform._parentID = -1, Bu(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), a.emit(\"removed\", this), this.emit(\"childRemoved\", a, this, o);\n      }\n      return r[0];\n    }, t.prototype.removeChildAt = function(e) {\n      var r = this.getChildAt(e);\n      return r.parent = null, r.transform._parentID = -1, Bu(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), r.emit(\"removed\", this), this.emit(\"childRemoved\", r, this, e), r;\n    }, t.prototype.removeChildren = function(e, r) {\n      e === void 0 && (e = 0), r === void 0 && (r = this.children.length);\n      var n = e, s = r, a = s - n, o;\n      if (a > 0 && a <= s) {\n        o = this.children.splice(n, a);\n        for (var u = 0; u < o.length; ++u)\n          o[u].parent = null, o[u].transform && (o[u].transform._parentID = -1);\n        this._boundsID++, this.onChildrenChange(e);\n        for (var u = 0; u < o.length; ++u)\n          o[u].emit(\"removed\", this), this.emit(\"childRemoved\", o[u], this, u);\n        return o;\n      } else if (a === 0 && this.children.length === 0)\n        return [];\n      throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n    }, t.prototype.sortChildren = function() {\n      for (var e = !1, r = 0, n = this.children.length; r < n; ++r) {\n        var s = this.children[r];\n        s._lastSortedIndex = r, !e && s.zIndex !== 0 && (e = !0);\n      }\n      e && this.children.length > 1 && this.children.sort(FD), this.sortDirty = !1;\n    }, t.prototype.updateTransform = function() {\n      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;\n      for (var e = 0, r = this.children.length; e < r; ++e) {\n        var n = this.children[e];\n        n.visible && n.updateTransform();\n      }\n    }, t.prototype.calculateBounds = function() {\n      this._bounds.clear(), this._calculateBounds();\n      for (var e = 0; e < this.children.length; e++) {\n        var r = this.children[e];\n        if (!(!r.visible || !r.renderable))\n          if (r.calculateBounds(), r._mask) {\n            var n = r._mask.isMaskData ? r._mask.maskObject : r._mask;\n            n ? (n.calculateBounds(), this._bounds.addBoundsMask(r._bounds, n._bounds)) : this._bounds.addBounds(r._bounds);\n          } else\n            r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);\n      }\n      this._bounds.updateID = this._boundsID;\n    }, t.prototype.getLocalBounds = function(e, r) {\n      r === void 0 && (r = !1);\n      var n = i.prototype.getLocalBounds.call(this, e);\n      if (!r)\n        for (var s = 0, a = this.children.length; s < a; ++s) {\n          var o = this.children[s];\n          o.visible && o.updateTransform();\n        }\n      return n;\n    }, t.prototype._calculateBounds = function() {\n    }, t.prototype._renderWithCulling = function(e) {\n      var r = e.renderTexture.sourceFrame;\n      if (r.width > 0 && r.height > 0) {\n        var n, s;\n        if (this.cullArea ? (n = this.cullArea, s = this.worldTransform) : this._render !== t.prototype._render && (n = this.getBounds(!0)), n && r.intersects(n, s))\n          this._render(e);\n        else if (this.cullArea)\n          return;\n        for (var a = 0, o = this.children.length; a < o; ++a) {\n          var u = this.children[a], l = u.cullable;\n          u.cullable = l || !this.cullArea, u.render(e), u.cullable = l;\n        }\n      }\n    }, t.prototype.render = function(e) {\n      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))\n        if (this._mask || this.filters && this.filters.length)\n          this.renderAdvanced(e);\n        else if (this.cullable)\n          this._renderWithCulling(e);\n        else {\n          this._render(e);\n          for (var r = 0, n = this.children.length; r < n; ++r)\n            this.children[r].render(e);\n        }\n    }, t.prototype.renderAdvanced = function(e) {\n      var r = this.filters, n = this._mask;\n      if (r) {\n        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;\n        for (var s = 0; s < r.length; s++)\n          r[s].enabled && this._enabledFilters.push(r[s]);\n      }\n      var a = r && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== Ze.NONE));\n      if (a && e.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && e.filter.push(this, this._enabledFilters), n && e.mask.push(this, this._mask), this.cullable)\n        this._renderWithCulling(e);\n      else {\n        this._render(e);\n        for (var s = 0, o = this.children.length; s < o; ++s)\n          this.children[s].render(e);\n      }\n      a && e.batch.flush(), n && e.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && e.filter.pop();\n    }, t.prototype._render = function(e) {\n    }, t.prototype.destroy = function(e) {\n      i.prototype.destroy.call(this), this.sortDirty = !1;\n      var r = typeof e == \"boolean\" ? e : e && e.children, n = this.removeChildren(0, this.children.length);\n      if (r)\n        for (var s = 0; s < n.length; ++s)\n          n[s].destroy(e);\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.scale.x * this.getLocalBounds().width;\n      },\n      set: function(e) {\n        var r = this.getLocalBounds().width;\n        r !== 0 ? this.scale.x = e / r : this.scale.x = 1, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.scale.y * this.getLocalBounds().height;\n      },\n      set: function(e) {\n        var r = this.getLocalBounds().height;\n        r !== 0 ? this.scale.y = e / r : this.scale.y = 1, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(He)\n);\nye.prototype.containerUpdateTransform = ye.prototype.updateTransform;\n/*!\n * @pixi/extensions - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/extensions is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Wh = function() {\n  return Wh = Object.assign || function(t) {\n    for (var e = arguments, r, n = 1, s = arguments.length; n < s; n++) {\n      r = e[n];\n      for (var a in r)\n        Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);\n    }\n    return t;\n  }, Wh.apply(this, arguments);\n}, fe;\n(function(i) {\n  i.Application = \"application\", i.RendererPlugin = \"renderer-webgl-plugin\", i.CanvasRendererPlugin = \"renderer-canvas-plugin\", i.Loader = \"loader\", i.LoadParser = \"load-parser\", i.ResolveParser = \"resolve-parser\", i.CacheParser = \"cache-parser\", i.DetectionParser = \"detection-parser\";\n})(fe || (fe = {}));\nvar _1 = function(i) {\n  if (typeof i == \"function\" || typeof i == \"object\" && i.extension) {\n    if (!i.extension)\n      throw new Error(\"Extension class must have an extension object\");\n    var t = typeof i.extension != \"object\" ? { type: i.extension } : i.extension;\n    i = Wh(Wh({}, t), { ref: i });\n  }\n  if (typeof i == \"object\")\n    i = Wh({}, i);\n  else\n    throw new Error(\"Invalid extension type\");\n  return typeof i.type == \"string\" && (i.type = [i.type]), i;\n}, an = {\n  /** @ignore */\n  _addHandlers: null,\n  /** @ignore */\n  _removeHandlers: null,\n  /** @ignore */\n  _queue: {},\n  /**\n   * Remove extensions from PixiJS.\n   * @param extensions - Extensions to be removed.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  remove: function() {\n    for (var i = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = i[r];\n    return e.map(_1).forEach(function(n) {\n      n.type.forEach(function(s) {\n        var a, o;\n        return (o = (a = t._removeHandlers)[s]) === null || o === void 0 ? void 0 : o.call(a, n);\n      });\n    }), this;\n  },\n  /**\n   * Register new extensions with PixiJS.\n   * @param extensions - The spread of extensions to add to PixiJS.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  add: function() {\n    for (var i = arguments, t = this, e = [], r = 0; r < arguments.length; r++)\n      e[r] = i[r];\n    return e.map(_1).forEach(function(n) {\n      n.type.forEach(function(s) {\n        var a = t._addHandlers, o = t._queue;\n        a[s] ? a[s](n) : (o[s] = o[s] || [], o[s].push(n));\n      });\n    }), this;\n  },\n  /**\n   * Internal method to handle extensions by name.\n   * @param type - The extension type.\n   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.\n   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handle: function(i, t, e) {\n    var r = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {};\n    if (r[i] || n[i])\n      throw new Error(\"Extension type \" + i + \" already has a handler\");\n    r[i] = t, n[i] = e;\n    var s = this._queue;\n    return s[i] && (s[i].forEach(function(a) {\n      return t(a);\n    }), delete s[i]), this;\n  },\n  /**\n   * Handle a type, but using a map by `name` property.\n   * @param type - Type of extension to handle.\n   * @param map - The object map of named extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByMap: function(i, t) {\n    return this.handle(i, function(e) {\n      t[e.name] = e.ref;\n    }, function(e) {\n      delete t[e.name];\n    });\n  },\n  /**\n   * Handle a type, but using a list of extensions.\n   * @param type - Type of extension to handle.\n   * @param list - The list of extensions.\n   * @returns {PIXI.extensions} For chaining.\n   */\n  handleByList: function(i, t) {\n    return this.handle(i, function(e) {\n      var r, n;\n      t.includes(e.ref) || (t.push(e.ref), i === fe.Loader && ((n = (r = e.ref).add) === null || n === void 0 || n.call(r)));\n    }, function(e) {\n      var r = t.indexOf(e.ref);\n      r !== -1 && t.splice(r, 1);\n    });\n  }\n};\n/*!\n * @pixi/runner - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/runner is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar pr = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.items = [], this._name = t, this._aliasCount = 0;\n    }\n    return i.prototype.emit = function(t, e, r, n, s, a, o, u) {\n      if (arguments.length > 8)\n        throw new Error(\"max arguments reached\");\n      var l = this, h = l.name, d = l.items;\n      this._aliasCount++;\n      for (var f = 0, p = d.length; f < p; f++)\n        d[f][h](t, e, r, n, s, a, o, u);\n      return d === this.items && this._aliasCount--, this;\n    }, i.prototype.ensureNonAliasedItems = function() {\n      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));\n    }, i.prototype.add = function(t) {\n      return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this;\n    }, i.prototype.remove = function(t) {\n      var e = this.items.indexOf(t);\n      return e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this;\n    }, i.prototype.contains = function(t) {\n      return this.items.indexOf(t) !== -1;\n    }, i.prototype.removeAll = function() {\n      return this.ensureNonAliasedItems(), this.items.length = 0, this;\n    }, i.prototype.destroy = function() {\n      this.removeAll(), this.items = null, this._name = null;\n    }, Object.defineProperty(i.prototype, \"empty\", {\n      /**\n       * `true` if there are no this Runner contains no listeners\n       * @readonly\n       */\n      get: function() {\n        return this.items.length === 0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"name\", {\n      /**\n       * The name of the runner.\n       * @readonly\n       */\n      get: function() {\n        return this._name;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n);\nObject.defineProperties(pr.prototype, {\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method dispatch\n   * @see PIXI.Runner#emit\n   */\n  dispatch: { value: pr.prototype.emit },\n  /**\n   * Alias for `emit`\n   * @memberof PIXI.Runner#\n   * @method run\n   * @see PIXI.Runner#emit\n   */\n  run: { value: pr.prototype.emit }\n});\n/*!\n * @pixi/ticker - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/ticker is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ngt.TARGET_FPMS = 0.06;\nvar Cs;\n(function(i) {\n  i[i.INTERACTION = 50] = \"INTERACTION\", i[i.HIGH = 25] = \"HIGH\", i[i.NORMAL = 0] = \"NORMAL\", i[i.LOW = -25] = \"LOW\", i[i.UTILITY = -50] = \"UTILITY\";\n})(Cs || (Cs = {}));\nvar R0 = (\n  /** @class */\n  function() {\n    function i(t, e, r, n) {\n      e === void 0 && (e = null), r === void 0 && (r = 0), n === void 0 && (n = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = e, this.priority = r, this.once = n;\n    }\n    return i.prototype.match = function(t, e) {\n      return e === void 0 && (e = null), this.fn === t && this.context === e;\n    }, i.prototype.emit = function(t) {\n      this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));\n      var e = this.next;\n      return this.once && this.destroy(!0), this._destroyed && (this.next = null), e;\n    }, i.prototype.connect = function(t) {\n      this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this;\n    }, i.prototype.destroy = function(t) {\n      t === void 0 && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);\n      var e = this.next;\n      return this.next = t ? null : e, this.previous = null, e;\n    }, i;\n  }()\n), Ge = (\n  /** @class */\n  function() {\n    function i() {\n      var t = this;\n      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new R0(null, null, 1 / 0), this.deltaMS = 1 / gt.TARGET_FPMS, this.elapsedMS = 1 / gt.TARGET_FPMS, this._tick = function(e) {\n        t._requestId = null, t.started && (t.update(e), t.started && t._requestId === null && t._head.next && (t._requestId = requestAnimationFrame(t._tick)));\n      };\n    }\n    return i.prototype._requestIfNeeded = function() {\n      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n    }, i.prototype._cancelIfNeeded = function() {\n      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n    }, i.prototype._startIfPossible = function() {\n      this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n    }, i.prototype.add = function(t, e, r) {\n      return r === void 0 && (r = Cs.NORMAL), this._addListener(new R0(t, e, r));\n    }, i.prototype.addOnce = function(t, e, r) {\n      return r === void 0 && (r = Cs.NORMAL), this._addListener(new R0(t, e, r, !0));\n    }, i.prototype._addListener = function(t) {\n      var e = this._head.next, r = this._head;\n      if (!e)\n        t.connect(r);\n      else {\n        for (; e; ) {\n          if (t.priority > e.priority) {\n            t.connect(r);\n            break;\n          }\n          r = e, e = e.next;\n        }\n        t.previous || t.connect(r);\n      }\n      return this._startIfPossible(), this;\n    }, i.prototype.remove = function(t, e) {\n      for (var r = this._head.next; r; )\n        r.match(t, e) ? r = r.destroy() : r = r.next;\n      return this._head.next || this._cancelIfNeeded(), this;\n    }, Object.defineProperty(i.prototype, \"count\", {\n      /**\n       * The number of listeners on this ticker, calculated by walking through linked list\n       * @readonly\n       * @member {number}\n       */\n      get: function() {\n        if (!this._head)\n          return 0;\n        for (var t = 0, e = this._head; e = e.next; )\n          t++;\n        return t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.start = function() {\n      this.started || (this.started = !0, this._requestIfNeeded());\n    }, i.prototype.stop = function() {\n      this.started && (this.started = !1, this._cancelIfNeeded());\n    }, i.prototype.destroy = function() {\n      if (!this._protected) {\n        this.stop();\n        for (var t = this._head.next; t; )\n          t = t.destroy(!0);\n        this._head.destroy(), this._head = null;\n      }\n    }, i.prototype.update = function(t) {\n      t === void 0 && (t = performance.now());\n      var e;\n      if (t > this.lastTime) {\n        if (e = this.elapsedMS = t - this.lastTime, e > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {\n          var r = t - this._lastFrame | 0;\n          if (r < this._minElapsedMS)\n            return;\n          this._lastFrame = t - r % this._minElapsedMS;\n        }\n        this.deltaMS = e, this.deltaTime = this.deltaMS * gt.TARGET_FPMS;\n        for (var n = this._head, s = n.next; s; )\n          s = s.emit(this.deltaTime);\n        n.next || this._cancelIfNeeded();\n      } else\n        this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n      this.lastTime = t;\n    }, Object.defineProperty(i.prototype, \"FPS\", {\n      /**\n       * The frames per second at which this ticker is running.\n       * The default is approximately 60 in most modern browsers.\n       * **Note:** This does not factor in the value of\n       * {@link PIXI.Ticker#speed}, which is specific\n       * to scaling {@link PIXI.Ticker#deltaTime}.\n       * @member {number}\n       * @readonly\n       */\n      get: function() {\n        return 1e3 / this.elapsedMS;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"minFPS\", {\n      /**\n       * Manages the maximum amount of milliseconds allowed to\n       * elapse between invoking {@link PIXI.Ticker#update}.\n       * This value is used to cap {@link PIXI.Ticker#deltaTime},\n       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n       * When setting this property it is clamped to a value between\n       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.\n       * @member {number}\n       * @default 10\n       */\n      get: function() {\n        return 1e3 / this._maxElapsedMS;\n      },\n      set: function(t) {\n        var e = Math.min(this.maxFPS, t), r = Math.min(Math.max(0, e) / 1e3, gt.TARGET_FPMS);\n        this._maxElapsedMS = 1 / r;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"maxFPS\", {\n      /**\n       * Manages the minimum amount of milliseconds required to\n       * elapse between invoking {@link PIXI.Ticker#update}.\n       * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n       * Otherwise it will be at least `minFPS`\n       * @member {number}\n       * @default 0\n       */\n      get: function() {\n        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n      },\n      set: function(t) {\n        if (t === 0)\n          this._minElapsedMS = 0;\n        else {\n          var e = Math.max(this.minFPS, t);\n          this._minElapsedMS = 1 / (e / 1e3);\n        }\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"shared\", {\n      /**\n       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n       * {@link PIXI.VideoResource} to update animation frames / video textures.\n       *\n       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n       *\n       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n       * @example\n       * let ticker = PIXI.Ticker.shared;\n       * // Set this to prevent starting this ticker when listeners are added.\n       * // By default this is true only for the PIXI.Ticker.shared instance.\n       * ticker.autoStart = false;\n       * // FYI, call this to ensure the ticker is stopped. It should be stopped\n       * // if you have not attempted to render anything yet.\n       * ticker.stop();\n       * // Call this when you are ready for a running shared ticker.\n       * ticker.start();\n       * @example\n       * // You may use the shared ticker to render...\n       * let renderer = PIXI.autoDetectRenderer();\n       * let stage = new PIXI.Container();\n       * document.body.appendChild(renderer.view);\n       * ticker.add(function (time) {\n       *     renderer.render(stage);\n       * });\n       * @example\n       * // Or you can just update it manually.\n       * ticker.autoStart = false;\n       * ticker.stop();\n       * function animate(time) {\n       *     ticker.update(time);\n       *     renderer.render(stage);\n       *     requestAnimationFrame(animate);\n       * }\n       * animate(performance.now());\n       * @member {PIXI.Ticker}\n       * @static\n       */\n      get: function() {\n        if (!i._shared) {\n          var t = i._shared = new i();\n          t.autoStart = !0, t._protected = !0;\n        }\n        return i._shared;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"system\", {\n      /**\n       * The system ticker instance used by {@link PIXI.InteractionManager} and by\n       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,\n       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.\n       *\n       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n       * @member {PIXI.Ticker}\n       * @static\n       */\n      get: function() {\n        if (!i._system) {\n          var t = i._system = new i();\n          t.autoStart = !0, t._protected = !0;\n        }\n        return i._system;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n), GD = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.init = function(t) {\n      var e = this;\n      t = Object.assign({\n        autoStart: !0,\n        sharedTicker: !1\n      }, t), Object.defineProperty(this, \"ticker\", {\n        set: function(r) {\n          this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, Cs.LOW);\n        },\n        get: function() {\n          return this._ticker;\n        }\n      }), this.stop = function() {\n        e._ticker.stop();\n      }, this.start = function() {\n        e._ticker.start();\n      }, this._ticker = null, this.ticker = t.sharedTicker ? Ge.shared : new Ge(), t.autoStart && this.start();\n    }, i.destroy = function() {\n      if (this._ticker) {\n        var t = this._ticker;\n        this.ticker = null, t.destroy();\n      }\n    }, i.extension = fe.Application, i;\n  }()\n);\n/*!\n * @pixi/core - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/core is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ngt.PREFER_ENV = Mn.any ? Ts.WEBGL : Ts.WEBGL2;\ngt.STRICT_TEXTURE_CACHE = !1;\nvar lc = [];\nfunction e0(i, t) {\n  if (!i)\n    return null;\n  var e = \"\";\n  if (typeof i == \"string\") {\n    var r = /\\.(\\w{3,4})(?:$|\\?|#)/i.exec(i);\n    r && (e = r[1].toLowerCase());\n  }\n  for (var n = lc.length - 1; n >= 0; --n) {\n    var s = lc[n];\n    if (s.test && s.test(i, e))\n      return new s(i, t);\n  }\n  throw new Error(\"Unrecognized source type to auto-detect Resource\");\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar xy = function(i, t) {\n  return xy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, xy(i, t);\n};\nfunction Ce(i, t) {\n  xy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar wy = function() {\n  return wy = Object.assign || function(t) {\n    for (var e = arguments, r, n = 1, s = arguments.length; n < s; n++) {\n      r = e[n];\n      for (var a in r)\n        Object.prototype.hasOwnProperty.call(r, a) && (t[a] = r[a]);\n    }\n    return t;\n  }, wy.apply(this, arguments);\n};\nfunction UD(i, t) {\n  var e = {};\n  for (var r in i)\n    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);\n  if (i != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)\n      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);\n  return e;\n}\nvar Jo = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      t === void 0 && (t = 0), e === void 0 && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new pr(\"setRealSize\"), this.onUpdate = new pr(\"update\"), this.onError = new pr(\"onError\");\n    }\n    return i.prototype.bind = function(t) {\n      this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height);\n    }, i.prototype.unbind = function(t) {\n      this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t);\n    }, i.prototype.resize = function(t, e) {\n      (t !== this._width || e !== this._height) && (this._width = t, this._height = e, this.onResize.emit(t, e));\n    }, Object.defineProperty(i.prototype, \"valid\", {\n      /**\n       * Has been validated\n       * @readonly\n       */\n      get: function() {\n        return !!this._width && !!this._height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.update = function() {\n      this.destroyed || this.onUpdate.emit();\n    }, i.prototype.load = function() {\n      return Promise.resolve(this);\n    }, Object.defineProperty(i.prototype, \"width\", {\n      /**\n       * The width of the resource.\n       * @readonly\n       */\n      get: function() {\n        return this._width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"height\", {\n      /**\n       * The height of the resource.\n       * @readonly\n       */\n      get: function() {\n        return this._height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.style = function(t, e, r) {\n      return !1;\n    }, i.prototype.dispose = function() {\n    }, i.prototype.destroy = function() {\n      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);\n    }, i.test = function(t, e) {\n      return !1;\n    }, i;\n  }()\n), au = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this, s = r || {}, a = s.width, o = s.height;\n      if (!a || !o)\n        throw new Error(\"BufferResource width or height invalid\");\n      return n = i.call(this, a, o) || this, n.data = e, n;\n    }\n    return t.prototype.upload = function(e, r, n) {\n      var s = e.gl;\n      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK);\n      var a = r.realWidth, o = r.realHeight;\n      return n.width === a && n.height === o ? s.texSubImage2D(r.target, 0, 0, 0, a, o, r.format, n.type, this.data) : (n.width = a, n.height = o, s.texImage2D(r.target, 0, n.internalFormat, a, o, 0, r.format, n.type, this.data)), !0;\n    }, t.prototype.dispose = function() {\n      this.data = null;\n    }, t.test = function(e) {\n      return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array;\n    }, t;\n  }(Jo)\n), jD = {\n  scaleMode: Cn.NEAREST,\n  format: ht.RGBA,\n  alphaMode: en.NPM\n}, Kt = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      e === void 0 && (e = null), r === void 0 && (r = null);\n      var n = i.call(this) || this;\n      r = r || {};\n      var s = r.alphaMode, a = r.mipmap, o = r.anisotropicLevel, u = r.scaleMode, l = r.width, h = r.height, d = r.wrapMode, f = r.format, p = r.type, v = r.target, g = r.resolution, m = r.resourceOptions;\n      return e && !(e instanceof Jo) && (e = e0(e, m), e.internal = !0), n.resolution = g || gt.RESOLUTION, n.width = Math.round((l || 0) * n.resolution) / n.resolution, n.height = Math.round((h || 0) * n.resolution) / n.resolution, n._mipmap = a !== void 0 ? a : gt.MIPMAP_TEXTURES, n.anisotropicLevel = o !== void 0 ? o : gt.ANISOTROPIC_LEVEL, n._wrapMode = d || gt.WRAP_MODE, n._scaleMode = u !== void 0 ? u : gt.SCALE_MODE, n.format = f || ht.RGBA, n.type = p || It.UNSIGNED_BYTE, n.target = v || Wo.TEXTURE_2D, n.alphaMode = s !== void 0 ? s : en.UNPACK, n.uid = Ko(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = l > 0 && h > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n;\n    }\n    return Object.defineProperty(t.prototype, \"realWidth\", {\n      /**\n       * Pixel width of the source of this texture\n       * @readonly\n       */\n      get: function() {\n        return Math.round(this.width * this.resolution);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"realHeight\", {\n      /**\n       * Pixel height of the source of this texture\n       * @readonly\n       */\n      get: function() {\n        return Math.round(this.height * this.resolution);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"mipmap\", {\n      /**\n       * Mipmap mode of the texture, affects downscaled images\n       * @default PIXI.settings.MIPMAP_TEXTURES\n       */\n      get: function() {\n        return this._mipmap;\n      },\n      set: function(e) {\n        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"scaleMode\", {\n      /**\n       * The scale mode to apply when scaling this texture\n       * @default PIXI.settings.SCALE_MODE\n       */\n      get: function() {\n        return this._scaleMode;\n      },\n      set: function(e) {\n        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"wrapMode\", {\n      /**\n       * How the texture wraps\n       * @default PIXI.settings.WRAP_MODE\n       */\n      get: function() {\n        return this._wrapMode;\n      },\n      set: function(e) {\n        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.setStyle = function(e, r) {\n      var n;\n      return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, n = !0), r !== void 0 && r !== this.mipmap && (this.mipmap = r, n = !0), n && this.dirtyStyleId++, this;\n    }, t.prototype.setSize = function(e, r, n) {\n      return n = n || this.resolution, this.setRealSize(e * n, r * n, n);\n    }, t.prototype.setRealSize = function(e, r, n) {\n      return this.resolution = n || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;\n    }, t.prototype._refreshPOT = function() {\n      this.isPowerOfTwo = p1(this.realWidth) && p1(this.realHeight);\n    }, t.prototype.setResolution = function(e) {\n      var r = this.resolution;\n      return r === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * r) / e, this.height = Math.round(this.height * r) / e, this.emit(\"update\", this)), this._refreshPOT(), this);\n    }, t.prototype.setResource = function(e) {\n      if (this.resource === e)\n        return this;\n      if (this.resource)\n        throw new Error(\"Resource can be set only once\");\n      return e.bind(this), this.resource = e, this;\n    }, t.prototype.update = function() {\n      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit(\"update\", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit(\"loaded\", this), this.emit(\"update\", this));\n    }, t.prototype.onError = function(e) {\n      this.emit(\"error\", this, e);\n    }, t.prototype.destroy = function() {\n      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Xn[this.cacheId], delete Gr[this.cacheId], this.cacheId = null), this.dispose(), t.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;\n    }, t.prototype.dispose = function() {\n      this.emit(\"dispose\", this);\n    }, t.prototype.castToBaseTexture = function() {\n      return this;\n    }, t.from = function(e, r, n) {\n      n === void 0 && (n = gt.STRICT_TEXTURE_CACHE);\n      var s = typeof e == \"string\", a = null;\n      if (s)\n        a = e;\n      else {\n        if (!e._pixiId) {\n          var o = r && r.pixiIdPrefix || \"pixiid\";\n          e._pixiId = o + \"_\" + Ko();\n        }\n        a = e._pixiId;\n      }\n      var u = Xn[a];\n      if (s && n && !u)\n        throw new Error('The cacheId \"' + a + '\" does not exist in BaseTextureCache.');\n      return u || (u = new t(e, r), u.cacheId = a, t.addToCache(u, a)), u;\n    }, t.fromBuffer = function(e, r, n, s) {\n      e = e || new Float32Array(r * n * 4);\n      var a = new au(e, { width: r, height: n }), o = e instanceof Float32Array ? It.FLOAT : It.UNSIGNED_BYTE;\n      return new t(a, Object.assign({}, jD, s || { width: r, height: n, type: o }));\n    }, t.addToCache = function(e, r) {\n      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), Xn[r] && console.warn(\"BaseTexture added to the cache with an id [\" + r + \"] that already had an entry\"), Xn[r] = e);\n    }, t.removeFromCache = function(e) {\n      if (typeof e == \"string\") {\n        var r = Xn[e];\n        if (r) {\n          var n = r.textureCacheIds.indexOf(e);\n          return n > -1 && r.textureCacheIds.splice(n, 1), delete Xn[e], r;\n        }\n      } else if (e && e.textureCacheIds) {\n        for (var s = 0; s < e.textureCacheIds.length; ++s)\n          delete Xn[e.textureCacheIds[s]];\n        return e.textureCacheIds.length = 0, e;\n      }\n      return null;\n    }, t._globalBatch = 0, t;\n  }($r)\n), r0 = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this, s = r || {}, a = s.width, o = s.height;\n      n = i.call(this, a, o) || this, n.items = [], n.itemDirtyIds = [];\n      for (var u = 0; u < e; u++) {\n        var l = new Kt();\n        n.items.push(l), n.itemDirtyIds.push(-2);\n      }\n      return n.length = e, n._load = null, n.baseTexture = null, n;\n    }\n    return t.prototype.initFromArray = function(e, r) {\n      for (var n = 0; n < this.length; n++)\n        e[n] && (e[n].castToBaseTexture ? this.addBaseTextureAt(e[n].castToBaseTexture(), n) : e[n] instanceof Jo ? this.addResourceAt(e[n], n) : this.addResourceAt(e0(e[n], r), n));\n    }, t.prototype.dispose = function() {\n      for (var e = 0, r = this.length; e < r; e++)\n        this.items[e].destroy();\n      this.items = null, this.itemDirtyIds = null, this._load = null;\n    }, t.prototype.addResourceAt = function(e, r) {\n      if (!this.items[r])\n        throw new Error(\"Index \" + r + \" is out of bounds\");\n      return e.valid && !this.valid && this.resize(e.width, e.height), this.items[r].setResource(e), this;\n    }, t.prototype.bind = function(e) {\n      if (this.baseTexture !== null)\n        throw new Error(\"Only one base texture per TextureArray is allowed\");\n      i.prototype.bind.call(this, e);\n      for (var r = 0; r < this.length; r++)\n        this.items[r].parentTextureArray = e, this.items[r].on(\"update\", e.update, e);\n    }, t.prototype.unbind = function(e) {\n      i.prototype.unbind.call(this, e);\n      for (var r = 0; r < this.length; r++)\n        this.items[r].parentTextureArray = null, this.items[r].off(\"update\", e.update, e);\n    }, t.prototype.load = function() {\n      var e = this;\n      if (this._load)\n        return this._load;\n      var r = this.items.map(function(s) {\n        return s.resource;\n      }).filter(function(s) {\n        return s;\n      }), n = r.map(function(s) {\n        return s.load();\n      });\n      return this._load = Promise.all(n).then(function() {\n        var s = e.items[0], a = s.realWidth, o = s.realHeight;\n        return e.resize(a, o), Promise.resolve(e);\n      }), this._load;\n    }, t;\n  }(Jo)\n), Sb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this, s = r || {}, a = s.width, o = s.height, u, l;\n      return Array.isArray(e) ? (u = e, l = e.length) : l = e, n = i.call(this, l, { width: a, height: o }) || this, u && n.initFromArray(u, r), n;\n    }\n    return t.prototype.addBaseTextureAt = function(e, r) {\n      if (e.resource)\n        this.addResourceAt(e.resource, r);\n      else\n        throw new Error(\"ArrayResource does not support RenderTexture\");\n      return this;\n    }, t.prototype.bind = function(e) {\n      i.prototype.bind.call(this, e), e.target = Wo.TEXTURE_2D_ARRAY;\n    }, t.prototype.upload = function(e, r, n) {\n      var s = this, a = s.length, o = s.itemDirtyIds, u = s.items, l = e.gl;\n      n.dirtyId < 0 && l.texImage3D(l.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, a, 0, r.format, n.type, null);\n      for (var h = 0; h < a; h++) {\n        var d = u[h];\n        o[h] < d.dirtyId && (o[h] = d.dirtyId, d.valid && l.texSubImage3D(\n          l.TEXTURE_2D_ARRAY,\n          0,\n          0,\n          // xoffset\n          0,\n          // yoffset\n          h,\n          // zoffset\n          d.resource.width,\n          d.resource.height,\n          1,\n          r.format,\n          n.type,\n          d.resource.source\n        ));\n      }\n      return !0;\n    }, t;\n  }(r0)\n), Dn = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      var r = this, n = e, s = n.naturalWidth || n.videoWidth || n.width, a = n.naturalHeight || n.videoHeight || n.height;\n      return r = i.call(this, s, a) || this, r.source = e, r.noSubImage = !1, r;\n    }\n    return t.crossOrigin = function(e, r, n) {\n      n === void 0 && r.indexOf(\"data:\") !== 0 ? e.crossOrigin = RD(r) : n !== !1 && (e.crossOrigin = typeof n == \"string\" ? n : \"anonymous\");\n    }, t.prototype.upload = function(e, r, n, s) {\n      var a = e.gl, o = r.realWidth, u = r.realHeight;\n      if (s = s || this.source, s instanceof HTMLImageElement) {\n        if (!s.complete || s.naturalWidth === 0)\n          return !1;\n      } else if (s instanceof HTMLVideoElement && s.readyState <= 1)\n        return !1;\n      return a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK), !this.noSubImage && r.target === a.TEXTURE_2D && n.width === o && n.height === u ? a.texSubImage2D(a.TEXTURE_2D, 0, 0, 0, r.format, n.type, s) : (n.width = o, n.height = u, a.texImage2D(r.target, 0, n.internalFormat, r.format, n.type, s)), !0;\n    }, t.prototype.update = function() {\n      if (!this.destroyed) {\n        var e = this.source, r = e.naturalWidth || e.videoWidth || e.width, n = e.naturalHeight || e.videoHeight || e.height;\n        this.resize(r, n), i.prototype.update.call(this);\n      }\n    }, t.prototype.dispose = function() {\n      this.source = null;\n    }, t;\n  }(Jo)\n), Tb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      return i.call(this, e) || this;\n    }\n    return t.test = function(e) {\n      var r = globalThis.OffscreenCanvas;\n      return r && e instanceof r ? !0 : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;\n    }, t;\n  }(Dn)\n), Cb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this, s = r || {}, a = s.width, o = s.height, u = s.autoLoad, l = s.linkBaseTexture;\n      if (e && e.length !== t.SIDES)\n        throw new Error(\"Invalid length. Got \" + e.length + \", expected 6\");\n      n = i.call(this, 6, { width: a, height: o }) || this;\n      for (var h = 0; h < t.SIDES; h++)\n        n.items[h].target = Wo.TEXTURE_CUBE_MAP_POSITIVE_X + h;\n      return n.linkBaseTexture = l !== !1, e && n.initFromArray(e, r), u !== !1 && n.load(), n;\n    }\n    return t.prototype.bind = function(e) {\n      i.prototype.bind.call(this, e), e.target = Wo.TEXTURE_CUBE_MAP;\n    }, t.prototype.addBaseTextureAt = function(e, r, n) {\n      if (!this.items[r])\n        throw new Error(\"Index \" + r + \" is out of bounds\");\n      if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)\n        if (e.resource)\n          this.addResourceAt(e.resource, r);\n        else\n          throw new Error(\"CubeResource does not support copying of renderTexture.\");\n      else\n        e.target = Wo.TEXTURE_CUBE_MAP_POSITIVE_X + r, e.parentTextureArray = this.baseTexture, this.items[r] = e;\n      return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[r] = e, this;\n    }, t.prototype.upload = function(e, r, n) {\n      for (var s = this.itemDirtyIds, a = 0; a < t.SIDES; a++) {\n        var o = this.items[a];\n        (s[a] < o.dirtyId || n.dirtyId < r.dirtyId) && (o.valid && o.resource ? (o.resource.upload(e, o, n), s[a] = o.dirtyId) : s[a] < -1 && (e.gl.texImage2D(o.target, 0, n.internalFormat, r.realWidth, r.realHeight, 0, r.format, n.type, null), s[a] = -1));\n      }\n      return !0;\n    }, t.test = function(e) {\n      return Array.isArray(e) && e.length === t.SIDES;\n    }, t.SIDES = 6, t;\n  }(r0)\n), i0 = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this;\n      if (r = r || {}, !(e instanceof HTMLImageElement)) {\n        var s = new Image();\n        Dn.crossOrigin(s, e, r.crossorigin), s.src = e, e = s;\n      }\n      return n = i.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : gt.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = typeof r.alphaMode == \"number\" ? r.alphaMode : null, n.bitmap = null, n._load = null, r.autoLoad !== !1 && n.load(), n;\n    }\n    return t.prototype.load = function(e) {\n      var r = this;\n      return this._load ? this._load : (e !== void 0 && (this.createBitmap = e), this._load = new Promise(function(n, s) {\n        var a = r.source;\n        r.url = a.src;\n        var o = function() {\n          r.destroyed || (a.onload = null, a.onerror = null, r.resize(a.width, a.height), r._load = null, r.createBitmap ? n(r.process()) : n(r));\n        };\n        a.complete && a.src ? o() : (a.onload = o, a.onerror = function(u) {\n          s(u), r.onError.emit(u);\n        });\n      }), this._load);\n    }, t.prototype.process = function() {\n      var e = this, r = this.source;\n      if (this._process !== null)\n        return this._process;\n      if (this.bitmap !== null || !globalThis.createImageBitmap)\n        return Promise.resolve(this);\n      var n = globalThis.createImageBitmap, s = !r.crossOrigin || r.crossOrigin === \"anonymous\";\n      return this._process = fetch(r.src, {\n        mode: s ? \"cors\" : \"no-cors\"\n      }).then(function(a) {\n        return a.blob();\n      }).then(function(a) {\n        return n(a, 0, 0, r.width, r.height, {\n          premultiplyAlpha: e.alphaMode === null || e.alphaMode === en.UNPACK ? \"premultiply\" : \"none\"\n        });\n      }).then(function(a) {\n        return e.destroyed ? Promise.reject() : (e.bitmap = a, e.update(), e._process = null, Promise.resolve(e));\n      }), this._process;\n    }, t.prototype.upload = function(e, r, n) {\n      if (typeof this.alphaMode == \"number\" && (r.alphaMode = this.alphaMode), !this.createBitmap)\n        return i.prototype.upload.call(this, e, r, n);\n      if (!this.bitmap && (this.process(), !this.bitmap))\n        return !1;\n      if (i.prototype.upload.call(this, e, r, n, this.bitmap), !this.preserveBitmap) {\n        var s = !0, a = r._glTextures;\n        for (var o in a) {\n          var u = a[o];\n          if (u !== n && u.dirtyId !== r.dirtyId) {\n            s = !1;\n            break;\n          }\n        }\n        s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);\n      }\n      return !0;\n    }, t.prototype.dispose = function() {\n      this.source.onload = null, this.source.onerror = null, i.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;\n    }, t.test = function(e) {\n      return typeof e == \"string\" || e instanceof HTMLImageElement;\n    }, t;\n  }(Dn)\n), Mb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this;\n      return r = r || {}, n = i.call(this, gt.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = e, n.scale = r.scale || 1, n._overrideWidth = r.width, n._overrideHeight = r.height, n._resolve = null, n._crossorigin = r.crossorigin, n._load = null, r.autoLoad !== !1 && n.load(), n;\n    }\n    return t.prototype.load = function() {\n      var e = this;\n      return this._load ? this._load : (this._load = new Promise(function(r) {\n        if (e._resolve = function() {\n          e.resize(e.source.width, e.source.height), r(e);\n        }, t.SVG_XML.test(e.svg.trim())) {\n          if (!btoa)\n            throw new Error(\"Your browser doesn't support base64 conversions.\");\n          e.svg = \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(e.svg)));\n        }\n        e._loadSvg();\n      }), this._load);\n    }, t.prototype._loadSvg = function() {\n      var e = this, r = new Image();\n      Dn.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(n) {\n        e._resolve && (r.onerror = null, e.onError.emit(n));\n      }, r.onload = function() {\n        if (e._resolve) {\n          var n = r.width, s = r.height;\n          if (!n || !s)\n            throw new Error(\"The SVG image must have width and height defined (in pixels), canvas API needs them.\");\n          var a = n * e.scale, o = s * e.scale;\n          (e._overrideWidth || e._overrideHeight) && (a = e._overrideWidth || e._overrideHeight / s * n, o = e._overrideHeight || e._overrideWidth / n * s), a = Math.round(a), o = Math.round(o);\n          var u = e.source;\n          u.width = a, u.height = o, u._pixiId = \"canvas_\" + Ko(), u.getContext(\"2d\").drawImage(r, 0, 0, n, s, 0, 0, a, o), e._resolve(), e._resolve = null;\n        }\n      };\n    }, t.getSize = function(e) {\n      var r = t.SVG_SIZE.exec(e), n = {};\n      return r && (n[r[1]] = Math.round(parseFloat(r[3])), n[r[5]] = Math.round(parseFloat(r[7]))), n;\n    }, t.prototype.dispose = function() {\n      i.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;\n    }, t.test = function(e, r) {\n      return r === \"svg\" || typeof e == \"string\" && e.startsWith(\"data:image/svg+xml\") || typeof e == \"string\" && t.SVG_XML.test(e);\n    }, t.SVG_XML = /^(<\\?xml[^?]+\\?>)?\\s*(<!--[^(-->)]*-->)?\\s*\\<svg/m, t.SVG_SIZE = /<svg[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*(?:\\s(width|height)=('|\")(\\d*(?:\\.\\d+)?)(?:px)?('|\"))[^>]*>/i, t;\n  }(Dn)\n), Pb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = this;\n      if (r = r || {}, !(e instanceof HTMLVideoElement)) {\n        var s = document.createElement(\"video\");\n        s.setAttribute(\"preload\", \"auto\"), s.setAttribute(\"webkit-playsinline\", \"\"), s.setAttribute(\"playsinline\", \"\"), typeof e == \"string\" && (e = [e]);\n        var a = e[0].src || e[0];\n        Dn.crossOrigin(s, a, r.crossorigin);\n        for (var o = 0; o < e.length; ++o) {\n          var u = document.createElement(\"source\"), l = e[o], h = l.src, d = l.mime;\n          h = h || e[o];\n          var f = h.split(\"?\").shift().toLowerCase(), p = f.slice(f.lastIndexOf(\".\") + 1);\n          d = d || t.MIME_TYPES[p] || \"video/\" + p, u.src = h, u.type = d, s.appendChild(u);\n        }\n        e = s;\n      }\n      return n = i.call(this, e) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = r.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = r.autoPlay !== !1, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), r.autoLoad !== !1 && n.load(), n;\n    }\n    return t.prototype.update = function(e) {\n      if (!this.destroyed) {\n        var r = Ge.shared.elapsedMS * this.source.playbackRate;\n        this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (i.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);\n      }\n    }, t.prototype.load = function() {\n      var e = this;\n      if (this._load)\n        return this._load;\n      var r = this.source;\n      return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = !0), r.addEventListener(\"play\", this._onPlayStart.bind(this)), r.addEventListener(\"pause\", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener(\"canplay\", this._onCanPlay), r.addEventListener(\"canplaythrough\", this._onCanPlay), r.addEventListener(\"error\", this._onError, !0)), this._load = new Promise(function(n) {\n        e.valid ? n(e) : (e._resolve = n, r.load());\n      }), this._load;\n    }, t.prototype._onError = function(e) {\n      this.source.removeEventListener(\"error\", this._onError, !0), this.onError.emit(e);\n    }, t.prototype._isSourcePlaying = function() {\n      var e = this.source;\n      return !e.paused && !e.ended && this._isSourceReady();\n    }, t.prototype._isSourceReady = function() {\n      var e = this.source;\n      return e.readyState > 2;\n    }, t.prototype._onPlayStart = function() {\n      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0);\n    }, t.prototype._onPlayStop = function() {\n      this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n    }, t.prototype._onCanPlay = function() {\n      var e = this.source;\n      e.removeEventListener(\"canplay\", this._onCanPlay), e.removeEventListener(\"canplaythrough\", this._onCanPlay);\n      var r = this.valid;\n      this.resize(e.videoWidth, e.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play();\n    }, t.prototype.dispose = function() {\n      this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1);\n      var e = this.source;\n      e && (e.removeEventListener(\"error\", this._onError, !0), e.pause(), e.src = \"\", e.load()), i.prototype.dispose.call(this);\n    }, Object.defineProperty(t.prototype, \"autoUpdate\", {\n      /** Should the base texture automatically update itself, set to true by default. */\n      get: function() {\n        return this._autoUpdate;\n      },\n      set: function(e) {\n        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"updateFPS\", {\n      /**\n       * How many times a second to update the texture from the video. Leave at 0 to update at every render.\n       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n       */\n      get: function() {\n        return this._updateFPS;\n      },\n      set: function(e) {\n        e !== this._updateFPS && (this._updateFPS = e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.test = function(e, r) {\n      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || t.TYPES.indexOf(r) > -1;\n    }, t.TYPES = [\"mp4\", \"m4v\", \"webm\", \"ogg\", \"ogv\", \"h264\", \"avi\", \"mov\"], t.MIME_TYPES = {\n      ogv: \"video/ogg\",\n      mov: \"video/quicktime\",\n      m4v: \"video/mp4\"\n    }, t;\n  }(Dn)\n), Ob = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      return i.call(this, e) || this;\n    }\n    return t.test = function(e) {\n      return !!globalThis.createImageBitmap && typeof ImageBitmap < \"u\" && e instanceof ImageBitmap;\n    }, t;\n  }(Dn)\n);\nlc.push(i0, Ob, Tb, Pb, Mb, au, Cb, Sb);\nvar UE = {\n  __proto__: null,\n  Resource: Jo,\n  BaseImageResource: Dn,\n  INSTALLED: lc,\n  autoDetectResource: e0,\n  AbstractMultiResource: r0,\n  ArrayResource: Sb,\n  BufferResource: au,\n  CanvasResource: Tb,\n  CubeResource: Cb,\n  ImageResource: i0,\n  SVGResource: Mb,\n  VideoResource: Pb,\n  ImageBitmapResource: Ob\n}, zD = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t() {\n      return i !== null && i.apply(this, arguments) || this;\n    }\n    return t.prototype.upload = function(e, r, n) {\n      var s = e.gl;\n      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === en.UNPACK);\n      var a = r.realWidth, o = r.realHeight;\n      return n.width === a && n.height === o ? s.texSubImage2D(r.target, 0, 0, 0, a, o, r.format, n.type, this.data) : (n.width = a, n.height = o, s.texImage2D(r.target, 0, n.internalFormat, a, o, 0, r.format, n.type, this.data)), !0;\n    }, t;\n  }(au)\n), gv = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this.width = Math.round(t || 100), this.height = Math.round(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new pr(\"disposeFramebuffer\"), this.multisample = ke.NONE;\n    }\n    return Object.defineProperty(i.prototype, \"colorTexture\", {\n      /**\n       * Reference to the colorTexture.\n       * @readonly\n       */\n      get: function() {\n        return this.colorTextures[0];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.addColorTexture = function(t, e) {\n      return t === void 0 && (t = 0), this.colorTextures[t] = e || new Kt(null, {\n        scaleMode: Cn.NEAREST,\n        resolution: 1,\n        mipmap: tn.OFF,\n        width: this.width,\n        height: this.height\n      }), this.dirtyId++, this.dirtyFormat++, this;\n    }, i.prototype.addDepthTexture = function(t) {\n      return this.depthTexture = t || new Kt(new zD(null, { width: this.width, height: this.height }), {\n        scaleMode: Cn.NEAREST,\n        resolution: 1,\n        width: this.width,\n        height: this.height,\n        mipmap: tn.OFF,\n        format: ht.DEPTH_COMPONENT,\n        type: It.UNSIGNED_SHORT\n      }), this.dirtyId++, this.dirtyFormat++, this;\n    }, i.prototype.enableDepth = function() {\n      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;\n    }, i.prototype.enableStencil = function() {\n      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;\n    }, i.prototype.resize = function(t, e) {\n      if (t = Math.round(t), e = Math.round(e), !(t === this.width && e === this.height)) {\n        this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;\n        for (var r = 0; r < this.colorTextures.length; r++) {\n          var n = this.colorTextures[r], s = n.resolution;\n          n.setSize(t / s, e / s);\n        }\n        if (this.depthTexture) {\n          var s = this.depthTexture.resolution;\n          this.depthTexture.setSize(t / s, e / s);\n        }\n      }\n    }, i.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, i.prototype.destroyDepthTexture = function() {\n      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);\n    }, i;\n  }()\n), Ib = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      e === void 0 && (e = {});\n      var r = this;\n      if (typeof e == \"number\") {\n        var n = arguments[0], s = arguments[1], a = arguments[2], o = arguments[3];\n        e = { width: n, height: s, scaleMode: a, resolution: o };\n      }\n      return e.width = e.width || 100, e.height = e.height || 100, e.multisample = e.multisample !== void 0 ? e.multisample : ke.NONE, r = i.call(this, null, e) || this, r.mipmap = tn.OFF, r.valid = !0, r.clearColor = [0, 0, 0, 0], r.framebuffer = new gv(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = e.multisample, r.maskStack = [], r.filterStack = [{}], r;\n    }\n    return t.prototype.resize = function(e, r) {\n      this.framebuffer.resize(e * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);\n    }, t.prototype.dispose = function() {\n      this.framebuffer.dispose(), i.prototype.dispose.call(this);\n    }, t.prototype.destroy = function() {\n      i.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;\n    }, t;\n  }(Kt)\n), Rb = (\n  /** @class */\n  function() {\n    function i() {\n      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);\n    }\n    return i.prototype.set = function(t, e, r) {\n      var n = e.width, s = e.height;\n      if (r) {\n        var a = t.width / 2 / n, o = t.height / 2 / s, u = t.x / n + a, l = t.y / s + o;\n        r = Le.add(r, Le.NW), this.x0 = u + a * Le.uX(r), this.y0 = l + o * Le.uY(r), r = Le.add(r, 2), this.x1 = u + a * Le.uX(r), this.y1 = l + o * Le.uY(r), r = Le.add(r, 2), this.x2 = u + a * Le.uX(r), this.y2 = l + o * Le.uY(r), r = Le.add(r, 2), this.x3 = u + a * Le.uX(r), this.y3 = l + o * Le.uY(r);\n      } else\n        this.x0 = t.x / n, this.y0 = t.y / s, this.x1 = (t.x + t.width) / n, this.y1 = t.y / s, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / s, this.x3 = t.x / n, this.y3 = (t.y + t.height) / s;\n      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;\n    }, i.prototype.toString = function() {\n      return \"[@pixi/core:TextureUvs \" + (\"x0=\" + this.x0 + \" y0=\" + this.y0 + \" \") + (\"x1=\" + this.x1 + \" y1=\" + this.y1 + \" x2=\" + this.x2 + \" \") + (\"y2=\" + this.y2 + \" x3=\" + this.x3 + \" y3=\" + this.y3) + \"]\";\n    }, i;\n  }()\n), b1 = new Rb();\nfunction Hd(i) {\n  i.destroy = function() {\n  }, i.on = function() {\n  }, i.once = function() {\n  }, i.emit = function() {\n  };\n}\nvar Ot = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r, n, s, a, o) {\n      var u = i.call(this) || this;\n      if (u.noFrame = !1, r || (u.noFrame = !0, r = new Nt(0, 0, 1, 1)), e instanceof t && (e = e.baseTexture), u.baseTexture = e, u._frame = r, u.trim = s, u.valid = !1, u._uvs = b1, u.uvMatrix = null, u.orig = n || r, u._rotate = Number(a || 0), a === !0)\n        u._rotate = 2;\n      else if (u._rotate % 2 !== 0)\n        throw new Error(\"attempt to use diamond-shaped UVs. If you are sure, set rotation manually\");\n      return u.defaultAnchor = o ? new xe(o.x, o.y) : new xe(0, 0), u._updateID = 0, u.textureCacheIds = [], e.valid ? u.noFrame ? e.valid && u.onBaseTextureUpdated(e) : u.frame = r : e.once(\"loaded\", u.onBaseTextureUpdated, u), u.noFrame && e.on(\"update\", u.onBaseTextureUpdated, u), u;\n    }\n    return t.prototype.update = function() {\n      this.baseTexture.resource && this.baseTexture.resource.update();\n    }, t.prototype.onBaseTextureUpdated = function(e) {\n      if (this.noFrame) {\n        if (!this.baseTexture.valid)\n          return;\n        this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs();\n      } else\n        this.frame = this._frame;\n      this.emit(\"update\", this);\n    }, t.prototype.destroy = function(e) {\n      if (this.baseTexture) {\n        if (e) {\n          var r = this.baseTexture.resource;\n          r && r.url && Gr[r.url] && t.removeFromCache(r.url), this.baseTexture.destroy();\n        }\n        this.baseTexture.off(\"loaded\", this.onBaseTextureUpdated, this), this.baseTexture.off(\"update\", this.onBaseTextureUpdated, this), this.baseTexture = null;\n      }\n      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, t.removeFromCache(this), this.textureCacheIds = null;\n    }, t.prototype.clone = function() {\n      var e = this._frame.clone(), r = this._frame === this.orig ? e : this.orig.clone(), n = new t(this.baseTexture, !this.noFrame && e, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);\n      return this.noFrame && (n._frame = e), n;\n    }, t.prototype.updateUvs = function() {\n      this._uvs === b1 && (this._uvs = new Rb()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;\n    }, t.from = function(e, r, n) {\n      r === void 0 && (r = {}), n === void 0 && (n = gt.STRICT_TEXTURE_CACHE);\n      var s = typeof e == \"string\", a = null;\n      if (s)\n        a = e;\n      else if (e instanceof Kt) {\n        if (!e.cacheId) {\n          var o = r && r.pixiIdPrefix || \"pixiid\";\n          e.cacheId = o + \"-\" + Ko(), Kt.addToCache(e, e.cacheId);\n        }\n        a = e.cacheId;\n      } else {\n        if (!e._pixiId) {\n          var o = r && r.pixiIdPrefix || \"pixiid\";\n          e._pixiId = o + \"_\" + Ko();\n        }\n        a = e._pixiId;\n      }\n      var u = Gr[a];\n      if (s && n && !u)\n        throw new Error('The cacheId \"' + a + '\" does not exist in TextureCache.');\n      return !u && !(e instanceof Kt) ? (r.resolution || (r.resolution = dv(e)), u = new t(new Kt(e, r)), u.baseTexture.cacheId = a, Kt.addToCache(u.baseTexture, a), t.addToCache(u, a)) : !u && e instanceof Kt && (u = new t(e), t.addToCache(u, a)), u;\n    }, t.fromURL = function(e, r) {\n      var n = Object.assign({ autoLoad: !1 }, r == null ? void 0 : r.resourceOptions), s = t.from(e, Object.assign({ resourceOptions: n }, r), !1), a = s.baseTexture.resource;\n      return s.baseTexture.valid ? Promise.resolve(s) : a.load().then(function() {\n        return Promise.resolve(s);\n      });\n    }, t.fromBuffer = function(e, r, n, s) {\n      return new t(Kt.fromBuffer(e, r, n, s));\n    }, t.fromLoader = function(e, r, n, s) {\n      var a = new Kt(e, Object.assign({\n        scaleMode: gt.SCALE_MODE,\n        resolution: dv(r)\n      }, s)), o = a.resource;\n      o instanceof i0 && (o.url = r);\n      var u = new t(a);\n      return n || (n = r), Kt.addToCache(u.baseTexture, n), t.addToCache(u, n), n !== r && (Kt.addToCache(u.baseTexture, r), t.addToCache(u, r)), u.baseTexture.valid ? Promise.resolve(u) : new Promise(function(l) {\n        u.baseTexture.once(\"loaded\", function() {\n          return l(u);\n        });\n      });\n    }, t.addToCache = function(e, r) {\n      r && (e.textureCacheIds.indexOf(r) === -1 && e.textureCacheIds.push(r), Gr[r] && console.warn(\"Texture added to the cache with an id [\" + r + \"] that already had an entry\"), Gr[r] = e);\n    }, t.removeFromCache = function(e) {\n      if (typeof e == \"string\") {\n        var r = Gr[e];\n        if (r) {\n          var n = r.textureCacheIds.indexOf(e);\n          return n > -1 && r.textureCacheIds.splice(n, 1), delete Gr[e], r;\n        }\n      } else if (e && e.textureCacheIds) {\n        for (var s = 0; s < e.textureCacheIds.length; ++s)\n          Gr[e.textureCacheIds[s]] === e && delete Gr[e.textureCacheIds[s]];\n        return e.textureCacheIds.length = 0, e;\n      }\n      return null;\n    }, Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * Returns resolution of baseTexture\n       * @readonly\n       */\n      get: function() {\n        return this.baseTexture.resolution;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"frame\", {\n      /**\n       * The frame specifies the region of the base texture that this texture uses.\n       * Please call `updateUvs()` after you change coordinates of `frame` manually.\n       */\n      get: function() {\n        return this._frame;\n      },\n      set: function(e) {\n        this._frame = e, this.noFrame = !1;\n        var r = e.x, n = e.y, s = e.width, a = e.height, o = r + s > this.baseTexture.width, u = n + a > this.baseTexture.height;\n        if (o || u) {\n          var l = o && u ? \"and\" : \"or\", h = \"X: \" + r + \" + \" + s + \" = \" + (r + s) + \" > \" + this.baseTexture.width, d = \"Y: \" + n + \" + \" + a + \" = \" + (n + a) + \" > \" + this.baseTexture.height;\n          throw new Error(\"Texture Error: frame does not fit inside the base Texture dimensions: \" + (h + \" \" + l + \" \" + d));\n        }\n        this.valid = s && a && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = e), this.valid && this.updateUvs();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"rotate\", {\n      /**\n       * Indicates whether the texture is rotated inside the atlas\n       * set to 2 to compensate for texture packer rotation\n       * set to 6 to compensate for spine packer rotation\n       * can be used to rotate or mirror sprites\n       * See {@link PIXI.groupD8} for explanation\n       */\n      get: function() {\n        return this._rotate;\n      },\n      set: function(e) {\n        this._rotate = e, this.valid && this.updateUvs();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Texture in pixels. */\n      get: function() {\n        return this.orig.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Texture in pixels. */\n      get: function() {\n        return this.orig.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.castToBaseTexture = function() {\n      return this.baseTexture;\n    }, Object.defineProperty(t, \"EMPTY\", {\n      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */\n      get: function() {\n        return t._EMPTY || (t._EMPTY = new t(new Kt()), Hd(t._EMPTY), Hd(t._EMPTY.baseTexture)), t._EMPTY;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"WHITE\", {\n      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */\n      get: function() {\n        if (!t._WHITE) {\n          var e = gt.ADAPTER.createCanvas(16, 16), r = e.getContext(\"2d\");\n          e.width = 16, e.height = 16, r.fillStyle = \"white\", r.fillRect(0, 0, 16, 16), t._WHITE = new t(Kt.from(e)), Hd(t._WHITE), Hd(t._WHITE.baseTexture);\n        }\n        return t._WHITE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }($r)\n), Si = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      var n = i.call(this, e, r) || this;\n      return n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n;\n    }\n    return Object.defineProperty(t.prototype, \"framebuffer\", {\n      /**\n       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.\n       * @readonly\n       */\n      get: function() {\n        return this.baseTexture.framebuffer;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"multisample\", {\n      /**\n       * Shortcut to `this.framebuffer.multisample`.\n       * @default PIXI.MSAA_QUALITY.NONE\n       */\n      get: function() {\n        return this.framebuffer.multisample;\n      },\n      set: function(e) {\n        this.framebuffer.multisample = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.resize = function(e, r, n) {\n      n === void 0 && (n = !0);\n      var s = this.baseTexture.resolution, a = Math.round(e * s) / s, o = Math.round(r * s) / s;\n      this.valid = a > 0 && o > 0, this._frame.width = this.orig.width = a, this._frame.height = this.orig.height = o, n && this.baseTexture.resize(a, o), this.updateUvs();\n    }, t.prototype.setResolution = function(e) {\n      var r = this.baseTexture;\n      r.resolution !== e && (r.setResolution(e), this.resize(r.width, r.height, !1));\n    }, t.create = function(e) {\n      for (var r = arguments, n = [], s = 1; s < arguments.length; s++)\n        n[s - 1] = r[s];\n      return typeof e == \"number\" && (jr(\"6.0.0\", \"Arguments (width, height, scaleMode, resolution) have been deprecated.\"), e = {\n        width: e,\n        height: n[0],\n        scaleMode: n[1],\n        resolution: n[2]\n      }), new t(new Ib(e));\n    }, t;\n  }(Ot)\n), jE = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;\n    }\n    return i.prototype.createTexture = function(t, e, r) {\n      r === void 0 && (r = ke.NONE);\n      var n = new Ib(Object.assign({\n        width: t,\n        height: e,\n        resolution: 1,\n        multisample: r\n      }, this.textureOptions));\n      return new Si(n);\n    }, i.prototype.getOptimalTexture = function(t, e, r, n) {\n      r === void 0 && (r = 1), n === void 0 && (n = ke.NONE);\n      var s;\n      t = Math.ceil(t * r - 1e-6), e = Math.ceil(e * r - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || e !== this._pixelsHeight ? (t = fv(t), e = fv(e), s = ((t & 65535) << 16 | e & 65535) >>> 0, n > 1 && (s += n * 4294967296)) : s = n > 1 ? -n : -1, this.texturePool[s] || (this.texturePool[s] = []);\n      var a = this.texturePool[s].pop();\n      return a || (a = this.createTexture(t, e, n)), a.filterPoolKey = s, a.setResolution(r), a;\n    }, i.prototype.getFilterTexture = function(t, e, r) {\n      var n = this.getOptimalTexture(t.width, t.height, e || t.resolution, r || ke.NONE);\n      return n.filterFrame = t.filterFrame, n;\n    }, i.prototype.returnTexture = function(t) {\n      var e = t.filterPoolKey;\n      t.filterFrame = null, this.texturePool[e].push(t);\n    }, i.prototype.returnFilterTexture = function(t) {\n      this.returnTexture(t);\n    }, i.prototype.clear = function(t) {\n      if (t = t !== !1, t)\n        for (var e in this.texturePool) {\n          var r = this.texturePool[e];\n          if (r)\n            for (var n = 0; n < r.length; n++)\n              r[n].destroy(!0);\n        }\n      this.texturePool = {};\n    }, i.prototype.setScreenSize = function(t) {\n      if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {\n        this.enableFullScreen = t.width > 0 && t.height > 0;\n        for (var e in this.texturePool)\n          if (Number(e) < 0) {\n            var r = this.texturePool[e];\n            if (r)\n              for (var n = 0; n < r.length; n++)\n                r[n].destroy(!0);\n            this.texturePool[e] = [];\n          }\n        this._pixelsWidth = t.width, this._pixelsHeight = t.height;\n      }\n    }, i.SCREEN_KEY = -1, i;\n  }()\n), Ey = (\n  /** @class */\n  function() {\n    function i(t, e, r, n, s, a, o) {\n      e === void 0 && (e = 0), r === void 0 && (r = !1), n === void 0 && (n = It.FLOAT), this.buffer = t, this.size = e, this.normalized = r, this.type = n, this.stride = s, this.start = a, this.instance = o;\n    }\n    return i.prototype.destroy = function() {\n      this.buffer = null;\n    }, i.from = function(t, e, r, n, s) {\n      return new i(t, e, r, n, s);\n    }, i;\n  }()\n), HD = 0, Ke = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      e === void 0 && (e = !0), r === void 0 && (r = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = e, this.id = HD++, this.disposeRunner = new pr(\"disposeBuffer\");\n    }\n    return i.prototype.update = function(t) {\n      t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++;\n    }, i.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, i.prototype.destroy = function() {\n      this.dispose(), this.data = null;\n    }, Object.defineProperty(i.prototype, \"index\", {\n      get: function() {\n        return this.type === In.ELEMENT_ARRAY_BUFFER;\n      },\n      /**\n       * Flags whether this is an index buffer.\n       *\n       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make\n       * the buffer of type `ARRAY_BUFFER`.\n       *\n       * For backwards compatibility.\n       */\n      set: function(t) {\n        this.type = t ? In.ELEMENT_ARRAY_BUFFER : In.ARRAY_BUFFER;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.from = function(t) {\n      return t instanceof Array && (t = new Float32Array(t)), new i(t);\n    }, i;\n  }()\n), $D = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array\n};\nfunction VD(i, t) {\n  for (var e = 0, r = 0, n = {}, s = 0; s < i.length; s++)\n    r += t[s], e += i[s].length;\n  for (var a = new ArrayBuffer(e * 4), o = null, u = 0, s = 0; s < i.length; s++) {\n    var l = t[s], h = i[s], d = AE(h);\n    n[d] || (n[d] = new $D[d](a)), o = n[d];\n    for (var f = 0; f < h.length; f++) {\n      var p = (f / l | 0) * r + u, v = f % l;\n      o[p + v] = h[f];\n    }\n    u += l;\n  }\n  return new Float32Array(a);\n}\nvar x1 = { 5126: 4, 5123: 2, 5121: 1 }, XD = 0, WD = {\n  Float32Array,\n  Uint32Array,\n  Int32Array,\n  Uint8Array,\n  Uint16Array\n}, lh = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      t === void 0 && (t = []), e === void 0 && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = XD++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new pr(\"disposeGeometry\"), this.refCount = 0;\n    }\n    return i.prototype.addAttribute = function(t, e, r, n, s, a, o, u) {\n      if (r === void 0 && (r = 0), n === void 0 && (n = !1), u === void 0 && (u = !1), !e)\n        throw new Error(\"You must pass a buffer when creating an attribute\");\n      e instanceof Ke || (e instanceof Array && (e = new Float32Array(e)), e = new Ke(e));\n      var l = t.split(\"|\");\n      if (l.length > 1) {\n        for (var h = 0; h < l.length; h++)\n          this.addAttribute(l[h], e, r, n, s);\n        return this;\n      }\n      var d = this.buffers.indexOf(e);\n      return d === -1 && (this.buffers.push(e), d = this.buffers.length - 1), this.attributes[t] = new Ey(d, r, n, s, a, o, u), this.instanced = this.instanced || u, this;\n    }, i.prototype.getAttribute = function(t) {\n      return this.attributes[t];\n    }, i.prototype.getBuffer = function(t) {\n      return this.buffers[this.getAttribute(t).buffer];\n    }, i.prototype.addIndex = function(t) {\n      return t instanceof Ke || (t instanceof Array && (t = new Uint16Array(t)), t = new Ke(t)), t.type = In.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.indexOf(t) === -1 && this.buffers.push(t), this;\n    }, i.prototype.getIndex = function() {\n      return this.indexBuffer;\n    }, i.prototype.interleave = function() {\n      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)\n        return this;\n      var t = [], e = [], r = new Ke(), n;\n      for (n in this.attributes) {\n        var s = this.attributes[n], a = this.buffers[s.buffer];\n        t.push(a.data), e.push(s.size * x1[s.type] / 4), s.buffer = 0;\n      }\n      for (r.data = VD(t, e), n = 0; n < this.buffers.length; n++)\n        this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();\n      return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;\n    }, i.prototype.getSize = function() {\n      for (var t in this.attributes) {\n        var e = this.attributes[t], r = this.buffers[e.buffer];\n        return r.data.length / (e.stride / 4 || e.size);\n      }\n      return 0;\n    }, i.prototype.dispose = function() {\n      this.disposeRunner.emit(this, !1);\n    }, i.prototype.destroy = function() {\n      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;\n    }, i.prototype.clone = function() {\n      for (var t = new i(), e = 0; e < this.buffers.length; e++)\n        t.buffers[e] = new Ke(this.buffers[e].data.slice(0));\n      for (var e in this.attributes) {\n        var r = this.attributes[e];\n        t.attributes[e] = new Ey(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);\n      }\n      return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = In.ELEMENT_ARRAY_BUFFER), t;\n    }, i.merge = function(t) {\n      for (var e = new i(), r = [], n = [], s = [], a, o = 0; o < t.length; o++) {\n        a = t[o];\n        for (var u = 0; u < a.buffers.length; u++)\n          n[u] = n[u] || 0, n[u] += a.buffers[u].data.length, s[u] = 0;\n      }\n      for (var o = 0; o < a.buffers.length; o++)\n        r[o] = new WD[AE(a.buffers[o].data)](n[o]), e.buffers[o] = new Ke(r[o]);\n      for (var o = 0; o < t.length; o++) {\n        a = t[o];\n        for (var u = 0; u < a.buffers.length; u++)\n          r[u].set(a.buffers[u].data, s[u]), s[u] += a.buffers[u].data.length;\n      }\n      if (e.attributes = a.attributes, a.indexBuffer) {\n        e.indexBuffer = e.buffers[a.buffers.indexOf(a.indexBuffer)], e.indexBuffer.type = In.ELEMENT_ARRAY_BUFFER;\n        for (var l = 0, h = 0, d = 0, f = 0, o = 0; o < a.buffers.length; o++)\n          if (a.buffers[o] !== a.indexBuffer) {\n            f = o;\n            break;\n          }\n        for (var o in a.attributes) {\n          var p = a.attributes[o];\n          (p.buffer | 0) === f && (h += p.size * x1[p.type] / 4);\n        }\n        for (var o = 0; o < t.length; o++) {\n          for (var v = t[o].indexBuffer.data, u = 0; u < v.length; u++)\n            e.indexBuffer.data[u + d] += l;\n          l += t[o].buffers[f].data.length / h, d += v.length;\n        }\n      }\n      return e;\n    }, i;\n  }()\n), zE = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t() {\n      var e = i.call(this) || this;\n      return e.addAttribute(\"aVertexPosition\", new Float32Array([\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1\n      ])).addIndex([0, 1, 3, 2]), e;\n    }\n    return t;\n  }(lh)\n), Db = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t() {\n      var e = i.call(this) || this;\n      return e.vertices = new Float32Array([\n        -1,\n        -1,\n        1,\n        -1,\n        1,\n        1,\n        -1,\n        1\n      ]), e.uvs = new Float32Array([\n        0,\n        0,\n        1,\n        0,\n        1,\n        1,\n        0,\n        1\n      ]), e.vertexBuffer = new Ke(e.vertices), e.uvBuffer = new Ke(e.uvs), e.addAttribute(\"aVertexPosition\", e.vertexBuffer).addAttribute(\"aTextureCoord\", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e;\n    }\n    return t.prototype.map = function(e, r) {\n      var n = 0, s = 0;\n      return this.uvs[0] = n, this.uvs[1] = s, this.uvs[2] = n + r.width / e.width, this.uvs[3] = s, this.uvs[4] = n + r.width / e.width, this.uvs[5] = s + r.height / e.height, this.uvs[6] = n, this.uvs[7] = s + r.height / e.height, n = r.x, s = r.y, this.vertices[0] = n, this.vertices[1] = s, this.vertices[2] = n + r.width, this.vertices[3] = s, this.vertices[4] = n + r.width, this.vertices[5] = s + r.height, this.vertices[6] = n, this.vertices[7] = s + r.height, this.invalidate(), this;\n    }, t.prototype.invalidate = function() {\n      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;\n    }, t;\n  }(lh)\n), YD = 0, ha = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = YD++, this.static = !!e, this.ubo = !!r, t instanceof Ke ? (this.buffer = t, this.buffer.type = In.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Ke(new Float32Array(1)), this.buffer.type = In.UNIFORM_BUFFER, this.autoManage = !0));\n    }\n    return i.prototype.update = function() {\n      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();\n    }, i.prototype.add = function(t, e, r) {\n      if (!this.ubo)\n        this.uniforms[t] = new i(e, r);\n      else\n        throw new Error(\"[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them\");\n    }, i.from = function(t, e, r) {\n      return new i(t, e, r);\n    }, i.uboFrom = function(t, e) {\n      return new i(t, e ?? !0, !0);\n    }, i;\n  }()\n), HE = (\n  /** @class */\n  function() {\n    function i() {\n      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = ke.NONE, this.sourceFrame = new Nt(), this.destinationFrame = new Nt(), this.bindingSourceFrame = new Nt(), this.bindingDestinationFrame = new Nt(), this.filters = [], this.transform = null;\n    }\n    return i.prototype.clear = function() {\n      this.target = null, this.filters = null, this.renderTexture = null;\n    }, i;\n  }()\n), $d = [new xe(), new xe(), new xe(), new xe()], D0 = new ar(), kb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new jE(), this.texturePool.setScreenSize(t.view), this.statePool = [], this.quad = new zE(), this.quadUv = new Db(), this.tempRect = new Nt(), this.activeState = {}, this.globalUniforms = new ha({\n        outputFrame: new Nt(),\n        inputSize: new Float32Array(4),\n        inputPixel: new Float32Array(4),\n        inputClamp: new Float32Array(4),\n        resolution: 1,\n        // legacy variables\n        filterArea: new Float32Array(4),\n        filterClamp: new Float32Array(4)\n      }, !0), this.forceClear = !1, this.useMaxPadding = !1;\n    }\n    return i.prototype.push = function(t, e) {\n      for (var r, n, s = this.renderer, a = this.defaultFilterStack, o = this.statePool.pop() || new HE(), u = this.renderer.renderTexture, l = e[0].resolution, h = e[0].multisample, d = e[0].padding, f = e[0].autoFit, p = (r = e[0].legacy) !== null && r !== void 0 ? r : !0, v = 1; v < e.length; v++) {\n        var g = e[v];\n        l = Math.min(l, g.resolution), h = Math.min(h, g.multisample), d = this.useMaxPadding ? Math.max(d, g.padding) : d + g.padding, f = f && g.autoFit, p = p || ((n = g.legacy) !== null && n !== void 0 ? n : !0);\n      }\n      a.length === 1 && (this.defaultFilterStack[0].renderTexture = u.current), a.push(o), o.resolution = l, o.multisample = h, o.legacy = p, o.target = t, o.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), o.sourceFrame.pad(d);\n      var m = this.tempRect.copyFrom(u.sourceFrame);\n      s.projection.transform && this.transformAABB(D0.copyFrom(s.projection.transform).invert(), m), f ? (o.sourceFrame.fit(m), (o.sourceFrame.width <= 0 || o.sourceFrame.height <= 0) && (o.sourceFrame.width = 0, o.sourceFrame.height = 0)) : o.sourceFrame.intersects(m) || (o.sourceFrame.width = 0, o.sourceFrame.height = 0), this.roundFrame(o.sourceFrame, u.current ? u.current.resolution : s.resolution, u.sourceFrame, u.destinationFrame, s.projection.transform), o.renderTexture = this.getOptimalFilterTexture(o.sourceFrame.width, o.sourceFrame.height, l, h), o.filters = e, o.destinationFrame.width = o.renderTexture.width, o.destinationFrame.height = o.renderTexture.height;\n      var y = this.tempRect;\n      y.x = 0, y.y = 0, y.width = o.sourceFrame.width, y.height = o.sourceFrame.height, o.renderTexture.filterFrame = o.sourceFrame, o.bindingSourceFrame.copyFrom(u.sourceFrame), o.bindingDestinationFrame.copyFrom(u.destinationFrame), o.transform = s.projection.transform, s.projection.transform = null, u.bind(o.renderTexture, o.sourceFrame, y), s.framebuffer.clear(0, 0, 0, 0);\n    }, i.prototype.pop = function() {\n      var t = this.defaultFilterStack, e = t.pop(), r = e.filters;\n      this.activeState = e;\n      var n = this.globalUniforms.uniforms;\n      n.outputFrame = e.sourceFrame, n.resolution = e.resolution;\n      var s = n.inputSize, a = n.inputPixel, o = n.inputClamp;\n      if (s[0] = e.destinationFrame.width, s[1] = e.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], a[0] = Math.round(s[0] * e.resolution), a[1] = Math.round(s[1] * e.resolution), a[2] = 1 / a[0], a[3] = 1 / a[1], o[0] = 0.5 * a[2], o[1] = 0.5 * a[3], o[2] = e.sourceFrame.width * s[2] - 0.5 * a[2], o[3] = e.sourceFrame.height * s[3] - 0.5 * a[3], e.legacy) {\n        var u = n.filterArea;\n        u[0] = e.destinationFrame.width, u[1] = e.destinationFrame.height, u[2] = e.sourceFrame.x, u[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp;\n      }\n      this.globalUniforms.update();\n      var l = t[t.length - 1];\n      if (this.renderer.framebuffer.blit(), r.length === 1)\n        r[0].apply(this, e.renderTexture, l.renderTexture, Wi.BLEND, e), this.returnFilterTexture(e.renderTexture);\n      else {\n        var h = e.renderTexture, d = this.getOptimalFilterTexture(h.width, h.height, e.resolution);\n        d.filterFrame = h.filterFrame;\n        var f = 0;\n        for (f = 0; f < r.length - 1; ++f) {\n          f === 1 && e.multisample > 1 && (d = this.getOptimalFilterTexture(h.width, h.height, e.resolution), d.filterFrame = h.filterFrame), r[f].apply(this, h, d, Wi.CLEAR, e);\n          var p = h;\n          h = d, d = p;\n        }\n        r[f].apply(this, h, l.renderTexture, Wi.BLEND, e), f > 1 && e.multisample > 1 && this.returnFilterTexture(e.renderTexture), this.returnFilterTexture(h), this.returnFilterTexture(d);\n      }\n      e.clear(), this.statePool.push(e);\n    }, i.prototype.bindAndClear = function(t, e) {\n      e === void 0 && (e = Wi.CLEAR);\n      var r = this.renderer, n = r.renderTexture, s = r.state;\n      if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t && t.filterFrame) {\n        var a = this.tempRect;\n        a.x = 0, a.y = 0, a.width = t.filterFrame.width, a.height = t.filterFrame.height, n.bind(t, t.filterFrame, a);\n      } else\n        t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);\n      var o = s.stateId & 1 || this.forceClear;\n      (e === Wi.CLEAR || e === Wi.BLIT && o) && this.renderer.framebuffer.clear(0, 0, 0, 0);\n    }, i.prototype.applyFilter = function(t, e, r, n) {\n      var s = this.renderer;\n      s.state.set(t.state), this.bindAndClear(r, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(qi.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(qi.TRIANGLE_STRIP));\n    }, i.prototype.calculateSpriteMatrix = function(t, e) {\n      var r = this.activeState, n = r.sourceFrame, s = r.destinationFrame, a = e._texture.orig, o = t.set(s.width, 0, 0, s.height, n.x, n.y), u = e.worldTransform.copyTo(ar.TEMP_MATRIX);\n      return u.invert(), o.prepend(u), o.scale(1 / a.width, 1 / a.height), o.translate(e.anchor.x, e.anchor.y), o;\n    }, i.prototype.destroy = function() {\n      this.renderer = null, this.texturePool.clear(!1);\n    }, i.prototype.getOptimalFilterTexture = function(t, e, r, n) {\n      return r === void 0 && (r = 1), n === void 0 && (n = ke.NONE), this.texturePool.getOptimalTexture(t, e, r, n);\n    }, i.prototype.getFilterTexture = function(t, e, r) {\n      if (typeof t == \"number\") {\n        var n = t;\n        t = e, e = n;\n      }\n      t = t || this.activeState.renderTexture;\n      var s = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution, r || ke.NONE);\n      return s.filterFrame = t.filterFrame, s;\n    }, i.prototype.returnFilterTexture = function(t) {\n      this.texturePool.returnTexture(t);\n    }, i.prototype.emptyPool = function() {\n      this.texturePool.clear(!0);\n    }, i.prototype.resize = function() {\n      this.texturePool.setScreenSize(this.renderer.view);\n    }, i.prototype.transformAABB = function(t, e) {\n      var r = $d[0], n = $d[1], s = $d[2], a = $d[3];\n      r.set(e.left, e.top), n.set(e.left, e.bottom), s.set(e.right, e.top), a.set(e.right, e.bottom), t.apply(r, r), t.apply(n, n), t.apply(s, s), t.apply(a, a);\n      var o = Math.min(r.x, n.x, s.x, a.x), u = Math.min(r.y, n.y, s.y, a.y), l = Math.max(r.x, n.x, s.x, a.x), h = Math.max(r.y, n.y, s.y, a.y);\n      e.x = o, e.y = u, e.width = l - o, e.height = h - u;\n    }, i.prototype.roundFrame = function(t, e, r, n, s) {\n      if (!(t.width <= 0 || t.height <= 0 || r.width <= 0 || r.height <= 0)) {\n        if (s) {\n          var a = s.a, o = s.b, u = s.c, l = s.d;\n          if ((Math.abs(o) > 1e-4 || Math.abs(u) > 1e-4) && (Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4))\n            return;\n        }\n        s = s ? D0.copyFrom(s) : D0.identity(), s.translate(-r.x, -r.y).scale(n.width / r.width, n.height / r.height).translate(n.x, n.y), this.transformAABB(s, t), t.ceil(e), this.transformAABB(s.invert(), t);\n      }\n    }, i;\n  }()\n), wd = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t;\n    }\n    return i.prototype.flush = function() {\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i.prototype.start = function() {\n    }, i.prototype.stop = function() {\n      this.flush();\n    }, i.prototype.render = function(t) {\n    }, i;\n  }()\n), Nb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.emptyRenderer = new wd(t), this.currentRenderer = this.emptyRenderer;\n    }\n    return i.prototype.setObjectRenderer = function(t) {\n      this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start());\n    }, i.prototype.flush = function() {\n      this.setObjectRenderer(this.emptyRenderer);\n    }, i.prototype.reset = function() {\n      this.setObjectRenderer(this.emptyRenderer);\n    }, i.prototype.copyBoundTextures = function(t, e) {\n      for (var r = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n)\n        t[n] = r[n] || null, t[n] && (t[n]._batchLocation = n);\n    }, i.prototype.boundArray = function(t, e, r, n) {\n      for (var s = t.elements, a = t.ids, o = t.count, u = 0, l = 0; l < o; l++) {\n        var h = s[l], d = h._batchLocation;\n        if (d >= 0 && d < n && e[d] === h) {\n          a[l] = d;\n          continue;\n        }\n        for (; u < n; ) {\n          var f = e[u];\n          if (f && f._batchEnabled === r && f._batchLocation === u) {\n            u++;\n            continue;\n          }\n          a[l] = u, h._batchLocation = u, e[u] = h;\n          break;\n        }\n      }\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), w1 = 0, Ab = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {\n        uint32Indices: !1\n      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t.view.addEventListener(\"webglcontextlost\", this.handleContextLost, !1), t.view.addEventListener(\"webglcontextrestored\", this.handleContextRestored, !1);\n    }\n    return Object.defineProperty(i.prototype, \"isLost\", {\n      /**\n       * `true` if the context is lost\n       * @readonly\n       */\n      get: function() {\n        return !this.gl || this.gl.isContextLost();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.contextChange = function(t) {\n      this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = w1++;\n    }, i.prototype.initFromContext = function(t) {\n      this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = w1++, this.renderer.runners.contextChange.emit(t);\n    }, i.prototype.initFromOptions = function(t) {\n      var e = this.createContext(this.renderer.view, t);\n      this.initFromContext(e);\n    }, i.prototype.createContext = function(t, e) {\n      var r;\n      if (gt.PREFER_ENV >= Ts.WEBGL2 && (r = t.getContext(\"webgl2\", e)), r)\n        this.webGLVersion = 2;\n      else if (this.webGLVersion = 1, r = t.getContext(\"webgl\", e) || t.getContext(\"experimental-webgl\", e), !r)\n        throw new Error(\"This browser does not support WebGL. Try using the canvas renderer\");\n      return this.gl = r, this.getExtensions(), this.gl;\n    }, i.prototype.getExtensions = function() {\n      var t = this.gl, e = {\n        loseContext: t.getExtension(\"WEBGL_lose_context\"),\n        anisotropicFiltering: t.getExtension(\"EXT_texture_filter_anisotropic\"),\n        floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n        s3tc: t.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n        s3tc_sRGB: t.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n        etc: t.getExtension(\"WEBGL_compressed_texture_etc\"),\n        etc1: t.getExtension(\"WEBGL_compressed_texture_etc1\"),\n        pvrtc: t.getExtension(\"WEBGL_compressed_texture_pvrtc\") || t.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n        atc: t.getExtension(\"WEBGL_compressed_texture_atc\"),\n        astc: t.getExtension(\"WEBGL_compressed_texture_astc\")\n      };\n      this.webGLVersion === 1 ? Object.assign(this.extensions, e, {\n        drawBuffers: t.getExtension(\"WEBGL_draw_buffers\"),\n        depthTexture: t.getExtension(\"WEBGL_depth_texture\"),\n        vertexArrayObject: t.getExtension(\"OES_vertex_array_object\") || t.getExtension(\"MOZ_OES_vertex_array_object\") || t.getExtension(\"WEBKIT_OES_vertex_array_object\"),\n        uint32ElementIndex: t.getExtension(\"OES_element_index_uint\"),\n        // Floats and half-floats\n        floatTexture: t.getExtension(\"OES_texture_float\"),\n        floatTextureLinear: t.getExtension(\"OES_texture_float_linear\"),\n        textureHalfFloat: t.getExtension(\"OES_texture_half_float\"),\n        textureHalfFloatLinear: t.getExtension(\"OES_texture_half_float_linear\")\n      }) : this.webGLVersion === 2 && Object.assign(this.extensions, e, {\n        // Floats and half-floats\n        colorBufferFloat: t.getExtension(\"EXT_color_buffer_float\")\n      });\n    }, i.prototype.handleContextLost = function(t) {\n      var e = this;\n      t.preventDefault(), setTimeout(function() {\n        e.gl.isContextLost() && e.extensions.loseContext && e.extensions.loseContext.restoreContext();\n      }, 0);\n    }, i.prototype.handleContextRestored = function() {\n      this.renderer.runners.contextChange.emit(this.gl);\n    }, i.prototype.destroy = function() {\n      var t = this.renderer.view;\n      this.renderer = null, t.removeEventListener(\"webglcontextlost\", this.handleContextLost), t.removeEventListener(\"webglcontextrestored\", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();\n    }, i.prototype.postrender = function() {\n      this.renderer.renderingToScreen && this.gl.flush();\n    }, i.prototype.validateContext = function(t) {\n      var e = t.getContextAttributes(), r = \"WebGL2RenderingContext\" in globalThis && t instanceof globalThis.WebGL2RenderingContext;\n      r && (this.webGLVersion = 2), e && !e.stencil && console.warn(\"Provided WebGL context does not have a stencil buffer, masks may not render correctly\");\n      var n = r || !!t.getExtension(\"OES_element_index_uint\");\n      this.supports.uint32Indices = n, n || console.warn(\"Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly\");\n    }, i;\n  }()\n), $E = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = ke.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;\n    }\n    return i;\n  }()\n), qD = new Nt(), Lb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new gv(10, 10), this.msaaSamples = null;\n    }\n    return i.prototype.contextChange = function() {\n      this.disposeAll(!0);\n      var t = this.gl = this.renderer.gl;\n      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Nt(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {\n        var e = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;\n        gt.PREFER_ENV === Ts.WEBGL_LEGACY && (e = null, r = null), e ? t.drawBuffers = function(n) {\n          return e.drawBuffersWEBGL(n);\n        } : (this.hasMRT = !1, t.drawBuffers = function() {\n        }), r || (this.writeDepthTexture = !1);\n      } else\n        this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES);\n    }, i.prototype.bind = function(t, e, r) {\n      r === void 0 && (r = 0);\n      var n = this.gl;\n      if (t) {\n        var s = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);\n        this.current !== t && (this.current = t, n.bindFramebuffer(n.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== r && (t.dirtyId++, t.dirtyFormat++, s.mipLevel = r), s.dirtyId !== t.dirtyId && (s.dirtyId = t.dirtyId, s.dirtyFormat !== t.dirtyFormat ? (s.dirtyFormat = t.dirtyFormat, s.dirtySize = t.dirtySize, this.updateFramebuffer(t, r)) : s.dirtySize !== t.dirtySize && (s.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));\n        for (var a = 0; a < t.colorTextures.length; a++) {\n          var o = t.colorTextures[a];\n          this.renderer.texture.unbind(o.parentTextureArray || o);\n        }\n        if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e) {\n          var u = e.width >> r, l = e.height >> r, h = u / e.width;\n          this.setViewport(e.x * h, e.y * h, u, l);\n        } else {\n          var u = t.width >> r, l = t.height >> r;\n          this.setViewport(0, 0, u, l);\n        }\n      } else\n        this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);\n    }, i.prototype.setViewport = function(t, e, r, n) {\n      var s = this.viewport;\n      t = Math.round(t), e = Math.round(e), r = Math.round(r), n = Math.round(n), (s.width !== r || s.height !== n || s.x !== t || s.y !== e) && (s.x = t, s.y = e, s.width = r, s.height = n, this.gl.viewport(t, e, r, n));\n    }, Object.defineProperty(i.prototype, \"size\", {\n      /**\n       * Get the size of the current width and height. Returns object with `width` and `height` values.\n       * @readonly\n       */\n      get: function() {\n        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.clear = function(t, e, r, n, s) {\n      s === void 0 && (s = lv.COLOR | lv.DEPTH);\n      var a = this.gl;\n      a.clearColor(t, e, r, n), a.clear(s);\n    }, i.prototype.initFramebuffer = function(t) {\n      var e = this.gl, r = new $E(e.createFramebuffer());\n      return r.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(t), t.disposeRunner.add(this), r;\n    }, i.prototype.resizeFramebuffer = function(t) {\n      var e = this.gl, r = t.glFramebuffers[this.CONTEXT_UID];\n      r.msaaBuffer && (e.bindRenderbuffer(e.RENDERBUFFER, r.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.RGBA8, t.width, t.height)), r.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, r.stencil), r.msaaBuffer ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r.multisample, e.DEPTH24_STENCIL8, t.width, t.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));\n      var n = t.colorTextures, s = n.length;\n      e.drawBuffers || (s = Math.min(s, 1));\n      for (var a = 0; a < s; a++) {\n        var o = n[a], u = o.parentTextureArray || o;\n        this.renderer.texture.bind(u, 0);\n      }\n      t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0);\n    }, i.prototype.updateFramebuffer = function(t, e) {\n      var r = this.gl, n = t.glFramebuffers[this.CONTEXT_UID], s = t.colorTextures, a = s.length;\n      r.drawBuffers || (a = Math.min(a, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(t) ? (n.msaaBuffer = n.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, n.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.RGBA8, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, n.msaaBuffer)) : n.msaaBuffer && (r.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));\n      for (var o = [], u = 0; u < a; u++) {\n        var l = s[u], h = l.parentTextureArray || l;\n        this.renderer.texture.bind(h, 0), !(u === 0 && n.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + u, l.target, h._glTextures[this.CONTEXT_UID].texture, e), o.push(r.COLOR_ATTACHMENT0 + u));\n      }\n      if (o.length > 1 && r.drawBuffers(o), t.depthTexture) {\n        var d = this.writeDepthTexture;\n        if (d) {\n          var f = t.depthTexture;\n          this.renderer.texture.bind(f, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, f._glTextures[this.CONTEXT_UID].texture, e);\n        }\n      }\n      (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, n.stencil), n.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, n.multisample, r.DEPTH24_STENCIL8, t.width, t.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t.width, t.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, n.stencil)) : n.stencil && (r.deleteRenderbuffer(n.stencil), n.stencil = null);\n    }, i.prototype.canMultisampleFramebuffer = function(t) {\n      return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture;\n    }, i.prototype.detectSamples = function(t) {\n      var e = this.msaaSamples, r = ke.NONE;\n      if (t <= 1 || e === null)\n        return r;\n      for (var n = 0; n < e.length; n++)\n        if (e[n] <= t) {\n          r = e[n];\n          break;\n        }\n      return r === 1 && (r = ke.NONE), r;\n    }, i.prototype.blit = function(t, e, r) {\n      var n = this, s = n.current, a = n.renderer, o = n.gl, u = n.CONTEXT_UID;\n      if (a.context.webGLVersion === 2 && s) {\n        var l = s.glFramebuffers[u];\n        if (l) {\n          if (!t) {\n            if (!l.msaaBuffer)\n              return;\n            var h = s.colorTextures[0];\n            if (!h)\n              return;\n            l.blitFramebuffer || (l.blitFramebuffer = new gv(s.width, s.height), l.blitFramebuffer.addColorTexture(0, h)), t = l.blitFramebuffer, t.colorTextures[0] !== h && (t.colorTextures[0] = h, t.dirtyId++, t.dirtyFormat++), (t.width !== s.width || t.height !== s.height) && (t.width = s.width, t.height = s.height, t.dirtyId++, t.dirtySize++);\n          }\n          e || (e = qD, e.width = s.width, e.height = s.height), r || (r = e);\n          var d = e.width === r.width && e.height === r.height;\n          this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer), o.blitFramebuffer(e.left, e.top, e.right, e.bottom, r.left, r.top, r.right, r.bottom, o.COLOR_BUFFER_BIT, d ? o.NEAREST : o.LINEAR);\n        }\n      }\n    }, i.prototype.disposeFramebuffer = function(t, e) {\n      var r = t.glFramebuffers[this.CONTEXT_UID], n = this.gl;\n      if (r) {\n        delete t.glFramebuffers[this.CONTEXT_UID];\n        var s = this.managedFramebuffers.indexOf(t);\n        s >= 0 && this.managedFramebuffers.splice(s, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(r.framebuffer), r.msaaBuffer && n.deleteRenderbuffer(r.msaaBuffer), r.stencil && n.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();\n      }\n    }, i.prototype.disposeAll = function(t) {\n      var e = this.managedFramebuffers;\n      this.managedFramebuffers = [];\n      for (var r = 0; r < e.length; r++)\n        this.disposeFramebuffer(e[r], t);\n    }, i.prototype.forceStencil = function() {\n      var t = this.current;\n      if (t) {\n        var e = t.glFramebuffers[this.CONTEXT_UID];\n        if (!(!e || e.stencil)) {\n          t.stencil = !0;\n          var r = t.width, n = t.height, s = this.gl, a = s.createRenderbuffer();\n          s.bindRenderbuffer(s.RENDERBUFFER, a), e.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, e.multisample, s.DEPTH24_STENCIL8, r, n) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, r, n), e.stencil = a, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, a);\n        }\n      }\n    }, i.prototype.reset = function() {\n      this.current = this.unknownFramebuffer, this.viewport = new Nt();\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), k0 = { 5126: 4, 5123: 2, 5121: 1 }, Bb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};\n    }\n    return i.prototype.contextChange = function() {\n      this.disposeAll(!0);\n      var t = this.gl = this.renderer.gl, e = this.renderer.context;\n      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, e.webGLVersion !== 2) {\n        var r = this.renderer.context.extensions.vertexArrayObject;\n        gt.PREFER_ENV === Ts.WEBGL_LEGACY && (r = null), r ? (t.createVertexArray = function() {\n          return r.createVertexArrayOES();\n        }, t.bindVertexArray = function(s) {\n          return r.bindVertexArrayOES(s);\n        }, t.deleteVertexArray = function(s) {\n          return r.deleteVertexArrayOES(s);\n        }) : (this.hasVao = !1, t.createVertexArray = function() {\n          return null;\n        }, t.bindVertexArray = function() {\n          return null;\n        }, t.deleteVertexArray = function() {\n          return null;\n        });\n      }\n      if (e.webGLVersion !== 2) {\n        var n = t.getExtension(\"ANGLE_instanced_arrays\");\n        n ? (t.vertexAttribDivisor = function(s, a) {\n          return n.vertexAttribDivisorANGLE(s, a);\n        }, t.drawElementsInstanced = function(s, a, o, u, l) {\n          return n.drawElementsInstancedANGLE(s, a, o, u, l);\n        }, t.drawArraysInstanced = function(s, a, o, u) {\n          return n.drawArraysInstancedANGLE(s, a, o, u);\n        }) : this.hasInstance = !1;\n      }\n      this.canUseUInt32ElementIndex = e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex;\n    }, i.prototype.bind = function(t, e) {\n      e = e || this.renderer.shader.shader;\n      var r = this.gl, n = t.glVertexArrayObjects[this.CONTEXT_UID], s = !1;\n      n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, s = !0);\n      var a = n[e.program.id] || this.initGeometryVao(t, e, s);\n      this._activeGeometry = t, this._activeVao !== a && (this._activeVao = a, this.hasVao ? r.bindVertexArray(a) : this.activateVao(t, e.program)), this.updateBuffers();\n    }, i.prototype.reset = function() {\n      this.unbind();\n    }, i.prototype.updateBuffers = function() {\n      for (var t = this._activeGeometry, e = this.renderer.buffer, r = 0; r < t.buffers.length; r++) {\n        var n = t.buffers[r];\n        e.update(n);\n      }\n    }, i.prototype.checkCompatibility = function(t, e) {\n      var r = t.attributes, n = e.attributeData;\n      for (var s in n)\n        if (!r[s])\n          throw new Error('shader and geometry incompatible, geometry missing the \"' + s + '\" attribute');\n    }, i.prototype.getSignature = function(t, e) {\n      var r = t.attributes, n = e.attributeData, s = [\"g\", t.id];\n      for (var a in r)\n        n[a] && s.push(a, n[a].location);\n      return s.join(\"-\");\n    }, i.prototype.initGeometryVao = function(t, e, r) {\n      r === void 0 && (r = !0);\n      var n = this.gl, s = this.CONTEXT_UID, a = this.renderer.buffer, o = e.program;\n      o.glPrograms[s] || this.renderer.shader.generateProgram(e), this.checkCompatibility(t, o);\n      var u = this.getSignature(t, o), l = t.glVertexArrayObjects[this.CONTEXT_UID], h = l[u];\n      if (h)\n        return l[o.id] = h, h;\n      var d = t.buffers, f = t.attributes, p = {}, v = {};\n      for (var g in d)\n        p[g] = 0, v[g] = 0;\n      for (var g in f)\n        !f[g].size && o.attributeData[g] ? f[g].size = o.attributeData[g].size : f[g].size || console.warn(\"PIXI Geometry attribute '\" + g + \"' size cannot be determined (likely the bound shader does not have the attribute)\"), p[f[g].buffer] += f[g].size * k0[f[g].type];\n      for (var g in f) {\n        var m = f[g], y = m.size;\n        m.stride === void 0 && (p[m.buffer] === y * k0[m.type] ? m.stride = 0 : m.stride = p[m.buffer]), m.start === void 0 && (m.start = v[m.buffer], v[m.buffer] += y * k0[m.type]);\n      }\n      h = n.createVertexArray(), n.bindVertexArray(h);\n      for (var _ = 0; _ < d.length; _++) {\n        var b = d[_];\n        a.bind(b), r && b._glBuffers[s].refCount++;\n      }\n      return this.activateVao(t, o), this._activeVao = h, l[o.id] = h, l[u] = h, h;\n    }, i.prototype.disposeGeometry = function(t, e) {\n      var r;\n      if (this.managedGeometries[t.id]) {\n        delete this.managedGeometries[t.id];\n        var n = t.glVertexArrayObjects[this.CONTEXT_UID], s = this.gl, a = t.buffers, o = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;\n        if (t.disposeRunner.remove(this), !!n) {\n          if (o)\n            for (var u = 0; u < a.length; u++) {\n              var l = a[u]._glBuffers[this.CONTEXT_UID];\n              l && (l.refCount--, l.refCount === 0 && !e && o.dispose(a[u], e));\n            }\n          if (!e) {\n            for (var h in n)\n              if (h[0] === \"g\") {\n                var d = n[h];\n                this._activeVao === d && this.unbind(), s.deleteVertexArray(d);\n              }\n          }\n          delete t.glVertexArrayObjects[this.CONTEXT_UID];\n        }\n      }\n    }, i.prototype.disposeAll = function(t) {\n      for (var e = Object.keys(this.managedGeometries), r = 0; r < e.length; r++)\n        this.disposeGeometry(this.managedGeometries[e[r]], t);\n    }, i.prototype.activateVao = function(t, e) {\n      var r = this.gl, n = this.CONTEXT_UID, s = this.renderer.buffer, a = t.buffers, o = t.attributes;\n      t.indexBuffer && s.bind(t.indexBuffer);\n      var u = null;\n      for (var l in o) {\n        var h = o[l], d = a[h.buffer], f = d._glBuffers[n];\n        if (e.attributeData[l]) {\n          u !== f && (s.bind(d), u = f);\n          var p = e.attributeData[l].location;\n          if (r.enableVertexAttribArray(p), r.vertexAttribPointer(p, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance)\n            if (this.hasInstance)\n              r.vertexAttribDivisor(p, 1);\n            else\n              throw new Error(\"geometry error, GPU Instancing is not supported on this device\");\n        }\n      }\n    }, i.prototype.draw = function(t, e, r, n) {\n      var s = this.gl, a = this._activeGeometry;\n      if (a.indexBuffer) {\n        var o = a.indexBuffer.data.BYTES_PER_ELEMENT, u = o === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;\n        o === 2 || o === 4 && this.canUseUInt32ElementIndex ? a.instanced ? s.drawElementsInstanced(t, e || a.indexBuffer.data.length, u, (r || 0) * o, n || 1) : s.drawElements(t, e || a.indexBuffer.data.length, u, (r || 0) * o) : console.warn(\"unsupported index buffer type: uint32\");\n      } else\n        a.instanced ? s.drawArraysInstanced(t, r, e || a.getSize(), n || 1) : s.drawArrays(t, r, e || a.getSize());\n      return this;\n    }, i.prototype.unbind = function() {\n      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), VE = (\n  /** @class */\n  function() {\n    function i(t) {\n      t === void 0 && (t = null), this.type = Ze.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = gt.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;\n    }\n    return Object.defineProperty(i.prototype, \"filter\", {\n      /**\n       * The sprite mask filter.\n       * If set to `null`, the default sprite mask filter is used.\n       * @default null\n       */\n      get: function() {\n        return this._filters ? this._filters[0] : null;\n      },\n      set: function(t) {\n        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.reset = function() {\n      this.pooled && (this.maskObject = null, this.type = Ze.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;\n    }, i.prototype.copyCountersOrReset = function(t) {\n      t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);\n    }, i;\n  }()\n);\nfunction E1(i, t, e) {\n  var r = i.createShader(t);\n  return i.shaderSource(r, e), i.compileShader(r), r;\n}\nfunction S1(i, t) {\n  var e = i.getShaderSource(t).split(`\n`).map(function(l, h) {\n    return h + \": \" + l;\n  }), r = i.getShaderInfoLog(t), n = r.split(`\n`), s = {}, a = n.map(function(l) {\n    return parseFloat(l.replace(/^ERROR\\: 0\\:([\\d]+)\\:.*$/, \"$1\"));\n  }).filter(function(l) {\n    return l && !s[l] ? (s[l] = !0, !0) : !1;\n  }), o = [\"\"];\n  a.forEach(function(l) {\n    e[l - 1] = \"%c\" + e[l - 1] + \"%c\", o.push(\"background: #FF0000; color:#FFFFFF; font-size: 10px\", \"font-size: 10px\");\n  });\n  var u = e.join(`\n`);\n  o[0] = u, console.error(r), console.groupCollapsed(\"click to view full shader code\"), console.warn.apply(console, o), console.groupEnd();\n}\nfunction ZD(i, t, e, r) {\n  i.getProgramParameter(t, i.LINK_STATUS) || (i.getShaderParameter(e, i.COMPILE_STATUS) || S1(i, e), i.getShaderParameter(r, i.COMPILE_STATUS) || S1(i, r), console.error(\"PixiJS Error: Could not initialize shader.\"), i.getProgramInfoLog(t) !== \"\" && console.warn(\"PixiJS Warning: gl.getProgramInfoLog()\", i.getProgramInfoLog(t)));\n}\nfunction N0(i) {\n  for (var t = new Array(i), e = 0; e < t.length; e++)\n    t[e] = !1;\n  return t;\n}\nfunction XE(i, t) {\n  switch (i) {\n    case \"float\":\n      return 0;\n    case \"vec2\":\n      return new Float32Array(2 * t);\n    case \"vec3\":\n      return new Float32Array(3 * t);\n    case \"vec4\":\n      return new Float32Array(4 * t);\n    case \"int\":\n    case \"uint\":\n    case \"sampler2D\":\n    case \"sampler2DArray\":\n      return 0;\n    case \"ivec2\":\n      return new Int32Array(2 * t);\n    case \"ivec3\":\n      return new Int32Array(3 * t);\n    case \"ivec4\":\n      return new Int32Array(4 * t);\n    case \"uvec2\":\n      return new Uint32Array(2 * t);\n    case \"uvec3\":\n      return new Uint32Array(3 * t);\n    case \"uvec4\":\n      return new Uint32Array(4 * t);\n    case \"bool\":\n      return !1;\n    case \"bvec2\":\n      return N0(2 * t);\n    case \"bvec3\":\n      return N0(3 * t);\n    case \"bvec4\":\n      return N0(4 * t);\n    case \"mat2\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\nvar WE = {}, yh = WE;\nfunction YE() {\n  if (yh === WE || yh && yh.isContextLost()) {\n    var i = gt.ADAPTER.createCanvas(), t = void 0;\n    gt.PREFER_ENV >= Ts.WEBGL2 && (t = i.getContext(\"webgl2\", {})), t || (t = i.getContext(\"webgl\", {}) || i.getContext(\"experimental-webgl\", {}), t ? t.getExtension(\"WEBGL_draw_buffers\") : t = null), yh = t;\n  }\n  return yh;\n}\nvar Vd;\nfunction KD() {\n  if (!Vd) {\n    Vd = si.MEDIUM;\n    var i = YE();\n    if (i && i.getShaderPrecisionFormat) {\n      var t = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT);\n      Vd = t.precision ? si.HIGH : si.MEDIUM;\n    }\n  }\n  return Vd;\n}\nfunction T1(i, t, e) {\n  if (i.substring(0, 9) !== \"precision\") {\n    var r = t;\n    return t === si.HIGH && e !== si.HIGH && (r = si.MEDIUM), \"precision \" + r + ` float;\n` + i;\n  } else if (e !== si.HIGH && i.substring(0, 15) === \"precision highp\")\n    return i.replace(\"precision highp\", \"precision mediump\");\n  return i;\n}\nvar JD = {\n  float: 1,\n  vec2: 2,\n  vec3: 3,\n  vec4: 4,\n  int: 1,\n  ivec2: 2,\n  ivec3: 3,\n  ivec4: 4,\n  uint: 1,\n  uvec2: 2,\n  uvec3: 3,\n  uvec4: 4,\n  bool: 1,\n  bvec2: 2,\n  bvec3: 3,\n  bvec4: 4,\n  mat2: 4,\n  mat3: 9,\n  mat4: 16,\n  sampler2D: 1\n};\nfunction qE(i) {\n  return JD[i];\n}\nvar Xd = null, C1 = {\n  FLOAT: \"float\",\n  FLOAT_VEC2: \"vec2\",\n  FLOAT_VEC3: \"vec3\",\n  FLOAT_VEC4: \"vec4\",\n  INT: \"int\",\n  INT_VEC2: \"ivec2\",\n  INT_VEC3: \"ivec3\",\n  INT_VEC4: \"ivec4\",\n  UNSIGNED_INT: \"uint\",\n  UNSIGNED_INT_VEC2: \"uvec2\",\n  UNSIGNED_INT_VEC3: \"uvec3\",\n  UNSIGNED_INT_VEC4: \"uvec4\",\n  BOOL: \"bool\",\n  BOOL_VEC2: \"bvec2\",\n  BOOL_VEC3: \"bvec3\",\n  BOOL_VEC4: \"bvec4\",\n  FLOAT_MAT2: \"mat2\",\n  FLOAT_MAT3: \"mat3\",\n  FLOAT_MAT4: \"mat4\",\n  SAMPLER_2D: \"sampler2D\",\n  INT_SAMPLER_2D: \"sampler2D\",\n  UNSIGNED_INT_SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n  INT_SAMPLER_CUBE: \"samplerCube\",\n  UNSIGNED_INT_SAMPLER_CUBE: \"samplerCube\",\n  SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  INT_SAMPLER_2D_ARRAY: \"sampler2DArray\",\n  UNSIGNED_INT_SAMPLER_2D_ARRAY: \"sampler2DArray\"\n};\nfunction ZE(i, t) {\n  if (!Xd) {\n    var e = Object.keys(C1);\n    Xd = {};\n    for (var r = 0; r < e.length; ++r) {\n      var n = e[r];\n      Xd[i[n]] = C1[n];\n    }\n  }\n  return Xd[t];\n}\nvar Yo = [\n  // a float cache layer\n  {\n    test: function(i) {\n      return i.type === \"float\" && i.size === 1 && !i.isArray;\n    },\n    code: function(i) {\n      return `\n            if(uv[\"` + i + '\"] !== ud[\"' + i + `\"].value)\n            {\n                ud[\"` + i + '\"].value = uv[\"' + i + `\"]\n                gl.uniform1f(ud[\"` + i + '\"].location, uv[\"' + i + `\"])\n            }\n            `;\n    }\n  },\n  // handling samplers\n  {\n    test: function(i, t) {\n      return (i.type === \"sampler2D\" || i.type === \"samplerCube\" || i.type === \"sampler2DArray\") && i.size === 1 && !i.isArray && (t == null || t.castToBaseTexture !== void 0);\n    },\n    code: function(i) {\n      return `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"` + i + `\"], t);\n\n            if(ud[\"` + i + `\"].value !== t)\n            {\n                ud[\"` + i + `\"].value = t;\n                gl.uniform1i(ud[\"` + i + `\"].location, t);\n; // eslint-disable-line max-len\n            }`;\n    }\n  },\n  // uploading pixi matrix object to mat3\n  {\n    test: function(i, t) {\n      return i.type === \"mat3\" && i.size === 1 && !i.isArray && t.a !== void 0;\n    },\n    code: function(i) {\n      return `\n            gl.uniformMatrix3fv(ud[\"` + i + '\"].location, false, uv[\"' + i + `\"].toArray(true));\n            `;\n    },\n    codeUbo: function(i) {\n      return `\n                var ` + i + \"_matrix = uv.\" + i + `.toArray(true);\n\n                data[offset] = ` + i + `_matrix[0];\n                data[offset+1] = ` + i + `_matrix[1];\n                data[offset+2] = ` + i + `_matrix[2];\n        \n                data[offset + 4] = ` + i + `_matrix[3];\n                data[offset + 5] = ` + i + `_matrix[4];\n                data[offset + 6] = ` + i + `_matrix[5];\n        \n                data[offset + 8] = ` + i + `_matrix[6];\n                data[offset + 9] = ` + i + `_matrix[7];\n                data[offset + 10] = ` + i + `_matrix[8];\n            `;\n    }\n  },\n  // uploading a pixi point as a vec2 with caching layer\n  {\n    test: function(i, t) {\n      return i.type === \"vec2\" && i.size === 1 && !i.isArray && t.x !== void 0;\n    },\n    code: function(i) {\n      return `\n                cv = ud[\"` + i + `\"].value;\n                v = uv[\"` + i + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"` + i + `\"].location, v.x, v.y);\n                }`;\n    },\n    codeUbo: function(i) {\n      return `\n                v = uv.` + i + `;\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `;\n    }\n  },\n  // caching layer for a vec2\n  {\n    test: function(i) {\n      return i.type === \"vec2\" && i.size === 1 && !i.isArray;\n    },\n    code: function(i) {\n      return `\n                cv = ud[\"` + i + `\"].value;\n                v = uv[\"` + i + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"` + i + `\"].location, v[0], v[1]);\n                }\n            `;\n    }\n  },\n  // upload a pixi rectangle as a vec4 with caching layer\n  {\n    test: function(i, t) {\n      return i.type === \"vec4\" && i.size === 1 && !i.isArray && t.width !== void 0;\n    },\n    code: function(i) {\n      return `\n                cv = ud[\"` + i + `\"].value;\n                v = uv[\"` + i + `\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"` + i + `\"].location, v.x, v.y, v.width, v.height)\n                }`;\n    },\n    codeUbo: function(i) {\n      return `\n                    v = uv.` + i + `;\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `;\n    }\n  },\n  // a caching layer for vec4 uploading\n  {\n    test: function(i) {\n      return i.type === \"vec4\" && i.size === 1 && !i.isArray;\n    },\n    code: function(i) {\n      return `\n                cv = ud[\"` + i + `\"].value;\n                v = uv[\"` + i + `\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"` + i + `\"].location, v[0], v[1], v[2], v[3])\n                }`;\n    }\n  }\n], QD = {\n  float: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }`,\n  vec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }`,\n  vec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }`,\n  vec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }`,\n  int: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  ivec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  ivec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  ivec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  uint: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }`,\n  uvec2: `\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }`,\n  uvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }`,\n  uvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }`,\n  bool: `\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }`,\n  bvec2: `\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }`,\n  bvec3: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }`,\n  bvec4: `\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }`,\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  sampler2D: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  samplerCube: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`,\n  sampler2DArray: `\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }`\n}, t2 = {\n  float: \"gl.uniform1fv(location, v)\",\n  vec2: \"gl.uniform2fv(location, v)\",\n  vec3: \"gl.uniform3fv(location, v)\",\n  vec4: \"gl.uniform4fv(location, v)\",\n  mat4: \"gl.uniformMatrix4fv(location, false, v)\",\n  mat3: \"gl.uniformMatrix3fv(location, false, v)\",\n  mat2: \"gl.uniformMatrix2fv(location, false, v)\",\n  int: \"gl.uniform1iv(location, v)\",\n  ivec2: \"gl.uniform2iv(location, v)\",\n  ivec3: \"gl.uniform3iv(location, v)\",\n  ivec4: \"gl.uniform4iv(location, v)\",\n  uint: \"gl.uniform1uiv(location, v)\",\n  uvec2: \"gl.uniform2uiv(location, v)\",\n  uvec3: \"gl.uniform3uiv(location, v)\",\n  uvec4: \"gl.uniform4uiv(location, v)\",\n  bool: \"gl.uniform1iv(location, v)\",\n  bvec2: \"gl.uniform2iv(location, v)\",\n  bvec3: \"gl.uniform3iv(location, v)\",\n  bvec4: \"gl.uniform4iv(location, v)\",\n  sampler2D: \"gl.uniform1iv(location, v)\",\n  samplerCube: \"gl.uniform1iv(location, v)\",\n  sampler2DArray: \"gl.uniform1iv(location, v)\"\n};\nfunction e2(i, t) {\n  var e, r = [`\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    `];\n  for (var n in i.uniforms) {\n    var s = t[n];\n    if (!s) {\n      !((e = i.uniforms[n]) === null || e === void 0) && e.group && (i.uniforms[n].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.` + n + \", '\" + n + `');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.` + n + `, syncData);\n                    `));\n      continue;\n    }\n    for (var a = i.uniforms[n], o = !1, u = 0; u < Yo.length; u++)\n      if (Yo[u].test(s, a)) {\n        r.push(Yo[u].code(n, a)), o = !0;\n        break;\n      }\n    if (!o) {\n      var l = s.size === 1 && !s.isArray ? QD : t2, h = l[s.type].replace(\"location\", 'ud[\"' + n + '\"].location');\n      r.push(`\n            cu = ud[\"` + n + `\"];\n            cv = cu.value;\n            v = uv[\"` + n + `\"];\n            ` + h + \";\");\n    }\n  }\n  return new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", r.join(`\n`));\n}\nvar r2 = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(`\n`);\nfunction i2(i) {\n  for (var t = \"\", e = 0; e < i; ++e)\n    e > 0 && (t += `\nelse `), e < i - 1 && (t += \"if(test == \" + e + \".0){}\");\n  return t;\n}\nfunction KE(i, t) {\n  if (i === 0)\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  for (var e = t.createShader(t.FRAGMENT_SHADER); ; ) {\n    var r = r2.replace(/%forloop%/gi, i2(i));\n    if (t.shaderSource(e, r), t.compileShader(e), !t.getShaderParameter(e, t.COMPILE_STATUS))\n      i = i / 2 | 0;\n    else\n      break;\n  }\n  return i;\n}\nvar _h;\nfunction n2() {\n  if (typeof _h == \"boolean\")\n    return _h;\n  try {\n    var i = new Function(\"param1\", \"param2\", \"param3\", \"return param1[param2] === param3;\");\n    _h = i({ a: \"b\" }, \"a\", \"b\") === !0;\n  } catch {\n    _h = !1;\n  }\n  return _h;\n}\nvar s2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}`, a2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n`, o2 = 0, Wd = {}, hh = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      r === void 0 && (r = \"pixi-shader\"), this.id = o2++, this.vertexSrc = t || i.defaultVertexSrc, this.fragmentSrc = e || i.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== \"#version\" && (r = r.replace(/\\s+/g, \"-\"), Wd[r] ? (Wd[r]++, r += \"-\" + Wd[r]) : Wd[r] = 1, this.vertexSrc = \"#define SHADER_NAME \" + r + `\n` + this.vertexSrc, this.fragmentSrc = \"#define SHADER_NAME \" + r + `\n` + this.fragmentSrc, this.vertexSrc = T1(this.vertexSrc, gt.PRECISION_VERTEX, si.HIGH), this.fragmentSrc = T1(this.fragmentSrc, gt.PRECISION_FRAGMENT, KD())), this.glPrograms = {}, this.syncUniforms = null;\n    }\n    return Object.defineProperty(i, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source.\n       * @constant\n       */\n      get: function() {\n        return a2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"defaultFragmentSrc\", {\n      /**\n       * The default fragment shader source.\n       * @constant\n       */\n      get: function() {\n        return s2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.from = function(t, e, r) {\n      var n = t + e, s = m1[n];\n      return s || (m1[n] = s = new i(t, e, r)), s;\n    }, i;\n  }()\n), xs = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this.uniformBindCount = 0, this.program = t, e ? e instanceof ha ? this.uniformGroup = e : this.uniformGroup = new ha(e) : this.uniformGroup = new ha({}), this.disposeRunner = new pr(\"disposeShader\");\n    }\n    return i.prototype.checkUniformExists = function(t, e) {\n      if (e.uniforms[t])\n        return !0;\n      for (var r in e.uniforms) {\n        var n = e.uniforms[r];\n        if (n.group && this.checkUniformExists(t, n))\n          return !0;\n      }\n      return !1;\n    }, i.prototype.destroy = function() {\n      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();\n    }, Object.defineProperty(i.prototype, \"uniforms\", {\n      /**\n       * Shader uniform values, shortcut for `uniformGroup.uniforms`.\n       * @readonly\n       */\n      get: function() {\n        return this.uniformGroup.uniforms;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.from = function(t, e, r) {\n      var n = hh.from(t, e);\n      return new i(n, r);\n    }, i;\n  }()\n), A0 = 0, L0 = 1, B0 = 2, F0 = 3, G0 = 4, U0 = 5, ga = (\n  /** @class */\n  function() {\n    function i() {\n      this.data = 0, this.blendMode = Et.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;\n    }\n    return Object.defineProperty(i.prototype, \"blend\", {\n      /**\n       * Activates blending of the computed fragment color values.\n       * @default true\n       */\n      get: function() {\n        return !!(this.data & 1 << A0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << A0) !== t && (this.data ^= 1 << A0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"offsets\", {\n      /**\n       * Activates adding an offset to depth values of polygon's fragments\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << L0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << L0) !== t && (this.data ^= 1 << L0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"culling\", {\n      /**\n       * Activates culling of polygons.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << B0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << B0) !== t && (this.data ^= 1 << B0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"depthTest\", {\n      /**\n       * Activates depth comparisons and updates to the depth buffer.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << F0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << F0) !== t && (this.data ^= 1 << F0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"depthMask\", {\n      /**\n       * Enables or disables writing to the depth buffer.\n       * @default true\n       */\n      get: function() {\n        return !!(this.data & 1 << U0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << U0) !== t && (this.data ^= 1 << U0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"clockwiseFrontFace\", {\n      /**\n       * Specifies whether or not front or back-facing polygons can be culled.\n       * @default false\n       */\n      get: function() {\n        return !!(this.data & 1 << G0);\n      },\n      set: function(t) {\n        !!(this.data & 1 << G0) !== t && (this.data ^= 1 << G0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"blendMode\", {\n      /**\n       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      get: function() {\n        return this._blendMode;\n      },\n      set: function(t) {\n        this.blend = t !== Et.NONE, this._blendMode = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"polygonOffset\", {\n      /**\n       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n       * @default 0\n       */\n      get: function() {\n        return this._polygonOffset;\n      },\n      set: function(t) {\n        this.offsets = !!t, this._polygonOffset = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.toString = function() {\n      return \"[@pixi/core:State \" + (\"blendMode=\" + this.blendMode + \" \") + (\"clockwiseFrontFace=\" + this.clockwiseFrontFace + \" \") + (\"culling=\" + this.culling + \" \") + (\"depthMask=\" + this.depthMask + \" \") + (\"polygonOffset=\" + this.polygonOffset) + \"]\";\n    }, i.for2d = function() {\n      var t = new i();\n      return t.depthTest = !1, t.blend = !0, t;\n    }, i;\n  }()\n), u2 = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n`, l2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, rn = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r, n) {\n      var s = this, a = hh.from(e || t.defaultVertexSrc, r || t.defaultFragmentSrc);\n      return s = i.call(this, a, n) || this, s.padding = 0, s.resolution = gt.FILTER_RESOLUTION, s.multisample = gt.FILTER_MULTISAMPLE, s.enabled = !0, s.autoFit = !0, s.state = new ga(), s;\n    }\n    return t.prototype.apply = function(e, r, n, s, a) {\n      e.applyFilter(this, r, n, s);\n    }, Object.defineProperty(t.prototype, \"blendMode\", {\n      /**\n       * Sets the blend mode of the filter.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      get: function() {\n        return this.state.blendMode;\n      },\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * The resolution of the filter. Setting this to be lower will lower the quality but\n       * increase the performance of the filter.\n       */\n      get: function() {\n        return this._resolution;\n      },\n      set: function(e) {\n        this._resolution = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source\n       * @constant\n       */\n      get: function() {\n        return l2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t, \"defaultFragmentSrc\", {\n      /**\n       * The default fragment shader source\n       * @constant\n       */\n      get: function() {\n        return u2;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(xs)\n), h2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n`, c2 = `varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n`, M1 = new ar(), n0 = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this._texture = t, this.mapCoord = new ar(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof e > \"u\" ? 0.5 : e, this.isSimple = !1;\n    }\n    return Object.defineProperty(i.prototype, \"texture\", {\n      /** Texture property. */\n      get: function() {\n        return this._texture;\n      },\n      set: function(t) {\n        this._texture = t, this._textureID = -1;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.multiplyUvs = function(t, e) {\n      e === void 0 && (e = t);\n      for (var r = this.mapCoord, n = 0; n < t.length; n += 2) {\n        var s = t[n], a = t[n + 1];\n        e[n] = s * r.a + a * r.c + r.tx, e[n + 1] = s * r.b + a * r.d + r.ty;\n      }\n      return e;\n    }, i.prototype.update = function(t) {\n      var e = this._texture;\n      if (!e || !e.valid || !t && this._textureID === e._updateID)\n        return !1;\n      this._textureID = e._updateID, this._updateID++;\n      var r = e._uvs;\n      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);\n      var n = e.orig, s = e.trim;\n      s && (M1.set(n.width / s.width, 0, 0, n.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(M1));\n      var a = e.baseTexture, o = this.uClampFrame, u = this.clampMargin / a.resolution, l = this.clampOffset;\n      return o[0] = (e._frame.x + u + l) / a.width, o[1] = (e._frame.y + u + l) / a.height, o[2] = (e._frame.x + e._frame.width - u + l) / a.width, o[3] = (e._frame.y + e._frame.height - u + l) / a.height, this.uClampOffset[0] = l / a.realWidth, this.uClampOffset[1] = l / a.realHeight, this.isSimple = e._frame.width === a.width && e._frame.height === a.height && e.rotate === 0, !0;\n    }, i;\n  }()\n), JE = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r, n) {\n      var s = this, a = null;\n      return typeof e != \"string\" && r === void 0 && n === void 0 && (a = e, e = void 0, r = void 0, n = void 0), s = i.call(this, e || h2, r || c2, n) || this, s.maskSprite = a, s.maskMatrix = new ar(), s;\n    }\n    return Object.defineProperty(t.prototype, \"maskSprite\", {\n      /**\n       * Sprite mask\n       * @type {PIXI.DisplayObject}\n       */\n      get: function() {\n        return this._maskSprite;\n      },\n      set: function(e) {\n        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.apply = function(e, r, n, s) {\n      var a = this._maskSprite, o = a._texture;\n      o.valid && (o.uvMatrix || (o.uvMatrix = new n0(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, a).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = a.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, e.applyFilter(this, r, n, s));\n    }, t;\n  }(rn)\n), Fb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;\n    }\n    return i.prototype.setMaskStack = function(t) {\n      this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t);\n    }, i.prototype.push = function(t, e) {\n      var r = e;\n      if (!r.isMaskData) {\n        var n = this.maskDataPool.pop() || new VE();\n        n.pooled = !0, n.maskObject = e, r = n;\n      }\n      var s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;\n      if (r.copyCountersOrReset(s), r._colorMask = s ? s._colorMask : 15, r.autoDetect && this.detect(r), r._target = t, r.type !== Ze.SPRITE && this.maskStack.push(r), r.enabled)\n        switch (r.type) {\n          case Ze.SCISSOR:\n            this.renderer.scissor.push(r);\n            break;\n          case Ze.STENCIL:\n            this.renderer.stencil.push(r);\n            break;\n          case Ze.SPRITE:\n            r.copyCountersOrReset(null), this.pushSpriteMask(r);\n            break;\n          case Ze.COLOR:\n            this.pushColorMask(r);\n            break;\n        }\n      r.type === Ze.SPRITE && this.maskStack.push(r);\n    }, i.prototype.pop = function(t) {\n      var e = this.maskStack.pop();\n      if (!(!e || e._target !== t)) {\n        if (e.enabled)\n          switch (e.type) {\n            case Ze.SCISSOR:\n              this.renderer.scissor.pop(e);\n              break;\n            case Ze.STENCIL:\n              this.renderer.stencil.pop(e.maskObject);\n              break;\n            case Ze.SPRITE:\n              this.popSpriteMask(e);\n              break;\n            case Ze.COLOR:\n              this.popColorMask(e);\n              break;\n          }\n        if (e.reset(), e.pooled && this.maskDataPool.push(e), this.maskStack.length !== 0) {\n          var r = this.maskStack[this.maskStack.length - 1];\n          r.type === Ze.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);\n        }\n      }\n    }, i.prototype.detect = function(t) {\n      var e = t.maskObject;\n      e ? e.isSprite ? t.type = Ze.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Ze.SCISSOR : t.type = Ze.STENCIL : t.type = Ze.COLOR;\n    }, i.prototype.pushSpriteMask = function(t) {\n      var e, r, n = t.maskObject, s = t._target, a = t._filters;\n      a || (a = this.alphaMaskPool[this.alphaMaskIndex], a || (a = this.alphaMaskPool[this.alphaMaskIndex] = [new JE()]));\n      var o = this.renderer, u = o.renderTexture, l, h;\n      if (u.current) {\n        var d = u.current;\n        l = t.resolution || d.resolution, h = (e = t.multisample) !== null && e !== void 0 ? e : d.multisample;\n      } else\n        l = t.resolution || o.resolution, h = (r = t.multisample) !== null && r !== void 0 ? r : o.multisample;\n      a[0].resolution = l, a[0].multisample = h, a[0].maskSprite = n;\n      var f = s.filterArea;\n      s.filterArea = n.getBounds(!0), o.filter.push(s, a), s.filterArea = f, t._filters || this.alphaMaskIndex++;\n    }, i.prototype.popSpriteMask = function(t) {\n      this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);\n    }, i.prototype.pushColorMask = function(t) {\n      var e = t._colorMask, r = t._colorMask = e & t.colorMask;\n      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n    }, i.prototype.popColorMask = function(t) {\n      var e = t._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;\n      r !== e && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), QE = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.maskStack = [], this.glConst = 0;\n    }\n    return i.prototype.getStackLength = function() {\n      return this.maskStack.length;\n    }, i.prototype.setMaskStack = function(t) {\n      var e = this.renderer.gl, r = this.getStackLength();\n      this.maskStack = t;\n      var n = this.getStackLength();\n      n !== r && (n === 0 ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()));\n    }, i.prototype._useCurrent = function() {\n    }, i.prototype.destroy = function() {\n      this.renderer = null, this.maskStack = null;\n    }, i;\n  }()\n), P1 = new ar(), O1 = [], Gb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return r.glConst = gt.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;\n    }\n    return t.prototype.getStackLength = function() {\n      var e = this.maskStack[this.maskStack.length - 1];\n      return e ? e._scissorCounter : 0;\n    }, t.prototype.calcScissorRect = function(e) {\n      var r;\n      if (!e._scissorRectLocal) {\n        var n = e._scissorRect, s = e.maskObject, a = this.renderer, o = a.renderTexture, u = s.getBounds(!0, (r = O1.pop()) !== null && r !== void 0 ? r : new Nt());\n        this.roundFrameToPixels(u, o.current ? o.current.resolution : a.resolution, o.sourceFrame, o.destinationFrame, a.projection.transform), n && u.fit(n), e._scissorRectLocal = u;\n      }\n    }, t.isMatrixRotated = function(e) {\n      if (!e)\n        return !1;\n      var r = e.a, n = e.b, s = e.c, a = e.d;\n      return (Math.abs(n) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(a) > 1e-4);\n    }, t.prototype.testScissor = function(e) {\n      var r = e.maskObject;\n      if (!r.isFastRect || !r.isFastRect() || t.isMatrixRotated(r.worldTransform) || t.isMatrixRotated(this.renderer.projection.transform))\n        return !1;\n      this.calcScissorRect(e);\n      var n = e._scissorRectLocal;\n      return n.width > 0 && n.height > 0;\n    }, t.prototype.roundFrameToPixels = function(e, r, n, s, a) {\n      t.isMatrixRotated(a) || (a = a ? P1.copyFrom(a) : P1.identity(), a.translate(-n.x, -n.y).scale(s.width / n.width, s.height / n.height).translate(s.x, s.y), this.renderer.filter.transformAABB(a, e), e.fit(s), e.x = Math.round(e.x * r), e.y = Math.round(e.y * r), e.width = Math.round(e.width * r), e.height = Math.round(e.height * r));\n    }, t.prototype.push = function(e) {\n      e._scissorRectLocal || this.calcScissorRect(e);\n      var r = this.renderer.gl;\n      e._scissorRect || r.enable(r.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent();\n    }, t.prototype.pop = function(e) {\n      var r = this.renderer.gl;\n      e && O1.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);\n    }, t.prototype._useCurrent = function() {\n      var e = this.maskStack[this.maskStack.length - 1]._scissorRect, r;\n      this.renderer.renderTexture.current ? r = e.y : r = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, r, e.width, e.height);\n    }, t;\n  }(QE)\n), Ub = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return r.glConst = gt.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;\n    }\n    return t.prototype.getStackLength = function() {\n      var e = this.maskStack[this.maskStack.length - 1];\n      return e ? e._stencilCounter : 0;\n    }, t.prototype.push = function(e) {\n      var r = e.maskObject, n = this.renderer.gl, s = e._stencilCounter;\n      s === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), e._stencilCounter++;\n      var a = e._colorMask;\n      a !== 0 && (e._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, s, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), r.renderable = !0, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = !1, a !== 0 && (e._colorMask = a, n.colorMask((a & 1) !== 0, (a & 2) !== 0, (a & 4) !== 0, (a & 8) !== 0)), this._useCurrent();\n    }, t.prototype.pop = function(e) {\n      var r = this.renderer.gl;\n      if (this.getStackLength() === 0)\n        r.disable(r.STENCIL_TEST);\n      else {\n        var n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, s = n ? n._colorMask : 15;\n        s !== 0 && (n._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, s !== 0 && (n._colorMask = s, r.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();\n      }\n    }, t.prototype._useCurrent = function() {\n      var e = this.renderer.gl;\n      e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP);\n    }, t;\n  }(QE)\n), jb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new ar(), this.transform = null;\n    }\n    return i.prototype.update = function(t, e, r, n) {\n      this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, n), this.transform && this.projectionMatrix.append(this.transform);\n      var s = this.renderer;\n      s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);\n    }, i.prototype.calculateProjection = function(t, e, r, n) {\n      var s = this.projectionMatrix, a = n ? -1 : 1;\n      s.identity(), s.a = 1 / e.width * 2, s.d = a * (1 / e.height * 2), s.tx = -1 - e.x * s.a, s.ty = -a - e.y * s.d;\n    }, i.prototype.setTransform = function(t) {\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), _a = new Nt(), bh = new Nt(), zb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.clearColor = t._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Nt(), this.destinationFrame = new Nt(), this.viewportFrame = new Nt();\n    }\n    return i.prototype.bind = function(t, e, r) {\n      t === void 0 && (t = null);\n      var n = this.renderer;\n      this.current = t;\n      var s, a, o;\n      t ? (s = t.baseTexture, o = s.resolution, e || (_a.width = t.frame.width, _a.height = t.frame.height, e = _a), r || (bh.x = t.frame.x, bh.y = t.frame.y, bh.width = e.width, bh.height = e.height, r = bh), a = s.framebuffer) : (o = n.resolution, e || (_a.width = n.screen.width, _a.height = n.screen.height, e = _a), r || (r = _a, r.width = e.width, r.height = e.height));\n      var u = this.viewportFrame;\n      u.x = r.x * o, u.y = r.y * o, u.width = r.width * o, u.height = r.height * o, t || (u.y = n.view.height - (u.y + u.height)), u.ceil(), this.renderer.framebuffer.bind(a, u), this.renderer.projection.update(r, e, o, !a), t ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(r);\n    }, i.prototype.clear = function(t, e) {\n      this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.clearColor;\n      var r = this.destinationFrame, n = this.current ? this.current.baseTexture : this.renderer.screen, s = r.width !== n.width || r.height !== n.height;\n      if (s) {\n        var a = this.viewportFrame, o = a.x, u = a.y, l = a.width, h = a.height;\n        o = Math.round(o), u = Math.round(u), l = Math.round(l), h = Math.round(h), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(o, u, l, h);\n      }\n      this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e), s && this.renderer.scissor.pop();\n    }, i.prototype.resize = function() {\n      this.bind(null);\n    }, i.prototype.reset = function() {\n      this.bind(null);\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n);\nfunction f2(i, t, e, r, n) {\n  e.buffer.update(n);\n}\nvar d2 = {\n  float: `\n        data[offset] = v;\n    `,\n  vec2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    `,\n  vec3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    `,\n  vec4: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    `,\n  mat2: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    `,\n  mat3: `\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    `,\n  mat4: `\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    `\n}, tS = {\n  float: 4,\n  vec2: 8,\n  vec3: 12,\n  vec4: 16,\n  int: 4,\n  ivec2: 8,\n  ivec3: 12,\n  ivec4: 16,\n  uint: 4,\n  uvec2: 8,\n  uvec3: 12,\n  uvec4: 16,\n  bool: 4,\n  bvec2: 8,\n  bvec3: 12,\n  bvec4: 16,\n  mat2: 16 * 2,\n  mat3: 16 * 3,\n  mat4: 16 * 4\n};\nfunction eS(i) {\n  for (var t = i.map(function(u) {\n    return {\n      data: u,\n      offset: 0,\n      dataLen: 0,\n      dirty: 0\n    };\n  }), e = 0, r = 0, n = 0, s = 0; s < t.length; s++) {\n    var a = t[s];\n    if (e = tS[a.data.type], a.data.size > 1 && (e = Math.max(e, 16) * a.data.size), a.dataLen = e, r % e !== 0 && r < 16) {\n      var o = r % e % 16;\n      r += o, n += o;\n    }\n    r + e > 16 ? (n = Math.ceil(n / 16) * 16, a.offset = n, n += e, r = e) : (a.offset = n, r += e, n += e);\n  }\n  return n = Math.ceil(n / 16) * 16, { uboElements: t, size: n };\n}\nfunction rS(i, t) {\n  var e = [];\n  for (var r in i)\n    t[r] && e.push(t[r]);\n  return e.sort(function(n, s) {\n    return n.index - s.index;\n  }), e;\n}\nfunction iS(i, t) {\n  if (!i.autoManage)\n    return { size: 0, syncFunc: f2 };\n  for (var e = rS(i.uniforms, t), r = eS(e), n = r.uboElements, s = r.size, a = [`\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    `], o = 0; o < n.length; o++) {\n    for (var u = n[o], l = i.uniforms[u.data.name], h = u.data.name, d = !1, f = 0; f < Yo.length; f++) {\n      var p = Yo[f];\n      if (p.codeUbo && p.test(u.data, l)) {\n        a.push(\"offset = \" + u.offset / 4 + \";\", Yo[f].codeUbo(u.data.name, l)), d = !0;\n        break;\n      }\n    }\n    if (!d)\n      if (u.data.size > 1) {\n        var v = qE(u.data.type), g = Math.max(tS[u.data.type] / 16, 1), m = v / g, y = (4 - m % 4) % 4;\n        a.push(`\n                cv = ud.` + h + `.value;\n                v = uv.` + h + `;\n                offset = ` + u.offset / 4 + `;\n\n                t = 0;\n\n                for(var i=0; i < ` + u.data.size * g + `; i++)\n                {\n                    for(var j = 0; j < ` + m + `; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ` + y + `;\n                }\n\n                `);\n      } else {\n        var _ = d2[u.data.type];\n        a.push(`\n                cv = ud.` + h + `.value;\n                v = uv.` + h + `;\n                offset = ` + u.offset / 4 + `;\n                ` + _ + `;\n                `);\n      }\n  }\n  return a.push(`\n       renderer.buffer.update(buffer);\n    `), {\n    size: s,\n    // eslint-disable-next-line no-new-func\n    syncFunc: new Function(\"ud\", \"uv\", \"renderer\", \"syncData\", \"buffer\", a.join(`\n`))\n  };\n}\nvar p2 = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i;\n  }()\n), nS = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this.program = t, this.uniformData = e, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};\n    }\n    return i.prototype.destroy = function() {\n      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;\n    }, i;\n  }()\n);\nfunction v2(i, t) {\n  for (var e = {}, r = t.getProgramParameter(i, t.ACTIVE_ATTRIBUTES), n = 0; n < r; n++) {\n    var s = t.getActiveAttrib(i, n);\n    if (s.name.indexOf(\"gl_\") !== 0) {\n      var a = ZE(t, s.type), o = {\n        type: a,\n        name: s.name,\n        size: qE(a),\n        location: t.getAttribLocation(i, s.name)\n      };\n      e[s.name] = o;\n    }\n  }\n  return e;\n}\nfunction g2(i, t) {\n  for (var e = {}, r = t.getProgramParameter(i, t.ACTIVE_UNIFORMS), n = 0; n < r; n++) {\n    var s = t.getActiveUniform(i, n), a = s.name.replace(/\\[.*?\\]$/, \"\"), o = !!s.name.match(/\\[.*?\\]$/), u = ZE(t, s.type);\n    e[a] = {\n      name: a,\n      index: n,\n      type: u,\n      size: s.size,\n      isArray: o,\n      value: XE(u, s.size)\n    };\n  }\n  return e;\n}\nfunction sS(i, t) {\n  var e = E1(i, i.VERTEX_SHADER, t.vertexSrc), r = E1(i, i.FRAGMENT_SHADER, t.fragmentSrc), n = i.createProgram();\n  if (i.attachShader(n, e), i.attachShader(n, r), i.linkProgram(n), i.getProgramParameter(n, i.LINK_STATUS) || ZD(i, n, e, r), t.attributeData = v2(n, i), t.uniformData = g2(n, i), !/^[ \\t]*#[ \\t]*version[ \\t]+300[ \\t]+es[ \\t]*$/m.test(t.vertexSrc)) {\n    var s = Object.keys(t.attributeData);\n    s.sort(function(h, d) {\n      return h > d ? 1 : -1;\n    });\n    for (var a = 0; a < s.length; a++)\n      t.attributeData[s[a]].location = a, i.bindAttribLocation(n, a, s[a]);\n    i.linkProgram(n);\n  }\n  i.deleteShader(e), i.deleteShader(r);\n  var o = {};\n  for (var a in t.uniformData) {\n    var u = t.uniformData[a];\n    o[a] = {\n      location: i.getUniformLocation(n, a),\n      value: XE(u.type, u.size)\n    };\n  }\n  var l = new nS(n, o);\n  return l;\n}\nvar m2 = 0, Yd = { textureCount: 0, uboCount: 0 }, Hb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = m2++;\n    }\n    return i.prototype.systemCheck = function() {\n      if (!n2())\n        throw new Error(\"Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.\");\n    }, i.prototype.contextChange = function(t) {\n      this.gl = t, this.reset();\n    }, i.prototype.bind = function(t, e) {\n      t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;\n      var r = t.program, n = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);\n      return this.shader = t, this.program !== r && (this.program = r, this.gl.useProgram(n.program)), e || (Yd.textureCount = 0, Yd.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Yd)), n;\n    }, i.prototype.setUniforms = function(t) {\n      var e = this.shader.program, r = e.glPrograms[this.renderer.CONTEXT_UID];\n      e.syncUniforms(r.uniformData, t, this.renderer);\n    }, i.prototype.syncUniformGroup = function(t, e) {\n      var r = this.getGlProgram();\n      (!t.static || t.dirtyId !== r.uniformDirtyGroups[t.id]) && (r.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, r, e));\n    }, i.prototype.syncUniforms = function(t, e, r) {\n      var n = t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t);\n      n(e.uniformData, t.uniforms, this.renderer, r);\n    }, i.prototype.createSyncGroups = function(t) {\n      var e = this.getSignature(t, this.shader.program.uniformData, \"u\");\n      return this.cache[e] || (this.cache[e] = e2(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id];\n    }, i.prototype.syncUniformBufferGroup = function(t, e) {\n      var r = this.getGlProgram();\n      if (!t.static || t.dirtyId !== 0 || !r.uniformGroups[t.id]) {\n        t.dirtyId = 0;\n        var n = r.uniformGroups[t.id] || this.createSyncBufferGroup(t, r, e);\n        t.buffer.update(), n(r.uniformData, t.uniforms, this.renderer, Yd, t.buffer);\n      }\n      this.renderer.buffer.bindBufferBase(t.buffer, r.uniformBufferBindings[e]);\n    }, i.prototype.createSyncBufferGroup = function(t, e, r) {\n      var n = this.renderer.gl;\n      this.renderer.buffer.bind(t.buffer);\n      var s = this.gl.getUniformBlockIndex(e.program, r);\n      e.uniformBufferBindings[r] = this.shader.uniformBindCount, n.uniformBlockBinding(e.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;\n      var a = this.getSignature(t, this.shader.program.uniformData, \"ubo\"), o = this._uboCache[a];\n      if (o || (o = this._uboCache[a] = iS(t, this.shader.program.uniformData)), t.autoManage) {\n        var u = new Float32Array(o.size / 4);\n        t.buffer.update(u);\n      }\n      return e.uniformGroups[t.id] = o.syncFunc, e.uniformGroups[t.id];\n    }, i.prototype.getSignature = function(t, e, r) {\n      var n = t.uniforms, s = [r + \"-\"];\n      for (var a in n)\n        s.push(a), e[a] && s.push(e[a].type);\n      return s.join(\"-\");\n    }, i.prototype.getGlProgram = function() {\n      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;\n    }, i.prototype.generateProgram = function(t) {\n      var e = this.gl, r = t.program, n = sS(e, r);\n      return r.glPrograms[this.renderer.CONTEXT_UID] = n, n;\n    }, i.prototype.reset = function() {\n      this.program = null, this.shader = null;\n    }, i.prototype.disposeShader = function(t) {\n      this.shader === t && (this.shader = null);\n    }, i.prototype.destroy = function() {\n      this.renderer = null, this.destroyed = !0;\n    }, i;\n  }()\n);\nfunction y2(i, t) {\n  return t === void 0 && (t = []), t[Et.NORMAL] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.ADD] = [i.ONE, i.ONE], t[Et.MULTIPLY] = [i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SCREEN] = [i.ONE, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.OVERLAY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.DARKEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.LIGHTEN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR_DODGE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR_BURN] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.HARD_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SOFT_LIGHT] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.DIFFERENCE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.EXCLUSION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.HUE] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SATURATION] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.COLOR] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.LUMINOSITY] = [i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.NONE] = [0, 0], t[Et.NORMAL_NPM] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.ADD_NPM] = [i.SRC_ALPHA, i.ONE, i.ONE, i.ONE], t[Et.SCREEN_NPM] = [i.SRC_ALPHA, i.ONE_MINUS_SRC_COLOR, i.ONE, i.ONE_MINUS_SRC_ALPHA], t[Et.SRC_IN] = [i.DST_ALPHA, i.ZERO], t[Et.SRC_OUT] = [i.ONE_MINUS_DST_ALPHA, i.ZERO], t[Et.SRC_ATOP] = [i.DST_ALPHA, i.ONE_MINUS_SRC_ALPHA], t[Et.DST_OVER] = [i.ONE_MINUS_DST_ALPHA, i.ONE], t[Et.DST_IN] = [i.ZERO, i.SRC_ALPHA], t[Et.DST_OUT] = [i.ZERO, i.ONE_MINUS_SRC_ALPHA], t[Et.DST_ATOP] = [i.ONE_MINUS_DST_ALPHA, i.SRC_ALPHA], t[Et.XOR] = [i.ONE_MINUS_DST_ALPHA, i.ONE_MINUS_SRC_ALPHA], t[Et.SUBTRACT] = [i.ONE, i.ONE, i.ONE, i.ONE, i.FUNC_REVERSE_SUBTRACT, i.FUNC_ADD], t;\n}\nvar _2 = 0, b2 = 1, x2 = 2, w2 = 3, E2 = 4, S2 = 5, $b = (\n  /** @class */\n  function() {\n    function i() {\n      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = Et.NONE, this._blendEq = !1, this.map = [], this.map[_2] = this.setBlend, this.map[b2] = this.setOffset, this.map[x2] = this.setCullFace, this.map[w2] = this.setDepthTest, this.map[E2] = this.setFrontFace, this.map[S2] = this.setDepthMask, this.checks = [], this.defaultState = new ga(), this.defaultState.blend = !0;\n    }\n    return i.prototype.contextChange = function(t) {\n      this.gl = t, this.blendModes = y2(t), this.set(this.defaultState), this.reset();\n    }, i.prototype.set = function(t) {\n      if (t = t || this.defaultState, this.stateId !== t.data) {\n        for (var e = this.stateId ^ t.data, r = 0; e; )\n          e & 1 && this.map[r].call(this, !!(t.data & 1 << r)), e = e >> 1, r++;\n        this.stateId = t.data;\n      }\n      for (var r = 0; r < this.checks.length; r++)\n        this.checks[r](this, t);\n    }, i.prototype.forceState = function(t) {\n      t = t || this.defaultState;\n      for (var e = 0; e < this.map.length; e++)\n        this.map[e].call(this, !!(t.data & 1 << e));\n      for (var e = 0; e < this.checks.length; e++)\n        this.checks[e](this, t);\n      this.stateId = t.data;\n    }, i.prototype.setBlend = function(t) {\n      this.updateCheck(i.checkBlendMode, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.BLEND);\n    }, i.prototype.setOffset = function(t) {\n      this.updateCheck(i.checkPolygonOffset, t), this.gl[t ? \"enable\" : \"disable\"](this.gl.POLYGON_OFFSET_FILL);\n    }, i.prototype.setDepthTest = function(t) {\n      this.gl[t ? \"enable\" : \"disable\"](this.gl.DEPTH_TEST);\n    }, i.prototype.setDepthMask = function(t) {\n      this.gl.depthMask(t);\n    }, i.prototype.setCullFace = function(t) {\n      this.gl[t ? \"enable\" : \"disable\"](this.gl.CULL_FACE);\n    }, i.prototype.setFrontFace = function(t) {\n      this.gl.frontFace(this.gl[t ? \"CW\" : \"CCW\"]);\n    }, i.prototype.setBlendMode = function(t) {\n      if (t !== this.blendMode) {\n        this.blendMode = t;\n        var e = this.blendModes[t], r = this.gl;\n        e.length === 2 ? r.blendFunc(e[0], e[1]) : r.blendFuncSeparate(e[0], e[1], e[2], e[3]), e.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));\n      }\n    }, i.prototype.setPolygonOffset = function(t, e) {\n      this.gl.polygonOffset(t, e);\n    }, i.prototype.reset = function() {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);\n    }, i.prototype.updateCheck = function(t, e) {\n      var r = this.checks.indexOf(t);\n      e && r === -1 ? this.checks.push(t) : !e && r !== -1 && this.checks.splice(r, 1);\n    }, i.checkBlendMode = function(t, e) {\n      t.setBlendMode(e.blendMode);\n    }, i.checkPolygonOffset = function(t, e) {\n      t.setPolygonOffset(1, e.polygonOffset);\n    }, i.prototype.destroy = function() {\n      this.gl = null;\n    }, i;\n  }()\n), Vb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.count = 0, this.checkCount = 0, this.maxIdle = gt.GC_MAX_IDLE, this.checkCountMax = gt.GC_MAX_CHECK_COUNT, this.mode = gt.GC_MODE;\n    }\n    return i.prototype.postrender = function() {\n      this.renderer.renderingToScreen && (this.count++, this.mode !== cv.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));\n    }, i.prototype.run = function() {\n      for (var t = this.renderer.texture, e = t.managedTextures, r = !1, n = 0; n < e.length; n++) {\n        var s = e[n];\n        !s.framebuffer && this.count - s.touched > this.maxIdle && (t.destroyTexture(s, !0), e[n] = null, r = !0);\n      }\n      if (r) {\n        for (var a = 0, n = 0; n < e.length; n++)\n          e[n] !== null && (e[a++] = e[n]);\n        e.length = a;\n      }\n    }, i.prototype.unload = function(t) {\n      var e = this.renderer.texture, r = t._texture;\n      r && !r.framebuffer && e.destroyTexture(r);\n      for (var n = t.children.length - 1; n >= 0; n--)\n        this.unload(t.children[n]);\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n);\nfunction T2(i) {\n  var t, e, r, n, s, a, o, u, l, h, d, f, p, v, g, m, y, _, b, w, T, x, S;\n  return \"WebGL2RenderingContext\" in globalThis && i instanceof globalThis.WebGL2RenderingContext ? S = (t = {}, t[It.UNSIGNED_BYTE] = (e = {}, e[ht.RGBA] = i.RGBA8, e[ht.RGB] = i.RGB8, e[ht.RG] = i.RG8, e[ht.RED] = i.R8, e[ht.RGBA_INTEGER] = i.RGBA8UI, e[ht.RGB_INTEGER] = i.RGB8UI, e[ht.RG_INTEGER] = i.RG8UI, e[ht.RED_INTEGER] = i.R8UI, e[ht.ALPHA] = i.ALPHA, e[ht.LUMINANCE] = i.LUMINANCE, e[ht.LUMINANCE_ALPHA] = i.LUMINANCE_ALPHA, e), t[It.BYTE] = (r = {}, r[ht.RGBA] = i.RGBA8_SNORM, r[ht.RGB] = i.RGB8_SNORM, r[ht.RG] = i.RG8_SNORM, r[ht.RED] = i.R8_SNORM, r[ht.RGBA_INTEGER] = i.RGBA8I, r[ht.RGB_INTEGER] = i.RGB8I, r[ht.RG_INTEGER] = i.RG8I, r[ht.RED_INTEGER] = i.R8I, r), t[It.UNSIGNED_SHORT] = (n = {}, n[ht.RGBA_INTEGER] = i.RGBA16UI, n[ht.RGB_INTEGER] = i.RGB16UI, n[ht.RG_INTEGER] = i.RG16UI, n[ht.RED_INTEGER] = i.R16UI, n[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT16, n), t[It.SHORT] = (s = {}, s[ht.RGBA_INTEGER] = i.RGBA16I, s[ht.RGB_INTEGER] = i.RGB16I, s[ht.RG_INTEGER] = i.RG16I, s[ht.RED_INTEGER] = i.R16I, s), t[It.UNSIGNED_INT] = (a = {}, a[ht.RGBA_INTEGER] = i.RGBA32UI, a[ht.RGB_INTEGER] = i.RGB32UI, a[ht.RG_INTEGER] = i.RG32UI, a[ht.RED_INTEGER] = i.R32UI, a[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT24, a), t[It.INT] = (o = {}, o[ht.RGBA_INTEGER] = i.RGBA32I, o[ht.RGB_INTEGER] = i.RGB32I, o[ht.RG_INTEGER] = i.RG32I, o[ht.RED_INTEGER] = i.R32I, o), t[It.FLOAT] = (u = {}, u[ht.RGBA] = i.RGBA32F, u[ht.RGB] = i.RGB32F, u[ht.RG] = i.RG32F, u[ht.RED] = i.R32F, u[ht.DEPTH_COMPONENT] = i.DEPTH_COMPONENT32F, u), t[It.HALF_FLOAT] = (l = {}, l[ht.RGBA] = i.RGBA16F, l[ht.RGB] = i.RGB16F, l[ht.RG] = i.RG16F, l[ht.RED] = i.R16F, l), t[It.UNSIGNED_SHORT_5_6_5] = (h = {}, h[ht.RGB] = i.RGB565, h), t[It.UNSIGNED_SHORT_4_4_4_4] = (d = {}, d[ht.RGBA] = i.RGBA4, d), t[It.UNSIGNED_SHORT_5_5_5_1] = (f = {}, f[ht.RGBA] = i.RGB5_A1, f), t[It.UNSIGNED_INT_2_10_10_10_REV] = (p = {}, p[ht.RGBA] = i.RGB10_A2, p[ht.RGBA_INTEGER] = i.RGB10_A2UI, p), t[It.UNSIGNED_INT_10F_11F_11F_REV] = (v = {}, v[ht.RGB] = i.R11F_G11F_B10F, v), t[It.UNSIGNED_INT_5_9_9_9_REV] = (g = {}, g[ht.RGB] = i.RGB9_E5, g), t[It.UNSIGNED_INT_24_8] = (m = {}, m[ht.DEPTH_STENCIL] = i.DEPTH24_STENCIL8, m), t[It.FLOAT_32_UNSIGNED_INT_24_8_REV] = (y = {}, y[ht.DEPTH_STENCIL] = i.DEPTH32F_STENCIL8, y), t) : S = (_ = {}, _[It.UNSIGNED_BYTE] = (b = {}, b[ht.RGBA] = i.RGBA, b[ht.RGB] = i.RGB, b[ht.ALPHA] = i.ALPHA, b[ht.LUMINANCE] = i.LUMINANCE, b[ht.LUMINANCE_ALPHA] = i.LUMINANCE_ALPHA, b), _[It.UNSIGNED_SHORT_5_6_5] = (w = {}, w[ht.RGB] = i.RGB, w), _[It.UNSIGNED_SHORT_4_4_4_4] = (T = {}, T[ht.RGBA] = i.RGBA, T), _[It.UNSIGNED_SHORT_5_5_5_1] = (x = {}, x[ht.RGBA] = i.RGBA, x), _), S;\n}\nvar Op = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = It.UNSIGNED_BYTE, this.internalFormat = ht.RGBA, this.samplerType = 0;\n    }\n    return i;\n  }()\n), Xb = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Kt(), this.hasIntegerTextures = !1;\n    }\n    return i.prototype.contextChange = function() {\n      var t = this.gl = this.renderer.gl;\n      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = T2(t);\n      var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);\n      this.boundTextures.length = e;\n      for (var r = 0; r < e; r++)\n        this.boundTextures[r] = null;\n      this.emptyTextures = {};\n      var n = new Op(t.createTexture());\n      t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new Op(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);\n      for (var r = 0; r < 6; r++)\n        t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);\n      t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);\n      for (var r = 0; r < this.boundTextures.length; r++)\n        this.bind(null, r);\n    }, i.prototype.bind = function(t, e) {\n      e === void 0 && (e = 0);\n      var r = this.gl;\n      if (t = t == null ? void 0 : t.castToBaseTexture(), t && t.valid && !t.parentTextureArray) {\n        t.touched = this.renderer.textureGC.count;\n        var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);\n        this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId ? (this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[e] = t;\n      } else\n        this.currentLocation !== e && (this.currentLocation = e, r.activeTexture(r.TEXTURE0 + e)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[e] = null;\n    }, i.prototype.reset = function() {\n      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;\n      for (var t = 0; t < this.boundTextures.length; t++)\n        this.boundTextures[t] = this.unknownTexture;\n    }, i.prototype.unbind = function(t) {\n      var e = this, r = e.gl, n = e.boundTextures;\n      if (this._unknownBoundTextures) {\n        this._unknownBoundTextures = !1;\n        for (var s = 0; s < n.length; s++)\n          n[s] === this.unknownTexture && this.bind(null, s);\n      }\n      for (var s = 0; s < n.length; s++)\n        n[s] === t && (this.currentLocation !== s && (r.activeTexture(r.TEXTURE0 + s), this.currentLocation = s), r.bindTexture(t.target, this.emptyTextures[t.target].texture), n[s] = null);\n    }, i.prototype.ensureSamplerType = function(t) {\n      var e = this, r = e.boundTextures, n = e.hasIntegerTextures, s = e.CONTEXT_UID;\n      if (n)\n        for (var a = t - 1; a >= 0; --a) {\n          var o = r[a];\n          if (o) {\n            var u = o._glTextures[s];\n            u.samplerType !== hv.FLOAT && this.renderer.texture.unbind(o);\n          }\n        }\n    }, i.prototype.initTexture = function(t) {\n      var e = new Op(this.gl.createTexture());\n      return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on(\"dispose\", this.destroyTexture, this), e;\n    }, i.prototype.initTextureType = function(t, e) {\n      var r, n;\n      e.internalFormat = (n = (r = this.internalFormats[t.type]) === null || r === void 0 ? void 0 : r[t.format]) !== null && n !== void 0 ? n : t.format, this.webGLVersion === 2 && t.type === It.HALF_FLOAT ? e.type = this.gl.HALF_FLOAT : e.type = t.type;\n    }, i.prototype.updateTexture = function(t) {\n      var e = t._glTextures[this.CONTEXT_UID];\n      if (e) {\n        var r = this.renderer;\n        if (this.initTextureType(t, e), t.resource && t.resource.upload(r, t, e))\n          e.samplerType !== hv.FLOAT && (this.hasIntegerTextures = !0);\n        else {\n          var n = t.realWidth, s = t.realHeight, a = r.gl;\n          (e.width !== n || e.height !== s || e.dirtyId < 0) && (e.width = n, e.height = s, a.texImage2D(t.target, 0, e.internalFormat, n, s, 0, t.format, e.type, null));\n        }\n        t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId;\n      }\n    }, i.prototype.destroyTexture = function(t, e) {\n      var r = this.gl;\n      if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), r.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off(\"dispose\", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {\n        var n = this.managedTextures.indexOf(t);\n        n !== -1 && Bu(this.managedTextures, n, 1);\n      }\n    }, i.prototype.updateTextureStyle = function(t) {\n      var e = t._glTextures[this.CONTEXT_UID];\n      e && ((t.mipmap === tn.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? e.mipmap = !1 : e.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? e.wrapMode = On.CLAMP : e.wrapMode = t.wrapMode, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId);\n    }, i.prototype.setStyle = function(t, e) {\n      var r = this.gl;\n      if (e.mipmap && t.mipmap !== tn.ON_MANUAL && r.generateMipmap(t.target), r.texParameteri(t.target, r.TEXTURE_WRAP_S, e.wrapMode), r.texParameteri(t.target, r.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {\n        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);\n        var n = this.renderer.context.extensions.anisotropicFiltering;\n        if (n && t.anisotropicLevel > 0 && t.scaleMode === Cn.LINEAR) {\n          var s = Math.min(t.anisotropicLevel, r.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));\n          r.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, s);\n        }\n      } else\n        r.texParameteri(t.target, r.TEXTURE_MIN_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR : r.NEAREST);\n      r.texParameteri(t.target, r.TEXTURE_MAG_FILTER, t.scaleMode === Cn.LINEAR ? r.LINEAR : r.NEAREST);\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), aS = {\n  __proto__: null,\n  FilterSystem: kb,\n  BatchSystem: Nb,\n  ContextSystem: Ab,\n  FramebufferSystem: Lb,\n  GeometrySystem: Bb,\n  MaskSystem: Fb,\n  ScissorSystem: Gb,\n  StencilSystem: Ub,\n  ProjectionSystem: jb,\n  RenderTextureSystem: zb,\n  ShaderSystem: Hb,\n  StateSystem: $b,\n  TextureGCSystem: Vb,\n  TextureSystem: Xb\n}, j0 = new ar(), oS = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e, r) {\n      e === void 0 && (e = nc.UNKNOWN);\n      var n = i.call(this) || this;\n      return r = Object.assign({}, gt.RENDER_OPTIONS, r), n.options = r, n.type = e, n.screen = new Nt(0, 0, r.width, r.height), n.view = r.view || gt.ADAPTER.createCanvas(), n.resolution = r.resolution || gt.RESOLUTION, n.useContextAlpha = r.useContextAlpha, n.autoDensity = !!r.autoDensity, n.preserveDrawingBuffer = r.preserveDrawingBuffer, n.clearBeforeRender = r.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 1], n._backgroundColorString = \"#000000\", n.backgroundColor = r.backgroundColor || n._backgroundColor, n.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (jr(\"6.0.0\", \"Option transparent is deprecated, please use backgroundAlpha instead.\"), n.useContextAlpha = r.transparent, n.backgroundAlpha = r.transparent ? 0 : 1), n._lastObjectRendered = null, n.plugins = {}, n;\n    }\n    return t.prototype.initPlugins = function(e) {\n      for (var r in e)\n        this.plugins[r] = new e[r](this);\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /**\n       * Same as view.width, actual number of pixels in the canvas by horizontal.\n       * @member {number}\n       * @readonly\n       * @default 800\n       */\n      get: function() {\n        return this.view.width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /**\n       * Same as view.height, actual number of pixels in the canvas by vertical.\n       * @member {number}\n       * @readonly\n       * @default 600\n       */\n      get: function() {\n        return this.view.height;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.resize = function(e, r) {\n      this.view.width = Math.round(e * this.resolution), this.view.height = Math.round(r * this.resolution);\n      var n = this.view.width / this.resolution, s = this.view.height / this.resolution;\n      this.screen.width = n, this.screen.height = s, this.autoDensity && (this.view.style.width = n + \"px\", this.view.style.height = s + \"px\"), this.emit(\"resize\", n, s);\n    }, t.prototype.generateTexture = function(e, r, n, s) {\n      r === void 0 && (r = {}), typeof r == \"number\" && (jr(\"6.1.0\", \"generateTexture options (scaleMode, resolution, region) are now object options.\"), r = { scaleMode: r, resolution: n, region: s });\n      var a = r.region, o = UD(r, [\"region\"]);\n      s = a || e.getLocalBounds(null, !0), s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);\n      var u = Si.create(wy({ width: s.width, height: s.height }, o));\n      return j0.tx = -s.x, j0.ty = -s.y, this.render(e, {\n        renderTexture: u,\n        clear: !1,\n        transform: j0,\n        skipUpdateTransform: !!e.parent\n      }), u;\n    }, t.prototype.destroy = function(e) {\n      for (var r in this.plugins)\n        this.plugins[r].destroy(), this.plugins[r] = null;\n      e && this.view.parentNode && this.view.parentNode.removeChild(this.view);\n      var n = this;\n      n.plugins = null, n.type = nc.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;\n    }, Object.defineProperty(t.prototype, \"backgroundColor\", {\n      /**\n       * The background color to fill if not transparent\n       * @member {number}\n       */\n      get: function() {\n        return this._backgroundColor;\n      },\n      set: function(e) {\n        this._backgroundColor = e, this._backgroundColorString = IE(e), Jl(e, this._backgroundColorRgba);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"backgroundAlpha\", {\n      /**\n       * The background color alpha. Setting this to 0 will make the canvas transparent.\n       * @member {number}\n       */\n      get: function() {\n        return this._backgroundColorRgba[3];\n      },\n      set: function(e) {\n        this._backgroundColorRgba[3] = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }($r)\n), C2 = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;\n    }\n    return i;\n  }()\n), M2 = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {};\n    }\n    return i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i.prototype.contextChange = function() {\n      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n    }, i.prototype.bind = function(t) {\n      var e = this, r = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n] || this.createGLBuffer(t);\n      r.bindBuffer(t.type, s.buffer);\n    }, i.prototype.bindBufferBase = function(t, e) {\n      var r = this, n = r.gl, s = r.CONTEXT_UID;\n      if (this.boundBufferBases[e] !== t) {\n        var a = t._glBuffers[s] || this.createGLBuffer(t);\n        this.boundBufferBases[e] = t, n.bindBufferBase(n.UNIFORM_BUFFER, e, a.buffer);\n      }\n    }, i.prototype.bindBufferRange = function(t, e, r) {\n      var n = this, s = n.gl, a = n.CONTEXT_UID;\n      r = r || 0;\n      var o = t._glBuffers[a] || this.createGLBuffer(t);\n      s.bindBufferRange(s.UNIFORM_BUFFER, e || 0, o.buffer, r * 256, 256);\n    }, i.prototype.update = function(t) {\n      var e = this, r = e.gl, n = e.CONTEXT_UID, s = t._glBuffers[n];\n      if (t._updateID !== s.updateID)\n        if (s.updateID = t._updateID, r.bindBuffer(t.type, s.buffer), s.byteLength >= t.data.byteLength)\n          r.bufferSubData(t.type, 0, t.data);\n        else {\n          var a = t.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;\n          s.byteLength = t.data.byteLength, r.bufferData(t.type, t.data, a);\n        }\n    }, i.prototype.dispose = function(t, e) {\n      if (this.managedBuffers[t.id]) {\n        delete this.managedBuffers[t.id];\n        var r = t._glBuffers[this.CONTEXT_UID], n = this.gl;\n        t.disposeRunner.remove(this), r && (e || n.deleteBuffer(r.buffer), delete t._glBuffers[this.CONTEXT_UID]);\n      }\n    }, i.prototype.disposeAll = function(t) {\n      for (var e = Object.keys(this.managedBuffers), r = 0; r < e.length; r++)\n        this.dispose(this.managedBuffers[e[r]], t);\n    }, i.prototype.createGLBuffer = function(t) {\n      var e = this, r = e.CONTEXT_UID, n = e.gl;\n      return t._glBuffers[r] = new C2(n.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[r];\n    }, i;\n  }()\n), Wb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      var r = i.call(this, nc.WEBGL, e) || this;\n      return e = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {\n        destroy: new pr(\"destroy\"),\n        contextChange: new pr(\"contextChange\"),\n        reset: new pr(\"reset\"),\n        update: new pr(\"update\"),\n        postrender: new pr(\"postrender\"),\n        prerender: new pr(\"prerender\"),\n        resize: new pr(\"resize\")\n      }, r.runners.contextChange.add(r), r.globalUniforms = new ha({\n        projectionMatrix: new ar()\n      }, !0), r.addSystem(Fb, \"mask\").addSystem(Ab, \"context\").addSystem($b, \"state\").addSystem(Hb, \"shader\").addSystem(Xb, \"texture\").addSystem(M2, \"buffer\").addSystem(Bb, \"geometry\").addSystem(Lb, \"framebuffer\").addSystem(Gb, \"scissor\").addSystem(Ub, \"stencil\").addSystem(jb, \"projection\").addSystem(Vb, \"textureGC\").addSystem(kb, \"filter\").addSystem(zb, \"renderTexture\").addSystem(Nb, \"batch\"), r.initPlugins(t.__plugins), r.multisample = void 0, e.context ? r.context.initFromContext(e.context) : r.context.initFromOptions({\n        alpha: !!r.useContextAlpha,\n        antialias: e.antialias,\n        premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== \"notMultiplied\",\n        stencil: !0,\n        preserveDrawingBuffer: e.preserveDrawingBuffer,\n        powerPreference: r.options.powerPreference\n      }), r.renderingToScreen = !0, BO(r.context.webGLVersion === 2 ? \"WebGL 2\" : \"WebGL 1\"), r.resize(r.options.width, r.options.height), r;\n    }\n    return t.create = function(e) {\n      if (FO())\n        return new t(e);\n      throw new Error('WebGL unsupported in this browser, use \"pixi.js-legacy\" for fallback canvas2d support.');\n    }, t.prototype.contextChange = function() {\n      var e = this.gl, r;\n      if (this.context.webGLVersion === 1) {\n        var n = e.getParameter(e.FRAMEBUFFER_BINDING);\n        e.bindFramebuffer(e.FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, n);\n      } else {\n        var n = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);\n        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), r = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, n);\n      }\n      r >= ke.HIGH ? this.multisample = ke.HIGH : r >= ke.MEDIUM ? this.multisample = ke.MEDIUM : r >= ke.LOW ? this.multisample = ke.LOW : this.multisample = ke.NONE;\n    }, t.prototype.addSystem = function(e, r) {\n      var n = new e(this);\n      if (this[r])\n        throw new Error('Whoops! The name \"' + r + '\" is already in use');\n      this[r] = n;\n      for (var s in this.runners)\n        this.runners[s].add(n);\n      return this;\n    }, t.prototype.render = function(e, r) {\n      var n, s, a, o;\n      if (r && (r instanceof Si ? (jr(\"6.0.0\", \"Renderer#render arguments changed, use options instead.\"), n = r, s = arguments[2], a = arguments[3], o = arguments[4]) : (n = r.renderTexture, s = r.clear, a = r.transform, o = r.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit(\"prerender\"), this.projection.transform = a, !this.context.isLost) {\n        if (n || (this._lastObjectRendered = e), !o) {\n          var u = e.enableTempParent();\n          e.updateTransform(), e.disableTempParent(u);\n        }\n        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (s !== void 0 ? s : this.clearBeforeRender) && this.renderTexture.clear(), e.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit(\"postrender\");\n      }\n    }, t.prototype.generateTexture = function(e, r, n, s) {\n      r === void 0 && (r = {});\n      var a = i.prototype.generateTexture.call(this, e, r, n, s);\n      return this.framebuffer.blit(), a;\n    }, t.prototype.resize = function(e, r) {\n      i.prototype.resize.call(this, e, r), this.runners.resize.emit(this.screen.height, this.screen.width);\n    }, t.prototype.reset = function() {\n      return this.runners.reset.emit(), this;\n    }, t.prototype.clear = function() {\n      this.renderTexture.bind(), this.renderTexture.clear();\n    }, t.prototype.destroy = function(e) {\n      this.runners.destroy.emit();\n      for (var r in this.runners)\n        this.runners[r].destroy();\n      i.prototype.destroy.call(this, e), this.gl = null;\n    }, Object.defineProperty(t.prototype, \"extract\", {\n      /**\n       * Please use `plugins.extract` instead.\n       * @member {PIXI.Extract} extract\n       * @deprecated since 6.0.0\n       * @readonly\n       */\n      get: function() {\n        return jr(\"6.0.0\", \"Renderer#extract has been deprecated, please use Renderer#plugins.extract instead.\"), this.plugins.extract;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.registerPlugin = function(e, r) {\n      jr(\"6.5.0\", \"Renderer.registerPlugin() has been deprecated, please use extensions.add() instead.\"), an.add({\n        name: e,\n        type: fe.RendererPlugin,\n        ref: r\n      });\n    }, t.__plugins = {}, t;\n  }(oS)\n);\nan.handleByMap(fe.RendererPlugin, Wb.__plugins);\nfunction Yb(i) {\n  return Wb.create(i);\n}\nvar P2 = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}`, O2 = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n`, uS = P2, qb = O2, I2 = (\n  /** @class */\n  function() {\n    function i(t) {\n      jr(\"6.1.0\", \"System class is deprecated, implemement ISystem interface instead.\"), this.renderer = t;\n    }\n    return i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i;\n  }()\n), mv = (\n  /** @class */\n  function() {\n    function i() {\n      this.texArray = null, this.blend = 0, this.type = qi.TRIANGLES, this.start = 0, this.size = 0, this.data = null;\n    }\n    return i;\n  }()\n), yv = (\n  /** @class */\n  function() {\n    function i() {\n      this.elements = [], this.ids = [], this.count = 0;\n    }\n    return i.prototype.clear = function() {\n      for (var t = 0; t < this.count; t++)\n        this.elements[t] = null;\n      this.count = 0;\n    }, i;\n  }()\n), _v = (\n  /** @class */\n  function() {\n    function i(t) {\n      typeof t == \"number\" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);\n    }\n    return Object.defineProperty(i.prototype, \"int8View\", {\n      /** View on the raw binary data as a `Int8Array`. */\n      get: function() {\n        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"uint8View\", {\n      /** View on the raw binary data as a `Uint8Array`. */\n      get: function() {\n        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"int16View\", {\n      /**  View on the raw binary data as a `Int16Array`. */\n      get: function() {\n        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"uint16View\", {\n      /** View on the raw binary data as a `Uint16Array`. */\n      get: function() {\n        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"int32View\", {\n      /** View on the raw binary data as a `Int32Array`. */\n      get: function() {\n        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.view = function(t) {\n      return this[t + \"View\"];\n    }, i.prototype.destroy = function() {\n      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;\n    }, i.sizeOf = function(t) {\n      switch (t) {\n        case \"int8\":\n        case \"uint8\":\n          return 1;\n        case \"int16\":\n        case \"uint16\":\n          return 2;\n        case \"int32\":\n        case \"uint32\":\n        case \"float32\":\n          return 4;\n        default:\n          throw new Error(t + \" isn't a valid view type\");\n      }\n    }, i;\n  }()\n), lS = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = ga.for2d(), r.size = gt.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on(\"prerender\", r.onPrerender, r), e.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;\n    }\n    return t.prototype.contextChange = function() {\n      var e = this.renderer.gl;\n      gt.PREFER_ENV === Ts.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), gt.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = KE(this.MAX_TEXTURES, e)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);\n      for (var r = 0; r < this._packedGeometryPoolSize; r++)\n        this._packedGeometries[r] = new this.geometryClass();\n      this.initFlushBuffers();\n    }, t.prototype.initFlushBuffers = function() {\n      for (var e = t._drawCallPool, r = t._textureArrayPool, n = this.size / 4, s = Math.floor(n / this.MAX_TEXTURES) + 1; e.length < n; )\n        e.push(new mv());\n      for (; r.length < s; )\n        r.push(new yv());\n      for (var a = 0; a < this.MAX_TEXTURES; a++)\n        this._tempBoundTextures[a] = null;\n    }, t.prototype.onPrerender = function() {\n      this._flushId = 0;\n    }, t.prototype.render = function(e) {\n      e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e);\n    }, t.prototype.buildTexturesAndDrawCalls = function() {\n      var e = this, r = e._bufferedTextures, n = e.MAX_TEXTURES, s = t._textureArrayPool, a = this.renderer.batch, o = this._tempBoundTextures, u = this.renderer.textureGC.count, l = ++Kt._globalBatch, h = 0, d = s[0], f = 0;\n      a.copyBoundTextures(o, n);\n      for (var p = 0; p < this._bufferSize; ++p) {\n        var v = r[p];\n        r[p] = null, v._batchEnabled !== l && (d.count >= n && (a.boundArray(d, o, l, n), this.buildDrawCalls(d, f, p), f = p, d = s[++h], ++l), v._batchEnabled = l, v.touched = u, d.elements[d.count++] = v);\n      }\n      d.count > 0 && (a.boundArray(d, o, l, n), this.buildDrawCalls(d, f, this._bufferSize), ++h, ++l);\n      for (var p = 0; p < o.length; p++)\n        o[p] = null;\n      Kt._globalBatch = l;\n    }, t.prototype.buildDrawCalls = function(e, r, n) {\n      var s = this, a = s._bufferedElements, o = s._attributeBuffer, u = s._indexBuffer, l = s.vertexSize, h = t._drawCallPool, d = this._dcIndex, f = this._aIndex, p = this._iIndex, v = h[d];\n      v.start = this._iIndex, v.texArray = e;\n      for (var g = r; g < n; ++g) {\n        var m = a[g], y = m._texture.baseTexture, _ = DE[y.alphaMode ? 1 : 0][m.blendMode];\n        a[g] = null, r < g && v.blend !== _ && (v.size = p - v.start, r = g, v = h[++d], v.texArray = e, v.start = p), this.packInterleavedGeometry(m, o, u, f, p), f += m.vertexData.length / 2 * l, p += m.indices.length, v.blend = _;\n      }\n      r < n && (v.size = p - v.start, ++d), this._dcIndex = d, this._aIndex = f, this._iIndex = p;\n    }, t.prototype.bindAndClearTexArray = function(e) {\n      for (var r = this.renderer.texture, n = 0; n < e.count; n++)\n        r.bind(e.elements[n], e.ids[n]), e.elements[n] = null;\n      e.count = 0;\n    }, t.prototype.updateGeometry = function() {\n      var e = this, r = e._packedGeometries, n = e._attributeBuffer, s = e._indexBuffer;\n      gt.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(n.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(n.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);\n    }, t.prototype.drawBatches = function() {\n      for (var e = this._dcIndex, r = this.renderer, n = r.gl, s = r.state, a = t._drawCallPool, o = null, u = 0; u < e; u++) {\n        var l = a[u], h = l.texArray, d = l.type, f = l.size, p = l.start, v = l.blend;\n        o !== h && (o = h, this.bindAndClearTexArray(h)), this.state.blendMode = v, s.set(this.state), n.drawElements(d, f, n.UNSIGNED_SHORT, p * 2);\n      }\n    }, t.prototype.flush = function() {\n      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);\n    }, t.prototype.start = function() {\n      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), gt.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);\n    }, t.prototype.stop = function() {\n      this.flush();\n    }, t.prototype.destroy = function() {\n      for (var e = 0; e < this._packedGeometryPoolSize; e++)\n        this._packedGeometries[e] && this._packedGeometries[e].destroy();\n      this.renderer.off(\"prerender\", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), i.prototype.destroy.call(this);\n    }, t.prototype.getAttributeBuffer = function(e) {\n      var r = fv(Math.ceil(e / 8)), n = v1(r), s = r * 8;\n      this._aBuffers.length <= n && (this._iBuffers.length = n + 1);\n      var a = this._aBuffers[s];\n      return a || (this._aBuffers[s] = a = new _v(s * this.vertexSize * 4)), a;\n    }, t.prototype.getIndexBuffer = function(e) {\n      var r = fv(Math.ceil(e / 12)), n = v1(r), s = r * 12;\n      this._iBuffers.length <= n && (this._iBuffers.length = n + 1);\n      var a = this._iBuffers[n];\n      return a || (this._iBuffers[n] = a = new Uint16Array(s)), a;\n    }, t.prototype.packInterleavedGeometry = function(e, r, n, s, a) {\n      for (var o = r.uint32View, u = r.float32View, l = s / this.vertexSize, h = e.uvs, d = e.indices, f = e.vertexData, p = e._texture.baseTexture._batchLocation, v = Math.min(e.worldAlpha, 1), g = v < 1 && e._texture.baseTexture.alphaMode ? wb(e._tintRGB, v) : e._tintRGB + (v * 255 << 24), m = 0; m < f.length; m += 2)\n        u[s++] = f[m], u[s++] = f[m + 1], u[s++] = h[m], u[s++] = h[m + 1], o[s++] = g, u[s++] = p;\n      for (var m = 0; m < d.length; m++)\n        n[a++] = l + d[m];\n    }, t._drawCallPool = [], t._textureArrayPool = [], t;\n  }(wd)\n), hS = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf(\"%count%\") < 0)\n        throw new Error('Fragment template must contain \"%count%\".');\n      if (e.indexOf(\"%forloop%\") < 0)\n        throw new Error('Fragment template must contain \"%forloop%\".');\n    }\n    return i.prototype.generateShader = function(t) {\n      if (!this.programCache[t]) {\n        for (var e = new Int32Array(t), r = 0; r < t; r++)\n          e[r] = r;\n        this.defaultGroupCache[t] = ha.from({ uSamplers: e }, !0);\n        var n = this.fragTemplate;\n        n = n.replace(/%count%/gi, \"\" + t), n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new hh(this.vertexSrc, n);\n      }\n      var s = {\n        tint: new Float32Array([1, 1, 1, 1]),\n        translationMatrix: new ar(),\n        default: this.defaultGroupCache[t]\n      };\n      return new xs(this.programCache[t], s);\n    }, i.prototype.generateSampleSrc = function(t) {\n      var e = \"\";\n      e += `\n`, e += `\n`;\n      for (var r = 0; r < t; r++)\n        r > 0 && (e += `\nelse `), r < t - 1 && (e += \"if(vTextureId < \" + r + \".5)\"), e += `\n{`, e += `\n\tcolor = texture2D(uSamplers[` + r + \"], vTextureCoord);\", e += `\n}`;\n      return e += `\n`, e += `\n`, e;\n    }, i;\n  }()\n), Zb = (\n  /** @class */\n  function(i) {\n    Ce(t, i);\n    function t(e) {\n      e === void 0 && (e = !1);\n      var r = i.call(this) || this;\n      return r._buffer = new Ke(null, e, !1), r._indexBuffer = new Ke(null, e, !0), r.addAttribute(\"aVertexPosition\", r._buffer, 2, !1, It.FLOAT).addAttribute(\"aTextureCoord\", r._buffer, 2, !1, It.FLOAT).addAttribute(\"aColor\", r._buffer, 4, !0, It.UNSIGNED_BYTE).addAttribute(\"aTextureId\", r._buffer, 1, !0, It.FLOAT).addIndex(r._indexBuffer), r;\n    }\n    return t;\n  }(lh)\n), I1 = `precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n`, R1 = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n`, cS = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.create = function(t) {\n      var e = Object.assign({\n        vertex: I1,\n        fragment: R1,\n        geometryClass: Zb,\n        vertexSize: 6\n      }, t), r = e.vertex, n = e.fragment, s = e.vertexSize, a = e.geometryClass;\n      return (\n        /** @class */\n        function(o) {\n          Ce(u, o);\n          function u(l) {\n            var h = o.call(this, l) || this;\n            return h.shaderGenerator = new hS(r, n), h.geometryClass = a, h.vertexSize = s, h;\n          }\n          return u;\n        }(lS)\n      );\n    }, Object.defineProperty(i, \"defaultVertexSrc\", {\n      /**\n       * The default vertex shader source\n       * @readonly\n       */\n      get: function() {\n        return I1;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"defaultFragmentTemplate\", {\n      /**\n       * The default fragment shader source\n       * @readonly\n       */\n      get: function() {\n        return R1;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n), Kb = cS.create();\nObject.assign(Kb, {\n  extension: {\n    name: \"batch\",\n    type: fe.RendererPlugin\n  }\n});\nvar fS = {}, R2 = function(i) {\n  Object.defineProperty(fS, i, {\n    get: function() {\n      return jr(\"6.0.0\", \"PIXI.systems.\" + i + \" has moved to PIXI.\" + i), UE[i];\n    }\n  });\n};\nfor (var Jb in UE)\n  R2(Jb);\nvar dS = {}, D2 = function(i) {\n  Object.defineProperty(dS, i, {\n    get: function() {\n      return jr(\"6.0.0\", \"PIXI.resources.\" + i + \" has moved to PIXI.\" + i), aS[i];\n    }\n  });\n};\nfor (var Jb in aS)\n  D2(Jb);\nvar k2 = \"6.5.9\";\nconst N2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AbstractBatchRenderer: lS,\n  AbstractMultiResource: r0,\n  AbstractRenderer: oS,\n  ArrayResource: Sb,\n  Attribute: Ey,\n  BaseImageResource: Dn,\n  BaseRenderTexture: Ib,\n  BaseTexture: Kt,\n  BatchDrawCall: mv,\n  BatchGeometry: Zb,\n  BatchPluginFactory: cS,\n  BatchRenderer: Kb,\n  BatchShaderGenerator: hS,\n  BatchSystem: Nb,\n  BatchTextureArray: yv,\n  Buffer: Ke,\n  BufferResource: au,\n  CanvasResource: Tb,\n  ContextSystem: Ab,\n  CubeResource: Cb,\n  get ExtensionType() {\n    return fe;\n  },\n  Filter: rn,\n  FilterState: HE,\n  FilterSystem: kb,\n  Framebuffer: gv,\n  FramebufferSystem: Lb,\n  GLFramebuffer: $E,\n  GLProgram: nS,\n  GLTexture: Op,\n  Geometry: lh,\n  GeometrySystem: Bb,\n  IGLUniformData: p2,\n  INSTALLED: lc,\n  ImageBitmapResource: Ob,\n  ImageResource: i0,\n  MaskData: VE,\n  MaskSystem: Fb,\n  ObjectRenderer: wd,\n  Program: hh,\n  ProjectionSystem: jb,\n  Quad: zE,\n  QuadUv: Db,\n  RenderTexture: Si,\n  RenderTexturePool: jE,\n  RenderTextureSystem: zb,\n  Renderer: Wb,\n  Resource: Jo,\n  SVGResource: Mb,\n  ScissorSystem: Gb,\n  Shader: xs,\n  ShaderSystem: Hb,\n  SpriteMaskFilter: JE,\n  State: ga,\n  StateSystem: $b,\n  StencilSystem: Ub,\n  System: I2,\n  Texture: Ot,\n  TextureGCSystem: Vb,\n  TextureMatrix: n0,\n  TextureSystem: Xb,\n  TextureUvs: Rb,\n  UniformGroup: ha,\n  VERSION: k2,\n  VideoResource: Pb,\n  ViewableBuffer: _v,\n  autoDetectRenderer: Yb,\n  autoDetectResource: e0,\n  checkMaxIfStatementsInShader: KE,\n  createUBOElements: eS,\n  defaultFilterVertex: qb,\n  defaultVertex: uS,\n  extensions: an,\n  generateProgram: sS,\n  generateUniformBufferSync: iS,\n  getTestContext: YE,\n  getUBOData: rS,\n  resources: fS,\n  systems: dS,\n  uniformParsers: Yo\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*!\n * @pixi/accessibility - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/accessibility is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar A2 = {\n  /**\n   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a\n   *   shadow div with attributes set\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessible: !1,\n  /**\n   * Sets the title attribute of the shadow div\n   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'\n   * @member {?string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleTitle: null,\n  /**\n   * Sets the aria-label attribute of the shadow div\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  accessibleHint: null,\n  /**\n   * @member {number}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   * @todo Needs docs.\n   */\n  tabIndex: 0,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleActive: !1,\n  /**\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @todo Needs docs.\n   */\n  _accessibleDiv: null,\n  /**\n   * Specify the type of div the accessible layer is. Screen readers treat the element differently\n   * depending on this type. Defaults to button.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default 'button'\n   */\n  accessibleType: \"button\",\n  /**\n   * Specify the pointer-events the accessible div will use\n   * Defaults to auto.\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   * @default 'auto'\n   */\n  accessiblePointerEvents: \"auto\",\n  /**\n   * Setting to false will prevent any children inside this container to\n   * be accessible. Defaults to true.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @default true\n   */\n  accessibleChildren: !0,\n  renderId: -1\n};\nHe.mixin(A2);\nvar L2 = 9, qd = 100, B2 = 0, F2 = 0, D1 = 2, k1 = 1, G2 = -1e3, U2 = -1e3, j2 = 2, z2 = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Mn.tablet || Mn.phone) && this.createTouchHook();\n      var e = document.createElement(\"div\");\n      e.style.width = qd + \"px\", e.style.height = qd + \"px\", e.style.position = \"absolute\", e.style.top = B2 + \"px\", e.style.left = F2 + \"px\", e.style.zIndex = D1.toString(), this.div = e, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1);\n    }\n    return Object.defineProperty(i.prototype, \"isActive\", {\n      /**\n       * Value of `true` if accessibility is currently active and accessibility layers are showing.\n       * @member {boolean}\n       * @readonly\n       */\n      get: function() {\n        return this._isActive;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"isMobileAccessibility\", {\n      /**\n       * Value of `true` if accessibility is enabled for touch devices.\n       * @member {boolean}\n       * @readonly\n       */\n      get: function() {\n        return this._isMobileAccessibility;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.createTouchHook = function() {\n      var t = this, e = document.createElement(\"button\");\n      e.style.width = k1 + \"px\", e.style.height = k1 + \"px\", e.style.position = \"absolute\", e.style.top = G2 + \"px\", e.style.left = U2 + \"px\", e.style.zIndex = j2.toString(), e.style.backgroundColor = \"#FF0000\", e.title = \"select to enable accessibility for this content\", e.addEventListener(\"focus\", function() {\n        t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook();\n      }), document.body.appendChild(e), this._hookDiv = e;\n    }, i.prototype.destroyTouchHook = function() {\n      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);\n    }, i.prototype.activate = function() {\n      var t;\n      this._isActive || (this._isActive = !0, globalThis.document.addEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.on(\"postrender\", this.update, this), (t = this.renderer.view.parentNode) === null || t === void 0 || t.appendChild(this.div));\n    }, i.prototype.deactivate = function() {\n      var t;\n      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.addEventListener(\"keydown\", this._onKeyDown, !1), this.renderer.off(\"postrender\", this.update), (t = this.div.parentNode) === null || t === void 0 || t.removeChild(this.div));\n    }, i.prototype.updateAccessibleObjects = function(t) {\n      if (!(!t.visible || !t.accessibleChildren)) {\n        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);\n        var e = t.children;\n        if (e)\n          for (var r = 0; r < e.length; r++)\n            this.updateAccessibleObjects(e[r]);\n      }\n    }, i.prototype.update = function() {\n      var t = performance.now();\n      if (!(Mn.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {\n        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);\n        var e = this.renderer.view.getBoundingClientRect(), r = e.left, n = e.top, s = e.width, a = e.height, o = this.renderer, u = o.width, l = o.height, h = o.resolution, d = s / u * h, f = a / l * h, p = this.div;\n        p.style.left = r + \"px\", p.style.top = n + \"px\", p.style.width = u + \"px\", p.style.height = l + \"px\";\n        for (var v = 0; v < this.children.length; v++) {\n          var g = this.children[v];\n          if (g.renderId !== this.renderId)\n            g._accessibleActive = !1, Bu(this.children, v, 1), this.div.removeChild(g._accessibleDiv), this.pool.push(g._accessibleDiv), g._accessibleDiv = null, v--;\n          else {\n            p = g._accessibleDiv;\n            var m = g.hitArea, y = g.worldTransform;\n            g.hitArea ? (p.style.left = (y.tx + m.x * y.a) * d + \"px\", p.style.top = (y.ty + m.y * y.d) * f + \"px\", p.style.width = m.width * y.a * d + \"px\", p.style.height = m.height * y.d * f + \"px\") : (m = g.getBounds(), this.capHitArea(m), p.style.left = m.x * d + \"px\", p.style.top = m.y * f + \"px\", p.style.width = m.width * d + \"px\", p.style.height = m.height * f + \"px\", p.title !== g.accessibleTitle && g.accessibleTitle !== null && (p.title = g.accessibleTitle), p.getAttribute(\"aria-label\") !== g.accessibleHint && g.accessibleHint !== null && p.setAttribute(\"aria-label\", g.accessibleHint)), (g.accessibleTitle !== p.title || g.tabIndex !== p.tabIndex) && (p.title = g.accessibleTitle, p.tabIndex = g.tabIndex, this.debug && this.updateDebugHTML(p));\n          }\n        }\n        this.renderId++;\n      }\n    }, i.prototype.updateDebugHTML = function(t) {\n      t.innerHTML = \"type: \" + t.type + \"</br> title : \" + t.title + \"</br> tabIndex: \" + t.tabIndex;\n    }, i.prototype.capHitArea = function(t) {\n      t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);\n      var e = this.renderer, r = e.width, n = e.height;\n      t.x + t.width > r && (t.width = r - t.x), t.y + t.height > n && (t.height = n - t.y);\n    }, i.prototype.addChild = function(t) {\n      var e = this.pool.pop();\n      e || (e = document.createElement(\"button\"), e.style.width = qd + \"px\", e.style.height = qd + \"px\", e.style.backgroundColor = this.debug ? \"rgba(255,255,255,0.5)\" : \"transparent\", e.style.position = \"absolute\", e.style.zIndex = D1.toString(), e.style.borderStyle = \"none\", navigator.userAgent.toLowerCase().indexOf(\"chrome\") > -1 ? e.setAttribute(\"aria-live\", \"off\") : e.setAttribute(\"aria-live\", \"polite\"), navigator.userAgent.match(/rv:.*Gecko\\//) ? e.setAttribute(\"aria-relevant\", \"additions\") : e.setAttribute(\"aria-relevant\", \"text\"), e.addEventListener(\"click\", this._onClick.bind(this)), e.addEventListener(\"focus\", this._onFocus.bind(this)), e.addEventListener(\"focusout\", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? e.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (e.title = \"displayObject \" + t.tabIndex), t.accessibleHint && t.accessibleHint !== null && e.setAttribute(\"aria-label\", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex;\n    }, i.prototype._onClick = function(t) {\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;\n      e.dispatchEvent(r, \"click\", n), e.dispatchEvent(r, \"pointertap\", n), e.dispatchEvent(r, \"tap\", n);\n    }, i.prototype._onFocus = function(t) {\n      t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"assertive\");\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;\n      e.dispatchEvent(r, \"mouseover\", n);\n    }, i.prototype._onFocusOut = function(t) {\n      t.target.getAttribute(\"aria-live\") || t.target.setAttribute(\"aria-live\", \"polite\");\n      var e = this.renderer.plugins.interaction, r = t.target.displayObject, n = e.eventData;\n      e.dispatchEvent(r, \"mouseout\", n);\n    }, i.prototype._onKeyDown = function(t) {\n      t.keyCode === L2 && this.activate();\n    }, i.prototype._onMouseMove = function(t) {\n      t.movementX === 0 && t.movementY === 0 || this.deactivate();\n    }, i.prototype.destroy = function() {\n      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener(\"mousemove\", this._onMouseMove, !0), globalThis.removeEventListener(\"keydown\", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;\n    }, i.extension = {\n      name: \"accessibility\",\n      type: [\n        fe.RendererPlugin,\n        fe.CanvasRendererPlugin\n      ]\n    }, i;\n  }()\n);\n/*!\n * @pixi/interaction - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/interaction is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar N1 = (\n  /** @class */\n  function() {\n    function i() {\n      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new xe(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;\n    }\n    return Object.defineProperty(i.prototype, \"pointerId\", {\n      /**\n       * The unique identifier of the pointer. It will be the same as `identifier`.\n       * @readonly\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n       */\n      get: function() {\n        return this.identifier;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.getLocalPosition = function(t, e, r) {\n      return t.worldTransform.applyInverse(r || this.global, e);\n    }, i.prototype.copyEvent = function(t) {\n      \"isPrimary\" in t && t.isPrimary && (this.isPrimary = !0), this.button = \"button\" in t && t.button;\n      var e = \"buttons\" in t && t.buttons;\n      this.buttons = Number.isInteger(e) ? e : \"which\" in t && t.which, this.width = \"width\" in t && t.width, this.height = \"height\" in t && t.height, this.tiltX = \"tiltX\" in t && t.tiltX, this.tiltY = \"tiltY\" in t && t.tiltY, this.pointerType = \"pointerType\" in t && t.pointerType, this.pressure = \"pressure\" in t && t.pressure, this.rotationAngle = \"rotationAngle\" in t && t.rotationAngle, this.twist = \"twist\" in t && t.twist || 0, this.tangentialPressure = \"tangentialPressure\" in t && t.tangentialPressure || 0;\n    }, i.prototype.reset = function() {\n      this.isPrimary = !1;\n    }, i;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Sy = function(i, t) {\n  return Sy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Sy(i, t);\n};\nfunction H2(i, t) {\n  Sy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar $2 = (\n  /** @class */\n  function() {\n    function i() {\n      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;\n    }\n    return i.prototype.stopPropagation = function() {\n      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;\n    }, i.prototype.reset = function() {\n      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;\n    }, i;\n  }()\n), z0 = (\n  /** @class */\n  function() {\n    function i(t) {\n      this._pointerId = t, this._flags = i.FLAGS.NONE;\n    }\n    return i.prototype._doSet = function(t, e) {\n      e ? this._flags = this._flags | t : this._flags = this._flags & ~t;\n    }, Object.defineProperty(i.prototype, \"pointerId\", {\n      /**\n       * Unique pointer id of the event\n       * @readonly\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._pointerId;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"flags\", {\n      /**\n       * State of the tracking data, expressed as bit flags\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._flags;\n      },\n      set: function(t) {\n        this._flags = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"none\", {\n      /**\n       * Is the tracked event inactive (not over or down)?\n       * @private\n       * @member {number}\n       */\n      get: function() {\n        return this._flags === i.FLAGS.NONE;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"over\", {\n      /**\n       * Is the tracked event over the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & i.FLAGS.OVER) !== 0;\n      },\n      set: function(t) {\n        this._doSet(i.FLAGS.OVER, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"rightDown\", {\n      /**\n       * Did the right mouse button come down in the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & i.FLAGS.RIGHT_DOWN) !== 0;\n      },\n      set: function(t) {\n        this._doSet(i.FLAGS.RIGHT_DOWN, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"leftDown\", {\n      /**\n       * Did the left mouse button come down in the DisplayObject?\n       * @private\n       * @member {boolean}\n       */\n      get: function() {\n        return (this._flags & i.FLAGS.LEFT_DOWN) !== 0;\n      },\n      set: function(t) {\n        this._doSet(i.FLAGS.LEFT_DOWN, t);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.FLAGS = Object.freeze({\n      NONE: 0,\n      OVER: 1 << 0,\n      LEFT_DOWN: 1 << 1,\n      RIGHT_DOWN: 1 << 2\n    }), i;\n  }()\n), V2 = (\n  /** @class */\n  function() {\n    function i() {\n      this._tempPoint = new xe();\n    }\n    return i.prototype.recursiveFindHit = function(t, e, r, n, s) {\n      var a;\n      if (!e || !e.visible)\n        return !1;\n      var o = t.data.global;\n      s = e.interactive || s;\n      var u = !1, l = s, h = !0;\n      if (e.hitArea)\n        n && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? u = !0 : (n = !1, h = !1)), l = !1;\n      else if (e._mask && n) {\n        var d = e._mask.isMaskData ? e._mask.maskObject : e._mask;\n        d && !(!((a = d.containsPoint) === null || a === void 0) && a.call(d, o)) && (n = !1);\n      }\n      if (h && e.interactiveChildren && e.children)\n        for (var f = e.children, p = f.length - 1; p >= 0; p--) {\n          var v = f[p], g = this.recursiveFindHit(t, v, r, n, l);\n          if (g) {\n            if (!v.parent)\n              continue;\n            l = !1, g && (t.target && (n = !1), u = !0);\n          }\n        }\n      return s && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (u = !0), e.interactive && (u && !t.target && (t.target = e), r && r(t, e, !!u))), u;\n    }, i.prototype.findHit = function(t, e, r, n) {\n      this.recursiveFindHit(t, e, r, n, !1);\n    }, i;\n  }()\n), X2 = {\n  interactive: !1,\n  interactiveChildren: !0,\n  hitArea: null,\n  /**\n   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive\n   * Setting this changes the 'cursor' property to `'pointer'`.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.buttonMode = true;\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  get buttonMode() {\n    return this.cursor === \"pointer\";\n  },\n  set buttonMode(i) {\n    i ? this.cursor = \"pointer\" : this.cursor === \"pointer\" && (this.cursor = null);\n  },\n  /**\n   * This defines what cursor mode is used when the mouse cursor\n   * is hovered over the displayObject.\n   * @example\n   * const sprite = new PIXI.Sprite(texture);\n   * sprite.interactive = true;\n   * sprite.cursor = 'wait';\n   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor\n   * @member {string}\n   * @memberof PIXI.DisplayObject#\n   */\n  cursor: null,\n  /**\n   * Internal set of all active pointers, by identifier\n   * @member {Map<number, InteractionTrackingData>}\n   * @memberof PIXI.DisplayObject#\n   * @private\n   */\n  get trackedPointers() {\n    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;\n  },\n  /**\n   * Map of all tracked pointers, by identifier. Use trackedPointers to access.\n   * @private\n   * @type {Map<number, InteractionTrackingData>}\n   */\n  _trackedPointers: void 0\n};\nHe.mixin(X2);\nvar Zd = 1, Kd = {\n  target: null,\n  data: {\n    global: null\n  }\n}, W2 = (\n  /** @class */\n  function(i) {\n    H2(t, i);\n    function t(e, r) {\n      var n = i.call(this) || this;\n      return r = r || {}, n.renderer = e, n.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : !0, n.interactionFrequency = r.interactionFrequency || 10, n.mouse = new N1(), n.mouse.identifier = Zd, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[Zd] = n.mouse, n.interactionDataPool = [], n.eventData = new $2(), n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !(\"PointerEvent\" in globalThis), n.supportsTouchEvents = \"ontouchstart\" in globalThis, n.supportsPointerEvents = !!globalThis.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {\n        default: \"inherit\",\n        pointer: \"pointer\"\n      }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new V2(), n._tempDisplayObject = new GE(), n._eventListenerOptions = { capture: !0, passive: !1 }, n._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : !0, n.setTargetElement(n.renderer.view, n.renderer.resolution), n;\n    }\n    return Object.defineProperty(t.prototype, \"useSystemTicker\", {\n      /**\n       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.\n       * @default true\n       */\n      get: function() {\n        return this._useSystemTicker;\n      },\n      set: function(e) {\n        this._useSystemTicker = e, e ? this.addTickerListener() : this.removeTickerListener();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"lastObjectRendered\", {\n      /**\n       * Last rendered object or temp object.\n       * @readonly\n       * @protected\n       */\n      get: function() {\n        return this.renderer._lastObjectRendered || this._tempDisplayObject;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.hitTest = function(e, r) {\n      return Kd.target = null, Kd.data.global = e, r || (r = this.lastObjectRendered), this.processInteractive(Kd, r, null, !0), Kd.target;\n    }, t.prototype.setTargetElement = function(e, r) {\n      r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = e, this.resolution = r, this.addEvents(), this.addTickerListener();\n    }, t.prototype.addTickerListener = function() {\n      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ge.system.add(this.tickerUpdate, this, Cs.INTERACTION), this.tickerAdded = !0);\n    }, t.prototype.removeTickerListener = function() {\n      this.tickerAdded && (Ge.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);\n    }, t.prototype.addEvents = function() {\n      if (!(this.eventsAdded || !this.interactionDOMElement)) {\n        var e = this.interactionDOMElement.style;\n        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"none\", e.msTouchAction = \"none\") : this.supportsPointerEvents && (e.touchAction = \"none\"), this.supportsPointerEvents ? (globalThis.document.addEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;\n      }\n    }, t.prototype.removeEvents = function() {\n      if (!(!this.eventsAdded || !this.interactionDOMElement)) {\n        var e = this.interactionDOMElement.style;\n        globalThis.navigator.msPointerEnabled ? (e.msContentZooming = \"\", e.msTouchAction = \"\") : this.supportsPointerEvents && (e.touchAction = \"\"), this.supportsPointerEvents ? (globalThis.document.removeEventListener(\"pointermove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerdown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerleave\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"pointerover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"pointercancel\", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener(\"pointerup\", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener(\"mousemove\", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mousedown\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseout\", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"mouseover\", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener(\"mouseup\", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener(\"touchstart\", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchcancel\", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchend\", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener(\"touchmove\", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;\n      }\n    }, t.prototype.tickerUpdate = function(e) {\n      this._deltaTime += e, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());\n    }, t.prototype.update = function() {\n      if (this.interactionDOMElement) {\n        if (this._didMove) {\n          this._didMove = !1;\n          return;\n        }\n        this.cursor = null;\n        for (var e in this.activeInteractionData)\n          if (this.activeInteractionData.hasOwnProperty(e)) {\n            var r = this.activeInteractionData[e];\n            if (r.originalEvent && r.pointerType !== \"touch\") {\n              var n = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);\n              this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0);\n            }\n          }\n        this.setCursorMode(this.cursor);\n      }\n    }, t.prototype.setCursorMode = function(e) {\n      e = e || \"default\";\n      var r = !0;\n      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = !1), this.currentCursorMode !== e) {\n        this.currentCursorMode = e;\n        var n = this.cursorStyles[e];\n        if (n)\n          switch (typeof n) {\n            case \"string\":\n              r && (this.interactionDOMElement.style.cursor = n);\n              break;\n            case \"function\":\n              n(e);\n              break;\n            case \"object\":\n              r && Object.assign(this.interactionDOMElement.style, n);\n              break;\n          }\n        else\n          r && typeof e == \"string\" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.interactionDOMElement.style.cursor = e);\n      }\n    }, t.prototype.dispatchEvent = function(e, r, n) {\n      (!n.stopPropagationHint || e === n.stopsPropagatingAt) && (n.currentTarget = e, n.type = r, e.emit(r, n), e[r] && e[r](n));\n    }, t.prototype.delayDispatchEvent = function(e, r, n) {\n      this.delayedEvents.push({ displayObject: e, eventString: r, eventData: n });\n    }, t.prototype.mapPositionToPoint = function(e, r, n) {\n      var s;\n      this.interactionDOMElement.parentElement ? s = this.interactionDOMElement.getBoundingClientRect() : s = {\n        x: 0,\n        y: 0,\n        width: this.interactionDOMElement.width,\n        height: this.interactionDOMElement.height,\n        left: 0,\n        top: 0\n      };\n      var a = 1 / this.resolution;\n      e.x = (r - s.left) * (this.interactionDOMElement.width / s.width) * a, e.y = (n - s.top) * (this.interactionDOMElement.height / s.height) * a;\n    }, t.prototype.processInteractive = function(e, r, n, s) {\n      var a = this.search.findHit(e, r, n, s), o = this.delayedEvents;\n      if (!o.length)\n        return a;\n      e.stopPropagationHint = !1;\n      var u = o.length;\n      this.delayedEvents = [];\n      for (var l = 0; l < u; l++) {\n        var h = o[l], d = h.displayObject, f = h.eventString, p = h.eventData;\n        p.stopsPropagatingAt === d && (p.stopPropagationHint = !0), this.dispatchEvent(d, f, p);\n      }\n      return a;\n    }, t.prototype.onPointerDown = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e);\n        if (this.autoPreventDefault && r[0].isNormalized) {\n          var n = e.cancelable || !(\"cancelable\" in e);\n          n && e.preventDefault();\n        }\n        for (var s = r.length, a = 0; a < s; a++) {\n          var o = r[a], u = this.getInteractionDataForPointerId(o), l = this.configureInteractionEventForDOMEvent(this.eventData, o, u);\n          if (l.data.originalEvent = e, this.processInteractive(l, this.lastObjectRendered, this.processPointerDown, !0), this.emit(\"pointerdown\", l), o.pointerType === \"touch\")\n            this.emit(\"touchstart\", l);\n          else if (o.pointerType === \"mouse\" || o.pointerType === \"pen\") {\n            var h = o.button === 2;\n            this.emit(h ? \"rightdown\" : \"mousedown\", this.eventData);\n          }\n        }\n      }\n    }, t.prototype.processPointerDown = function(e, r, n) {\n      var s = e.data, a = e.data.identifier;\n      if (n) {\n        if (r.trackedPointers[a] || (r.trackedPointers[a] = new z0(a)), this.dispatchEvent(r, \"pointerdown\", e), s.pointerType === \"touch\")\n          this.dispatchEvent(r, \"touchstart\", e);\n        else if (s.pointerType === \"mouse\" || s.pointerType === \"pen\") {\n          var o = s.button === 2;\n          o ? r.trackedPointers[a].rightDown = !0 : r.trackedPointers[a].leftDown = !0, this.dispatchEvent(r, o ? \"rightdown\" : \"mousedown\", e);\n        }\n      }\n    }, t.prototype.onPointerComplete = function(e, r, n) {\n      var s = this.normalizeToPointerData(e), a = s.length, o = e.target;\n      e.composedPath && e.composedPath().length > 0 && (o = e.composedPath()[0]);\n      for (var u = o !== this.interactionDOMElement ? \"outside\" : \"\", l = 0; l < a; l++) {\n        var h = s[l], d = this.getInteractionDataForPointerId(h), f = this.configureInteractionEventForDOMEvent(this.eventData, h, d);\n        if (f.data.originalEvent = e, this.processInteractive(f, this.lastObjectRendered, n, r || !u), this.emit(r ? \"pointercancel\" : \"pointerup\" + u, f), h.pointerType === \"mouse\" || h.pointerType === \"pen\") {\n          var p = h.button === 2;\n          this.emit(p ? \"rightup\" + u : \"mouseup\" + u, f);\n        } else\n          h.pointerType === \"touch\" && (this.emit(r ? \"touchcancel\" : \"touchend\" + u, f), this.releaseInteractionDataForPointerId(h.pointerId));\n      }\n    }, t.prototype.onPointerCancel = function(e) {\n      this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !0, this.processPointerCancel);\n    }, t.prototype.processPointerCancel = function(e, r) {\n      var n = e.data, s = e.data.identifier;\n      r.trackedPointers[s] !== void 0 && (delete r.trackedPointers[s], this.dispatchEvent(r, \"pointercancel\", e), n.pointerType === \"touch\" && this.dispatchEvent(r, \"touchcancel\", e));\n    }, t.prototype.onPointerUp = function(e) {\n      this.supportsTouchEvents && e.pointerType === \"touch\" || this.onPointerComplete(e, !1, this.processPointerUp);\n    }, t.prototype.processPointerUp = function(e, r, n) {\n      var s = e.data, a = e.data.identifier, o = r.trackedPointers[a], u = s.pointerType === \"touch\", l = s.pointerType === \"mouse\" || s.pointerType === \"pen\", h = !1;\n      if (l) {\n        var d = s.button === 2, f = z0.FLAGS, p = d ? f.RIGHT_DOWN : f.LEFT_DOWN, v = o !== void 0 && o.flags & p;\n        n ? (this.dispatchEvent(r, d ? \"rightup\" : \"mouseup\", e), v && (this.dispatchEvent(r, d ? \"rightclick\" : \"click\", e), h = !0)) : v && this.dispatchEvent(r, d ? \"rightupoutside\" : \"mouseupoutside\", e), o && (d ? o.rightDown = !1 : o.leftDown = !1);\n      }\n      n ? (this.dispatchEvent(r, \"pointerup\", e), u && this.dispatchEvent(r, \"touchend\", e), o && ((!l || h) && this.dispatchEvent(r, \"pointertap\", e), u && (this.dispatchEvent(r, \"tap\", e), o.over = !1))) : o && (this.dispatchEvent(r, \"pointerupoutside\", e), u && this.dispatchEvent(r, \"touchendoutside\", e)), o && o.none && delete r.trackedPointers[a];\n    }, t.prototype.onPointerMove = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e);\n        (r[0].pointerType === \"mouse\" || r[0].pointerType === \"pen\") && (this._didMove = !0, this.cursor = null);\n        for (var n = r.length, s = 0; s < n; s++) {\n          var a = r[s], o = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, o);\n          u.data.originalEvent = e, this.processInteractive(u, this.lastObjectRendered, this.processPointerMove, !0), this.emit(\"pointermove\", u), a.pointerType === \"touch\" && this.emit(\"touchmove\", u), (a.pointerType === \"mouse\" || a.pointerType === \"pen\") && this.emit(\"mousemove\", u);\n        }\n        r[0].pointerType === \"mouse\" && this.setCursorMode(this.cursor);\n      }\n    }, t.prototype.processPointerMove = function(e, r, n) {\n      var s = e.data, a = s.pointerType === \"touch\", o = s.pointerType === \"mouse\" || s.pointerType === \"pen\";\n      o && this.processPointerOverOut(e, r, n), (!this.moveWhenInside || n) && (this.dispatchEvent(r, \"pointermove\", e), a && this.dispatchEvent(r, \"touchmove\", e), o && this.dispatchEvent(r, \"mousemove\", e));\n    }, t.prototype.onPointerOut = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e), n = r[0];\n        n.pointerType === \"mouse\" && (this.mouseOverRenderer = !1, this.setCursorMode(null));\n        var s = this.getInteractionDataForPointerId(n), a = this.configureInteractionEventForDOMEvent(this.eventData, n, s);\n        a.data.originalEvent = n, this.processInteractive(a, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit(\"pointerout\", a), n.pointerType === \"mouse\" || n.pointerType === \"pen\" ? this.emit(\"mouseout\", a) : this.releaseInteractionDataForPointerId(s.identifier);\n      }\n    }, t.prototype.processPointerOverOut = function(e, r, n) {\n      var s = e.data, a = e.data.identifier, o = s.pointerType === \"mouse\" || s.pointerType === \"pen\", u = r.trackedPointers[a];\n      n && !u && (u = r.trackedPointers[a] = new z0(a)), u !== void 0 && (n && this.mouseOverRenderer ? (u.over || (u.over = !0, this.delayDispatchEvent(r, \"pointerover\", e), o && this.delayDispatchEvent(r, \"mouseover\", e)), o && this.cursor === null && (this.cursor = r.cursor)) : u.over && (u.over = !1, this.dispatchEvent(r, \"pointerout\", this.eventData), o && this.dispatchEvent(r, \"mouseout\", e), u.none && delete r.trackedPointers[a]));\n    }, t.prototype.onPointerOver = function(e) {\n      if (!(this.supportsTouchEvents && e.pointerType === \"touch\")) {\n        var r = this.normalizeToPointerData(e), n = r[0], s = this.getInteractionDataForPointerId(n), a = this.configureInteractionEventForDOMEvent(this.eventData, n, s);\n        a.data.originalEvent = n, n.pointerType === \"mouse\" && (this.mouseOverRenderer = !0), this.emit(\"pointerover\", a), (n.pointerType === \"mouse\" || n.pointerType === \"pen\") && this.emit(\"mouseover\", a);\n      }\n    }, t.prototype.getInteractionDataForPointerId = function(e) {\n      var r = e.pointerId, n;\n      return r === Zd || e.pointerType === \"mouse\" ? n = this.mouse : this.activeInteractionData[r] ? n = this.activeInteractionData[r] : (n = this.interactionDataPool.pop() || new N1(), n.identifier = r, this.activeInteractionData[r] = n), n.copyEvent(e), n;\n    }, t.prototype.releaseInteractionDataForPointerId = function(e) {\n      var r = this.activeInteractionData[e];\n      r && (delete this.activeInteractionData[e], r.reset(), this.interactionDataPool.push(r));\n    }, t.prototype.configureInteractionEventForDOMEvent = function(e, r, n) {\n      return e.data = n, this.mapPositionToPoint(n.global, r.clientX, r.clientY), r.pointerType === \"touch\" && (r.globalX = n.global.x, r.globalY = n.global.y), n.originalEvent = r, e.reset(), e;\n    }, t.prototype.normalizeToPointerData = function(e) {\n      var r = [];\n      if (this.supportsTouchEvents && e instanceof TouchEvent)\n        for (var n = 0, s = e.changedTouches.length; n < s; n++) {\n          var a = e.changedTouches[n];\n          typeof a.button > \"u\" && (a.button = e.touches.length ? 1 : 0), typeof a.buttons > \"u\" && (a.buttons = e.touches.length ? 1 : 0), typeof a.isPrimary > \"u\" && (a.isPrimary = e.touches.length === 1 && e.type === \"touchstart\"), typeof a.width > \"u\" && (a.width = a.radiusX || 1), typeof a.height > \"u\" && (a.height = a.radiusY || 1), typeof a.tiltX > \"u\" && (a.tiltX = 0), typeof a.tiltY > \"u\" && (a.tiltY = 0), typeof a.pointerType > \"u\" && (a.pointerType = \"touch\"), typeof a.pointerId > \"u\" && (a.pointerId = a.identifier || 0), typeof a.pressure > \"u\" && (a.pressure = a.force || 0.5), typeof a.twist > \"u\" && (a.twist = 0), typeof a.tangentialPressure > \"u\" && (a.tangentialPressure = 0), typeof a.layerX > \"u\" && (a.layerX = a.offsetX = a.clientX), typeof a.layerY > \"u\" && (a.layerY = a.offsetY = a.clientY), a.isNormalized = !0, r.push(a);\n        }\n      else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {\n        var o = e;\n        typeof o.isPrimary > \"u\" && (o.isPrimary = !0), typeof o.width > \"u\" && (o.width = 1), typeof o.height > \"u\" && (o.height = 1), typeof o.tiltX > \"u\" && (o.tiltX = 0), typeof o.tiltY > \"u\" && (o.tiltY = 0), typeof o.pointerType > \"u\" && (o.pointerType = \"mouse\"), typeof o.pointerId > \"u\" && (o.pointerId = Zd), typeof o.pressure > \"u\" && (o.pressure = 0.5), typeof o.twist > \"u\" && (o.twist = 0), typeof o.tangentialPressure > \"u\" && (o.tangentialPressure = 0), o.isNormalized = !0, r.push(o);\n      } else\n        r.push(e);\n      return r;\n    }, t.prototype.destroy = function() {\n      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;\n    }, t.extension = {\n      name: \"interaction\",\n      type: [\n        fe.RendererPlugin,\n        fe.CanvasRendererPlugin\n      ]\n    }, t;\n  }($r)\n);\n/*!\n * @pixi/extract - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Y2 = new Nt(), q2 = 4, Z2 = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.renderer = t;\n    }\n    return i.prototype.image = function(t, e, r) {\n      var n = new Image();\n      return n.src = this.base64(t, e, r), n;\n    }, i.prototype.base64 = function(t, e, r) {\n      return this.canvas(t).toDataURL(e, r);\n    }, i.prototype.canvas = function(t, e) {\n      var r = this._rawPixels(t, e), n = r.pixels, s = r.width, a = r.height, o = r.flipY, u = new y1(s, a, 1), l = u.context.getImageData(0, 0, s, a);\n      if (i.arrayPostDivide(n, l.data), u.context.putImageData(l, 0, 0), o) {\n        var h = new y1(u.width, u.height, 1);\n        h.context.scale(1, -1), h.context.drawImage(u.canvas, 0, -a), u.destroy(), u = h;\n      }\n      return u.canvas;\n    }, i.prototype.pixels = function(t, e) {\n      var r = this._rawPixels(t, e).pixels;\n      return i.arrayPostDivide(r, r), r;\n    }, i.prototype._rawPixels = function(t, e) {\n      var r = this.renderer, n, s = !1, a, o = !1;\n      if (t)\n        if (t instanceof Si)\n          a = t;\n        else {\n          var u = r.context.webGLVersion >= 2 ? r.multisample : ke.NONE;\n          if (a = this.renderer.generateTexture(t, { multisample: u }), u !== ke.NONE) {\n            var l = Si.create({\n              width: a.width,\n              height: a.height\n            });\n            r.framebuffer.bind(a.framebuffer), r.framebuffer.blit(l.framebuffer), r.framebuffer.bind(null), a.destroy(!0), a = l;\n          }\n          o = !0;\n        }\n      a ? (n = a.baseTexture.resolution, e = e ?? a.frame, s = !1, r.renderTexture.bind(a)) : (n = r.resolution, e || (e = Y2, e.width = r.width, e.height = r.height), s = !0, r.renderTexture.bind(null));\n      var h = Math.round(e.width * n), d = Math.round(e.height * n), f = new Uint8Array(q2 * h * d), p = r.gl;\n      return p.readPixels(Math.round(e.x * n), Math.round(e.y * n), h, d, p.RGBA, p.UNSIGNED_BYTE, f), o && a.destroy(!0), { pixels: f, width: h, height: d, flipY: s };\n    }, i.prototype.destroy = function() {\n      this.renderer = null;\n    }, i.arrayPostDivide = function(t, e) {\n      for (var r = 0; r < t.length; r += 4) {\n        var n = e[r + 3] = t[r + 3];\n        n !== 0 ? (e[r] = Math.round(Math.min(t[r] * 255 / n, 255)), e[r + 1] = Math.round(Math.min(t[r + 1] * 255 / n, 255)), e[r + 2] = Math.round(Math.min(t[r + 2] * 255 / n, 255))) : (e[r] = t[r], e[r + 1] = t[r + 1], e[r + 2] = t[r + 2]);\n      }\n    }, i.extension = {\n      name: \"extract\",\n      type: fe.RendererPlugin\n    }, i;\n  }()\n);\n/*!\n * @pixi/loaders - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/loaders is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar Jd = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      e === void 0 && (e = !1), this._fn = t, this._once = e, this._thisArg = r, this._next = this._prev = this._owner = null;\n    }\n    return i.prototype.detach = function() {\n      return this._owner === null ? !1 : (this._owner.detach(this), !0);\n    }, i;\n  }()\n);\nfunction A1(i, t) {\n  return i._head ? (i._tail._next = t, t._prev = i._tail, i._tail = t) : (i._head = t, i._tail = t), t._owner = i, t;\n}\nvar ys = (\n  /** @class */\n  function() {\n    function i() {\n      this._head = this._tail = void 0;\n    }\n    return i.prototype.handlers = function(t) {\n      t === void 0 && (t = !1);\n      var e = this._head;\n      if (t)\n        return !!e;\n      for (var r = []; e; )\n        r.push(e), e = e._next;\n      return r;\n    }, i.prototype.has = function(t) {\n      if (!(t instanceof Jd))\n        throw new Error(\"MiniSignal#has(): First arg must be a SignalBinding object.\");\n      return t._owner === this;\n    }, i.prototype.dispatch = function() {\n      for (var t = arguments, e = [], r = 0; r < arguments.length; r++)\n        e[r] = t[r];\n      var n = this._head;\n      if (!n)\n        return !1;\n      for (; n; )\n        n._once && this.detach(n), n._fn.apply(n._thisArg, e), n = n._next;\n      return !0;\n    }, i.prototype.add = function(t, e) {\n      if (e === void 0 && (e = null), typeof t != \"function\")\n        throw new Error(\"MiniSignal#add(): First arg must be a Function.\");\n      return A1(this, new Jd(t, !1, e));\n    }, i.prototype.once = function(t, e) {\n      if (e === void 0 && (e = null), typeof t != \"function\")\n        throw new Error(\"MiniSignal#once(): First arg must be a Function.\");\n      return A1(this, new Jd(t, !0, e));\n    }, i.prototype.detach = function(t) {\n      if (!(t instanceof Jd))\n        throw new Error(\"MiniSignal#detach(): First arg must be a SignalBinding object.\");\n      return t._owner !== this ? this : (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, t._next === null && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null, this);\n    }, i.prototype.detachAll = function() {\n      var t = this._head;\n      if (!t)\n        return this;\n      for (this._head = this._tail = null; t; )\n        t._owner = null, t = t._next;\n      return this;\n    }, i;\n  }()\n);\nfunction pS(i, t) {\n  t = t || {};\n  for (var e = {\n    // eslint-disable-next-line max-len\n    key: [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"],\n    q: {\n      name: \"queryKey\",\n      parser: /(?:^|&)([^&=]*)=?([^&]*)/g\n    },\n    parser: {\n      // eslint-disable-next-line max-len\n      strict: /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\n      // eslint-disable-next-line max-len\n      loose: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n    }\n  }, r = e.parser[t.strictMode ? \"strict\" : \"loose\"].exec(i), n = {}, s = 14; s--; )\n    n[e.key[s]] = r[s] || \"\";\n  return n[e.q.name] = {}, n[e.key[12]].replace(e.q.parser, function(a, o, u) {\n    o && (n[e.q.name][o] = u);\n  }), n;\n}\nvar H0, Qd = null, K2 = 0, L1 = 200, J2 = 204, Q2 = 1223, tk = 2;\nfunction B1() {\n}\nfunction F1(i, t, e) {\n  t && t.indexOf(\".\") === 0 && (t = t.substring(1)), t && (i[t] = e);\n}\nfunction $0(i) {\n  return i.toString().replace(\"object \", \"\");\n}\nvar Ft = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      if (this._dequeue = B1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof t != \"string\" || typeof e != \"string\")\n        throw new Error(\"Both name and url are required for constructing a resource.\");\n      r = r || {}, this._flags = 0, this._setFlag(i.STATUS_FLAGS.DATA_URL, e.indexOf(\"data:\") === 0), this.name = t, this.url = e, this.extension = this._getExtension(), this.data = null, this.crossOrigin = r.crossOrigin === !0 ? \"anonymous\" : r.crossOrigin, this.timeout = r.timeout || 0, this.loadType = r.loadType || this._determineLoadType(), this.xhrType = r.xhrType, this.metadata = r.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = i.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = B1, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new ys(), this.onProgress = new ys(), this.onComplete = new ys(), this.onAfterMiddleware = new ys();\n    }\n    return i.setExtensionLoadType = function(t, e) {\n      F1(i._loadTypeMap, t, e);\n    }, i.setExtensionXhrType = function(t, e) {\n      F1(i._xhrTypeMap, t, e);\n    }, Object.defineProperty(i.prototype, \"isDataUrl\", {\n      /**\n       * When the resource starts to load.\n       * @memberof PIXI.LoaderResource\n       * @callback OnStartSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       */\n      /**\n       * When the resource reports loading progress.\n       * @memberof PIXI.LoaderResource\n       * @callback OnProgressSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       * @param {number} percentage - The progress of the load in the range [0, 1].\n       */\n      /**\n       * When the resource finishes loading.\n       * @memberof PIXI.LoaderResource\n       * @callback OnCompleteSignal\n       * @param {PIXI.Resource} resource - The resource that the event happened on.\n       */\n      /**\n       * @memberof PIXI.LoaderResource\n       * @typedef {object} IMetadata\n       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n       *      element to use for loading, instead of creating one.\n       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n       *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n       * @property {string|string[]} [mimeType] - The mime type to use for the source element\n       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n       *      where each index is the mime type to use for the corresponding url index.\n       */\n      /**\n       * Stores whether or not this url is a data url.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(i.STATUS_FLAGS.DATA_URL);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"isComplete\", {\n      /**\n       * Describes if this resource has finished loading. Is true when the resource has completely\n       * loaded.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(i.STATUS_FLAGS.COMPLETE);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"isLoading\", {\n      /**\n       * Describes if this resource is currently loading. Is true when the resource starts loading,\n       * and is false again when complete.\n       * @readonly\n       * @member {boolean}\n       */\n      get: function() {\n        return this._hasFlag(i.STATUS_FLAGS.LOADING);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.complete = function() {\n      this._clearEvents(), this._finish();\n    }, i.prototype.abort = function(t) {\n      if (!this.error) {\n        if (this.error = new Error(t), this._clearEvents(), this.xhr)\n          this.xhr.abort();\n        else if (this.xdr)\n          this.xdr.abort();\n        else if (this.data)\n          if (this.data.src)\n            this.data.src = i.EMPTY_GIF;\n          else\n            for (; this.data.firstChild; )\n              this.data.removeChild(this.data.firstChild);\n        this._finish();\n      }\n    }, i.prototype.load = function(t) {\n      var e = this;\n      if (!this.isLoading) {\n        if (this.isComplete) {\n          t && setTimeout(function() {\n            return t(e);\n          }, 1);\n          return;\n        } else\n          t && this.onComplete.once(t);\n        switch (this._setFlag(i.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != \"string\") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {\n          case i.LOAD_TYPE.IMAGE:\n            this.type = i.TYPE.IMAGE, this._loadElement(\"image\");\n            break;\n          case i.LOAD_TYPE.AUDIO:\n            this.type = i.TYPE.AUDIO, this._loadSourceElement(\"audio\");\n            break;\n          case i.LOAD_TYPE.VIDEO:\n            this.type = i.TYPE.VIDEO, this._loadSourceElement(\"video\");\n            break;\n          case i.LOAD_TYPE.XHR:\n          default:\n            typeof H0 > \"u\" && (H0 = !!(globalThis.XDomainRequest && !(\"withCredentials\" in new XMLHttpRequest()))), H0 && this.crossOrigin ? this._loadXdr() : this._loadXhr();\n            break;\n        }\n      }\n    }, i.prototype._hasFlag = function(t) {\n      return (this._flags & t) !== 0;\n    }, i.prototype._setFlag = function(t, e) {\n      this._flags = e ? this._flags | t : this._flags & ~t;\n    }, i.prototype._clearEvents = function() {\n      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener(\"error\", this._boundOnError, !1), this.data.removeEventListener(\"load\", this._boundComplete, !1), this.data.removeEventListener(\"progress\", this._boundOnProgress, !1), this.data.removeEventListener(\"canplaythrough\", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener(\"error\", this._boundXhrOnError, !1), this.xhr.removeEventListener(\"timeout\", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener(\"abort\", this._boundXhrOnAbort, !1), this.xhr.removeEventListener(\"progress\", this._boundOnProgress, !1), this.xhr.removeEventListener(\"load\", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));\n    }, i.prototype._finish = function() {\n      if (this.isComplete)\n        throw new Error(\"Complete called again for an already completed resource.\");\n      this._setFlag(i.STATUS_FLAGS.COMPLETE, !0), this._setFlag(i.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);\n    }, i.prototype._loadElement = function(t) {\n      this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"image\" && typeof globalThis.Image < \"u\" ? this.data = new Image() : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n    }, i.prototype._loadSourceElement = function(t) {\n      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : t === \"audio\" && typeof globalThis.Audio < \"u\" ? this.data = new Audio() : this.data = document.createElement(t), this.data === null) {\n        this.abort(\"Unsupported element: \" + t);\n        return;\n      }\n      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)\n        if (navigator.isCocoonJS)\n          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n        else if (Array.isArray(this.url))\n          for (var e = this.metadata.mimeType, r = 0; r < this.url.length; ++r)\n            this.data.appendChild(this._createSource(t, this.url[r], Array.isArray(e) ? e[r] : e));\n        else {\n          var e = this.metadata.mimeType;\n          this.data.appendChild(this._createSource(t, this.url, Array.isArray(e) ? e[0] : e));\n        }\n      this.data.addEventListener(\"error\", this._boundOnError, !1), this.data.addEventListener(\"load\", this._boundComplete, !1), this.data.addEventListener(\"progress\", this._boundOnProgress, !1), this.data.addEventListener(\"canplaythrough\", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));\n    }, i.prototype._loadXhr = function() {\n      typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n      var t = this.xhr = new XMLHttpRequest();\n      this.crossOrigin === \"use-credentials\" && (t.withCredentials = !0), t.open(\"GET\", this.url, !0), t.timeout = this.timeout, this.xhrType === i.XHR_RESPONSE_TYPE.JSON || this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT ? t.responseType = i.XHR_RESPONSE_TYPE.TEXT : t.responseType = this.xhrType, t.addEventListener(\"error\", this._boundXhrOnError, !1), t.addEventListener(\"timeout\", this._boundXhrOnTimeout, !1), t.addEventListener(\"abort\", this._boundXhrOnAbort, !1), t.addEventListener(\"progress\", this._boundOnProgress, !1), t.addEventListener(\"load\", this._boundXhrOnLoad, !1), t.send();\n    }, i.prototype._loadXdr = function() {\n      typeof this.xhrType != \"string\" && (this.xhrType = this._determineXhrType());\n      var t = this.xhr = new globalThis.XDomainRequest();\n      t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open(\"GET\", this.url, !0), setTimeout(function() {\n        return t.send();\n      }, 1);\n    }, i.prototype._createSource = function(t, e, r) {\n      r || (r = t + \"/\" + this._getExtension(e));\n      var n = document.createElement(\"source\");\n      return n.src = e, n.type = r, n;\n    }, i.prototype._onError = function(t) {\n      this.abort(\"Failed to load element using: \" + t.target.nodeName);\n    }, i.prototype._onProgress = function(t) {\n      t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total);\n    }, i.prototype._onTimeout = function() {\n      this.abort(\"Load timed out.\");\n    }, i.prototype._xhrOnError = function() {\n      var t = this.xhr;\n      this.abort($0(t) + \" Request failed. Status: \" + t.status + ', text: \"' + t.statusText + '\"');\n    }, i.prototype._xhrOnTimeout = function() {\n      var t = this.xhr;\n      this.abort($0(t) + \" Request timed out.\");\n    }, i.prototype._xhrOnAbort = function() {\n      var t = this.xhr;\n      this.abort($0(t) + \" Request was aborted by the user.\");\n    }, i.prototype._xhrOnLoad = function() {\n      var t = this.xhr, e = \"\", r = typeof t.status > \"u\" ? L1 : t.status;\n      (t.responseType === \"\" || t.responseType === \"text\" || typeof t.responseType > \"u\") && (e = t.responseText), r === K2 && (e.length > 0 || t.responseType === i.XHR_RESPONSE_TYPE.BUFFER) ? r = L1 : r === Q2 && (r = J2);\n      var n = r / 100 | 0;\n      if (n === tk)\n        if (this.xhrType === i.XHR_RESPONSE_TYPE.TEXT)\n          this.data = e, this.type = i.TYPE.TEXT;\n        else if (this.xhrType === i.XHR_RESPONSE_TYPE.JSON)\n          try {\n            this.data = JSON.parse(e), this.type = i.TYPE.JSON;\n          } catch (o) {\n            this.abort(\"Error trying to parse loaded json: \" + o);\n            return;\n          }\n        else if (this.xhrType === i.XHR_RESPONSE_TYPE.DOCUMENT)\n          try {\n            if (globalThis.DOMParser) {\n              var s = new DOMParser();\n              this.data = s.parseFromString(e, \"text/xml\");\n            } else {\n              var a = document.createElement(\"div\");\n              a.innerHTML = e, this.data = a;\n            }\n            this.type = i.TYPE.XML;\n          } catch (o) {\n            this.abort(\"Error trying to parse loaded xml: \" + o);\n            return;\n          }\n        else\n          this.data = t.response || e;\n      else {\n        this.abort(\"[\" + t.status + \"] \" + t.statusText + \": \" + t.responseURL);\n        return;\n      }\n      this.complete();\n    }, i.prototype._determineCrossOrigin = function(t, e) {\n      if (t.indexOf(\"data:\") === 0)\n        return \"\";\n      if (globalThis.origin !== globalThis.location.origin)\n        return \"anonymous\";\n      e = e || globalThis.location, Qd || (Qd = document.createElement(\"a\")), Qd.href = t;\n      var r = pS(Qd.href, { strictMode: !0 }), n = !r.port && e.port === \"\" || r.port === e.port, s = r.protocol ? r.protocol + \":\" : \"\";\n      return r.host !== e.hostname || !n || s !== e.protocol ? \"anonymous\" : \"\";\n    }, i.prototype._determineXhrType = function() {\n      return i._xhrTypeMap[this.extension] || i.XHR_RESPONSE_TYPE.TEXT;\n    }, i.prototype._determineLoadType = function() {\n      return i._loadTypeMap[this.extension] || i.LOAD_TYPE.XHR;\n    }, i.prototype._getExtension = function(t) {\n      t === void 0 && (t = this.url);\n      var e = \"\";\n      if (this.isDataUrl) {\n        var r = t.indexOf(\"/\");\n        e = t.substring(r + 1, t.indexOf(\";\", r));\n      } else {\n        var n = t.indexOf(\"?\"), s = t.indexOf(\"#\"), a = Math.min(n > -1 ? n : t.length, s > -1 ? s : t.length);\n        t = t.substring(0, a), e = t.substring(t.lastIndexOf(\".\") + 1);\n      }\n      return e.toLowerCase();\n    }, i.prototype._getMimeFromXhrType = function(t) {\n      switch (t) {\n        case i.XHR_RESPONSE_TYPE.BUFFER:\n          return \"application/octet-binary\";\n        case i.XHR_RESPONSE_TYPE.BLOB:\n          return \"application/blob\";\n        case i.XHR_RESPONSE_TYPE.DOCUMENT:\n          return \"application/xml\";\n        case i.XHR_RESPONSE_TYPE.JSON:\n          return \"application/json\";\n        case i.XHR_RESPONSE_TYPE.DEFAULT:\n        case i.XHR_RESPONSE_TYPE.TEXT:\n        default:\n          return \"text/plain\";\n      }\n    }, i;\n  }()\n);\n(function(i) {\n  (function(t) {\n    t[t.NONE = 0] = \"NONE\", t[t.DATA_URL = 1] = \"DATA_URL\", t[t.COMPLETE = 2] = \"COMPLETE\", t[t.LOADING = 4] = \"LOADING\";\n  })(i.STATUS_FLAGS || (i.STATUS_FLAGS = {})), function(t) {\n    t[t.UNKNOWN = 0] = \"UNKNOWN\", t[t.JSON = 1] = \"JSON\", t[t.XML = 2] = \"XML\", t[t.IMAGE = 3] = \"IMAGE\", t[t.AUDIO = 4] = \"AUDIO\", t[t.VIDEO = 5] = \"VIDEO\", t[t.TEXT = 6] = \"TEXT\";\n  }(i.TYPE || (i.TYPE = {})), function(t) {\n    t[t.XHR = 1] = \"XHR\", t[t.IMAGE = 2] = \"IMAGE\", t[t.AUDIO = 3] = \"AUDIO\", t[t.VIDEO = 4] = \"VIDEO\";\n  }(i.LOAD_TYPE || (i.LOAD_TYPE = {})), function(t) {\n    t.DEFAULT = \"text\", t.BUFFER = \"arraybuffer\", t.BLOB = \"blob\", t.DOCUMENT = \"document\", t.JSON = \"json\", t.TEXT = \"text\";\n  }(i.XHR_RESPONSE_TYPE || (i.XHR_RESPONSE_TYPE = {})), i._loadTypeMap = {\n    // images\n    gif: i.LOAD_TYPE.IMAGE,\n    png: i.LOAD_TYPE.IMAGE,\n    bmp: i.LOAD_TYPE.IMAGE,\n    jpg: i.LOAD_TYPE.IMAGE,\n    jpeg: i.LOAD_TYPE.IMAGE,\n    tif: i.LOAD_TYPE.IMAGE,\n    tiff: i.LOAD_TYPE.IMAGE,\n    webp: i.LOAD_TYPE.IMAGE,\n    tga: i.LOAD_TYPE.IMAGE,\n    avif: i.LOAD_TYPE.IMAGE,\n    svg: i.LOAD_TYPE.IMAGE,\n    \"svg+xml\": i.LOAD_TYPE.IMAGE,\n    // audio\n    mp3: i.LOAD_TYPE.AUDIO,\n    ogg: i.LOAD_TYPE.AUDIO,\n    wav: i.LOAD_TYPE.AUDIO,\n    // videos\n    mp4: i.LOAD_TYPE.VIDEO,\n    webm: i.LOAD_TYPE.VIDEO\n  }, i._xhrTypeMap = {\n    // xml\n    xhtml: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    html: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx: i.XHR_RESPONSE_TYPE.DOCUMENT,\n    // images\n    gif: i.XHR_RESPONSE_TYPE.BLOB,\n    png: i.XHR_RESPONSE_TYPE.BLOB,\n    bmp: i.XHR_RESPONSE_TYPE.BLOB,\n    jpg: i.XHR_RESPONSE_TYPE.BLOB,\n    jpeg: i.XHR_RESPONSE_TYPE.BLOB,\n    tif: i.XHR_RESPONSE_TYPE.BLOB,\n    tiff: i.XHR_RESPONSE_TYPE.BLOB,\n    webp: i.XHR_RESPONSE_TYPE.BLOB,\n    tga: i.XHR_RESPONSE_TYPE.BLOB,\n    avif: i.XHR_RESPONSE_TYPE.BLOB,\n    // json\n    json: i.XHR_RESPONSE_TYPE.JSON,\n    // text\n    text: i.XHR_RESPONSE_TYPE.TEXT,\n    txt: i.XHR_RESPONSE_TYPE.TEXT,\n    // fonts\n    ttf: i.XHR_RESPONSE_TYPE.BUFFER,\n    otf: i.XHR_RESPONSE_TYPE.BUFFER\n  }, i.EMPTY_GIF = \"data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==\";\n})(Ft || (Ft = {}));\nfunction ba() {\n}\nfunction ek(i) {\n  return function() {\n    for (var e = arguments, r = [], n = 0; n < arguments.length; n++)\n      r[n] = e[n];\n    if (i === null)\n      throw new Error(\"Callback was already called.\");\n    var s = i;\n    i = null, s.apply(this, r);\n  };\n}\nvar rk = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this.data = t, this.callback = e;\n    }\n    return i;\n  }()\n), V0 = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      var r = this;\n      if (e === void 0 && (e = 1), this.workers = 0, this.saturated = ba, this.unsaturated = ba, this.empty = ba, this.drain = ba, this.error = ba, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(n, s, a) {\n        if (a && typeof a != \"function\")\n          throw new Error(\"task callback must be a function\");\n        if (r.started = !0, n == null && r.idle()) {\n          setTimeout(function() {\n            return r.drain();\n          }, 1);\n          return;\n        }\n        var o = new rk(n, typeof a == \"function\" ? a : ba);\n        s ? r._tasks.unshift(o) : r._tasks.push(o), setTimeout(r.process, 1);\n      }, this.process = function() {\n        for (; !r.paused && r.workers < r.concurrency && r._tasks.length; ) {\n          var n = r._tasks.shift();\n          r._tasks.length === 0 && r.empty(), r.workers += 1, r.workers === r.concurrency && r.saturated(), r._worker(n.data, ek(r._next(n)));\n        }\n      }, this._worker = t, e === 0)\n        throw new Error(\"Concurrency must not be zero\");\n      this.concurrency = e, this.buffer = e / 4;\n    }\n    return i.prototype._next = function(t) {\n      var e = this;\n      return function() {\n        for (var r = arguments, n = [], s = 0; s < arguments.length; s++)\n          n[s] = r[s];\n        e.workers -= 1, t.callback.apply(t, n), n[0] != null && e.error(n[0], t.data), e.workers <= e.concurrency - e.buffer && e.unsaturated(), e.idle() && e.drain(), e.process();\n      };\n    }, i.prototype.push = function(t, e) {\n      this._insert(t, !1, e);\n    }, i.prototype.kill = function() {\n      this.workers = 0, this.drain = ba, this.started = !1, this._tasks = [];\n    }, i.prototype.unshift = function(t, e) {\n      this._insert(t, !0, e);\n    }, i.prototype.length = function() {\n      return this._tasks.length;\n    }, i.prototype.running = function() {\n      return this.workers;\n    }, i.prototype.idle = function() {\n      return this._tasks.length + this.workers === 0;\n    }, i.prototype.pause = function() {\n      this.paused !== !0 && (this.paused = !0);\n    }, i.prototype.resume = function() {\n      if (this.paused !== !1) {\n        this.paused = !1;\n        for (var t = 1; t <= this.concurrency; t++)\n          this.process();\n      }\n    }, i.eachSeries = function(t, e, r, n) {\n      var s = 0, a = t.length;\n      function o(u) {\n        if (u || s === a) {\n          r && r(u);\n          return;\n        }\n        n ? setTimeout(function() {\n          e(t[s++], o);\n        }, 1) : e(t[s++], o);\n      }\n      o();\n    }, i.queue = function(t, e) {\n      return new i(t, e);\n    }, i;\n  }()\n), X0 = 100, ik = /(#[\\w-]+)?$/, ii = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      var r = this;\n      t === void 0 && (t = \"\"), e === void 0 && (e = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = \"\", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(u, l) {\n        return r._loadResource(u, l);\n      }, this.resources = {}, this.baseUrl = t, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(u, l) {\n        return r._loadResource(u, l);\n      }, this._queue = V0.queue(this._boundLoadResource, e), this._queue.pause(), this.resources = {}, this.onProgress = new ys(), this.onError = new ys(), this.onLoad = new ys(), this.onStart = new ys(), this.onComplete = new ys();\n      for (var n = 0; n < i._plugins.length; ++n) {\n        var s = i._plugins[n], a = s.pre, o = s.use;\n        a && this.pre(a), o && this.use(o);\n      }\n      this._protected = !1;\n    }\n    return i.prototype._add = function(t, e, r, n) {\n      if (this.loading && (!r || !r.parentResource))\n        throw new Error(\"Cannot add resources while the loader is running.\");\n      if (this.resources[t])\n        throw new Error('Resource named \"' + t + '\" already exists.');\n      if (e = this._prepareUrl(e), this.resources[t] = new Ft(t, e, r), typeof n == \"function\" && this.resources[t].onAfterMiddleware.once(n), this.loading) {\n        for (var s = r.parentResource, a = [], o = 0; o < s.children.length; ++o)\n          s.children[o].isComplete || a.push(s.children[o]);\n        var u = s.progressChunk * (a.length + 1), l = u / (a.length + 2);\n        s.children.push(this.resources[t]), s.progressChunk = l;\n        for (var o = 0; o < a.length; ++o)\n          a[o].progressChunk = l;\n        this.resources[t].progressChunk = l;\n      }\n      return this._queue.push(this.resources[t]), this;\n    }, i.prototype.pre = function(t) {\n      return this._beforeMiddleware.push(t), this;\n    }, i.prototype.use = function(t) {\n      return this._afterMiddleware.push(t), this;\n    }, i.prototype.reset = function() {\n      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();\n      for (var t in this.resources) {\n        var e = this.resources[t];\n        e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort(\"loader reset\");\n      }\n      return this.resources = {}, this;\n    }, i.prototype.load = function(t) {\n      if (jr(\"6.5.0\", \"@pixi/loaders is being replaced with @pixi/assets in the next major release.\"), typeof t == \"function\" && this.onComplete.once(t), this.loading)\n        return this;\n      if (this._queue.idle())\n        this._onStart(), this._onComplete();\n      else {\n        for (var e = this._queue._tasks.length, r = X0 / e, n = 0; n < this._queue._tasks.length; ++n)\n          this._queue._tasks[n].data.progressChunk = r;\n        this._onStart(), this._queue.resume();\n      }\n      return this;\n    }, Object.defineProperty(i.prototype, \"concurrency\", {\n      /**\n       * The number of resources to load concurrently.\n       * @default 10\n       */\n      get: function() {\n        return this._queue.concurrency;\n      },\n      set: function(t) {\n        this._queue.concurrency = t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype._prepareUrl = function(t) {\n      var e = pS(t, { strictMode: !0 }), r;\n      if (e.protocol || !e.path || t.indexOf(\"//\") === 0 ? r = t : this.baseUrl.length && this.baseUrl.lastIndexOf(\"/\") !== this.baseUrl.length - 1 && t.charAt(0) !== \"/\" ? r = this.baseUrl + \"/\" + t : r = this.baseUrl + t, this.defaultQueryString) {\n        var n = ik.exec(r)[0];\n        r = r.slice(0, r.length - n.length), r.indexOf(\"?\") !== -1 ? r += \"&\" + this.defaultQueryString : r += \"?\" + this.defaultQueryString, r += n;\n      }\n      return r;\n    }, i.prototype._loadResource = function(t, e) {\n      var r = this;\n      t._dequeue = e, V0.eachSeries(this._beforeMiddleware, function(n, s) {\n        n.call(r, t, function() {\n          s(t.isComplete ? {} : null);\n        });\n      }, function() {\n        t.isComplete ? r._onLoad(t) : (t._onLoadBinding = t.onComplete.once(r._onLoad, r), t.load());\n      }, !0);\n    }, i.prototype._onStart = function() {\n      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);\n    }, i.prototype._onComplete = function() {\n      this.progress = X0, this.loading = !1, this.onComplete.dispatch(this, this.resources);\n    }, i.prototype._onLoad = function(t) {\n      var e = this;\n      t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), V0.eachSeries(this._afterMiddleware, function(r, n) {\n        r.call(e, t, n);\n      }, function() {\n        t.onAfterMiddleware.dispatch(t), e.progress = Math.min(X0, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && e._resourcesParsing.length === 0 && e._onComplete();\n      }, !0);\n    }, i.prototype.destroy = function() {\n      this._protected || this.reset();\n    }, Object.defineProperty(i, \"shared\", {\n      /** A premade instance of the loader that can be used to load resources. */\n      get: function() {\n        var t = i._shared;\n        return t || (t = new i(), t._protected = !0, i._shared = t), t;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.registerPlugin = function(t) {\n      return jr(\"6.5.0\", \"Loader.registerPlugin() is deprecated, use extensions.add() instead.\"), an.add({\n        type: fe.Loader,\n        ref: t\n      }), i;\n    }, i._plugins = [], i;\n  }()\n);\nan.handleByList(fe.Loader, ii._plugins);\nii.prototype.add = function(t, e, r, n) {\n  if (Array.isArray(t)) {\n    for (var s = 0; s < t.length; ++s)\n      this.add(t[s]);\n    return this;\n  }\n  if (typeof t == \"object\" && (r = t, n = e || r.callback || r.onComplete, e = r.url, t = r.name || r.key || r.url), typeof e != \"string\" && (n = r, r = e, e = t), typeof e != \"string\")\n    throw new Error(\"No url passed to add resource to loader.\");\n  return typeof r == \"function\" && (n = r, r = null), this._add(t, e, r, n);\n};\nvar nk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.init = function(t) {\n      t = Object.assign({\n        sharedLoader: !1\n      }, t), this.loader = t.sharedLoader ? ii.shared : new ii();\n    }, i.destroy = function() {\n      this.loader && (this.loader.destroy(), this.loader = null);\n    }, i.extension = fe.Application, i;\n  }()\n), sk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.add = function() {\n      Ft.setExtensionLoadType(\"svg\", Ft.LOAD_TYPE.XHR), Ft.setExtensionXhrType(\"svg\", Ft.XHR_RESPONSE_TYPE.TEXT);\n    }, i.use = function(t, e) {\n      if (t.data && (t.type === Ft.TYPE.IMAGE || t.extension === \"svg\")) {\n        var r = t.data, n = t.url, s = t.name, a = t.metadata;\n        Ot.fromLoader(r, n, s, a).then(function(o) {\n          t.texture = o, e();\n        }).catch(e);\n      } else\n        e();\n    }, i.extension = fe.Loader, i;\n  }()\n), ak = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nfunction ok(i) {\n  for (var t = \"\", e = 0; e < i.length; ) {\n    for (var r = [0, 0, 0], n = [0, 0, 0, 0], s = 0; s < r.length; ++s)\n      e < i.length ? r[s] = i.charCodeAt(e++) & 255 : r[s] = 0;\n    n[0] = r[0] >> 2, n[1] = (r[0] & 3) << 4 | r[1] >> 4, n[2] = (r[1] & 15) << 2 | r[2] >> 6, n[3] = r[2] & 63;\n    var a = e - (i.length - 1);\n    switch (a) {\n      case 2:\n        n[3] = 64, n[2] = 64;\n        break;\n      case 1:\n        n[3] = 64;\n        break;\n    }\n    for (var s = 0; s < n.length; ++s)\n      t += ak.charAt(n[s]);\n  }\n  return t;\n}\nfunction uk(i, t) {\n  if (!i.data) {\n    t();\n    return;\n  }\n  if (i.xhr && i.xhrType === Ft.XHR_RESPONSE_TYPE.BLOB) {\n    if (!self.Blob || typeof i.data == \"string\") {\n      var e = i.xhr.getResponseHeader(\"content-type\");\n      if (e && e.indexOf(\"image\") === 0) {\n        i.data = new Image(), i.data.src = \"data:\" + e + \";base64,\" + ok(i.xhr.responseText), i.type = Ft.TYPE.IMAGE, i.data.onload = function() {\n          i.data.onload = null, t();\n        };\n        return;\n      }\n    } else if (i.data.type.indexOf(\"image\") === 0) {\n      var r = globalThis.URL || globalThis.webkitURL, n = r.createObjectURL(i.data);\n      i.blob = i.data, i.data = new Image(), i.data.src = n, i.type = Ft.TYPE.IMAGE, i.data.onload = function() {\n        r.revokeObjectURL(n), i.data.onload = null, t();\n      };\n      return;\n    }\n  }\n  t();\n}\nvar lk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.extension = fe.Loader, i.use = uk, i;\n  }()\n);\nan.add(sk, lk);\n/*!\n * @pixi/compressed-textures - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/compressed-textures is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar le, jt;\n(function(i) {\n  i[i.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = \"COMPRESSED_RGB_S3TC_DXT1_EXT\", i[i.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = \"COMPRESSED_RGBA_S3TC_DXT1_EXT\", i[i.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = \"COMPRESSED_RGBA_S3TC_DXT3_EXT\", i[i.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = \"COMPRESSED_RGBA_S3TC_DXT5_EXT\", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT\", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT\", i[i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = \"COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT\", i[i.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = \"COMPRESSED_SRGB_S3TC_DXT1_EXT\", i[i.COMPRESSED_R11_EAC = 37488] = \"COMPRESSED_R11_EAC\", i[i.COMPRESSED_SIGNED_R11_EAC = 37489] = \"COMPRESSED_SIGNED_R11_EAC\", i[i.COMPRESSED_RG11_EAC = 37490] = \"COMPRESSED_RG11_EAC\", i[i.COMPRESSED_SIGNED_RG11_EAC = 37491] = \"COMPRESSED_SIGNED_RG11_EAC\", i[i.COMPRESSED_RGB8_ETC2 = 37492] = \"COMPRESSED_RGB8_ETC2\", i[i.COMPRESSED_RGBA8_ETC2_EAC = 37496] = \"COMPRESSED_RGBA8_ETC2_EAC\", i[i.COMPRESSED_SRGB8_ETC2 = 37493] = \"COMPRESSED_SRGB8_ETC2\", i[i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\", i[i.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\", i[i.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\", i[i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\", i[i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\", i[i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\", i[i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\", i[i.COMPRESSED_RGB_ETC1_WEBGL = 36196] = \"COMPRESSED_RGB_ETC1_WEBGL\", i[i.COMPRESSED_RGB_ATC_WEBGL = 35986] = \"COMPRESSED_RGB_ATC_WEBGL\", i[i.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\", i[i.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = \"COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\", i[i.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = \"COMPRESSED_RGBA_ASTC_4x4_KHR\";\n})(jt || (jt = {}));\nvar bv = (le = {}, // WEBGL_compressed_texture_s3tc\nle[jt.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, le[jt.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, le[jt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, le[jt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc\nle[jt.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, le[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, le[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, le[jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc\nle[jt.COMPRESSED_R11_EAC] = 0.5, le[jt.COMPRESSED_SIGNED_R11_EAC] = 0.5, le[jt.COMPRESSED_RG11_EAC] = 1, le[jt.COMPRESSED_SIGNED_RG11_EAC] = 1, le[jt.COMPRESSED_RGB8_ETC2] = 0.5, le[jt.COMPRESSED_RGBA8_ETC2_EAC] = 1, le[jt.COMPRESSED_SRGB8_ETC2] = 0.5, le[jt.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, le[jt.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, le[jt.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc\nle[jt.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, le[jt.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, le[jt.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, le[jt.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1\nle[jt.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt\n// WEBGL_compressed_texture_atc\nle[jt.COMPRESSED_RGB_ATC_WEBGL] = 0.5, le[jt.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, le[jt.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt\n// WEBGL_compressed_texture_astc\n/* eslint-disable-next-line camelcase */\nle[jt.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, le);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Ty = function(i, t) {\n  return Ty = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Ty(i, t);\n};\nfunction vS(i, t) {\n  Ty(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction hk(i, t, e, r) {\n  function n(s) {\n    return s instanceof e ? s : new e(function(a) {\n      a(s);\n    });\n  }\n  return new (e || (e = Promise))(function(s, a) {\n    function o(h) {\n      try {\n        l(r.next(h));\n      } catch (d) {\n        a(d);\n      }\n    }\n    function u(h) {\n      try {\n        l(r.throw(h));\n      } catch (d) {\n        a(d);\n      }\n    }\n    function l(h) {\n      h.done ? s(h.value) : n(h.value).then(o, u);\n    }\n    l((r = r.apply(i, t || [])).next());\n  });\n}\nfunction ck(i, t) {\n  var e = { label: 0, sent: function() {\n    if (s[0] & 1)\n      throw s[1];\n    return s[1];\n  }, trys: [], ops: [] }, r, n, s, a;\n  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == \"function\" && (a[Symbol.iterator] = function() {\n    return this;\n  }), a;\n  function o(l) {\n    return function(h) {\n      return u([l, h]);\n    };\n  }\n  function u(l) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; e; )\n      try {\n        if (r = 1, n && (s = l[0] & 2 ? n.return : l[0] ? n.throw || ((s = n.return) && s.call(n), 0) : n.next) && !(s = s.call(n, l[1])).done)\n          return s;\n        switch (n = 0, s && (l = [l[0] & 2, s.value]), l[0]) {\n          case 0:\n          case 1:\n            s = l;\n            break;\n          case 4:\n            return e.label++, { value: l[1], done: !1 };\n          case 5:\n            e.label++, n = l[1], l = [0];\n            continue;\n          case 7:\n            l = e.ops.pop(), e.trys.pop();\n            continue;\n          default:\n            if (s = e.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {\n              e = 0;\n              continue;\n            }\n            if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {\n              e.label = l[1];\n              break;\n            }\n            if (l[0] === 6 && e.label < s[1]) {\n              e.label = s[1], s = l;\n              break;\n            }\n            if (s && e.label < s[2]) {\n              e.label = s[2], e.ops.push(l);\n              break;\n            }\n            s[2] && e.ops.pop(), e.trys.pop();\n            continue;\n        }\n        l = t.call(i, e);\n      } catch (h) {\n        l = [6, h], n = 0;\n      } finally {\n        r = s = 0;\n      }\n    if (l[0] & 5)\n      throw l[1];\n    return { value: l[0] ? l[1] : void 0, done: !0 };\n  }\n}\nvar fk = (\n  /** @class */\n  function(i) {\n    vS(t, i);\n    function t(e, r) {\n      r === void 0 && (r = { width: 1, height: 1, autoLoad: !0 });\n      var n = this, s, a;\n      return typeof e == \"string\" ? (s = e, a = new Uint8Array()) : (s = null, a = e), n = i.call(this, a, r) || this, n.origin = s, n.buffer = a ? new _v(a) : null, n.origin && r.autoLoad !== !1 && n.load(), a && a.length && (n.loaded = !0, n.onBlobLoaded(n.buffer.rawBinaryData)), n;\n    }\n    return t.prototype.onBlobLoaded = function(e) {\n    }, t.prototype.load = function() {\n      return hk(this, void 0, Promise, function() {\n        var e, r, n;\n        return ck(this, function(s) {\n          switch (s.label) {\n            case 0:\n              return [4, fetch(this.origin)];\n            case 1:\n              return e = s.sent(), [4, e.blob()];\n            case 2:\n              return r = s.sent(), [4, r.arrayBuffer()];\n            case 3:\n              return n = s.sent(), this.data = new Uint32Array(n), this.buffer = new _v(n), this.loaded = !0, this.onBlobLoaded(n), this.update(), [2, this];\n          }\n        });\n      });\n    }, t;\n  }(au)\n), Cy = (\n  /** @class */\n  function(i) {\n    vS(t, i);\n    function t(e, r) {\n      var n = i.call(this, e, r) || this;\n      return n.format = r.format, n.levels = r.levels || 1, n._width = r.width, n._height = r.height, n._extension = t._formatToExtension(n.format), (r.levelBuffers || n.buffer) && (n._levelBuffers = r.levelBuffers || t._createLevelBuffers(\n        e instanceof Uint8Array ? e : n.buffer.uint8View,\n        n.format,\n        n.levels,\n        4,\n        4,\n        // PVRTC has 8x4 blocks in 2bpp mode\n        n.width,\n        n.height\n      )), n;\n    }\n    return t.prototype.upload = function(e, r, n) {\n      var s = e.gl, a = e.context.extensions[this._extension];\n      if (!a)\n        throw new Error(this._extension + \" textures are not supported on the current machine\");\n      if (!this._levelBuffers)\n        return !1;\n      for (var o = 0, u = this.levels; o < u; o++) {\n        var l = this._levelBuffers[o], h = l.levelID, d = l.levelWidth, f = l.levelHeight, p = l.levelBuffer;\n        s.compressedTexImage2D(s.TEXTURE_2D, h, this.format, d, f, 0, p);\n      }\n      return !0;\n    }, t.prototype.onBlobLoaded = function() {\n      this._levelBuffers = t._createLevelBuffers(\n        this.buffer.uint8View,\n        this.format,\n        this.levels,\n        4,\n        4,\n        // PVRTC has 8x4 blocks in 2bpp mode\n        this.width,\n        this.height\n      );\n    }, t._formatToExtension = function(e) {\n      if (e >= 33776 && e <= 33779)\n        return \"s3tc\";\n      if (e >= 37488 && e <= 37497)\n        return \"etc\";\n      if (e >= 35840 && e <= 35843)\n        return \"pvrtc\";\n      if (e >= 36196)\n        return \"etc1\";\n      if (e >= 35986 && e <= 34798)\n        return \"atc\";\n      throw new Error(\"Invalid (compressed) texture format given!\");\n    }, t._createLevelBuffers = function(e, r, n, s, a, o, u) {\n      for (var l = new Array(n), h = e.byteOffset, d = o, f = u, p = d + s - 1 & ~(s - 1), v = f + a - 1 & ~(a - 1), g = p * v * bv[r], m = 0; m < n; m++)\n        l[m] = {\n          levelID: m,\n          levelWidth: n > 1 ? d : p,\n          levelHeight: n > 1 ? f : v,\n          levelBuffer: new Uint8Array(e.buffer, h, g)\n        }, h += g, d = d >> 1 || 1, f = f >> 1 || 1, p = d + s - 1 & ~(s - 1), v = f + a - 1 & ~(a - 1), g = p * v * bv[r];\n      return l;\n    }, t;\n  }(fk)\n), dk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.use = function(t, e) {\n      var r = t.data, n = this;\n      if (t.type === Ft.TYPE.JSON && r && r.cacheID && r.textures) {\n        for (var s = r.textures, a = void 0, o = void 0, u = 0, l = s.length; u < l; u++) {\n          var h = s[u], d = h.src, f = h.format;\n          if (f || (o = d), i.textureFormats[f]) {\n            a = d;\n            break;\n          }\n        }\n        if (a = a || o, !a) {\n          e(new Error(\"Cannot load compressed-textures in \" + t.url + \", make sure you provide a fallback\"));\n          return;\n        }\n        if (a === t.url) {\n          e(new Error(\"URL of compressed texture cannot be the same as the manifest's URL\"));\n          return;\n        }\n        var p = {\n          crossOrigin: t.crossOrigin,\n          metadata: t.metadata.imageMetadata,\n          parentResource: t\n        }, v = Mu.resolve(t.url.replace(n.baseUrl, \"\"), a), g = r.cacheID;\n        n.add(g, v, p, function(m) {\n          if (m.error) {\n            e(m.error);\n            return;\n          }\n          var y = m.texture, _ = y === void 0 ? null : y, b = m.textures, w = b === void 0 ? {} : b;\n          Object.assign(t, { texture: _, textures: w }), e();\n        });\n      } else\n        e();\n    }, Object.defineProperty(i, \"textureExtensions\", {\n      /**  Map of available texture extensions. */\n      get: function() {\n        if (!i._textureExtensions) {\n          var t = gt.ADAPTER.createCanvas(), e = t.getContext(\"webgl\");\n          if (!e)\n            return console.warn(\"WebGL not available for compressed textures. Silently failing.\"), {};\n          var r = {\n            s3tc: e.getExtension(\"WEBGL_compressed_texture_s3tc\"),\n            s3tc_sRGB: e.getExtension(\"WEBGL_compressed_texture_s3tc_srgb\"),\n            etc: e.getExtension(\"WEBGL_compressed_texture_etc\"),\n            etc1: e.getExtension(\"WEBGL_compressed_texture_etc1\"),\n            pvrtc: e.getExtension(\"WEBGL_compressed_texture_pvrtc\") || e.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\"),\n            atc: e.getExtension(\"WEBGL_compressed_texture_atc\"),\n            astc: e.getExtension(\"WEBGL_compressed_texture_astc\")\n          };\n          i._textureExtensions = r;\n        }\n        return i._textureExtensions;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"textureFormats\", {\n      /** Map of available texture formats. */\n      get: function() {\n        if (!i._textureFormats) {\n          var t = i.textureExtensions;\n          i._textureFormats = {};\n          for (var e in t) {\n            var r = t[e];\n            r && Object.assign(i._textureFormats, Object.getPrototypeOf(r));\n          }\n        }\n        return i._textureFormats;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.extension = fe.Loader, i;\n  }()\n);\nfunction gS(i, t, e) {\n  var r = {\n    textures: {},\n    texture: null\n  };\n  if (!t)\n    return r;\n  var n = t.map(function(s) {\n    return new Ot(new Kt(s, Object.assign({\n      mipmap: tn.OFF,\n      alphaMode: en.NO_PREMULTIPLIED_ALPHA\n    }, e)));\n  });\n  return n.forEach(function(s, a) {\n    var o = s.baseTexture, u = i + \"-\" + (a + 1);\n    Kt.addToCache(o, u), Ot.addToCache(s, u), a === 0 && (Kt.addToCache(o, i), Ot.addToCache(s, i), r.texture = s), r.textures[u] = s;\n  }), r;\n}\nvar xh, Oi, W0 = 4, tp = 124, pk = 32, G1 = 20, vk = 542327876, ep = {\n  SIZE: 1,\n  FLAGS: 2,\n  HEIGHT: 3,\n  WIDTH: 4,\n  MIPMAP_COUNT: 7,\n  PIXEL_FORMAT: 19\n}, gk = {\n  SIZE: 0,\n  FLAGS: 1,\n  FOURCC: 2,\n  RGB_BITCOUNT: 3,\n  R_BIT_MASK: 4,\n  G_BIT_MASK: 5,\n  B_BIT_MASK: 6,\n  A_BIT_MASK: 7\n}, rp = {\n  DXGI_FORMAT: 0,\n  RESOURCE_DIMENSION: 1,\n  MISC_FLAG: 2,\n  ARRAY_SIZE: 3,\n  MISC_FLAGS2: 4\n}, Ri;\n(function(i) {\n  i[i.DXGI_FORMAT_UNKNOWN = 0] = \"DXGI_FORMAT_UNKNOWN\", i[i.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = \"DXGI_FORMAT_R32G32B32A32_TYPELESS\", i[i.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = \"DXGI_FORMAT_R32G32B32A32_FLOAT\", i[i.DXGI_FORMAT_R32G32B32A32_UINT = 3] = \"DXGI_FORMAT_R32G32B32A32_UINT\", i[i.DXGI_FORMAT_R32G32B32A32_SINT = 4] = \"DXGI_FORMAT_R32G32B32A32_SINT\", i[i.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = \"DXGI_FORMAT_R32G32B32_TYPELESS\", i[i.DXGI_FORMAT_R32G32B32_FLOAT = 6] = \"DXGI_FORMAT_R32G32B32_FLOAT\", i[i.DXGI_FORMAT_R32G32B32_UINT = 7] = \"DXGI_FORMAT_R32G32B32_UINT\", i[i.DXGI_FORMAT_R32G32B32_SINT = 8] = \"DXGI_FORMAT_R32G32B32_SINT\", i[i.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = \"DXGI_FORMAT_R16G16B16A16_TYPELESS\", i[i.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = \"DXGI_FORMAT_R16G16B16A16_FLOAT\", i[i.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = \"DXGI_FORMAT_R16G16B16A16_UNORM\", i[i.DXGI_FORMAT_R16G16B16A16_UINT = 12] = \"DXGI_FORMAT_R16G16B16A16_UINT\", i[i.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = \"DXGI_FORMAT_R16G16B16A16_SNORM\", i[i.DXGI_FORMAT_R16G16B16A16_SINT = 14] = \"DXGI_FORMAT_R16G16B16A16_SINT\", i[i.DXGI_FORMAT_R32G32_TYPELESS = 15] = \"DXGI_FORMAT_R32G32_TYPELESS\", i[i.DXGI_FORMAT_R32G32_FLOAT = 16] = \"DXGI_FORMAT_R32G32_FLOAT\", i[i.DXGI_FORMAT_R32G32_UINT = 17] = \"DXGI_FORMAT_R32G32_UINT\", i[i.DXGI_FORMAT_R32G32_SINT = 18] = \"DXGI_FORMAT_R32G32_SINT\", i[i.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = \"DXGI_FORMAT_R32G8X24_TYPELESS\", i[i.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = \"DXGI_FORMAT_D32_FLOAT_S8X24_UINT\", i[i.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = \"DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS\", i[i.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = \"DXGI_FORMAT_X32_TYPELESS_G8X24_UINT\", i[i.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = \"DXGI_FORMAT_R10G10B10A2_TYPELESS\", i[i.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = \"DXGI_FORMAT_R10G10B10A2_UNORM\", i[i.DXGI_FORMAT_R10G10B10A2_UINT = 25] = \"DXGI_FORMAT_R10G10B10A2_UINT\", i[i.DXGI_FORMAT_R11G11B10_FLOAT = 26] = \"DXGI_FORMAT_R11G11B10_FLOAT\", i[i.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = \"DXGI_FORMAT_R8G8B8A8_TYPELESS\", i[i.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = \"DXGI_FORMAT_R8G8B8A8_UNORM\", i[i.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = \"DXGI_FORMAT_R8G8B8A8_UNORM_SRGB\", i[i.DXGI_FORMAT_R8G8B8A8_UINT = 30] = \"DXGI_FORMAT_R8G8B8A8_UINT\", i[i.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = \"DXGI_FORMAT_R8G8B8A8_SNORM\", i[i.DXGI_FORMAT_R8G8B8A8_SINT = 32] = \"DXGI_FORMAT_R8G8B8A8_SINT\", i[i.DXGI_FORMAT_R16G16_TYPELESS = 33] = \"DXGI_FORMAT_R16G16_TYPELESS\", i[i.DXGI_FORMAT_R16G16_FLOAT = 34] = \"DXGI_FORMAT_R16G16_FLOAT\", i[i.DXGI_FORMAT_R16G16_UNORM = 35] = \"DXGI_FORMAT_R16G16_UNORM\", i[i.DXGI_FORMAT_R16G16_UINT = 36] = \"DXGI_FORMAT_R16G16_UINT\", i[i.DXGI_FORMAT_R16G16_SNORM = 37] = \"DXGI_FORMAT_R16G16_SNORM\", i[i.DXGI_FORMAT_R16G16_SINT = 38] = \"DXGI_FORMAT_R16G16_SINT\", i[i.DXGI_FORMAT_R32_TYPELESS = 39] = \"DXGI_FORMAT_R32_TYPELESS\", i[i.DXGI_FORMAT_D32_FLOAT = 40] = \"DXGI_FORMAT_D32_FLOAT\", i[i.DXGI_FORMAT_R32_FLOAT = 41] = \"DXGI_FORMAT_R32_FLOAT\", i[i.DXGI_FORMAT_R32_UINT = 42] = \"DXGI_FORMAT_R32_UINT\", i[i.DXGI_FORMAT_R32_SINT = 43] = \"DXGI_FORMAT_R32_SINT\", i[i.DXGI_FORMAT_R24G8_TYPELESS = 44] = \"DXGI_FORMAT_R24G8_TYPELESS\", i[i.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = \"DXGI_FORMAT_D24_UNORM_S8_UINT\", i[i.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = \"DXGI_FORMAT_R24_UNORM_X8_TYPELESS\", i[i.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = \"DXGI_FORMAT_X24_TYPELESS_G8_UINT\", i[i.DXGI_FORMAT_R8G8_TYPELESS = 48] = \"DXGI_FORMAT_R8G8_TYPELESS\", i[i.DXGI_FORMAT_R8G8_UNORM = 49] = \"DXGI_FORMAT_R8G8_UNORM\", i[i.DXGI_FORMAT_R8G8_UINT = 50] = \"DXGI_FORMAT_R8G8_UINT\", i[i.DXGI_FORMAT_R8G8_SNORM = 51] = \"DXGI_FORMAT_R8G8_SNORM\", i[i.DXGI_FORMAT_R8G8_SINT = 52] = \"DXGI_FORMAT_R8G8_SINT\", i[i.DXGI_FORMAT_R16_TYPELESS = 53] = \"DXGI_FORMAT_R16_TYPELESS\", i[i.DXGI_FORMAT_R16_FLOAT = 54] = \"DXGI_FORMAT_R16_FLOAT\", i[i.DXGI_FORMAT_D16_UNORM = 55] = \"DXGI_FORMAT_D16_UNORM\", i[i.DXGI_FORMAT_R16_UNORM = 56] = \"DXGI_FORMAT_R16_UNORM\", i[i.DXGI_FORMAT_R16_UINT = 57] = \"DXGI_FORMAT_R16_UINT\", i[i.DXGI_FORMAT_R16_SNORM = 58] = \"DXGI_FORMAT_R16_SNORM\", i[i.DXGI_FORMAT_R16_SINT = 59] = \"DXGI_FORMAT_R16_SINT\", i[i.DXGI_FORMAT_R8_TYPELESS = 60] = \"DXGI_FORMAT_R8_TYPELESS\", i[i.DXGI_FORMAT_R8_UNORM = 61] = \"DXGI_FORMAT_R8_UNORM\", i[i.DXGI_FORMAT_R8_UINT = 62] = \"DXGI_FORMAT_R8_UINT\", i[i.DXGI_FORMAT_R8_SNORM = 63] = \"DXGI_FORMAT_R8_SNORM\", i[i.DXGI_FORMAT_R8_SINT = 64] = \"DXGI_FORMAT_R8_SINT\", i[i.DXGI_FORMAT_A8_UNORM = 65] = \"DXGI_FORMAT_A8_UNORM\", i[i.DXGI_FORMAT_R1_UNORM = 66] = \"DXGI_FORMAT_R1_UNORM\", i[i.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = \"DXGI_FORMAT_R9G9B9E5_SHAREDEXP\", i[i.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = \"DXGI_FORMAT_R8G8_B8G8_UNORM\", i[i.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = \"DXGI_FORMAT_G8R8_G8B8_UNORM\", i[i.DXGI_FORMAT_BC1_TYPELESS = 70] = \"DXGI_FORMAT_BC1_TYPELESS\", i[i.DXGI_FORMAT_BC1_UNORM = 71] = \"DXGI_FORMAT_BC1_UNORM\", i[i.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = \"DXGI_FORMAT_BC1_UNORM_SRGB\", i[i.DXGI_FORMAT_BC2_TYPELESS = 73] = \"DXGI_FORMAT_BC2_TYPELESS\", i[i.DXGI_FORMAT_BC2_UNORM = 74] = \"DXGI_FORMAT_BC2_UNORM\", i[i.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = \"DXGI_FORMAT_BC2_UNORM_SRGB\", i[i.DXGI_FORMAT_BC3_TYPELESS = 76] = \"DXGI_FORMAT_BC3_TYPELESS\", i[i.DXGI_FORMAT_BC3_UNORM = 77] = \"DXGI_FORMAT_BC3_UNORM\", i[i.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = \"DXGI_FORMAT_BC3_UNORM_SRGB\", i[i.DXGI_FORMAT_BC4_TYPELESS = 79] = \"DXGI_FORMAT_BC4_TYPELESS\", i[i.DXGI_FORMAT_BC4_UNORM = 80] = \"DXGI_FORMAT_BC4_UNORM\", i[i.DXGI_FORMAT_BC4_SNORM = 81] = \"DXGI_FORMAT_BC4_SNORM\", i[i.DXGI_FORMAT_BC5_TYPELESS = 82] = \"DXGI_FORMAT_BC5_TYPELESS\", i[i.DXGI_FORMAT_BC5_UNORM = 83] = \"DXGI_FORMAT_BC5_UNORM\", i[i.DXGI_FORMAT_BC5_SNORM = 84] = \"DXGI_FORMAT_BC5_SNORM\", i[i.DXGI_FORMAT_B5G6R5_UNORM = 85] = \"DXGI_FORMAT_B5G6R5_UNORM\", i[i.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = \"DXGI_FORMAT_B5G5R5A1_UNORM\", i[i.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = \"DXGI_FORMAT_B8G8R8A8_UNORM\", i[i.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = \"DXGI_FORMAT_B8G8R8X8_UNORM\", i[i.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = \"DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM\", i[i.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = \"DXGI_FORMAT_B8G8R8A8_TYPELESS\", i[i.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = \"DXGI_FORMAT_B8G8R8A8_UNORM_SRGB\", i[i.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = \"DXGI_FORMAT_B8G8R8X8_TYPELESS\", i[i.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = \"DXGI_FORMAT_B8G8R8X8_UNORM_SRGB\", i[i.DXGI_FORMAT_BC6H_TYPELESS = 94] = \"DXGI_FORMAT_BC6H_TYPELESS\", i[i.DXGI_FORMAT_BC6H_UF16 = 95] = \"DXGI_FORMAT_BC6H_UF16\", i[i.DXGI_FORMAT_BC6H_SF16 = 96] = \"DXGI_FORMAT_BC6H_SF16\", i[i.DXGI_FORMAT_BC7_TYPELESS = 97] = \"DXGI_FORMAT_BC7_TYPELESS\", i[i.DXGI_FORMAT_BC7_UNORM = 98] = \"DXGI_FORMAT_BC7_UNORM\", i[i.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = \"DXGI_FORMAT_BC7_UNORM_SRGB\", i[i.DXGI_FORMAT_AYUV = 100] = \"DXGI_FORMAT_AYUV\", i[i.DXGI_FORMAT_Y410 = 101] = \"DXGI_FORMAT_Y410\", i[i.DXGI_FORMAT_Y416 = 102] = \"DXGI_FORMAT_Y416\", i[i.DXGI_FORMAT_NV12 = 103] = \"DXGI_FORMAT_NV12\", i[i.DXGI_FORMAT_P010 = 104] = \"DXGI_FORMAT_P010\", i[i.DXGI_FORMAT_P016 = 105] = \"DXGI_FORMAT_P016\", i[i.DXGI_FORMAT_420_OPAQUE = 106] = \"DXGI_FORMAT_420_OPAQUE\", i[i.DXGI_FORMAT_YUY2 = 107] = \"DXGI_FORMAT_YUY2\", i[i.DXGI_FORMAT_Y210 = 108] = \"DXGI_FORMAT_Y210\", i[i.DXGI_FORMAT_Y216 = 109] = \"DXGI_FORMAT_Y216\", i[i.DXGI_FORMAT_NV11 = 110] = \"DXGI_FORMAT_NV11\", i[i.DXGI_FORMAT_AI44 = 111] = \"DXGI_FORMAT_AI44\", i[i.DXGI_FORMAT_IA44 = 112] = \"DXGI_FORMAT_IA44\", i[i.DXGI_FORMAT_P8 = 113] = \"DXGI_FORMAT_P8\", i[i.DXGI_FORMAT_A8P8 = 114] = \"DXGI_FORMAT_A8P8\", i[i.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = \"DXGI_FORMAT_B4G4R4A4_UNORM\", i[i.DXGI_FORMAT_P208 = 116] = \"DXGI_FORMAT_P208\", i[i.DXGI_FORMAT_V208 = 117] = \"DXGI_FORMAT_V208\", i[i.DXGI_FORMAT_V408 = 118] = \"DXGI_FORMAT_V408\", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE\", i[i.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = \"DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE\", i[i.DXGI_FORMAT_FORCE_UINT = 121] = \"DXGI_FORMAT_FORCE_UINT\";\n})(Ri || (Ri = {}));\nvar My;\n(function(i) {\n  i[i.DDS_DIMENSION_TEXTURE1D = 2] = \"DDS_DIMENSION_TEXTURE1D\", i[i.DDS_DIMENSION_TEXTURE2D = 3] = \"DDS_DIMENSION_TEXTURE2D\", i[i.DDS_DIMENSION_TEXTURE3D = 6] = \"DDS_DIMENSION_TEXTURE3D\";\n})(My || (My = {}));\nvar mk = 1, yk = 2, _k = 4, bk = 64, xk = 512, wk = 131072, Ek = 827611204, Sk = 861165636, Tk = 894720068, Ck = 808540228, Mk = 4, Pk = (xh = {}, xh[Ek] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, xh[Sk] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, xh[Tk] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, xh), Ok = (Oi = {}, // WEBGL_compressed_texture_s3tc\nOi[Ri.DXGI_FORMAT_BC1_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC1_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC2_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC2_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC3_TYPELESS] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, Oi[Ri.DXGI_FORMAT_BC3_UNORM] = jt.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb\nOi[Ri.DXGI_FORMAT_BC1_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, Oi[Ri.DXGI_FORMAT_BC2_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, Oi[Ri.DXGI_FORMAT_BC3_UNORM_SRGB] = jt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, Oi);\nfunction Ik(i) {\n  var t = new Uint32Array(i), e = t[0];\n  if (e !== vk)\n    throw new Error(\"Invalid DDS file magic word\");\n  var r = new Uint32Array(i, 0, tp / Uint32Array.BYTES_PER_ELEMENT), n = r[ep.HEIGHT], s = r[ep.WIDTH], a = r[ep.MIPMAP_COUNT], o = new Uint32Array(i, ep.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, pk / Uint32Array.BYTES_PER_ELEMENT), u = o[mk];\n  if (u & _k) {\n    var l = o[gk.FOURCC];\n    if (l !== Ck) {\n      var h = Pk[l], d = W0 + tp, f = new Uint8Array(i, d), p = new Cy(f, {\n        format: h,\n        width: s,\n        height: n,\n        levels: a\n        // CompressedTextureResource will separate the levelBuffers for us!\n      });\n      return [p];\n    }\n    var v = W0 + tp, g = new Uint32Array(t.buffer, v, G1 / Uint32Array.BYTES_PER_ELEMENT), m = g[rp.DXGI_FORMAT], y = g[rp.RESOURCE_DIMENSION], _ = g[rp.MISC_FLAG], b = g[rp.ARRAY_SIZE], w = Ok[m];\n    if (w === void 0)\n      throw new Error(\"DDSParser cannot parse texture data with DXGI format \" + m);\n    if (_ === Mk)\n      throw new Error(\"DDSParser does not support cubemap textures\");\n    if (y === My.DDS_DIMENSION_TEXTURE3D)\n      throw new Error(\"DDSParser does not supported 3D texture data\");\n    var T = new Array(), x = W0 + tp + G1;\n    if (b === 1)\n      T.push(new Uint8Array(i, x));\n    else {\n      for (var S = bv[w], C = 0, M = s, I = n, R = 0; R < a; R++) {\n        var N = Math.max(1, M + 3 & -4), A = Math.max(1, I + 3 & -4), U = N * A * S;\n        C += U, M = M >>> 1, I = I >>> 1;\n      }\n      for (var B = x, R = 0; R < b; R++)\n        T.push(new Uint8Array(i, B, C)), B += C;\n    }\n    return T.map(function(G) {\n      return new Cy(G, {\n        format: w,\n        width: s,\n        height: n,\n        levels: a\n      });\n    });\n  }\n  throw u & bk ? new Error(\"DDSParser does not support uncompressed texture data.\") : u & xk ? new Error(\"DDSParser does not supported YUV uncompressed texture data.\") : u & wk ? new Error(\"DDSParser does not support single-channel (lumninance) texture data!\") : u & yk ? new Error(\"DDSParser does not support single-channel (alpha) texture data!\") : new Error(\"DDSParser failed to load a texture file due to an unknown reason!\");\n}\nvar Os, $n, wh, U1 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], Rk = 67305985, Ii = {\n  FILE_IDENTIFIER: 0,\n  ENDIANNESS: 12,\n  GL_TYPE: 16,\n  GL_TYPE_SIZE: 20,\n  GL_FORMAT: 24,\n  GL_INTERNAL_FORMAT: 28,\n  GL_BASE_INTERNAL_FORMAT: 32,\n  PIXEL_WIDTH: 36,\n  PIXEL_HEIGHT: 40,\n  PIXEL_DEPTH: 44,\n  NUMBER_OF_ARRAY_ELEMENTS: 48,\n  NUMBER_OF_FACES: 52,\n  NUMBER_OF_MIPMAP_LEVELS: 56,\n  BYTES_OF_KEY_VALUE_DATA: 60\n}, Py = 64, j1 = (Os = {}, Os[It.UNSIGNED_BYTE] = 1, Os[It.UNSIGNED_SHORT] = 2, Os[It.INT] = 4, Os[It.UNSIGNED_INT] = 4, Os[It.FLOAT] = 4, Os[It.HALF_FLOAT] = 8, Os), Dk = ($n = {}, $n[ht.RGBA] = 4, $n[ht.RGB] = 3, $n[ht.RG] = 2, $n[ht.RED] = 1, $n[ht.LUMINANCE] = 1, $n[ht.LUMINANCE_ALPHA] = 2, $n[ht.ALPHA] = 1, $n), kk = (wh = {}, wh[It.UNSIGNED_SHORT_4_4_4_4] = 2, wh[It.UNSIGNED_SHORT_5_5_5_1] = 2, wh[It.UNSIGNED_SHORT_5_6_5] = 2, wh);\nfunction Nk(i, t, e) {\n  e === void 0 && (e = !1);\n  var r = new DataView(t);\n  if (!Ak(i, r))\n    return null;\n  var n = r.getUint32(Ii.ENDIANNESS, !0) === Rk, s = r.getUint32(Ii.GL_TYPE, n), a = r.getUint32(Ii.GL_FORMAT, n), o = r.getUint32(Ii.GL_INTERNAL_FORMAT, n), u = r.getUint32(Ii.PIXEL_WIDTH, n), l = r.getUint32(Ii.PIXEL_HEIGHT, n) || 1, h = r.getUint32(Ii.PIXEL_DEPTH, n) || 1, d = r.getUint32(Ii.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, f = r.getUint32(Ii.NUMBER_OF_FACES, n), p = r.getUint32(Ii.NUMBER_OF_MIPMAP_LEVELS, n), v = r.getUint32(Ii.BYTES_OF_KEY_VALUE_DATA, n);\n  if (l === 0 || h !== 1)\n    throw new Error(\"Only 2D textures are supported\");\n  if (f !== 1)\n    throw new Error(\"CubeTextures are not supported by KTXLoader yet!\");\n  if (d !== 1)\n    throw new Error(\"WebGL does not support array textures\");\n  var g = 4, m = 4, y = u + 3 & -4, _ = l + 3 & -4, b = new Array(d), w = u * l;\n  s === 0 && (w = y * _);\n  var T;\n  if (s !== 0 ? j1[s] ? T = j1[s] * Dk[a] : T = kk[s] : T = bv[o], T === void 0)\n    throw new Error(\"Unable to resolve the pixel format stored in the *.ktx file!\");\n  for (var x = e ? Bk(r, v, n) : null, S = w * T, C = S, M = u, I = l, R = y, N = _, A = Py + v, U = 0; U < p; U++) {\n    for (var B = r.getUint32(A, n), G = A + 4, $ = 0; $ < d; $++) {\n      var Z = b[$];\n      Z || (Z = b[$] = new Array(p)), Z[U] = {\n        levelID: U,\n        // don't align mipWidth when texture not compressed! (glType not zero)\n        levelWidth: p > 1 || s !== 0 ? M : R,\n        levelHeight: p > 1 || s !== 0 ? I : N,\n        levelBuffer: new Uint8Array(t, G, C)\n      }, G += C;\n    }\n    A += B + 4, A = A % 4 !== 0 ? A + 4 - A % 4 : A, M = M >> 1 || 1, I = I >> 1 || 1, R = M + g - 1 & ~(g - 1), N = I + m - 1 & ~(m - 1), C = R * N * T;\n  }\n  return s !== 0 ? {\n    uncompressed: b.map(function(H) {\n      var z = H[0].levelBuffer, X = !1;\n      return s === It.FLOAT ? z = new Float32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4) : s === It.UNSIGNED_INT ? (X = !0, z = new Uint32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4)) : s === It.INT && (X = !0, z = new Int32Array(H[0].levelBuffer.buffer, H[0].levelBuffer.byteOffset, H[0].levelBuffer.byteLength / 4)), {\n        resource: new au(z, {\n          width: H[0].levelWidth,\n          height: H[0].levelHeight\n        }),\n        type: s,\n        format: X ? Lk(a) : a\n      };\n    }),\n    kvData: x\n  } : {\n    compressed: b.map(function(H) {\n      return new Cy(null, {\n        format: o,\n        width: u,\n        height: l,\n        levels: p,\n        levelBuffers: H\n      });\n    }),\n    kvData: x\n  };\n}\nfunction Ak(i, t) {\n  for (var e = 0; e < U1.length; e++)\n    if (t.getUint8(e) !== U1[e])\n      return console.error(i + \" is not a valid *.ktx file!\"), !1;\n  return !0;\n}\nfunction Lk(i) {\n  switch (i) {\n    case ht.RGBA:\n      return ht.RGBA_INTEGER;\n    case ht.RGB:\n      return ht.RGB_INTEGER;\n    case ht.RG:\n      return ht.RG_INTEGER;\n    case ht.RED:\n      return ht.RED_INTEGER;\n    default:\n      return i;\n  }\n}\nfunction Bk(i, t, e) {\n  for (var r = /* @__PURE__ */ new Map(), n = 0; n < t; ) {\n    var s = i.getUint32(Py + n, e), a = Py + n + 4, o = 3 - (s + 3) % 4;\n    if (s === 0 || s > t - n) {\n      console.error(\"KTXLoader: keyAndValueByteSize out of bounds\");\n      break;\n    }\n    for (var u = 0; u < s && i.getUint8(a + u) !== 0; u++)\n      ;\n    if (u === -1) {\n      console.error(\"KTXLoader: Failed to find null byte terminating kvData key\");\n      break;\n    }\n    var l = new TextDecoder().decode(new Uint8Array(i.buffer, a, u)), h = new DataView(i.buffer, a + u + 1, s - u - 1);\n    r.set(l, h), n += 4 + s + o;\n  }\n  return r;\n}\nFt.setExtensionXhrType(\"dds\", Ft.XHR_RESPONSE_TYPE.BUFFER);\nvar Fk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.use = function(t, e) {\n      if (t.extension === \"dds\" && t.data)\n        try {\n          Object.assign(t, gS(t.name || t.url, Ik(t.data), t.metadata));\n        } catch (r) {\n          e(r);\n          return;\n        }\n      e();\n    }, i.extension = fe.Loader, i;\n  }()\n);\nFt.setExtensionXhrType(\"ktx\", Ft.XHR_RESPONSE_TYPE.BUFFER);\nvar Gk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.use = function(t, e) {\n      if (t.extension === \"ktx\" && t.data)\n        try {\n          var r = t.name || t.url, n = Nk(r, t.data, this.loadKeyValueData), s = n.compressed, a = n.uncompressed, o = n.kvData;\n          if (s) {\n            var u = gS(r, s, t.metadata);\n            if (o && u.textures)\n              for (var l in u.textures)\n                u.textures[l].baseTexture.ktxKeyValueData = o;\n            Object.assign(t, u);\n          } else if (a) {\n            var h = {};\n            a.forEach(function(d, f) {\n              var p = new Ot(new Kt(d.resource, {\n                mipmap: tn.OFF,\n                alphaMode: en.NO_PREMULTIPLIED_ALPHA,\n                type: d.type,\n                format: d.format\n              })), v = r + \"-\" + (f + 1);\n              o && (p.baseTexture.ktxKeyValueData = o), Kt.addToCache(p.baseTexture, v), Ot.addToCache(p, v), f === 0 && (h[r] = p, Kt.addToCache(p.baseTexture, r), Ot.addToCache(p, r)), h[v] = p;\n            }), Object.assign(t, { textures: h });\n          }\n        } catch (d) {\n          e(d);\n          return;\n        }\n      e();\n    }, i.extension = fe.Loader, i.loadKeyValueData = !1, i;\n  }()\n);\n/*!\n * @pixi/particle-container - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/particle-container is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Oy = function(i, t) {\n  return Oy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Oy(i, t);\n};\nfunction mS(i, t) {\n  Oy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\n(function(i) {\n  mS(t, i);\n  function t(e, r, n, s) {\n    e === void 0 && (e = 1500), n === void 0 && (n = 16384), s === void 0 && (s = !1);\n    var a = i.call(this) || this, o = 16384;\n    return n > o && (n = o), a._properties = [!1, !0, !1, !1, !1], a._maxSize = e, a._batchSize = n, a._buffers = null, a._bufferUpdateIDs = [], a._updateID = 0, a.interactiveChildren = !1, a.blendMode = Et.NORMAL, a.autoResize = s, a.roundPixels = !0, a.baseTexture = null, a.setProperties(r), a._tint = 0, a.tintRgb = new Float32Array(4), a.tint = 16777215, a;\n  }\n  return t.prototype.setProperties = function(e) {\n    e && (this._properties[0] = \"vertices\" in e || \"scale\" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = \"position\" in e ? !!e.position : this._properties[1], this._properties[2] = \"rotation\" in e ? !!e.rotation : this._properties[2], this._properties[3] = \"uvs\" in e ? !!e.uvs : this._properties[3], this._properties[4] = \"tint\" in e || \"alpha\" in e ? !!e.tint || !!e.alpha : this._properties[4]);\n  }, t.prototype.updateTransform = function() {\n    this.displayObjectUpdateTransform();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * @default 0xFFFFFF\n     */\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      this._tint = e, Jl(e, this.tintRgb);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.render = function(e) {\n    var r = this;\n    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once(\"update\", function() {\n      return r.onChildrenChange(0);\n    })), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this));\n  }, t.prototype.onChildrenChange = function(e) {\n    for (var r = Math.floor(e / this._batchSize); this._bufferUpdateIDs.length < r; )\n      this._bufferUpdateIDs.push(0);\n    this._bufferUpdateIDs[r] = ++this._updateID;\n  }, t.prototype.dispose = function() {\n    if (this._buffers) {\n      for (var e = 0; e < this._buffers.length; ++e)\n        this._buffers[e].destroy();\n      this._buffers = null;\n    }\n  }, t.prototype.destroy = function(e) {\n    i.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;\n  }, t;\n})(ye);\nvar z1 = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      this.geometry = new lh(), this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];\n      for (var n = 0; n < t.length; ++n) {\n        var s = t[n];\n        s = {\n          attributeName: s.attributeName,\n          size: s.size,\n          uploadFunction: s.uploadFunction,\n          type: s.type || It.FLOAT,\n          offset: s.offset\n        }, e[n] ? this.dynamicProperties.push(s) : this.staticProperties.push(s);\n      }\n      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();\n    }\n    return i.prototype.initBuffers = function() {\n      var t = this.geometry, e = 0;\n      this.indexBuffer = new Ke(PD(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;\n      for (var r = 0; r < this.dynamicProperties.length; ++r) {\n        var n = this.dynamicProperties[r];\n        n.offset = e, e += n.size, this.dynamicStride += n.size;\n      }\n      var s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);\n      this.dynamicData = new Float32Array(s), this.dynamicDataUint32 = new Uint32Array(s), this.dynamicBuffer = new Ke(this.dynamicData, !1, !1);\n      var a = 0;\n      this.staticStride = 0;\n      for (var r = 0; r < this.staticProperties.length; ++r) {\n        var n = this.staticProperties[r];\n        n.offset = a, a += n.size, this.staticStride += n.size;\n      }\n      var o = new ArrayBuffer(this.size * this.staticStride * 4 * 4);\n      this.staticData = new Float32Array(o), this.staticDataUint32 = new Uint32Array(o), this.staticBuffer = new Ke(this.staticData, !0, !1);\n      for (var r = 0; r < this.dynamicProperties.length; ++r) {\n        var n = this.dynamicProperties[r];\n        t.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === It.UNSIGNED_BYTE, n.type, this.dynamicStride * 4, n.offset * 4);\n      }\n      for (var r = 0; r < this.staticProperties.length; ++r) {\n        var n = this.staticProperties[r];\n        t.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === It.UNSIGNED_BYTE, n.type, this.staticStride * 4, n.offset * 4);\n      }\n    }, i.prototype.uploadDynamic = function(t, e, r) {\n      for (var n = 0; n < this.dynamicProperties.length; n++) {\n        var s = this.dynamicProperties[n];\n        s.uploadFunction(t, e, r, s.type === It.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, s.offset);\n      }\n      this.dynamicBuffer._updateID++;\n    }, i.prototype.uploadStatic = function(t, e, r) {\n      for (var n = 0; n < this.staticProperties.length; n++) {\n        var s = this.staticProperties[n];\n        s.uploadFunction(t, e, r, s.type === It.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, s.offset);\n      }\n      this.staticBuffer._updateID++;\n    }, i.prototype.destroy = function() {\n      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();\n    }, i;\n  }()\n), Uk = `varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}`, jk = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n`, zk = (\n  /** @class */\n  function(i) {\n    mS(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return r.shader = null, r.properties = null, r.tempMatrix = new ar(), r.properties = [\n        // verticesData\n        {\n          attributeName: \"aVertexPosition\",\n          size: 2,\n          uploadFunction: r.uploadVertices,\n          offset: 0\n        },\n        // positionData\n        {\n          attributeName: \"aPositionCoord\",\n          size: 2,\n          uploadFunction: r.uploadPosition,\n          offset: 0\n        },\n        // rotationData\n        {\n          attributeName: \"aRotation\",\n          size: 1,\n          uploadFunction: r.uploadRotation,\n          offset: 0\n        },\n        // uvsData\n        {\n          attributeName: \"aTextureCoord\",\n          size: 2,\n          uploadFunction: r.uploadUvs,\n          offset: 0\n        },\n        // tintData\n        {\n          attributeName: \"aColor\",\n          size: 1,\n          type: It.UNSIGNED_BYTE,\n          uploadFunction: r.uploadTint,\n          offset: 0\n        }\n      ], r.shader = xs.from(jk, Uk, {}), r.state = ga.for2d(), r;\n    }\n    return t.prototype.render = function(e) {\n      var r = e.children, n = e._maxSize, s = e._batchSize, a = this.renderer, o = r.length;\n      if (o !== 0) {\n        o > n && !e.autoResize && (o = n);\n        var u = e._buffers;\n        u || (u = e._buffers = this.generateBuffers(e));\n        var l = r[0]._texture.baseTexture, h = l.alphaMode > 0;\n        this.state.blendMode = kE(e.blendMode, h), a.state.set(this.state);\n        var d = a.gl, f = e.worldTransform.copyTo(this.tempMatrix);\n        f.prepend(a.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = f.toArray(!0), this.shader.uniforms.uColor = MD(e.tintRgb, e.worldAlpha, this.shader.uniforms.uColor, h), this.shader.uniforms.uSampler = l, this.renderer.shader.bind(this.shader);\n        for (var p = !1, v = 0, g = 0; v < o; v += s, g += 1) {\n          var m = o - v;\n          m > s && (m = s), g >= u.length && u.push(this._generateOneMoreBuffer(e));\n          var y = u[g];\n          y.uploadDynamic(r, v, m);\n          var _ = e._bufferUpdateIDs[g] || 0;\n          p = p || y._updateID < _, p && (y._updateID = e._updateID, y.uploadStatic(r, v, m)), a.geometry.bind(y.geometry), d.drawElements(d.TRIANGLES, m * 6, d.UNSIGNED_SHORT, 0);\n        }\n      }\n    }, t.prototype.generateBuffers = function(e) {\n      for (var r = [], n = e._maxSize, s = e._batchSize, a = e._properties, o = 0; o < n; o += s)\n        r.push(new z1(this.properties, a, s));\n      return r;\n    }, t.prototype._generateOneMoreBuffer = function(e) {\n      var r = e._batchSize, n = e._properties;\n      return new z1(this.properties, n, r);\n    }, t.prototype.uploadVertices = function(e, r, n, s, a, o) {\n      for (var u = 0, l = 0, h = 0, d = 0, f = 0; f < n; ++f) {\n        var p = e[r + f], v = p._texture, g = p.scale.x, m = p.scale.y, y = v.trim, _ = v.orig;\n        y ? (l = y.x - p.anchor.x * _.width, u = l + y.width, d = y.y - p.anchor.y * _.height, h = d + y.height) : (u = _.width * (1 - p.anchor.x), l = _.width * -p.anchor.x, h = _.height * (1 - p.anchor.y), d = _.height * -p.anchor.y), s[o] = l * g, s[o + 1] = d * m, s[o + a] = u * g, s[o + a + 1] = d * m, s[o + a * 2] = u * g, s[o + a * 2 + 1] = h * m, s[o + a * 3] = l * g, s[o + a * 3 + 1] = h * m, o += a * 4;\n      }\n    }, t.prototype.uploadPosition = function(e, r, n, s, a, o) {\n      for (var u = 0; u < n; u++) {\n        var l = e[r + u].position;\n        s[o] = l.x, s[o + 1] = l.y, s[o + a] = l.x, s[o + a + 1] = l.y, s[o + a * 2] = l.x, s[o + a * 2 + 1] = l.y, s[o + a * 3] = l.x, s[o + a * 3 + 1] = l.y, o += a * 4;\n      }\n    }, t.prototype.uploadRotation = function(e, r, n, s, a, o) {\n      for (var u = 0; u < n; u++) {\n        var l = e[r + u].rotation;\n        s[o] = l, s[o + a] = l, s[o + a * 2] = l, s[o + a * 3] = l, o += a * 4;\n      }\n    }, t.prototype.uploadUvs = function(e, r, n, s, a, o) {\n      for (var u = 0; u < n; ++u) {\n        var l = e[r + u]._texture._uvs;\n        l ? (s[o] = l.x0, s[o + 1] = l.y0, s[o + a] = l.x1, s[o + a + 1] = l.y1, s[o + a * 2] = l.x2, s[o + a * 2 + 1] = l.y2, s[o + a * 3] = l.x3, s[o + a * 3 + 1] = l.y3, o += a * 4) : (s[o] = 0, s[o + 1] = 0, s[o + a] = 0, s[o + a + 1] = 0, s[o + a * 2] = 0, s[o + a * 2 + 1] = 0, s[o + a * 3] = 0, s[o + a * 3 + 1] = 0, o += a * 4);\n      }\n    }, t.prototype.uploadTint = function(e, r, n, s, a, o) {\n      for (var u = 0; u < n; ++u) {\n        var l = e[r + u], h = l._texture.baseTexture.alphaMode > 0, d = l.alpha, f = d < 1 && h ? wb(l._tintRGB, d) : l._tintRGB + (d * 255 << 24);\n        s[o] = f, s[o + a] = f, s[o + a * 2] = f, s[o + a * 3] = f, o += a * 4;\n      }\n    }, t.prototype.destroy = function() {\n      i.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;\n    }, t.extension = {\n      name: \"particle\",\n      type: fe.RendererPlugin\n    }, t;\n  }(wd)\n);\n/*!\n * @pixi/graphics - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar _s;\n(function(i) {\n  i.MITER = \"miter\", i.BEVEL = \"bevel\", i.ROUND = \"round\";\n})(_s || (_s = {}));\nvar oa;\n(function(i) {\n  i.BUTT = \"butt\", i.ROUND = \"round\", i.SQUARE = \"square\";\n})(oa || (oa = {}));\nvar hc = {\n  adaptive: !0,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 1e-4,\n  _segmentsCount: function(i, t) {\n    if (t === void 0 && (t = 20), !this.adaptive || !i || isNaN(i))\n      return t;\n    var e = Math.ceil(i / this.maxLength);\n    return e < this.minSegments ? e = this.minSegments : e > this.maxSegments && (e = this.maxSegments), e;\n  }\n}, yS = (\n  /** @class */\n  function() {\n    function i() {\n      this.color = 16777215, this.alpha = 1, this.texture = Ot.WHITE, this.matrix = null, this.visible = !1, this.reset();\n    }\n    return i.prototype.clone = function() {\n      var t = new i();\n      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t;\n    }, i.prototype.reset = function() {\n      this.color = 16777215, this.alpha = 1, this.texture = Ot.WHITE, this.matrix = null, this.visible = !1;\n    }, i.prototype.destroy = function() {\n      this.texture = null, this.matrix = null;\n    }, i;\n  }()\n);\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Iy = function(i, t) {\n  return Iy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Iy(i, t);\n};\nfunction Qb(i, t) {\n  Iy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nfunction H1(i, t) {\n  var e, r;\n  t === void 0 && (t = !1);\n  var n = i.length;\n  if (!(n < 6)) {\n    for (var s = 0, a = 0, o = i[n - 2], u = i[n - 1]; a < n; a += 2) {\n      var l = i[a], h = i[a + 1];\n      s += (l - o) * (h + u), o = l, u = h;\n    }\n    if (!t && s > 0 || t && s <= 0)\n      for (var d = n / 2, a = d + d % 2; a < n; a += 2) {\n        var f = n - a - 2, p = n - a - 1, v = a, g = a + 1;\n        e = [i[v], i[f]], i[f] = e[0], i[v] = e[1], r = [i[g], i[p]], i[p] = r[0], i[g] = r[1];\n      }\n  }\n}\nvar _S = {\n  build: function(i) {\n    i.points = i.shape.points.slice();\n  },\n  triangulate: function(i, t) {\n    var e = i.points, r = i.holes, n = t.points, s = t.indices;\n    if (e.length >= 6) {\n      H1(e, !1);\n      for (var a = [], o = 0; o < r.length; o++) {\n        var u = r[o];\n        H1(u.points, !0), a.push(e.length / 2), e = e.concat(u.points);\n      }\n      var l = sc(e, a, 2);\n      if (!l)\n        return;\n      for (var h = n.length / 2, o = 0; o < l.length; o += 3)\n        s.push(l[o] + h), s.push(l[o + 1] + h), s.push(l[o + 2] + h);\n      for (var o = 0; o < e.length; o++)\n        n.push(e[o]);\n    }\n  }\n}, xv = {\n  build: function(i) {\n    var t = i.points, e, r, n, s, a, o;\n    if (i.type === ur.CIRC) {\n      var u = i.shape;\n      e = u.x, r = u.y, a = o = u.radius, n = s = 0;\n    } else if (i.type === ur.ELIP) {\n      var l = i.shape;\n      e = l.x, r = l.y, a = l.width, o = l.height, n = s = 0;\n    } else {\n      var h = i.shape, d = h.width / 2, f = h.height / 2;\n      e = h.x + d, r = h.y + f, a = o = Math.max(0, Math.min(h.radius, Math.min(d, f))), n = d - a, s = f - o;\n    }\n    if (!(a >= 0 && o >= 0 && n >= 0 && s >= 0)) {\n      t.length = 0;\n      return;\n    }\n    var p = Math.ceil(2.3 * Math.sqrt(a + o)), v = p * 8 + (n ? 4 : 0) + (s ? 4 : 0);\n    if (t.length = v, v !== 0) {\n      if (p === 0) {\n        t.length = 8, t[0] = t[6] = e + n, t[1] = t[3] = r + s, t[2] = t[4] = e - n, t[5] = t[7] = r - s;\n        return;\n      }\n      var g = 0, m = p * 4 + (n ? 2 : 0) + 2, y = m, _ = v;\n      {\n        var b = n + a, w = s, T = e + b, x = e - b, S = r + w;\n        if (t[g++] = T, t[g++] = S, t[--m] = S, t[--m] = x, s) {\n          var C = r - w;\n          t[y++] = x, t[y++] = C, t[--_] = C, t[--_] = T;\n        }\n      }\n      for (var M = 1; M < p; M++) {\n        var I = Math.PI / 2 * (M / p), b = n + Math.cos(I) * a, w = s + Math.sin(I) * o, T = e + b, x = e - b, S = r + w, C = r - w;\n        t[g++] = T, t[g++] = S, t[--m] = S, t[--m] = x, t[y++] = x, t[y++] = C, t[--_] = C, t[--_] = T;\n      }\n      {\n        var b = n, w = s + o, T = e + b, x = e - b, S = r + w, C = r - w;\n        t[g++] = T, t[g++] = S, t[--_] = C, t[--_] = T, n && (t[g++] = x, t[g++] = S, t[--_] = C, t[--_] = x);\n      }\n    }\n  },\n  triangulate: function(i, t) {\n    var e = i.points, r = t.points, n = t.indices;\n    if (e.length !== 0) {\n      var s = r.length / 2, a = s, o, u;\n      if (i.type !== ur.RREC) {\n        var l = i.shape;\n        o = l.x, u = l.y;\n      } else {\n        var h = i.shape;\n        o = h.x + h.width / 2, u = h.y + h.height / 2;\n      }\n      var d = i.matrix;\n      r.push(i.matrix ? d.a * o + d.c * u + d.tx : o, i.matrix ? d.b * o + d.d * u + d.ty : u), s++, r.push(e[0], e[1]);\n      for (var f = 2; f < e.length; f += 2)\n        r.push(e[f], e[f + 1]), n.push(s++, a, s);\n      n.push(a + 1, a, s);\n    }\n  }\n}, Hk = {\n  build: function(i) {\n    var t = i.shape, e = t.x, r = t.y, n = t.width, s = t.height, a = i.points;\n    a.length = 0, a.push(e, r, e + n, r, e + n, r + s, e, r + s);\n  },\n  triangulate: function(i, t) {\n    var e = i.points, r = t.points, n = r.length / 2;\n    r.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]), t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3);\n  }\n};\nfunction gu(i, t, e) {\n  var r = t - i;\n  return i + r * e;\n}\nfunction ip(i, t, e, r, n, s, a) {\n  a === void 0 && (a = []);\n  for (var o = 20, u = a, l = 0, h = 0, d = 0, f = 0, p = 0, v = 0, g = 0, m = 0; g <= o; ++g)\n    m = g / o, l = gu(i, e, m), h = gu(t, r, m), d = gu(e, n, m), f = gu(r, s, m), p = gu(l, d, m), v = gu(h, f, m), !(g === 0 && u[u.length - 2] === p && u[u.length - 1] === v) && u.push(p, v);\n  return u;\n}\nvar $k = {\n  build: function(i) {\n    if (ai.nextRoundedRectBehavior) {\n      xv.build(i);\n      return;\n    }\n    var t = i.shape, e = i.points, r = t.x, n = t.y, s = t.width, a = t.height, o = Math.max(0, Math.min(t.radius, Math.min(s, a) / 2));\n    e.length = 0, o ? (ip(r, n + o, r, n, r + o, n, e), ip(r + s - o, n, r + s, n, r + s, n + o, e), ip(r + s, n + a - o, r + s, n + a, r + s - o, n + a, e), ip(r + o, n + a, r, n + a, r, n + a - o, e)) : e.push(r, n, r + s, n, r + s, n + a, r, n + a);\n  },\n  triangulate: function(i, t) {\n    if (ai.nextRoundedRectBehavior) {\n      xv.triangulate(i, t);\n      return;\n    }\n    for (var e = i.points, r = t.points, n = t.indices, s = r.length / 2, a = sc(e, null, 2), o = 0, u = a.length; o < u; o += 3)\n      n.push(a[o] + s), n.push(a[o + 1] + s), n.push(a[o + 2] + s);\n    for (var o = 0, u = e.length; o < u; o++)\n      r.push(e[o], e[++o]);\n  }\n};\nfunction $1(i, t, e, r, n, s, a, o) {\n  var u = i - e * n, l = t - r * n, h = i + e * s, d = t + r * s, f, p;\n  a ? (f = r, p = -e) : (f = -r, p = e);\n  var v = u + f, g = l + p, m = h + f, y = d + p;\n  return o.push(v, g), o.push(m, y), 2;\n}\nfunction xa(i, t, e, r, n, s, a, o) {\n  var u = e - i, l = r - t, h = Math.atan2(u, l), d = Math.atan2(n - i, s - t);\n  o && h < d ? h += Math.PI * 2 : !o && h > d && (d += Math.PI * 2);\n  var f = h, p = d - h, v = Math.abs(p), g = Math.sqrt(u * u + l * l), m = (15 * v * Math.sqrt(g) / Math.PI >> 0) + 1, y = p / m;\n  if (f += y, o) {\n    a.push(i, t), a.push(e, r);\n    for (var _ = 1, b = f; _ < m; _++, b += y)\n      a.push(i, t), a.push(i + Math.sin(b) * g, t + Math.cos(b) * g);\n    a.push(i, t), a.push(n, s);\n  } else {\n    a.push(e, r), a.push(i, t);\n    for (var _ = 1, b = f; _ < m; _++, b += y)\n      a.push(i + Math.sin(b) * g, t + Math.cos(b) * g), a.push(i, t);\n    a.push(n, s), a.push(i, t);\n  }\n  return m * 2;\n}\nfunction Vk(i, t) {\n  var e = i.shape, r = i.points || e.points.slice(), n = t.closePointEps;\n  if (r.length !== 0) {\n    var s = i.lineStyle, a = new xe(r[0], r[1]), o = new xe(r[r.length - 2], r[r.length - 1]), u = e.type !== ur.POLY || e.closeStroke, l = Math.abs(a.x - o.x) < n && Math.abs(a.y - o.y) < n;\n    if (u) {\n      r = r.slice(), l && (r.pop(), r.pop(), o.set(r[r.length - 2], r[r.length - 1]));\n      var h = (a.x + o.x) * 0.5, d = (o.y + a.y) * 0.5;\n      r.unshift(h, d), r.push(h, d);\n    }\n    var f = t.points, p = r.length / 2, v = r.length, g = f.length / 2, m = s.width / 2, y = m * m, _ = s.miterLimit * s.miterLimit, b = r[0], w = r[1], T = r[2], x = r[3], S = 0, C = 0, M = -(w - x), I = b - T, R = 0, N = 0, A = Math.sqrt(M * M + I * I);\n    M /= A, I /= A, M *= m, I *= m;\n    var U = s.alignment, B = (1 - U) * 2, G = U * 2;\n    u || (s.cap === oa.ROUND ? v += xa(b - M * (B - G) * 0.5, w - I * (B - G) * 0.5, b - M * B, w - I * B, b + M * G, w + I * G, f, !0) + 2 : s.cap === oa.SQUARE && (v += $1(b, w, M, I, B, G, !0, f))), f.push(b - M * B, w - I * B), f.push(b + M * G, w + I * G);\n    for (var $ = 1; $ < p - 1; ++$) {\n      b = r[($ - 1) * 2], w = r[($ - 1) * 2 + 1], T = r[$ * 2], x = r[$ * 2 + 1], S = r[($ + 1) * 2], C = r[($ + 1) * 2 + 1], M = -(w - x), I = b - T, A = Math.sqrt(M * M + I * I), M /= A, I /= A, M *= m, I *= m, R = -(x - C), N = T - S, A = Math.sqrt(R * R + N * N), R /= A, N /= A, R *= m, N *= m;\n      var Z = T - b, H = w - x, z = T - S, X = C - x, ct = Z * z + H * X, it = H * z - X * Z, lt = it < 0;\n      if (Math.abs(it) < 1e-3 * Math.abs(ct)) {\n        f.push(T - M * B, x - I * B), f.push(T + M * G, x + I * G), ct >= 0 && (s.join === _s.ROUND ? v += xa(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 4 : v += 2, f.push(T - R * G, x - N * G), f.push(T + R * B, x + N * B));\n        continue;\n      }\n      var et = (-M + b) * (-I + x) - (-M + T) * (-I + w), k = (-R + S) * (-N + x) - (-R + T) * (-N + C), ft = (Z * k - z * et) / it, Q = (X * et - H * k) / it, St = (ft - T) * (ft - T) + (Q - x) * (Q - x), at = T + (ft - T) * B, q = x + (Q - x) * B, bt = T - (ft - T) * G, st = x - (Q - x) * G, W = Math.min(Z * Z + H * H, z * z + X * X), nt = lt ? B : G, dt = W + nt * nt * y, V = St <= dt;\n      V ? s.join === _s.BEVEL || St / y > _ ? (lt ? (f.push(at, q), f.push(T + M * G, x + I * G), f.push(at, q), f.push(T + R * G, x + N * G)) : (f.push(T - M * B, x - I * B), f.push(bt, st), f.push(T - R * B, x - N * B), f.push(bt, st)), v += 2) : s.join === _s.ROUND ? lt ? (f.push(at, q), f.push(T + M * G, x + I * G), v += xa(T, x, T + M * G, x + I * G, T + R * G, x + N * G, f, !0) + 4, f.push(at, q), f.push(T + R * G, x + N * G)) : (f.push(T - M * B, x - I * B), f.push(bt, st), v += xa(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 4, f.push(T - R * B, x - N * B), f.push(bt, st)) : (f.push(at, q), f.push(bt, st)) : (f.push(T - M * B, x - I * B), f.push(T + M * G, x + I * G), s.join === _s.ROUND ? lt ? v += xa(T, x, T + M * G, x + I * G, T + R * G, x + N * G, f, !0) + 2 : v += xa(T, x, T - M * B, x - I * B, T - R * B, x - N * B, f, !1) + 2 : s.join === _s.MITER && St / y <= _ && (lt ? (f.push(bt, st), f.push(bt, st)) : (f.push(at, q), f.push(at, q)), v += 2), f.push(T - R * B, x - N * B), f.push(T + R * G, x + N * G), v += 2);\n    }\n    b = r[(p - 2) * 2], w = r[(p - 2) * 2 + 1], T = r[(p - 1) * 2], x = r[(p - 1) * 2 + 1], M = -(w - x), I = b - T, A = Math.sqrt(M * M + I * I), M /= A, I /= A, M *= m, I *= m, f.push(T - M * B, x - I * B), f.push(T + M * G, x + I * G), u || (s.cap === oa.ROUND ? v += xa(T - M * (B - G) * 0.5, x - I * (B - G) * 0.5, T - M * B, x - I * B, T + M * G, x + I * G, f, !1) + 2 : s.cap === oa.SQUARE && (v += $1(T, x, M, I, B, G, !1, f)));\n    for (var xt = t.indices, Dt = hc.epsilon * hc.epsilon, $ = g; $ < v + g - 2; ++$)\n      b = f[$ * 2], w = f[$ * 2 + 1], T = f[($ + 1) * 2], x = f[($ + 1) * 2 + 1], S = f[($ + 2) * 2], C = f[($ + 2) * 2 + 1], !(Math.abs(b * (x - C) + T * (C - w) + S * (w - x)) < Dt) && xt.push($, $ + 1, $ + 2);\n  }\n}\nfunction Xk(i, t) {\n  var e = 0, r = i.shape, n = i.points || r.points, s = r.type !== ur.POLY || r.closeStroke;\n  if (n.length !== 0) {\n    var a = t.points, o = t.indices, u = n.length / 2, l = a.length / 2, h = l;\n    for (a.push(n[0], n[1]), e = 1; e < u; e++)\n      a.push(n[e * 2], n[e * 2 + 1]), o.push(h, h + 1), h++;\n    s && o.push(h, l);\n  }\n}\nfunction V1(i, t) {\n  i.lineStyle.native ? Xk(i, t) : Vk(i, t);\n}\nvar X1 = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.curveTo = function(t, e, r, n, s, a) {\n      var o = a[a.length - 2], u = a[a.length - 1], l = u - e, h = o - t, d = n - e, f = r - t, p = Math.abs(l * f - h * d);\n      if (p < 1e-8 || s === 0)\n        return (a[a.length - 2] !== t || a[a.length - 1] !== e) && a.push(t, e), null;\n      var v = l * l + h * h, g = d * d + f * f, m = l * d + h * f, y = s * Math.sqrt(v) / p, _ = s * Math.sqrt(g) / p, b = y * m / v, w = _ * m / g, T = y * f + _ * h, x = y * d + _ * l, S = h * (_ + b), C = l * (_ + b), M = f * (y + w), I = d * (y + w), R = Math.atan2(C - x, S - T), N = Math.atan2(I - x, M - T);\n      return {\n        cx: T + t,\n        cy: x + e,\n        radius: s,\n        startAngle: R,\n        endAngle: N,\n        anticlockwise: h * d > f * l\n      };\n    }, i.arc = function(t, e, r, n, s, a, o, u, l) {\n      for (var h = o - a, d = hc._segmentsCount(Math.abs(h) * s, Math.ceil(Math.abs(h) / pv) * 40), f = h / (d * 2), p = f * 2, v = Math.cos(f), g = Math.sin(f), m = d - 1, y = m % 1 / m, _ = 0; _ <= m; ++_) {\n        var b = _ + y * _, w = f + a + p * b, T = Math.cos(w), x = -Math.sin(w);\n        l.push((v * T + g * x) * s + r, (v * -x + g * T) * s + n);\n      }\n    }, i;\n  }()\n), Wk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.curveLength = function(t, e, r, n, s, a, o, u) {\n      for (var l = 10, h = 0, d = 0, f = 0, p = 0, v = 0, g = 0, m = 0, y = 0, _ = 0, b = 0, w = 0, T = t, x = e, S = 1; S <= l; ++S)\n        d = S / l, f = d * d, p = f * d, v = 1 - d, g = v * v, m = g * v, y = m * t + 3 * g * d * r + 3 * v * f * s + p * o, _ = m * e + 3 * g * d * n + 3 * v * f * a + p * u, b = T - y, w = x - _, T = y, x = _, h += Math.sqrt(b * b + w * w);\n      return h;\n    }, i.curveTo = function(t, e, r, n, s, a, o) {\n      var u = o[o.length - 2], l = o[o.length - 1];\n      o.length -= 2;\n      var h = hc._segmentsCount(i.curveLength(u, l, t, e, r, n, s, a)), d = 0, f = 0, p = 0, v = 0, g = 0;\n      o.push(u, l);\n      for (var m = 1, y = 0; m <= h; ++m)\n        y = m / h, d = 1 - y, f = d * d, p = f * d, v = y * y, g = v * y, o.push(p * u + 3 * f * y * t + 3 * d * v * r + g * s, p * l + 3 * f * y * e + 3 * d * v * n + g * a);\n    }, i;\n  }()\n), Yk = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.curveLength = function(t, e, r, n, s, a) {\n      var o = t - 2 * r + s, u = e - 2 * n + a, l = 2 * r - 2 * t, h = 2 * n - 2 * e, d = 4 * (o * o + u * u), f = 4 * (o * l + u * h), p = l * l + h * h, v = 2 * Math.sqrt(d + f + p), g = Math.sqrt(d), m = 2 * d * g, y = 2 * Math.sqrt(p), _ = f / g;\n      return (m * v + g * f * (v - y) + (4 * p * d - f * f) * Math.log((2 * g + _ + v) / (_ + y))) / (4 * m);\n    }, i.curveTo = function(t, e, r, n, s) {\n      for (var a = s[s.length - 2], o = s[s.length - 1], u = hc._segmentsCount(i.curveLength(a, o, t, e, r, n)), l = 0, h = 0, d = 1; d <= u; ++d) {\n        var f = d / u;\n        l = a + (t - a) * f, h = o + (e - o) * f, s.push(l + (t + (r - t) * f - l) * f, h + (e + (n - e) * f - h) * f);\n      }\n    }, i;\n  }()\n), qk = (\n  /** @class */\n  function() {\n    function i() {\n      this.reset();\n    }\n    return i.prototype.begin = function(t, e, r) {\n      this.reset(), this.style = t, this.start = e, this.attribStart = r;\n    }, i.prototype.end = function(t, e) {\n      this.attribSize = e - this.attribStart, this.size = t - this.start;\n    }, i.prototype.reset = function() {\n      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;\n    }, i;\n  }()\n), wa, Y0 = (wa = {}, wa[ur.POLY] = _S, wa[ur.CIRC] = xv, wa[ur.ELIP] = xv, wa[ur.RECT] = Hk, wa[ur.RREC] = $k, wa), W1 = [], np = [], Y1 = (\n  /** @class */\n  function() {\n    function i(t, e, r, n) {\n      e === void 0 && (e = null), r === void 0 && (r = null), n === void 0 && (n = null), this.points = [], this.holes = [], this.shape = t, this.lineStyle = r, this.fillStyle = e, this.matrix = n, this.type = t.type;\n    }\n    return i.prototype.clone = function() {\n      return new i(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n    }, i.prototype.destroy = function() {\n      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;\n    }, i;\n  }()\n), mu = new xe(), Zk = (\n  /** @class */\n  function(i) {\n    Qb(t, i);\n    function t() {\n      var e = i.call(this) || this;\n      return e.closePointEps = 1e-4, e.boundsPadding = 0, e.uvsFloat32 = null, e.indicesUint16 = null, e.batchable = !1, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.drawCalls = [], e.batchDirty = -1, e.batches = [], e.dirty = 0, e.cacheDirty = -1, e.clearDirty = 0, e.shapeIndex = 0, e._bounds = new vv(), e.boundsDirty = -1, e;\n    }\n    return Object.defineProperty(t.prototype, \"bounds\", {\n      /**\n       * Get the current bounds of the graphic geometry.\n       * @readonly\n       */\n      get: function() {\n        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.invalidate = function() {\n      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;\n      for (var e = 0; e < this.drawCalls.length; e++)\n        this.drawCalls[e].texArray.clear(), np.push(this.drawCalls[e]);\n      this.drawCalls.length = 0;\n      for (var e = 0; e < this.batches.length; e++) {\n        var r = this.batches[e];\n        r.reset(), W1.push(r);\n      }\n      this.batches.length = 0;\n    }, t.prototype.clear = function() {\n      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;\n    }, t.prototype.drawShape = function(e, r, n, s) {\n      r === void 0 && (r = null), n === void 0 && (n = null), s === void 0 && (s = null);\n      var a = new Y1(e, r, n, s);\n      return this.graphicsData.push(a), this.dirty++, this;\n    }, t.prototype.drawHole = function(e, r) {\n      if (r === void 0 && (r = null), !this.graphicsData.length)\n        return null;\n      var n = new Y1(e, null, null, r), s = this.graphicsData[this.graphicsData.length - 1];\n      return n.lineStyle = s.lineStyle, s.holes.push(n), this.dirty++, this;\n    }, t.prototype.destroy = function() {\n      i.prototype.destroy.call(this);\n      for (var e = 0; e < this.graphicsData.length; ++e)\n        this.graphicsData[e].destroy();\n      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;\n    }, t.prototype.containsPoint = function(e) {\n      for (var r = this.graphicsData, n = 0; n < r.length; ++n) {\n        var s = r[n];\n        if (s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, mu) : mu.copyFrom(e), s.shape.contains(mu.x, mu.y))) {\n          var a = !1;\n          if (s.holes)\n            for (var o = 0; o < s.holes.length; o++) {\n              var u = s.holes[o];\n              if (u.shape.contains(mu.x, mu.y)) {\n                a = !0;\n                break;\n              }\n            }\n          if (!a)\n            return !0;\n        }\n      }\n      return !1;\n    }, t.prototype.updateBatches = function() {\n      if (!this.graphicsData.length) {\n        this.batchable = !0;\n        return;\n      }\n      if (this.validateBatching()) {\n        this.cacheDirty = this.dirty;\n        var e = this.uvs, r = this.graphicsData, n = null, s = null;\n        this.batches.length > 0 && (n = this.batches[this.batches.length - 1], s = n.style);\n        for (var a = this.shapeIndex; a < r.length; a++) {\n          this.shapeIndex++;\n          var o = r[a], u = o.fillStyle, l = o.lineStyle, h = Y0[o.type];\n          h.build(o), o.matrix && this.transformPoints(o.points, o.matrix), (u.visible || l.visible) && this.processHoles(o.holes);\n          for (var d = 0; d < 2; d++) {\n            var f = d === 0 ? u : l;\n            if (f.visible) {\n              var p = f.texture.baseTexture, v = this.indices.length, g = this.points.length / 2;\n              p.wrapMode = On.REPEAT, d === 0 ? this.processFill(o) : this.processLine(o);\n              var m = this.points.length / 2 - g;\n              m !== 0 && (n && !this._compareStyles(s, f) && (n.end(v, g), n = null), n || (n = W1.pop() || new qk(), n.begin(f, v, g), this.batches.push(n), s = f), this.addUvs(this.points, e, f.texture, g, m, f.matrix));\n            }\n          }\n        }\n        var y = this.indices.length, _ = this.points.length / 2;\n        if (n && n.end(y, _), this.batches.length === 0) {\n          this.batchable = !0;\n          return;\n        }\n        var b = _ > 65535;\n        this.indicesUint16 && this.indices.length === this.indicesUint16.length && b === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = b ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();\n      }\n    }, t.prototype._compareStyles = function(e, r) {\n      return !(!e || !r || e.texture.baseTexture !== r.texture.baseTexture || e.color + e.alpha !== r.color + r.alpha || !!e.native != !!r.native);\n    }, t.prototype.validateBatching = function() {\n      if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        return !1;\n      for (var e = 0, r = this.graphicsData.length; e < r; e++) {\n        var n = this.graphicsData[e], s = n.fillStyle, a = n.lineStyle;\n        if (s && !s.texture.baseTexture.valid || a && !a.texture.baseTexture.valid)\n          return !1;\n      }\n      return !0;\n    }, t.prototype.packBatches = function() {\n      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);\n      for (var e = this.batches, r = 0, n = e.length; r < n; r++)\n        for (var s = e[r], a = 0; a < s.size; a++) {\n          var o = s.start + a;\n          this.indicesUint16[o] = this.indicesUint16[o] - s.attribStart;\n        }\n    }, t.prototype.isBatchable = function() {\n      if (this.points.length > 65535 * 2)\n        return !1;\n      for (var e = this.batches, r = 0; r < e.length; r++)\n        if (e[r].style.native)\n          return !1;\n      return this.points.length < t.BATCHABLE_SIZE * 2;\n    }, t.prototype.buildDrawCalls = function() {\n      for (var e = ++Kt._globalBatch, r = 0; r < this.drawCalls.length; r++)\n        this.drawCalls[r].texArray.clear(), np.push(this.drawCalls[r]);\n      this.drawCalls.length = 0;\n      var n = this.colors, s = this.textureIds, a = np.pop();\n      a || (a = new mv(), a.texArray = new yv()), a.texArray.count = 0, a.start = 0, a.size = 0, a.type = qi.TRIANGLES;\n      var o = 0, u = null, l = 0, h = !1, d = qi.TRIANGLES, f = 0;\n      this.drawCalls.push(a);\n      for (var r = 0; r < this.batches.length; r++) {\n        var p = this.batches[r], v = 8, g = p.style, m = g.texture.baseTexture;\n        h !== !!g.native && (h = !!g.native, d = h ? qi.LINES : qi.TRIANGLES, u = null, o = v, e++), u !== m && (u = m, m._batchEnabled !== e && (o === v && (e++, o = 0, a.size > 0 && (a = np.pop(), a || (a = new mv(), a.texArray = new yv()), this.drawCalls.push(a)), a.start = f, a.size = 0, a.texArray.count = 0, a.type = d), m.touched = 1, m._batchEnabled = e, m._batchLocation = o, m.wrapMode = On.REPEAT, a.texArray.elements[a.texArray.count++] = m, o++)), a.size += p.size, f += p.size, l = m._batchLocation, this.addColors(n, g.color, g.alpha, p.attribSize, p.attribStart), this.addTextureIds(s, l, p.attribSize, p.attribStart);\n      }\n      Kt._globalBatch = e, this.packAttributes();\n    }, t.prototype.packAttributes = function() {\n      for (var e = this.points, r = this.uvs, n = this.colors, s = this.textureIds, a = new ArrayBuffer(e.length * 3 * 4), o = new Float32Array(a), u = new Uint32Array(a), l = 0, h = 0; h < e.length / 2; h++)\n        o[l++] = e[h * 2], o[l++] = e[h * 2 + 1], o[l++] = r[h * 2], o[l++] = r[h * 2 + 1], u[l++] = n[h], o[l++] = s[h];\n      this._buffer.update(a), this._indexBuffer.update(this.indicesUint16);\n    }, t.prototype.processFill = function(e) {\n      if (e.holes.length)\n        _S.triangulate(e, this);\n      else {\n        var r = Y0[e.type];\n        r.triangulate(e, this);\n      }\n    }, t.prototype.processLine = function(e) {\n      V1(e, this);\n      for (var r = 0; r < e.holes.length; r++)\n        V1(e.holes[r], this);\n    }, t.prototype.processHoles = function(e) {\n      for (var r = 0; r < e.length; r++) {\n        var n = e[r], s = Y0[n.type];\n        s.build(n), n.matrix && this.transformPoints(n.points, n.matrix);\n      }\n    }, t.prototype.calculateBounds = function() {\n      var e = this._bounds;\n      e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding);\n    }, t.prototype.transformPoints = function(e, r) {\n      for (var n = 0; n < e.length / 2; n++) {\n        var s = e[n * 2], a = e[n * 2 + 1];\n        e[n * 2] = r.a * s + r.c * a + r.tx, e[n * 2 + 1] = r.b * s + r.d * a + r.ty;\n      }\n    }, t.prototype.addColors = function(e, r, n, s, a) {\n      a === void 0 && (a = 0);\n      var o = (r >> 16) + (r & 65280) + ((r & 255) << 16), u = wb(o, n);\n      e.length = Math.max(e.length, a + s);\n      for (var l = 0; l < s; l++)\n        e[a + l] = u;\n    }, t.prototype.addTextureIds = function(e, r, n, s) {\n      s === void 0 && (s = 0), e.length = Math.max(e.length, s + n);\n      for (var a = 0; a < n; a++)\n        e[s + a] = r;\n    }, t.prototype.addUvs = function(e, r, n, s, a, o) {\n      o === void 0 && (o = null);\n      for (var u = 0, l = r.length, h = n.frame; u < a; ) {\n        var d = e[(s + u) * 2], f = e[(s + u) * 2 + 1];\n        if (o) {\n          var p = o.a * d + o.c * f + o.tx;\n          f = o.b * d + o.d * f + o.ty, d = p;\n        }\n        u++, r.push(d / h.width, f / h.height);\n      }\n      var v = n.baseTexture;\n      (h.width < v.width || h.height < v.height) && this.adjustUvs(r, n, l, a);\n    }, t.prototype.adjustUvs = function(e, r, n, s) {\n      for (var a = r.baseTexture, o = 1e-6, u = n + s * 2, l = r.frame, h = l.width / a.width, d = l.height / a.height, f = l.x / l.width, p = l.y / l.height, v = Math.floor(e[n] + o), g = Math.floor(e[n + 1] + o), m = n + 2; m < u; m += 2)\n        v = Math.min(v, Math.floor(e[m] + o)), g = Math.min(g, Math.floor(e[m + 1] + o));\n      f -= v, p -= g;\n      for (var m = n; m < u; m += 2)\n        e[m] = (e[m] + f) * h, e[m + 1] = (e[m + 1] + p) * d;\n    }, t.BATCHABLE_SIZE = 100, t;\n  }(Zb)\n), Kk = (\n  /** @class */\n  function(i) {\n    Qb(t, i);\n    function t() {\n      var e = i !== null && i.apply(this, arguments) || this;\n      return e.width = 0, e.alignment = 0.5, e.native = !1, e.cap = oa.BUTT, e.join = _s.MITER, e.miterLimit = 10, e;\n    }\n    return t.prototype.clone = function() {\n      var e = new t();\n      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e;\n    }, t.prototype.reset = function() {\n      i.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;\n    }, t;\n  }(yS)\n), Jk = new Float32Array(3), q0 = {}, ai = (\n  /** @class */\n  function(i) {\n    Qb(t, i);\n    function t(e) {\n      e === void 0 && (e = null);\n      var r = i.call(this) || this;\n      return r.shader = null, r.pluginName = \"batch\", r.currentPath = null, r.batches = [], r.batchTint = -1, r.batchDirty = -1, r.vertexData = null, r._fillStyle = new yS(), r._lineStyle = new Kk(), r._matrix = null, r._holeMode = !1, r.state = ga.for2d(), r._geometry = e || new Zk(), r._geometry.refCount++, r._transformID = -1, r.tint = 16777215, r.blendMode = Et.NORMAL, r;\n    }\n    return Object.defineProperty(t.prototype, \"geometry\", {\n      /**\n       * Includes vertex positions, face indices, normals, colors, UVs, and\n       * custom attributes within buffers, reducing the cost of passing all\n       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n       * @readonly\n       */\n      get: function() {\n        return this._geometry;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.clone = function() {\n      return this.finishPoly(), new t(this._geometry);\n    }, Object.defineProperty(t.prototype, \"blendMode\", {\n      get: function() {\n        return this.state.blendMode;\n      },\n      /**\n       * The blend mode to be applied to the graphic shape. Apply a value of\n       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n       * primitive in the GraphicsGeometry list is rendered sequentially, modes\n       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n       * be applied per-primitive.\n       * @default PIXI.BLEND_MODES.NORMAL\n       */\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The tint applied to each graphic shape. This is a hex value. A value of\n       * 0xFFFFFF will remove any tint effect.\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return this._tint;\n      },\n      set: function(e) {\n        this._tint = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"fill\", {\n      /**\n       * The current fill style.\n       * @readonly\n       */\n      get: function() {\n        return this._fillStyle;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"line\", {\n      /**\n       * The current line style.\n       * @readonly\n       */\n      get: function() {\n        return this._lineStyle;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.lineStyle = function(e, r, n, s, a) {\n      return e === void 0 && (e = null), r === void 0 && (r = 0), n === void 0 && (n = 1), s === void 0 && (s = 0.5), a === void 0 && (a = !1), typeof e == \"number\" && (e = { width: e, color: r, alpha: n, alignment: s, native: a }), this.lineTextureStyle(e);\n    }, t.prototype.lineTextureStyle = function(e) {\n      e = Object.assign({\n        width: 0,\n        texture: Ot.WHITE,\n        color: e && e.texture ? 16777215 : 0,\n        alpha: 1,\n        matrix: null,\n        alignment: 0.5,\n        native: !1,\n        cap: oa.BUTT,\n        join: _s.MITER,\n        miterLimit: 10\n      }, e), this.currentPath && this.startPoly();\n      var r = e.width > 0 && e.alpha > 0;\n      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, { visible: r }, e)) : this._lineStyle.reset(), this;\n    }, t.prototype.startPoly = function() {\n      if (this.currentPath) {\n        var e = this.currentPath.points, r = this.currentPath.points.length;\n        r > 2 && (this.drawShape(this.currentPath), this.currentPath = new Pp(), this.currentPath.closeStroke = !1, this.currentPath.points.push(e[r - 2], e[r - 1]));\n      } else\n        this.currentPath = new Pp(), this.currentPath.closeStroke = !1;\n    }, t.prototype.finishPoly = function() {\n      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);\n    }, t.prototype.moveTo = function(e, r) {\n      return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = r, this;\n    }, t.prototype.lineTo = function(e, r) {\n      this.currentPath || this.moveTo(0, 0);\n      var n = this.currentPath.points, s = n[n.length - 2], a = n[n.length - 1];\n      return (s !== e || a !== r) && n.push(e, r), this;\n    }, t.prototype._initCurve = function(e, r) {\n      e === void 0 && (e = 0), r === void 0 && (r = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, r]) : this.moveTo(e, r);\n    }, t.prototype.quadraticCurveTo = function(e, r, n, s) {\n      this._initCurve();\n      var a = this.currentPath.points;\n      return a.length === 0 && this.moveTo(0, 0), Yk.curveTo(e, r, n, s, a), this;\n    }, t.prototype.bezierCurveTo = function(e, r, n, s, a, o) {\n      return this._initCurve(), Wk.curveTo(e, r, n, s, a, o, this.currentPath.points), this;\n    }, t.prototype.arcTo = function(e, r, n, s, a) {\n      this._initCurve(e, r);\n      var o = this.currentPath.points, u = X1.curveTo(e, r, n, s, a, o);\n      if (u) {\n        var l = u.cx, h = u.cy, d = u.radius, f = u.startAngle, p = u.endAngle, v = u.anticlockwise;\n        this.arc(l, h, d, f, p, v);\n      }\n      return this;\n    }, t.prototype.arc = function(e, r, n, s, a, o) {\n      if (o === void 0 && (o = !1), s === a)\n        return this;\n      !o && a <= s ? a += pv : o && s <= a && (s += pv);\n      var u = a - s;\n      if (u === 0)\n        return this;\n      var l = e + Math.cos(s) * n, h = r + Math.sin(s) * n, d = this._geometry.closePointEps, f = this.currentPath ? this.currentPath.points : null;\n      if (f) {\n        var p = Math.abs(f[f.length - 2] - l), v = Math.abs(f[f.length - 1] - h);\n        p < d && v < d || f.push(l, h);\n      } else\n        this.moveTo(l, h), f = this.currentPath.points;\n      return X1.arc(l, h, e, r, n, s, a, o, f), this;\n    }, t.prototype.beginFill = function(e, r) {\n      return e === void 0 && (e = 0), r === void 0 && (r = 1), this.beginTextureFill({ texture: Ot.WHITE, color: e, alpha: r });\n    }, t.prototype.beginTextureFill = function(e) {\n      e = Object.assign({\n        texture: Ot.WHITE,\n        color: 16777215,\n        alpha: 1,\n        matrix: null\n      }, e), this.currentPath && this.startPoly();\n      var r = e.alpha > 0;\n      return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, { visible: r }, e)) : this._fillStyle.reset(), this;\n    }, t.prototype.endFill = function() {\n      return this.finishPoly(), this._fillStyle.reset(), this;\n    }, t.prototype.drawRect = function(e, r, n, s) {\n      return this.drawShape(new Nt(e, r, n, s));\n    }, t.prototype.drawRoundedRect = function(e, r, n, s, a) {\n      return this.drawShape(new LD(e, r, n, s, a));\n    }, t.prototype.drawCircle = function(e, r, n) {\n      return this.drawShape(new ND(e, r, n));\n    }, t.prototype.drawEllipse = function(e, r, n, s) {\n      return this.drawShape(new AD(e, r, n, s));\n    }, t.prototype.drawPolygon = function() {\n      for (var e = arguments, r = [], n = 0; n < arguments.length; n++)\n        r[n] = e[n];\n      var s, a = !0, o = r[0];\n      o.points ? (a = o.closeStroke, s = o.points) : Array.isArray(r[0]) ? s = r[0] : s = r;\n      var u = new Pp(s);\n      return u.closeStroke = a, this.drawShape(u), this;\n    }, t.prototype.drawShape = function(e) {\n      return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;\n    }, t.prototype.clear = function() {\n      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;\n    }, t.prototype.isFastRect = function() {\n      var e = this._geometry.graphicsData;\n      return e.length === 1 && e[0].shape.type === ur.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width);\n    }, t.prototype._render = function(e) {\n      this.finishPoly();\n      var r = this._geometry;\n      r.updateBatches(), r.batchable ? (this.batchDirty !== r.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e));\n    }, t.prototype._populateBatches = function() {\n      var e = this._geometry, r = this.blendMode, n = e.batches.length;\n      this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(e.points);\n      for (var s = 0; s < n; s++) {\n        var a = e.batches[s], o = a.style.color, u = new Float32Array(this.vertexData.buffer, a.attribStart * 4 * 2, a.attribSize * 2), l = new Float32Array(e.uvsFloat32.buffer, a.attribStart * 4 * 2, a.attribSize * 2), h = new Uint16Array(e.indicesUint16.buffer, a.start * 2, a.size), d = {\n          vertexData: u,\n          blendMode: r,\n          indices: h,\n          uvs: l,\n          _batchRGB: Jl(o),\n          _tintRGB: o,\n          _texture: a.style.texture,\n          alpha: a.style.alpha,\n          worldAlpha: 1\n        };\n        this.batches[s] = d;\n      }\n    }, t.prototype._renderBatched = function(e) {\n      if (this.batches.length) {\n        e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();\n        for (var r = 0, n = this.batches.length; r < n; r++) {\n          var s = this.batches[r];\n          s.worldAlpha = this.worldAlpha * s.alpha, e.plugins[this.pluginName].render(s);\n        }\n      }\n    }, t.prototype._renderDirect = function(e) {\n      var r = this._resolveDirectShader(e), n = this._geometry, s = this.tint, a = this.worldAlpha, o = r.uniforms, u = n.drawCalls;\n      o.translationMatrix = this.transform.worldTransform, o.tint[0] = (s >> 16 & 255) / 255 * a, o.tint[1] = (s >> 8 & 255) / 255 * a, o.tint[2] = (s & 255) / 255 * a, o.tint[3] = a, e.shader.bind(r), e.geometry.bind(n, r), e.state.set(this.state);\n      for (var l = 0, h = u.length; l < h; l++)\n        this._renderDrawCallDirect(e, n.drawCalls[l]);\n    }, t.prototype._renderDrawCallDirect = function(e, r) {\n      for (var n = r.texArray, s = r.type, a = r.size, o = r.start, u = n.count, l = 0; l < u; l++)\n        e.texture.bind(n.elements[l], l);\n      e.geometry.draw(s, a, o);\n    }, t.prototype._resolveDirectShader = function(e) {\n      var r = this.shader, n = this.pluginName;\n      if (!r) {\n        if (!q0[n]) {\n          for (var s = e.plugins[n].MAX_TEXTURES, a = new Int32Array(s), o = 0; o < s; o++)\n            a[o] = o;\n          var u = {\n            tint: new Float32Array([1, 1, 1, 1]),\n            translationMatrix: new ar(),\n            default: ha.from({ uSamplers: a }, !0)\n          }, l = e.plugins[n]._shader.program;\n          q0[n] = new xs(l, u);\n        }\n        r = q0[n];\n      }\n      return r;\n    }, t.prototype._calculateBounds = function() {\n      this.finishPoly();\n      var e = this._geometry;\n      if (e.graphicsData.length) {\n        var r = e.bounds, n = r.minX, s = r.minY, a = r.maxX, o = r.maxY;\n        this._bounds.addFrame(this.transform, n, s, a, o);\n      }\n    }, t.prototype.containsPoint = function(e) {\n      return this.worldTransform.applyInverse(e, t._TEMP_POINT), this._geometry.containsPoint(t._TEMP_POINT);\n    }, t.prototype.calculateTints = function() {\n      if (this.batchTint !== this.tint) {\n        this.batchTint = this.tint;\n        for (var e = Jl(this.tint, Jk), r = 0; r < this.batches.length; r++) {\n          var n = this.batches[r], s = n._batchRGB, a = e[0] * s[0] * 255, o = e[1] * s[1] * 255, u = e[2] * s[2] * 255, l = (a << 16) + (o << 8) + (u | 0);\n          n._tintRGB = (l >> 16) + (l & 65280) + ((l & 255) << 16);\n        }\n      }\n    }, t.prototype.calculateVertices = function() {\n      var e = this.transform._worldID;\n      if (this._transformID !== e) {\n        this._transformID = e;\n        for (var r = this.transform.worldTransform, n = r.a, s = r.b, a = r.c, o = r.d, u = r.tx, l = r.ty, h = this._geometry.points, d = this.vertexData, f = 0, p = 0; p < h.length; p += 2) {\n          var v = h[p], g = h[p + 1];\n          d[f++] = n * v + a * g + u, d[f++] = o * g + s * v + l;\n        }\n      }\n    }, t.prototype.closePath = function() {\n      var e = this.currentPath;\n      return e && (e.closeStroke = !0, this.finishPoly()), this;\n    }, t.prototype.setMatrix = function(e) {\n      return this._matrix = e, this;\n    }, t.prototype.beginHole = function() {\n      return this.finishPoly(), this._holeMode = !0, this;\n    }, t.prototype.endHole = function() {\n      return this.finishPoly(), this._holeMode = !1, this;\n    }, t.prototype.destroy = function(e) {\n      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, i.prototype.destroy.call(this, e);\n    }, t.nextRoundedRectBehavior = !1, t._TEMP_POINT = new xe(), t;\n  }(ye)\n);\n/*!\n * @pixi/sprite - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Ry = function(i, t) {\n  return Ry = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Ry(i, t);\n};\nfunction Qk(i, t) {\n  Ry(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar Eh = new xe(), tN = new Uint16Array([0, 1, 2, 0, 2, 3]), Ue = (\n  /** @class */\n  function(i) {\n    Qk(t, i);\n    function t(e) {\n      var r = i.call(this) || this;\n      return r._anchor = new Ou(r._onAnchorUpdate, r, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), r._texture = null, r._width = 0, r._height = 0, r._tint = null, r._tintRGB = null, r.tint = 16777215, r.blendMode = Et.NORMAL, r._cachedTint = 16777215, r.uvs = null, r.texture = e || Ot.EMPTY, r.vertexData = new Float32Array(8), r.vertexTrimmedData = null, r._transformID = -1, r._textureID = -1, r._transformTrimmedID = -1, r._textureTrimmedID = -1, r.indices = tN, r.pluginName = \"batch\", r.isSprite = !0, r._roundPixels = gt.ROUND_PIXELS, r;\n    }\n    return t.prototype._onTextureUpdate = function() {\n      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Pu(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Pu(this.scale.y) * this._height / this._texture.orig.height);\n    }, t.prototype._onAnchorUpdate = function() {\n      this._transformID = -1, this._transformTrimmedID = -1;\n    }, t.prototype.calculateVertices = function() {\n      var e = this._texture;\n      if (!(this._transformID === this.transform._worldID && this._textureID === e._updateID)) {\n        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;\n        var r = this.transform.worldTransform, n = r.a, s = r.b, a = r.c, o = r.d, u = r.tx, l = r.ty, h = this.vertexData, d = e.trim, f = e.orig, p = this._anchor, v = 0, g = 0, m = 0, y = 0;\n        if (d ? (g = d.x - p._x * f.width, v = g + d.width, y = d.y - p._y * f.height, m = y + d.height) : (g = -p._x * f.width, v = g + f.width, y = -p._y * f.height, m = y + f.height), h[0] = n * g + a * y + u, h[1] = o * y + s * g + l, h[2] = n * v + a * y + u, h[3] = o * y + s * v + l, h[4] = n * v + a * m + u, h[5] = o * m + s * v + l, h[6] = n * g + a * m + u, h[7] = o * m + s * g + l, this._roundPixels)\n          for (var _ = gt.RESOLUTION, b = 0; b < h.length; ++b)\n            h[b] = Math.round((h[b] * _ | 0) / _);\n      }\n    }, t.prototype.calculateTrimmedVertices = function() {\n      if (!this.vertexTrimmedData)\n        this.vertexTrimmedData = new Float32Array(8);\n      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)\n        return;\n      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;\n      var e = this._texture, r = this.vertexTrimmedData, n = e.orig, s = this._anchor, a = this.transform.worldTransform, o = a.a, u = a.b, l = a.c, h = a.d, d = a.tx, f = a.ty, p = -s._x * n.width, v = p + n.width, g = -s._y * n.height, m = g + n.height;\n      r[0] = o * p + l * g + d, r[1] = h * g + u * p + f, r[2] = o * v + l * g + d, r[3] = h * g + u * v + f, r[4] = o * v + l * m + d, r[5] = h * m + u * v + f, r[6] = o * p + l * m + d, r[7] = h * m + u * p + f;\n    }, t.prototype._render = function(e) {\n      this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this);\n    }, t.prototype._calculateBounds = function() {\n      var e = this._texture.trim, r = this._texture.orig;\n      !e || e.width === r.width && e.height === r.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));\n    }, t.prototype.getLocalBounds = function(e) {\n      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new vv()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : i.prototype.getLocalBounds.call(this, e);\n    }, t.prototype.containsPoint = function(e) {\n      this.worldTransform.applyInverse(e, Eh);\n      var r = this._texture.orig.width, n = this._texture.orig.height, s = -r * this.anchor.x, a = 0;\n      return Eh.x >= s && Eh.x < s + r && (a = -n * this.anchor.y, Eh.y >= a && Eh.y < a + n);\n    }, t.prototype.destroy = function(e) {\n      i.prototype.destroy.call(this, e), this._texture.off(\"update\", this._onTextureUpdate, this), this._anchor = null;\n      var r = typeof e == \"boolean\" ? e : e && e.texture;\n      if (r) {\n        var n = typeof e == \"boolean\" ? e : e && e.baseTexture;\n        this._texture.destroy(!!n);\n      }\n      this._texture = null;\n    }, t.from = function(e, r) {\n      var n = e instanceof Ot ? e : Ot.from(e, r);\n      return new t(n);\n    }, Object.defineProperty(t.prototype, \"roundPixels\", {\n      get: function() {\n        return this._roundPixels;\n      },\n      /**\n       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n       *\n       * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n       * The main disadvantage is movement of objects may appear less smooth.\n       *\n       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.\n       * @default false\n       */\n      set: function(e) {\n        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n      },\n      set: function(e) {\n        var r = Pu(this.scale.x) || 1;\n        this.scale.x = r * e / this._texture.orig.width, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n      },\n      set: function(e) {\n        var r = Pu(this.scale.y) || 1;\n        this.scale.y = r * e / this._texture.orig.height, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"anchor\", {\n      /**\n       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n       * and passed to the constructor.\n       *\n       * The default is `(0,0)`, this means the sprite's origin is the top left.\n       *\n       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n       *\n       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n       *\n       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n       * @example\n       * const sprite = new PIXI.Sprite(texture);\n       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n       */\n      get: function() {\n        return this._anchor;\n      },\n      set: function(e) {\n        this._anchor.copyFrom(e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The tint applied to the sprite. This is a hex value.\n       *\n       * A value of 0xFFFFFF will remove any tint effect.\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return this._tint;\n      },\n      set: function(e) {\n        this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"texture\", {\n      /** The texture that the sprite is using. */\n      get: function() {\n        return this._texture;\n      },\n      set: function(e) {\n        this._texture !== e && (this._texture && this._texture.off(\"update\", this._onTextureUpdate, this), this._texture = e || Ot.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once(\"update\", this._onTextureUpdate, this)));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(ye)\n);\n/*!\n * @pixi/text - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/text is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Dy = function(i, t) {\n  return Dy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Dy(i, t);\n};\nfunction eN(i, t) {\n  Dy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar cc;\n(function(i) {\n  i[i.LINEAR_VERTICAL = 0] = \"LINEAR_VERTICAL\", i[i.LINEAR_HORIZONTAL = 1] = \"LINEAR_HORIZONTAL\";\n})(cc || (cc = {}));\nvar Z0 = {\n  align: \"left\",\n  breakWords: !1,\n  dropShadow: !1,\n  dropShadowAlpha: 1,\n  dropShadowAngle: Math.PI / 6,\n  dropShadowBlur: 0,\n  dropShadowColor: \"black\",\n  dropShadowDistance: 5,\n  fill: \"black\",\n  fillGradientType: cc.LINEAR_VERTICAL,\n  fillGradientStops: [],\n  fontFamily: \"Arial\",\n  fontSize: 26,\n  fontStyle: \"normal\",\n  fontVariant: \"normal\",\n  fontWeight: \"normal\",\n  letterSpacing: 0,\n  lineHeight: 0,\n  lineJoin: \"miter\",\n  miterLimit: 10,\n  padding: 0,\n  stroke: \"black\",\n  strokeThickness: 0,\n  textBaseline: \"alphabetic\",\n  trim: !1,\n  whiteSpace: \"pre\",\n  wordWrap: !1,\n  wordWrapWidth: 100,\n  leading: 0\n}, rN = [\n  \"serif\",\n  \"sans-serif\",\n  \"monospace\",\n  \"cursive\",\n  \"fantasy\",\n  \"system-ui\"\n], Qo = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.styleID = 0, this.reset(), J0(this, t, t);\n    }\n    return i.prototype.clone = function() {\n      var t = {};\n      return J0(t, this, Z0), new i(t);\n    }, i.prototype.reset = function() {\n      J0(this, Z0, Z0);\n    }, Object.defineProperty(i.prototype, \"align\", {\n      /**\n       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._align;\n      },\n      set: function(t) {\n        this._align !== t && (this._align = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"breakWords\", {\n      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n      get: function() {\n        return this._breakWords;\n      },\n      set: function(t) {\n        this._breakWords !== t && (this._breakWords = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadow\", {\n      /** Set a drop shadow for the text. */\n      get: function() {\n        return this._dropShadow;\n      },\n      set: function(t) {\n        this._dropShadow !== t && (this._dropShadow = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadowAlpha\", {\n      /** Set alpha for the drop shadow. */\n      get: function() {\n        return this._dropShadowAlpha;\n      },\n      set: function(t) {\n        this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadowAngle\", {\n      /** Set a angle of the drop shadow. */\n      get: function() {\n        return this._dropShadowAngle;\n      },\n      set: function(t) {\n        this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadowBlur\", {\n      /** Set a shadow blur radius. */\n      get: function() {\n        return this._dropShadowBlur;\n      },\n      set: function(t) {\n        this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadowColor\", {\n      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */\n      get: function() {\n        return this._dropShadowColor;\n      },\n      set: function(t) {\n        var e = K0(t);\n        this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"dropShadowDistance\", {\n      /** Set a distance of the drop shadow. */\n      get: function() {\n        return this._dropShadowDistance;\n      },\n      set: function(t) {\n        this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fill\", {\n      /**\n       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.\n       *\n       * Can be an array to create a gradient eg ['#000000','#FFFFFF']\n       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n       *\n       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n       */\n      get: function() {\n        return this._fill;\n      },\n      set: function(t) {\n        var e = K0(t);\n        this._fill !== e && (this._fill = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fillGradientType\", {\n      /**\n       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.\n       *\n       * @see PIXI.TEXT_GRADIENT\n       */\n      get: function() {\n        return this._fillGradientType;\n      },\n      set: function(t) {\n        this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fillGradientStops\", {\n      /**\n       * If fill is an array of colours to create a gradient, this array can set the stop points\n       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.\n       */\n      get: function() {\n        return this._fillGradientStops;\n      },\n      set: function(t) {\n        iN(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fontFamily\", {\n      /** The font family. */\n      get: function() {\n        return this._fontFamily;\n      },\n      set: function(t) {\n        this.fontFamily !== t && (this._fontFamily = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fontSize\", {\n      /**\n       * The font size\n       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')\n       */\n      get: function() {\n        return this._fontSize;\n      },\n      set: function(t) {\n        this._fontSize !== t && (this._fontSize = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fontStyle\", {\n      /**\n       * The font style\n       * ('normal', 'italic' or 'oblique')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontStyle;\n      },\n      set: function(t) {\n        this._fontStyle !== t && (this._fontStyle = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fontVariant\", {\n      /**\n       * The font variant\n       * ('normal' or 'small-caps')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontVariant;\n      },\n      set: function(t) {\n        this._fontVariant !== t && (this._fontVariant = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"fontWeight\", {\n      /**\n       * The font weight\n       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._fontWeight;\n      },\n      set: function(t) {\n        this._fontWeight !== t && (this._fontWeight = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"letterSpacing\", {\n      /** The amount of spacing between letters, default is 0. */\n      get: function() {\n        return this._letterSpacing;\n      },\n      set: function(t) {\n        this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"lineHeight\", {\n      /** The line height, a number that represents the vertical space that a letter uses. */\n      get: function() {\n        return this._lineHeight;\n      },\n      set: function(t) {\n        this._lineHeight !== t && (this._lineHeight = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"leading\", {\n      /** The space between lines. */\n      get: function() {\n        return this._leading;\n      },\n      set: function(t) {\n        this._leading !== t && (this._leading = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"lineJoin\", {\n      /**\n       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.\n       * Default is 'miter' (creates a sharp corner).\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._lineJoin;\n      },\n      set: function(t) {\n        this._lineJoin !== t && (this._lineJoin = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"miterLimit\", {\n      /**\n       * The miter limit to use when using the 'miter' lineJoin mode.\n       *\n       * This can reduce or increase the spikiness of rendered text.\n       */\n      get: function() {\n        return this._miterLimit;\n      },\n      set: function(t) {\n        this._miterLimit !== t && (this._miterLimit = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"padding\", {\n      /**\n       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n       * by adding padding to all sides of the text.\n       */\n      get: function() {\n        return this._padding;\n      },\n      set: function(t) {\n        this._padding !== t && (this._padding = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"stroke\", {\n      /**\n       * A canvas fillstyle that will be used on the text stroke\n       * e.g 'blue', '#FCFF00'\n       */\n      get: function() {\n        return this._stroke;\n      },\n      set: function(t) {\n        var e = K0(t);\n        this._stroke !== e && (this._stroke = e, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"strokeThickness\", {\n      /**\n       * A number that represents the thickness of the stroke.\n       *\n       * @default 0\n       */\n      get: function() {\n        return this._strokeThickness;\n      },\n      set: function(t) {\n        this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"textBaseline\", {\n      /**\n       * The baseline of the text that is rendered.\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._textBaseline;\n      },\n      set: function(t) {\n        this._textBaseline !== t && (this._textBaseline = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"trim\", {\n      /** Trim transparent borders. */\n      get: function() {\n        return this._trim;\n      },\n      set: function(t) {\n        this._trim !== t && (this._trim = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"whiteSpace\", {\n      /**\n       * How newlines and spaces should be handled.\n       * Default is 'pre' (preserve, preserve).\n       *\n       *  value       | New lines     |   Spaces\n       *  ---         | ---           |   ---\n       * 'normal'     | Collapse      |   Collapse\n       * 'pre'        | Preserve      |   Preserve\n       * 'pre-line'   | Preserve      |   Collapse\n       *\n       * @member {string}\n       */\n      get: function() {\n        return this._whiteSpace;\n      },\n      set: function(t) {\n        this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"wordWrap\", {\n      /** Indicates if word wrap should be used. */\n      get: function() {\n        return this._wordWrap;\n      },\n      set: function(t) {\n        this._wordWrap !== t && (this._wordWrap = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"wordWrapWidth\", {\n      /** The width at which text will wrap, it needs wordWrap to be set to true. */\n      get: function() {\n        return this._wordWrapWidth;\n      },\n      set: function(t) {\n        this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.toFontString = function() {\n      var t = typeof this.fontSize == \"number\" ? this.fontSize + \"px\" : this.fontSize, e = this.fontFamily;\n      Array.isArray(this.fontFamily) || (e = this.fontFamily.split(\",\"));\n      for (var r = e.length - 1; r >= 0; r--) {\n        var n = e[r].trim();\n        !/([\\\"\\'])[^\\'\\\"]+\\1/.test(n) && rN.indexOf(n) < 0 && (n = '\"' + n + '\"'), e[r] = n;\n      }\n      return this.fontStyle + \" \" + this.fontVariant + \" \" + this.fontWeight + \" \" + t + \" \" + e.join(\",\");\n    }, i;\n  }()\n);\nfunction q1(i) {\n  return typeof i == \"number\" ? IE(i) : (typeof i == \"string\" && i.indexOf(\"0x\") === 0 && (i = i.replace(\"0x\", \"#\")), i);\n}\nfunction K0(i) {\n  if (Array.isArray(i)) {\n    for (var t = 0; t < i.length; ++t)\n      i[t] = q1(i[t]);\n    return i;\n  } else\n    return q1(i);\n}\nfunction iN(i, t) {\n  if (!Array.isArray(i) || !Array.isArray(t) || i.length !== t.length)\n    return !1;\n  for (var e = 0; e < i.length; ++e)\n    if (i[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction J0(i, t, e) {\n  for (var r in e)\n    Array.isArray(t[r]) ? i[r] = t[r].slice() : i[r] = t[r];\n}\nvar sp = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: !0\n}, Gn = (\n  /** @class */\n  function() {\n    function i(t, e, r, n, s, a, o, u, l) {\n      this.text = t, this.style = e, this.width = r, this.height = n, this.lines = s, this.lineWidths = a, this.lineHeight = o, this.maxLineWidth = u, this.fontProperties = l;\n    }\n    return i.measureText = function(t, e, r, n) {\n      n === void 0 && (n = i._canvas), r = r ?? e.wordWrap;\n      var s = e.toFontString(), a = i.measureFont(s);\n      a.fontSize === 0 && (a.fontSize = e.fontSize, a.ascent = e.fontSize);\n      var o = n.getContext(\"2d\", sp);\n      o.font = s;\n      for (var u = r ? i.wordWrap(t, e, n) : t, l = u.split(/(?:\\r\\n|\\r|\\n)/), h = new Array(l.length), d = 0, f = 0; f < l.length; f++) {\n        var p = o.measureText(l[f]).width + (l[f].length - 1) * e.letterSpacing;\n        h[f] = p, d = Math.max(d, p);\n      }\n      var v = d + e.strokeThickness;\n      e.dropShadow && (v += e.dropShadowDistance);\n      var g = e.lineHeight || a.fontSize + e.strokeThickness, m = Math.max(g, a.fontSize + e.strokeThickness) + (l.length - 1) * (g + e.leading);\n      return e.dropShadow && (m += e.dropShadowDistance), new i(t, e, v, m, l, h, g + e.leading, d, a);\n    }, i.wordWrap = function(t, e, r) {\n      r === void 0 && (r = i._canvas);\n      for (var n = r.getContext(\"2d\", sp), s = 0, a = \"\", o = \"\", u = /* @__PURE__ */ Object.create(null), l = e.letterSpacing, h = e.whiteSpace, d = i.collapseSpaces(h), f = i.collapseNewlines(h), p = !d, v = e.wordWrapWidth + l, g = i.tokenize(t), m = 0; m < g.length; m++) {\n        var y = g[m];\n        if (i.isNewline(y)) {\n          if (!f) {\n            o += i.addLine(a), p = !d, a = \"\", s = 0;\n            continue;\n          }\n          y = \" \";\n        }\n        if (d) {\n          var _ = i.isBreakingSpace(y), b = i.isBreakingSpace(a[a.length - 1]);\n          if (_ && b)\n            continue;\n        }\n        var w = i.getFromCache(y, l, u, n);\n        if (w > v)\n          if (a !== \"\" && (o += i.addLine(a), a = \"\", s = 0), i.canBreakWords(y, e.breakWords))\n            for (var T = i.wordWrapSplit(y), x = 0; x < T.length; x++) {\n              for (var S = T[x], C = 1; T[x + C]; ) {\n                var M = T[x + C], I = S[S.length - 1];\n                if (!i.canBreakChars(I, M, y, x, e.breakWords))\n                  S += M;\n                else\n                  break;\n                C++;\n              }\n              x += S.length - 1;\n              var R = i.getFromCache(S, l, u, n);\n              R + s > v && (o += i.addLine(a), p = !1, a = \"\", s = 0), a += S, s += R;\n            }\n          else {\n            a.length > 0 && (o += i.addLine(a), a = \"\", s = 0);\n            var N = m === g.length - 1;\n            o += i.addLine(y, !N), p = !1, a = \"\", s = 0;\n          }\n        else\n          w + s > v && (p = !1, o += i.addLine(a), a = \"\", s = 0), (a.length > 0 || !i.isBreakingSpace(y) || p) && (a += y, s += w);\n      }\n      return o += i.addLine(a, !1), o;\n    }, i.addLine = function(t, e) {\n      return e === void 0 && (e = !0), t = i.trimRight(t), t = e ? t + `\n` : t, t;\n    }, i.getFromCache = function(t, e, r, n) {\n      var s = r[t];\n      if (typeof s != \"number\") {\n        var a = t.length * e;\n        s = n.measureText(t).width + a, r[t] = s;\n      }\n      return s;\n    }, i.collapseSpaces = function(t) {\n      return t === \"normal\" || t === \"pre-line\";\n    }, i.collapseNewlines = function(t) {\n      return t === \"normal\";\n    }, i.trimRight = function(t) {\n      if (typeof t != \"string\")\n        return \"\";\n      for (var e = t.length - 1; e >= 0; e--) {\n        var r = t[e];\n        if (!i.isBreakingSpace(r))\n          break;\n        t = t.slice(0, -1);\n      }\n      return t;\n    }, i.isNewline = function(t) {\n      return typeof t != \"string\" ? !1 : i._newlines.indexOf(t.charCodeAt(0)) >= 0;\n    }, i.isBreakingSpace = function(t, e) {\n      return typeof t != \"string\" ? !1 : i._breakingSpaces.indexOf(t.charCodeAt(0)) >= 0;\n    }, i.tokenize = function(t) {\n      var e = [], r = \"\";\n      if (typeof t != \"string\")\n        return e;\n      for (var n = 0; n < t.length; n++) {\n        var s = t[n], a = t[n + 1];\n        if (i.isBreakingSpace(s, a) || i.isNewline(s)) {\n          r !== \"\" && (e.push(r), r = \"\"), e.push(s);\n          continue;\n        }\n        r += s;\n      }\n      return r !== \"\" && e.push(r), e;\n    }, i.canBreakWords = function(t, e) {\n      return e;\n    }, i.canBreakChars = function(t, e, r, n, s) {\n      return !0;\n    }, i.wordWrapSplit = function(t) {\n      return t.split(\"\");\n    }, i.measureFont = function(t) {\n      if (i._fonts[t])\n        return i._fonts[t];\n      var e = {\n        ascent: 0,\n        descent: 0,\n        fontSize: 0\n      }, r = i._canvas, n = i._context;\n      n.font = t;\n      var s = i.METRICS_STRING + i.BASELINE_SYMBOL, a = Math.ceil(n.measureText(s).width), o = Math.ceil(n.measureText(i.BASELINE_SYMBOL).width), u = Math.ceil(i.HEIGHT_MULTIPLIER * o);\n      o = o * i.BASELINE_MULTIPLIER | 0, r.width = a, r.height = u, n.fillStyle = \"#f00\", n.fillRect(0, 0, a, u), n.font = t, n.textBaseline = \"alphabetic\", n.fillStyle = \"#000\", n.fillText(s, 0, o);\n      var l = n.getImageData(0, 0, a, u).data, h = l.length, d = a * 4, f = 0, p = 0, v = !1;\n      for (f = 0; f < o; ++f) {\n        for (var g = 0; g < d; g += 4)\n          if (l[p + g] !== 255) {\n            v = !0;\n            break;\n          }\n        if (!v)\n          p += d;\n        else\n          break;\n      }\n      for (e.ascent = o - f, p = h - d, v = !1, f = u; f > o; --f) {\n        for (var g = 0; g < d; g += 4)\n          if (l[p + g] !== 255) {\n            v = !0;\n            break;\n          }\n        if (!v)\n          p -= d;\n        else\n          break;\n      }\n      return e.descent = f - o, e.fontSize = e.ascent + e.descent, i._fonts[t] = e, e;\n    }, i.clearMetrics = function(t) {\n      t === void 0 && (t = \"\"), t ? delete i._fonts[t] : i._fonts = {};\n    }, Object.defineProperty(i, \"_canvas\", {\n      /**\n       * Cached canvas element for measuring text\n       * TODO: this should be private, but isn't because of backward compat, will fix later.\n       * @ignore\n       */\n      get: function() {\n        if (!i.__canvas) {\n          var t = void 0;\n          try {\n            var e = new OffscreenCanvas(0, 0), r = e.getContext(\"2d\", sp);\n            if (r && r.measureText)\n              return i.__canvas = e, e;\n            t = gt.ADAPTER.createCanvas();\n          } catch {\n            t = gt.ADAPTER.createCanvas();\n          }\n          t.width = t.height = 10, i.__canvas = t;\n        }\n        return i.__canvas;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i, \"_context\", {\n      /**\n       * TODO: this should be private, but isn't because of backward compat, will fix later.\n       * @ignore\n       */\n      get: function() {\n        return i.__context || (i.__context = i._canvas.getContext(\"2d\", sp)), i.__context;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i;\n  }()\n);\nGn._fonts = {};\nGn.METRICS_STRING = \"|ÉqÅ\";\nGn.BASELINE_SYMBOL = \"M\";\nGn.BASELINE_MULTIPLIER = 1.4;\nGn.HEIGHT_MULTIPLIER = 2;\nGn._newlines = [\n  10,\n  13\n];\nGn._breakingSpaces = [\n  9,\n  32,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8200,\n  8201,\n  8202,\n  8287,\n  12288\n];\nvar nN = {\n  texture: !0,\n  children: !1,\n  baseTexture: !0\n}, tx = (\n  /** @class */\n  function(i) {\n    eN(t, i);\n    function t(e, r, n) {\n      var s = this, a = !1;\n      n || (n = gt.ADAPTER.createCanvas(), a = !0), n.width = 3, n.height = 3;\n      var o = Ot.from(n);\n      return o.orig = new Nt(), o.trim = new Nt(), s = i.call(this, o) || this, s._ownCanvas = a, s.canvas = n, s.context = n.getContext(\"2d\", {\n        // required for trimming to work without warnings\n        willReadFrequently: !0\n      }), s._resolution = gt.RESOLUTION, s._autoResolution = !0, s._text = null, s._style = null, s._styleListener = null, s._font = \"\", s.text = e, s.style = r, s.localStyleID = -1, s;\n    }\n    return t.prototype.updateText = function(e) {\n      var r = this._style;\n      if (this.localStyleID !== r.styleID && (this.dirty = !0, this.localStyleID = r.styleID), !(!this.dirty && e)) {\n        this._font = this._style.toFontString();\n        var n = this.context, s = Gn.measureText(this._text || \" \", this._style, this._style.wordWrap, this.canvas), a = s.width, o = s.height, u = s.lines, l = s.lineHeight, h = s.lineWidths, d = s.maxLineWidth, f = s.fontProperties;\n        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a) + r.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, o) + r.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = r.strokeThickness, n.textBaseline = r.textBaseline, n.lineJoin = r.lineJoin, n.miterLimit = r.miterLimit;\n        for (var p, v, g = r.dropShadow ? 2 : 1, m = 0; m < g; ++m) {\n          var y = r.dropShadow && m === 0, _ = y ? Math.ceil(Math.max(1, o) + r.padding * 2) : 0, b = _ * this._resolution;\n          if (y) {\n            n.fillStyle = \"black\", n.strokeStyle = \"black\";\n            var w = r.dropShadowColor, T = Jl(typeof w == \"number\" ? w : RE(w)), x = r.dropShadowBlur * this._resolution, S = r.dropShadowDistance * this._resolution;\n            n.shadowColor = \"rgba(\" + T[0] * 255 + \",\" + T[1] * 255 + \",\" + T[2] * 255 + \",\" + r.dropShadowAlpha + \")\", n.shadowBlur = x, n.shadowOffsetX = Math.cos(r.dropShadowAngle) * S, n.shadowOffsetY = Math.sin(r.dropShadowAngle) * S + b;\n          } else\n            n.fillStyle = this._generateFillStyle(r, u, s), n.strokeStyle = r.stroke, n.shadowColor = \"black\", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;\n          var C = (l - f.fontSize) / 2;\n          (!t.nextLineHeightBehavior || l - f.fontSize < 0) && (C = 0);\n          for (var M = 0; M < u.length; M++)\n            p = r.strokeThickness / 2, v = r.strokeThickness / 2 + M * l + f.ascent + C, r.align === \"right\" ? p += d - h[M] : r.align === \"center\" && (p += (d - h[M]) / 2), r.stroke && r.strokeThickness && this.drawLetterSpacing(u[M], p + r.padding, v + r.padding - _, !0), r.fill && this.drawLetterSpacing(u[M], p + r.padding, v + r.padding - _);\n        }\n        this.updateTexture();\n      }\n    }, t.prototype.drawLetterSpacing = function(e, r, n, s) {\n      s === void 0 && (s = !1);\n      var a = this._style, o = a.letterSpacing, u = t.experimentalLetterSpacing && (\"letterSpacing\" in CanvasRenderingContext2D.prototype || \"textLetterSpacing\" in CanvasRenderingContext2D.prototype);\n      if (o === 0 || u) {\n        u && (this.context.letterSpacing = o, this.context.textLetterSpacing = o), s ? this.context.strokeText(e, r, n) : this.context.fillText(e, r, n);\n        return;\n      }\n      for (var l = r, h = Array.from ? Array.from(e) : e.split(\"\"), d = this.context.measureText(e).width, f = 0, p = 0; p < h.length; ++p) {\n        var v = h[p];\n        s ? this.context.strokeText(v, l, n) : this.context.fillText(v, l, n);\n        for (var g = \"\", m = p + 1; m < h.length; ++m)\n          g += h[m];\n        f = this.context.measureText(g).width, l += d - f + o, d = f;\n      }\n    }, t.prototype.updateTexture = function() {\n      var e = this.canvas;\n      if (this._style.trim) {\n        var r = ID(e);\n        r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0));\n      }\n      var n = this._texture, s = this._style, a = s.trim ? 0 : s.padding, o = n.baseTexture;\n      n.trim.width = n._frame.width = e.width / this._resolution, n.trim.height = n._frame.height = e.height / this._resolution, n.trim.x = -a, n.trim.y = -a, n.orig.width = n._frame.width - a * 2, n.orig.height = n._frame.height - a * 2, this._onTextureUpdate(), o.setRealSize(e.width, e.height, this._resolution), n.updateUvs(), this.dirty = !1;\n    }, t.prototype._render = function(e) {\n      this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), i.prototype._render.call(this, e);\n    }, t.prototype.updateTransform = function() {\n      this.updateText(!0), i.prototype.updateTransform.call(this);\n    }, t.prototype.getBounds = function(e, r) {\n      return this.updateText(!0), this._textureID === -1 && (e = !1), i.prototype.getBounds.call(this, e, r);\n    }, t.prototype.getLocalBounds = function(e) {\n      return this.updateText(!0), i.prototype.getLocalBounds.call(this, e);\n    }, t.prototype._calculateBounds = function() {\n      this.calculateVertices(), this._bounds.addQuad(this.vertexData);\n    }, t.prototype._generateFillStyle = function(e, r, n) {\n      var s = e.fill;\n      if (Array.isArray(s)) {\n        if (s.length === 1)\n          return s[0];\n      } else\n        return s;\n      var a, o = e.dropShadow ? e.dropShadowDistance : 0, u = e.padding || 0, l = this.canvas.width / this._resolution - o - u * 2, h = this.canvas.height / this._resolution - o - u * 2, d = s.slice(), f = e.fillGradientStops.slice();\n      if (!f.length)\n        for (var p = d.length + 1, v = 1; v < p; ++v)\n          f.push(v / p);\n      if (d.unshift(s[0]), f.unshift(0), d.push(s[s.length - 1]), f.push(1), e.fillGradientType === cc.LINEAR_VERTICAL) {\n        a = this.context.createLinearGradient(l / 2, u, l / 2, h + u);\n        for (var g = n.fontProperties.fontSize + e.strokeThickness, v = 0; v < r.length; v++) {\n          var m = n.lineHeight * (v - 1) + g, y = n.lineHeight * v, _ = y;\n          v > 0 && m > y && (_ = (y + m) / 2);\n          var b = y + g, w = n.lineHeight * (v + 1), T = b;\n          v + 1 < r.length && w < b && (T = (b + w) / 2);\n          for (var x = (T - _) / h, S = 0; S < d.length; S++) {\n            var C = 0;\n            typeof f[S] == \"number\" ? C = f[S] : C = S / d.length;\n            var M = Math.min(1, Math.max(0, _ / h + C * x));\n            M = Number(M.toFixed(5)), a.addColorStop(M, d[S]);\n          }\n        }\n      } else {\n        a = this.context.createLinearGradient(u, h / 2, l + u, h / 2);\n        for (var I = d.length + 1, R = 1, v = 0; v < d.length; v++) {\n          var N = void 0;\n          typeof f[v] == \"number\" ? N = f[v] : N = R / I, a.addColorStop(N, d[v]), R++;\n        }\n      }\n      return a;\n    }, t.prototype.destroy = function(e) {\n      typeof e == \"boolean\" && (e = { children: e }), e = Object.assign({}, nN, e), i.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;\n    }, Object.defineProperty(t.prototype, \"width\", {\n      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;\n      },\n      set: function(e) {\n        this.updateText(!0);\n        var r = Pu(this.scale.x) || 1;\n        this.scale.x = r * e / this._texture.orig.width, this._width = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"height\", {\n      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */\n      get: function() {\n        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;\n      },\n      set: function(e) {\n        this.updateText(!0);\n        var r = Pu(this.scale.y) || 1;\n        this.scale.y = r * e / this._texture.orig.height, this._height = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"style\", {\n      /**\n       * Set the style of the text.\n       *\n       * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n       */\n      get: function() {\n        return this._style;\n      },\n      set: function(e) {\n        e = e || {}, e instanceof Qo ? this._style = e : this._style = new Qo(e), this.localStyleID = -1, this.dirty = !0;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"text\", {\n      /** Set the copy for the text object. To split a line you can use '\\n'. */\n      get: function() {\n        return this._text;\n      },\n      set: function(e) {\n        e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"resolution\", {\n      /**\n       * The resolution / device pixel ratio of the canvas.\n       *\n       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n       * @default 1\n       */\n      get: function() {\n        return this._resolution;\n      },\n      set: function(e) {\n        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.nextLineHeightBehavior = !1, t.experimentalLetterSpacing = !1, t;\n  }(Ue)\n);\n/*!\n * @pixi/prepare - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/prepare is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\ngt.UPLOADS_PER_FRAME = 4;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar ky = function(i, t) {\n  return ky = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, ky(i, t);\n};\nfunction sN(i, t) {\n  ky(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar aN = (\n  /** @class */\n  function() {\n    function i(t) {\n      this.maxItemsPerFrame = t, this.itemsLeft = 0;\n    }\n    return i.prototype.beginFrame = function() {\n      this.itemsLeft = this.maxItemsPerFrame;\n    }, i.prototype.allowedToUpload = function() {\n      return this.itemsLeft-- > 0;\n    }, i;\n  }()\n);\nfunction oN(i, t) {\n  var e = !1;\n  if (i && i._textures && i._textures.length) {\n    for (var r = 0; r < i._textures.length; r++)\n      if (i._textures[r] instanceof Ot) {\n        var n = i._textures[r].baseTexture;\n        t.indexOf(n) === -1 && (t.push(n), e = !0);\n      }\n  }\n  return e;\n}\nfunction uN(i, t) {\n  if (i.baseTexture instanceof Kt) {\n    var e = i.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction lN(i, t) {\n  if (i._texture && i._texture instanceof Ot) {\n    var e = i._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction hN(i, t) {\n  return t instanceof tx ? (t.updateText(!0), !0) : !1;\n}\nfunction cN(i, t) {\n  if (t instanceof Qo) {\n    var e = t.toFontString();\n    return Gn.measureFont(e), !0;\n  }\n  return !1;\n}\nfunction fN(i, t) {\n  if (i instanceof tx) {\n    t.indexOf(i.style) === -1 && t.push(i.style), t.indexOf(i) === -1 && t.push(i);\n    var e = i._texture.baseTexture;\n    return t.indexOf(e) === -1 && t.push(e), !0;\n  }\n  return !1;\n}\nfunction dN(i, t) {\n  return i instanceof Qo ? (t.indexOf(i) === -1 && t.push(i), !0) : !1;\n}\nvar pN = (\n  /** @class */\n  function() {\n    function i(t) {\n      var e = this;\n      this.limiter = new aN(gt.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {\n        e.queue && e.prepareItems();\n      }, this.registerFindHook(fN), this.registerFindHook(dN), this.registerFindHook(oN), this.registerFindHook(uN), this.registerFindHook(lN), this.registerUploadHook(hN), this.registerUploadHook(cN);\n    }\n    return i.prototype.upload = function(t, e) {\n      var r = this;\n      return typeof t == \"function\" && (e = t, t = null), e && jr(\"6.5.0\", \"BasePrepare.upload callback is deprecated, use the return Promise instead.\"), new Promise(function(n) {\n        t && r.add(t);\n        var s = function() {\n          e == null || e(), n();\n        };\n        r.queue.length ? (r.completes.push(s), r.ticking || (r.ticking = !0, Ge.system.addOnce(r.tick, r, Cs.UTILITY))) : s();\n      });\n    }, i.prototype.tick = function() {\n      setTimeout(this.delayedTick, 0);\n    }, i.prototype.prepareItems = function() {\n      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {\n        var t = this.queue[0], e = !1;\n        if (t && !t._destroyed) {\n          for (var r = 0, n = this.uploadHooks.length; r < n; r++)\n            if (this.uploadHooks[r](this.uploadHookHelper, t)) {\n              this.queue.shift(), e = !0;\n              break;\n            }\n        }\n        e || this.queue.shift();\n      }\n      if (this.queue.length)\n        Ge.system.addOnce(this.tick, this, Cs.UTILITY);\n      else {\n        this.ticking = !1;\n        var s = this.completes.slice(0);\n        this.completes.length = 0;\n        for (var r = 0, n = s.length; r < n; r++)\n          s[r]();\n      }\n    }, i.prototype.registerFindHook = function(t) {\n      return t && this.addHooks.push(t), this;\n    }, i.prototype.registerUploadHook = function(t) {\n      return t && this.uploadHooks.push(t), this;\n    }, i.prototype.add = function(t) {\n      for (var e = 0, r = this.addHooks.length; e < r && !this.addHooks[e](t, this.queue); e++)\n        ;\n      if (t instanceof ye)\n        for (var e = t.children.length - 1; e >= 0; e--)\n          this.add(t.children[e]);\n      return this;\n    }, i.prototype.destroy = function() {\n      this.ticking && Ge.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;\n    }, i;\n  }()\n);\nfunction bS(i, t) {\n  return t instanceof Kt ? (t._glTextures[i.CONTEXT_UID] || i.texture.bind(t), !0) : !1;\n}\nfunction vN(i, t) {\n  if (!(t instanceof ai))\n    return !1;\n  var e = t.geometry;\n  t.finishPoly(), e.updateBatches();\n  for (var r = e.batches, n = 0; n < r.length; n++) {\n    var s = r[n].style.texture;\n    s && bS(i, s.baseTexture);\n  }\n  return e.batchable || i.geometry.bind(e, t._resolveDirectShader(i)), !0;\n}\nfunction gN(i, t) {\n  return i instanceof ai ? (t.push(i), !0) : !1;\n}\nvar mN = (\n  /** @class */\n  function(i) {\n    sN(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return r.uploadHookHelper = r.renderer, r.registerFindHook(gN), r.registerUploadHook(bS), r.registerUploadHook(vN), r;\n    }\n    return t.extension = {\n      name: \"prepare\",\n      type: fe.RendererPlugin\n    }, t;\n  }(pN)\n);\n/*!\n * @pixi/spritesheet - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar yN = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      r === void 0 && (r = null), this.linkedSheets = [], this._texture = t instanceof Ot ? t : null, this.baseTexture = t instanceof Kt ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;\n      var n = this.baseTexture.resource;\n      this.resolution = this._updateResolution(r || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;\n    }\n    return i.prototype._updateResolution = function(t) {\n      t === void 0 && (t = null);\n      var e = this.data.meta.scale, r = dv(t, null);\n      return r === null && (r = e !== void 0 ? parseFloat(e) : 1), r !== 1 && this.baseTexture.setResolution(r), r;\n    }, i.prototype.parse = function(t) {\n      var e = this;\n      return t && jr(\"6.5.0\", \"Spritesheet.parse callback is deprecated, use the return Promise instead.\"), new Promise(function(r) {\n        e._callback = function(n) {\n          t == null || t(n), r(n);\n        }, e._batchIndex = 0, e._frameKeys.length <= i.BATCH_SIZE ? (e._processFrames(0), e._processAnimations(), e._parseComplete()) : e._nextBatch();\n      });\n    }, i.prototype._processFrames = function(t) {\n      for (var e = t, r = i.BATCH_SIZE; e - t < r && e < this._frameKeys.length; ) {\n        var n = this._frameKeys[e], s = this._frames[n], a = s.frame;\n        if (a) {\n          var o = null, u = null, l = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame, h = new Nt(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);\n          s.rotated ? o = new Nt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.h) / this.resolution, Math.floor(a.w) / this.resolution) : o = new Nt(Math.floor(a.x) / this.resolution, Math.floor(a.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (u = new Nt(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(a.w) / this.resolution, Math.floor(a.h) / this.resolution)), this.textures[n] = new Ot(this.baseTexture, o, h, u, s.rotated ? 2 : 0, s.anchor), Ot.addToCache(this.textures[n], n);\n        }\n        e++;\n      }\n    }, i.prototype._processAnimations = function() {\n      var t = this.data.animations || {};\n      for (var e in t) {\n        this.animations[e] = [];\n        for (var r = 0; r < t[e].length; r++) {\n          var n = t[e][r];\n          this.animations[e].push(this.textures[n]);\n        }\n      }\n    }, i.prototype._parseComplete = function() {\n      var t = this._callback;\n      this._callback = null, this._batchIndex = 0, t.call(this, this.textures);\n    }, i.prototype._nextBatch = function() {\n      var t = this;\n      this._processFrames(this._batchIndex * i.BATCH_SIZE), this._batchIndex++, setTimeout(function() {\n        t._batchIndex * i.BATCH_SIZE < t._frameKeys.length ? t._nextBatch() : (t._processAnimations(), t._parseComplete());\n      }, 0);\n    }, i.prototype.destroy = function(t) {\n      var e;\n      t === void 0 && (t = !1);\n      for (var r in this.textures)\n        this.textures[r].destroy();\n      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && ((e = this._texture) === null || e === void 0 || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];\n    }, i.BATCH_SIZE = 1e3, i;\n  }()\n), _N = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.use = function(t, e) {\n      var r, n, s = this, a = t.name + \"_image\";\n      if (!t.data || t.type !== Ft.TYPE.JSON || !t.data.frames || s.resources[a]) {\n        e();\n        return;\n      }\n      var o = (n = (r = t.data) === null || r === void 0 ? void 0 : r.meta) === null || n === void 0 ? void 0 : n.related_multi_packs;\n      if (Array.isArray(o))\n        for (var u = function(v) {\n          if (typeof v != \"string\")\n            return \"continue\";\n          var g = v.replace(\".json\", \"\"), m = Mu.resolve(t.url.replace(s.baseUrl, \"\"), v);\n          if (s.resources[g] || Object.values(s.resources).some(function(_) {\n            return Mu.format(Mu.parse(_.url)) === m;\n          }))\n            return \"continue\";\n          var y = {\n            crossOrigin: t.crossOrigin,\n            loadType: Ft.LOAD_TYPE.XHR,\n            xhrType: Ft.XHR_RESPONSE_TYPE.JSON,\n            parentResource: t,\n            metadata: t.metadata\n          };\n          s.add(g, m, y);\n        }, l = 0, h = o; l < h.length; l++) {\n          var d = h[l];\n          u(d);\n        }\n      var f = {\n        crossOrigin: t.crossOrigin,\n        metadata: t.metadata.imageMetadata,\n        parentResource: t\n      }, p = i.getResourcePath(t, s.baseUrl);\n      s.add(a, p, f, function(g) {\n        if (g.error) {\n          e(g.error);\n          return;\n        }\n        var m = new yN(g.texture, t.data, t.url);\n        m.parse().then(function() {\n          t.spritesheet = m, t.textures = m.textures, e();\n        });\n      });\n    }, i.getResourcePath = function(t, e) {\n      return t.isDataUrl ? t.data.meta.image : Mu.resolve(t.url.replace(e, \"\"), t.data.meta.image);\n    }, i.extension = fe.Loader, i;\n  }()\n);\n/*!\n * @pixi/sprite-tiling - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Ny = function(i, t) {\n  return Ny = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Ny(i, t);\n};\nfunction xS(i, t) {\n  Ny(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar Sh = new xe();\n(function(i) {\n  xS(t, i);\n  function t(e, r, n) {\n    r === void 0 && (r = 100), n === void 0 && (n = 100);\n    var s = i.call(this, e) || this;\n    return s.tileTransform = new FE(), s._width = r, s._height = n, s.uvMatrix = s.texture.uvMatrix || new n0(e), s.pluginName = \"tilingSprite\", s.uvRespectAnchor = !1, s;\n  }\n  return Object.defineProperty(t.prototype, \"clampMargin\", {\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get: function() {\n      return this.uvMatrix.clampMargin;\n    },\n    set: function(e) {\n      this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tileScale\", {\n    /** The scaling of the image that is being tiled. */\n    get: function() {\n      return this.tileTransform.scale;\n    },\n    set: function(e) {\n      this.tileTransform.scale.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"tilePosition\", {\n    /** The offset of the image that is being tiled. */\n    get: function() {\n      return this.tileTransform.position;\n    },\n    set: function(e) {\n      this.tileTransform.position.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._onTextureUpdate = function() {\n    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;\n  }, t.prototype._render = function(e) {\n    var r = this._texture;\n    !r || !r.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this));\n  }, t.prototype._calculateBounds = function() {\n    var e = this._width * -this._anchor._x, r = this._height * -this._anchor._y, n = this._width * (1 - this._anchor._x), s = this._height * (1 - this._anchor._y);\n    this._bounds.addFrame(this.transform, e, r, n, s);\n  }, t.prototype.getLocalBounds = function(e) {\n    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Nt()), e = this._localBoundsRect), this._bounds.getRectangle(e)) : i.prototype.getLocalBounds.call(this, e);\n  }, t.prototype.containsPoint = function(e) {\n    this.worldTransform.applyInverse(e, Sh);\n    var r = this._width, n = this._height, s = -r * this.anchor._x;\n    if (Sh.x >= s && Sh.x < s + r) {\n      var a = -n * this.anchor._y;\n      if (Sh.y >= a && Sh.y < a + n)\n        return !0;\n    }\n    return !1;\n  }, t.prototype.destroy = function(e) {\n    i.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null;\n  }, t.from = function(e, r) {\n    var n = e instanceof Ot ? e : Ot.from(e, r);\n    return new t(n, r.width, r.height);\n  }, Object.defineProperty(t.prototype, \"width\", {\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(Ue);\nvar bN = `#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n`, Z1 = `#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, xN = `#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n`, wN = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n`, EN = `#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n`, ap = new ar(), SN = (\n  /** @class */\n  function(i) {\n    xS(t, i);\n    function t(e) {\n      var r = i.call(this, e) || this;\n      return e.runners.contextChange.add(r), r.quad = new Db(), r.state = ga.for2d(), r;\n    }\n    return t.prototype.contextChange = function() {\n      var e = this.renderer, r = { globals: e.globalUniforms };\n      this.simpleShader = xs.from(Z1, bN, r), this.shader = e.context.webGLVersion > 1 ? xs.from(wN, EN, r) : xs.from(Z1, xN, r);\n    }, t.prototype.render = function(e) {\n      var r = this.renderer, n = this.quad, s = n.vertices;\n      s[0] = s[6] = e._width * -e.anchor.x, s[1] = s[3] = e._height * -e.anchor.y, s[2] = s[4] = e._width * (1 - e.anchor.x), s[5] = s[7] = e._height * (1 - e.anchor.y);\n      var a = e.uvRespectAnchor ? e.anchor.x : 0, o = e.uvRespectAnchor ? e.anchor.y : 0;\n      s = n.uvs, s[0] = s[6] = -a, s[1] = s[3] = -o, s[2] = s[4] = 1 - a, s[5] = s[7] = 1 - o, n.invalidate();\n      var u = e._texture, l = u.baseTexture, h = l.alphaMode > 0, d = e.tileTransform.localTransform, f = e.uvMatrix, p = l.isPowerOfTwo && u.frame.width === l.width && u.frame.height === l.height;\n      p && (l._glTextures[r.CONTEXT_UID] ? p = l.wrapMode !== On.CLAMP : l.wrapMode === On.CLAMP && (l.wrapMode = On.REPEAT));\n      var v = p ? this.simpleShader : this.shader, g = u.width, m = u.height, y = e._width, _ = e._height;\n      ap.set(d.a * g / y, d.b * g / _, d.c * m / y, d.d * m / _, d.tx / y, d.ty / _), ap.invert(), p ? ap.prepend(f.mapCoord) : (v.uniforms.uMapCoord = f.mapCoord.toArray(!0), v.uniforms.uClampFrame = f.uClampFrame, v.uniforms.uClampOffset = f.uClampOffset), v.uniforms.uTransform = ap.toArray(!0), v.uniforms.uColor = NE(e.tint, e.worldAlpha, v.uniforms.uColor, h), v.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), v.uniforms.uSampler = u, r.shader.bind(v), r.geometry.bind(n), this.state.blendMode = kE(e.blendMode, h), r.state.set(this.state), r.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }, t.extension = {\n      name: \"tilingSprite\",\n      type: fe.RendererPlugin\n    }, t;\n  }(wd)\n);\n/*!\n * @pixi/mesh - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mesh is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Ay = function(i, t) {\n  return Ay = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Ay(i, t);\n};\nfunction ex(i, t) {\n  Ay(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar TN = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;\n    }\n    return i.prototype.update = function(t) {\n      if (!(!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {\n        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;\n        var e = this.uvBuffer.data;\n        (!this.data || this.data.length !== e.length) && (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++;\n      }\n    }, i;\n  }()\n), Q0 = new xe(), K1 = new Pp(), fc = (\n  /** @class */\n  function(i) {\n    ex(t, i);\n    function t(e, r, n, s) {\n      s === void 0 && (s = qi.TRIANGLES);\n      var a = i.call(this) || this;\n      return a.geometry = e, a.shader = r, a.state = n || ga.for2d(), a.drawMode = s, a.start = 0, a.size = 0, a.uvs = null, a.indices = null, a.vertexData = new Float32Array(1), a.vertexDirty = -1, a._transformID = -1, a._roundPixels = gt.ROUND_PIXELS, a.batchUvs = null, a;\n    }\n    return Object.defineProperty(t.prototype, \"geometry\", {\n      /**\n       * Includes vertex positions, face indices, normals, colors, UVs, and\n       * custom attributes within buffers, reducing the cost of passing all\n       * this data to the GPU. Can be shared between multiple Mesh objects.\n       */\n      get: function() {\n        return this._geometry;\n      },\n      set: function(e) {\n        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"uvBuffer\", {\n      /**\n       * To change mesh uv's, change its uvBuffer data and increment its _updateID.\n       * @readonly\n       */\n      get: function() {\n        return this.geometry.buffers[1];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"verticesBuffer\", {\n      /**\n       * To change mesh vertices, change its uvBuffer data and increment its _updateID.\n       * Incrementing _updateID is optional because most of Mesh objects do it anyway.\n       * @readonly\n       */\n      get: function() {\n        return this.geometry.buffers[0];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"material\", {\n      get: function() {\n        return this.shader;\n      },\n      /** Alias for {@link PIXI.Mesh#shader}. */\n      set: function(e) {\n        this.shader = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"blendMode\", {\n      get: function() {\n        return this.state.blendMode;\n      },\n      /**\n       * The blend mode to be applied to the Mesh. Apply a value of\n       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n       * @default PIXI.BLEND_MODES.NORMAL;\n       */\n      set: function(e) {\n        this.state.blendMode = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"roundPixels\", {\n      get: function() {\n        return this._roundPixels;\n      },\n      /**\n       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n       * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n       * The main disadvantage is movement of objects may appear less smooth.\n       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n       * @default false\n       */\n      set: function(e) {\n        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      /**\n       * The multiply tint applied to the Mesh. This is a hex value. A value of\n       * `0xFFFFFF` will remove any tint effect.\n       *\n       * Null for non-MeshMaterial shaders\n       * @default 0xFFFFFF\n       */\n      get: function() {\n        return \"tint\" in this.shader ? this.shader.tint : null;\n      },\n      set: function(e) {\n        this.shader.tint = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"texture\", {\n      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n      get: function() {\n        return \"texture\" in this.shader ? this.shader.texture : null;\n      },\n      set: function(e) {\n        this.shader.texture = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._render = function(e) {\n      var r = this.geometry.buffers[0].data, n = this.shader;\n      n.batchable && this.drawMode === qi.TRIANGLES && r.length < t.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e);\n    }, t.prototype._renderDefault = function(e) {\n      var r = this.shader;\n      r.alpha = this.worldAlpha, r.update && r.update(), e.batch.flush(), r.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(r), e.state.set(this.state), e.geometry.bind(this.geometry, r), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);\n    }, t.prototype._renderToBatch = function(e) {\n      var r = this.geometry, n = this.shader;\n      n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = r.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;\n      var s = this.material.pluginName;\n      e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this);\n    }, t.prototype.calculateVertices = function() {\n      var e = this.geometry, r = e.buffers[0], n = r.data, s = r._updateID;\n      if (!(s === this.vertexDirty && this._transformID === this.transform._worldID)) {\n        this._transformID = this.transform._worldID, this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));\n        for (var a = this.transform.worldTransform, o = a.a, u = a.b, l = a.c, h = a.d, d = a.tx, f = a.ty, p = this.vertexData, v = 0; v < p.length / 2; v++) {\n          var g = n[v * 2], m = n[v * 2 + 1];\n          p[v * 2] = o * g + l * m + d, p[v * 2 + 1] = u * g + h * m + f;\n        }\n        if (this._roundPixels)\n          for (var y = gt.RESOLUTION, v = 0; v < p.length; ++v)\n            p[v] = Math.round((p[v] * y | 0) / y);\n        this.vertexDirty = s;\n      }\n    }, t.prototype.calculateUvs = function() {\n      var e = this.geometry.buffers[1], r = this.shader;\n      r.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new TN(e, r.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);\n    }, t.prototype._calculateBounds = function() {\n      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);\n    }, t.prototype.containsPoint = function(e) {\n      if (!this.getBounds().contains(e.x, e.y))\n        return !1;\n      this.worldTransform.applyInverse(e, Q0);\n      for (var r = this.geometry.getBuffer(\"aVertexPosition\").data, n = K1.points, s = this.geometry.getIndex().data, a = s.length, o = this.drawMode === 4 ? 3 : 1, u = 0; u + 2 < a; u += o) {\n        var l = s[u] * 2, h = s[u + 1] * 2, d = s[u + 2] * 2;\n        if (n[0] = r[l], n[1] = r[l + 1], n[2] = r[h], n[3] = r[h + 1], n[4] = r[d], n[5] = r[d + 1], K1.contains(Q0.x, Q0.y))\n          return !0;\n      }\n      return !1;\n    }, t.prototype.destroy = function(e) {\n      i.prototype.destroy.call(this, e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;\n    }, t.BATCHABLE_SIZE = 100, t;\n  }(ye)\n), CN = `varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n`, MN = `attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n`, dc = (\n  /** @class */\n  function(i) {\n    ex(t, i);\n    function t(e, r) {\n      var n = this, s = {\n        uSampler: e,\n        alpha: 1,\n        uTextureMatrix: ar.IDENTITY,\n        uColor: new Float32Array([1, 1, 1, 1])\n      };\n      return r = Object.assign({\n        tint: 16777215,\n        alpha: 1,\n        pluginName: \"batch\"\n      }, r), r.uniforms && Object.assign(s, r.uniforms), n = i.call(this, r.program || hh.from(MN, CN), s) || this, n._colorDirty = !1, n.uvMatrix = new n0(e), n.batchable = r.program === void 0, n.pluginName = r.pluginName, n.tint = r.tint, n.alpha = r.alpha, n;\n    }\n    return Object.defineProperty(t.prototype, \"texture\", {\n      /** Reference to the texture being rendered. */\n      get: function() {\n        return this.uniforms.uSampler;\n      },\n      set: function(e) {\n        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"alpha\", {\n      get: function() {\n        return this._alpha;\n      },\n      /**\n       * This gets automatically set by the object using this.\n       * @default 1\n       */\n      set: function(e) {\n        e !== this._alpha && (this._alpha = e, this._colorDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"tint\", {\n      get: function() {\n        return this._tint;\n      },\n      /**\n       * Multiply tint for the material.\n       * @default 0xFFFFFF\n       */\n      set: function(e) {\n        e !== this._tint && (this._tint = e, this._tintRGB = (e >> 16) + (e & 65280) + ((e & 255) << 16), this._colorDirty = !0);\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.update = function() {\n      if (this._colorDirty) {\n        this._colorDirty = !1;\n        var e = this.texture.baseTexture;\n        NE(this._tint, this._alpha, this.uniforms.uColor, e.alphaMode);\n      }\n      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);\n    }, t;\n  }(xs)\n), s0 = (\n  /** @class */\n  function(i) {\n    ex(t, i);\n    function t(e, r, n) {\n      var s = i.call(this) || this, a = new Ke(e), o = new Ke(r, !0), u = new Ke(n, !0, !0);\n      return s.addAttribute(\"aVertexPosition\", a, 2, !1, It.FLOAT).addAttribute(\"aTextureCoord\", o, 2, !1, It.FLOAT).addIndex(u), s._updateId = -1, s;\n    }\n    return Object.defineProperty(t.prototype, \"vertexDirtyId\", {\n      /**\n       * If the vertex position is updated.\n       * @readonly\n       * @private\n       */\n      get: function() {\n        return this.buffers[0]._updateID;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(lh)\n);\n/*!\n * @pixi/text-bitmap - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Ly = function(i, t) {\n  return Ly = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Ly(i, t);\n};\nfunction PN(i, t) {\n  Ly(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar wv = (\n  /** @class */\n  function() {\n    function i() {\n      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];\n    }\n    return i;\n  }()\n), ON = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.test = function(t) {\n      return typeof t == \"string\" && t.indexOf(\"info face=\") === 0;\n    }, i.parse = function(t) {\n      var e = t.match(/^[a-z]+\\s+.+$/gm), r = {\n        info: [],\n        common: [],\n        page: [],\n        char: [],\n        chars: [],\n        kerning: [],\n        kernings: [],\n        distanceField: []\n      };\n      for (var n in e) {\n        var s = e[n].match(/^[a-z]+/gm)[0], a = e[n].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm), o = {};\n        for (var u in a) {\n          var l = a[u].split(\"=\"), h = l[0], d = l[1].replace(/\"/gm, \"\"), f = parseFloat(d), p = isNaN(f) ? d : f;\n          o[h] = p;\n        }\n        r[s].push(o);\n      }\n      var v = new wv();\n      return r.info.forEach(function(g) {\n        return v.info.push({\n          face: g.face,\n          size: parseInt(g.size, 10)\n        });\n      }), r.common.forEach(function(g) {\n        return v.common.push({\n          lineHeight: parseInt(g.lineHeight, 10)\n        });\n      }), r.page.forEach(function(g) {\n        return v.page.push({\n          id: parseInt(g.id, 10),\n          file: g.file\n        });\n      }), r.char.forEach(function(g) {\n        return v.char.push({\n          id: parseInt(g.id, 10),\n          page: parseInt(g.page, 10),\n          x: parseInt(g.x, 10),\n          y: parseInt(g.y, 10),\n          width: parseInt(g.width, 10),\n          height: parseInt(g.height, 10),\n          xoffset: parseInt(g.xoffset, 10),\n          yoffset: parseInt(g.yoffset, 10),\n          xadvance: parseInt(g.xadvance, 10)\n        });\n      }), r.kerning.forEach(function(g) {\n        return v.kerning.push({\n          first: parseInt(g.first, 10),\n          second: parseInt(g.second, 10),\n          amount: parseInt(g.amount, 10)\n        });\n      }), r.distanceField.forEach(function(g) {\n        return v.distanceField.push({\n          distanceRange: parseInt(g.distanceRange, 10),\n          fieldType: g.fieldType\n        });\n      }), v;\n    }, i;\n  }()\n), By = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.test = function(t) {\n      return t instanceof XMLDocument && t.getElementsByTagName(\"page\").length && t.getElementsByTagName(\"info\")[0].getAttribute(\"face\") !== null;\n    }, i.parse = function(t) {\n      for (var e = new wv(), r = t.getElementsByTagName(\"info\"), n = t.getElementsByTagName(\"common\"), s = t.getElementsByTagName(\"page\"), a = t.getElementsByTagName(\"char\"), o = t.getElementsByTagName(\"kerning\"), u = t.getElementsByTagName(\"distanceField\"), l = 0; l < r.length; l++)\n        e.info.push({\n          face: r[l].getAttribute(\"face\"),\n          size: parseInt(r[l].getAttribute(\"size\"), 10)\n        });\n      for (var l = 0; l < n.length; l++)\n        e.common.push({\n          lineHeight: parseInt(n[l].getAttribute(\"lineHeight\"), 10)\n        });\n      for (var l = 0; l < s.length; l++)\n        e.page.push({\n          id: parseInt(s[l].getAttribute(\"id\"), 10) || 0,\n          file: s[l].getAttribute(\"file\")\n        });\n      for (var l = 0; l < a.length; l++) {\n        var h = a[l];\n        e.char.push({\n          id: parseInt(h.getAttribute(\"id\"), 10),\n          page: parseInt(h.getAttribute(\"page\"), 10) || 0,\n          x: parseInt(h.getAttribute(\"x\"), 10),\n          y: parseInt(h.getAttribute(\"y\"), 10),\n          width: parseInt(h.getAttribute(\"width\"), 10),\n          height: parseInt(h.getAttribute(\"height\"), 10),\n          xoffset: parseInt(h.getAttribute(\"xoffset\"), 10),\n          yoffset: parseInt(h.getAttribute(\"yoffset\"), 10),\n          xadvance: parseInt(h.getAttribute(\"xadvance\"), 10)\n        });\n      }\n      for (var l = 0; l < o.length; l++)\n        e.kerning.push({\n          first: parseInt(o[l].getAttribute(\"first\"), 10),\n          second: parseInt(o[l].getAttribute(\"second\"), 10),\n          amount: parseInt(o[l].getAttribute(\"amount\"), 10)\n        });\n      for (var l = 0; l < u.length; l++)\n        e.distanceField.push({\n          fieldType: u[l].getAttribute(\"fieldType\"),\n          distanceRange: parseInt(u[l].getAttribute(\"distanceRange\"), 10)\n        });\n      return e;\n    }, i;\n  }()\n), IN = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.test = function(t) {\n      if (typeof t == \"string\" && t.indexOf(\"<font>\") > -1) {\n        var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n        return By.test(e);\n      }\n      return !1;\n    }, i.parse = function(t) {\n      var e = new globalThis.DOMParser().parseFromString(t, \"text/xml\");\n      return By.parse(e);\n    }, i;\n  }()\n), ty = [\n  ON,\n  By,\n  IN\n];\nfunction wS(i) {\n  for (var t = 0; t < ty.length; t++)\n    if (ty[t].test(i))\n      return ty[t];\n  return null;\n}\nfunction RN(i, t, e, r, n, s) {\n  var a = e.fill;\n  if (Array.isArray(a)) {\n    if (a.length === 1)\n      return a[0];\n  } else\n    return a;\n  var o, u = e.dropShadow ? e.dropShadowDistance : 0, l = e.padding || 0, h = i.width / r - u - l * 2, d = i.height / r - u - l * 2, f = a.slice(), p = e.fillGradientStops.slice();\n  if (!p.length)\n    for (var v = f.length + 1, g = 1; g < v; ++g)\n      p.push(g / v);\n  if (f.unshift(a[0]), p.unshift(0), f.push(a[a.length - 1]), p.push(1), e.fillGradientType === cc.LINEAR_VERTICAL) {\n    o = t.createLinearGradient(h / 2, l, h / 2, d + l);\n    for (var m = 0, y = s.fontProperties.fontSize + e.strokeThickness, _ = y / d, g = 0; g < n.length; g++)\n      for (var b = s.lineHeight * g, w = 0; w < f.length; w++) {\n        var T = 0;\n        typeof p[w] == \"number\" ? T = p[w] : T = w / f.length;\n        var x = b / d + T * _, S = Math.max(m, x);\n        S = Math.min(S, 1), o.addColorStop(S, f[w]), m = S;\n      }\n  } else {\n    o = t.createLinearGradient(l, d / 2, h + l, d / 2);\n    for (var C = f.length + 1, M = 1, g = 0; g < f.length; g++) {\n      var I = void 0;\n      typeof p[g] == \"number\" ? I = p[g] : I = M / C, o.addColorStop(I, f[g]), M++;\n    }\n  }\n  return o;\n}\nfunction DN(i, t, e, r, n, s, a) {\n  var o = e.text, u = e.fontProperties;\n  t.translate(r, n), t.scale(s, s);\n  var l = a.strokeThickness / 2, h = -(a.strokeThickness / 2);\n  if (t.font = a.toFontString(), t.lineWidth = a.strokeThickness, t.textBaseline = a.textBaseline, t.lineJoin = a.lineJoin, t.miterLimit = a.miterLimit, t.fillStyle = RN(i, t, a, s, [o], e), t.strokeStyle = a.stroke, a.dropShadow) {\n    var d = a.dropShadowColor, f = Jl(typeof d == \"number\" ? d : RE(d)), p = a.dropShadowBlur * s, v = a.dropShadowDistance * s;\n    t.shadowColor = \"rgba(\" + f[0] * 255 + \",\" + f[1] * 255 + \",\" + f[2] * 255 + \",\" + a.dropShadowAlpha + \")\", t.shadowBlur = p, t.shadowOffsetX = Math.cos(a.dropShadowAngle) * v, t.shadowOffsetY = Math.sin(a.dropShadowAngle) * v;\n  } else\n    t.shadowColor = \"black\", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;\n  a.stroke && a.strokeThickness && t.strokeText(o, l, h + e.lineHeight - u.descent), a.fill && t.fillText(o, l, h + e.lineHeight - u.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = \"rgba(0, 0, 0, 0)\";\n}\nfunction ES(i) {\n  return Array.from ? Array.from(i) : i.split(\"\");\n}\nfunction kN(i) {\n  typeof i == \"string\" && (i = [i]);\n  for (var t = [], e = 0, r = i.length; e < r; e++) {\n    var n = i[e];\n    if (Array.isArray(n)) {\n      if (n.length !== 2)\n        throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + n.length + \".\");\n      var s = n[0].charCodeAt(0), a = n[1].charCodeAt(0);\n      if (a < s)\n        throw new Error(\"[BitmapFont]: Invalid character range.\");\n      for (var o = s, u = a; o <= u; o++)\n        t.push(String.fromCharCode(o));\n    } else\n      t.push.apply(t, ES(n));\n  }\n  if (t.length === 0)\n    throw new Error(\"[BitmapFont]: Empty set when resolving characters.\");\n  return t;\n}\nfunction Ip(i) {\n  return i.codePointAt ? i.codePointAt(0) : i.charCodeAt(0);\n}\nvar ks = (\n  /** @class */\n  function() {\n    function i(t, e, r) {\n      var n, s, a = t.info[0], o = t.common[0], u = t.page[0], l = t.distanceField[0], h = dv(u.file), d = {};\n      this._ownsTextures = r, this.font = a.face, this.size = a.size, this.lineHeight = o.lineHeight / h, this.chars = {}, this.pageTextures = d;\n      for (var f = 0; f < t.page.length; f++) {\n        var p = t.page[f], v = p.id, g = p.file;\n        d[v] = e instanceof Array ? e[f] : e[g], l != null && l.fieldType && l.fieldType !== \"none\" && (d[v].baseTexture.alphaMode = en.NO_PREMULTIPLIED_ALPHA, d[v].baseTexture.mipmap = tn.OFF);\n      }\n      for (var f = 0; f < t.char.length; f++) {\n        var m = t.char[f], v = m.id, y = m.page, _ = t.char[f], b = _.x, w = _.y, T = _.width, x = _.height, S = _.xoffset, C = _.yoffset, M = _.xadvance;\n        b /= h, w /= h, T /= h, x /= h, S /= h, C /= h, M /= h;\n        var I = new Nt(b + d[y].frame.x / h, w + d[y].frame.y / h, T, x);\n        this.chars[v] = {\n          xOffset: S,\n          yOffset: C,\n          xAdvance: M,\n          kerning: {},\n          texture: new Ot(d[y].baseTexture, I),\n          page: y\n        };\n      }\n      for (var f = 0; f < t.kerning.length; f++) {\n        var R = t.kerning[f], N = R.first, A = R.second, U = R.amount;\n        N /= h, A /= h, U /= h, this.chars[A] && (this.chars[A].kerning[N] = U);\n      }\n      this.distanceFieldRange = l == null ? void 0 : l.distanceRange, this.distanceFieldType = (s = (n = l == null ? void 0 : l.fieldType) === null || n === void 0 ? void 0 : n.toLowerCase()) !== null && s !== void 0 ? s : \"none\";\n    }\n    return i.prototype.destroy = function() {\n      for (var t in this.chars)\n        this.chars[t].texture.destroy(), this.chars[t].texture = null;\n      for (var t in this.pageTextures)\n        this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;\n      this.chars = null, this.pageTextures = null;\n    }, i.install = function(t, e, r) {\n      var n;\n      if (t instanceof wv)\n        n = t;\n      else {\n        var s = wS(t);\n        if (!s)\n          throw new Error(\"Unrecognized data format for font.\");\n        n = s.parse(t);\n      }\n      e instanceof Ot && (e = [e]);\n      var a = new i(n, e, r);\n      return i.available[a.font] = a, a;\n    }, i.uninstall = function(t) {\n      var e = i.available[t];\n      if (!e)\n        throw new Error(\"No font found named '\" + t + \"'\");\n      e.destroy(), delete i.available[t];\n    }, i.from = function(t, e, r) {\n      if (!t)\n        throw new Error(\"[BitmapFont] Property `name` is required.\");\n      var n = Object.assign({}, i.defaultOptions, r), s = n.chars, a = n.padding, o = n.resolution, u = n.textureWidth, l = n.textureHeight, h = kN(s), d = e instanceof Qo ? e : new Qo(e), f = u, p = new wv();\n      p.info[0] = {\n        face: d.fontFamily,\n        size: d.fontSize\n      }, p.common[0] = {\n        lineHeight: d.fontSize\n      };\n      for (var v = 0, g = 0, m, y, _, b = 0, w = [], T = 0; T < h.length; T++) {\n        m || (m = gt.ADAPTER.createCanvas(), m.width = u, m.height = l, y = m.getContext(\"2d\"), _ = new Kt(m, { resolution: o }), w.push(new Ot(_)), p.page.push({\n          id: w.length - 1,\n          file: \"\"\n        }));\n        var x = h[T], S = Gn.measureText(x, d, !1, m), C = S.width, M = Math.ceil(S.height), I = Math.ceil((d.fontStyle === \"italic\" ? 2 : 1) * C);\n        if (g >= l - M * o) {\n          if (g === 0)\n            throw new Error(\"[BitmapFont] textureHeight \" + l + \"px is too small \" + (\"(fontFamily: '\" + d.fontFamily + \"', fontSize: \" + d.fontSize + \"px, char: '\" + x + \"')\"));\n          --T, m = null, y = null, _ = null, g = 0, v = 0, b = 0;\n          continue;\n        }\n        if (b = Math.max(M + S.fontProperties.descent, b), I * o + v >= f) {\n          if (v === 0)\n            throw new Error(\"[BitmapFont] textureWidth \" + u + \"px is too small \" + (\"(fontFamily: '\" + d.fontFamily + \"', fontSize: \" + d.fontSize + \"px, char: '\" + x + \"')\"));\n          --T, g += b * o, g = Math.ceil(g), v = 0, b = 0;\n          continue;\n        }\n        DN(m, y, S, v, g, o, d);\n        var R = Ip(S.text);\n        p.char.push({\n          id: R,\n          page: w.length - 1,\n          x: v / o,\n          y: g / o,\n          width: I,\n          height: M,\n          xoffset: 0,\n          yoffset: 0,\n          xadvance: Math.ceil(C - (d.dropShadow ? d.dropShadowDistance : 0) - (d.stroke ? d.strokeThickness : 0))\n        }), v += (I + 2 * a) * o, v = Math.ceil(v);\n      }\n      for (var T = 0, N = h.length; T < N; T++)\n        for (var A = h[T], U = 0; U < N; U++) {\n          var B = h[U], G = y.measureText(A).width, $ = y.measureText(B).width, Z = y.measureText(A + B).width, H = Z - (G + $);\n          H && p.kerning.push({\n            first: Ip(A),\n            second: Ip(B),\n            amount: H\n          });\n        }\n      var z = new i(p, w, !0);\n      return i.available[t] !== void 0 && i.uninstall(t), i.available[t] = z, z;\n    }, i.ALPHA = [[\"a\", \"z\"], [\"A\", \"Z\"], \" \"], i.NUMERIC = [[\"0\", \"9\"]], i.ALPHANUMERIC = [[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \" \"], i.ASCII = [[\" \", \"~\"]], i.defaultOptions = {\n      resolution: 1,\n      textureWidth: 512,\n      textureHeight: 512,\n      padding: 4,\n      chars: i.ALPHANUMERIC\n    }, i.available = {}, i;\n  }()\n), NN = `// Pixi texture info\\r\nvarying vec2 vTextureCoord;\\r\nuniform sampler2D uSampler;\\r\n\\r\n// Tint\\r\nuniform vec4 uColor;\\r\n\\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\\r\nuniform float uFWidth;\\r\n\\r\nvoid main(void) {\\r\n\\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\\r\n\\r\n  // MSDF\\r\n  float median = texColor.r + texColor.g + texColor.b -\\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\\r\n                  max(texColor.r, max(texColor.g, texColor.b));\\r\n  // SDF\\r\n  median = min(median, texColor.a);\\r\n\\r\n  float screenPxDistance = uFWidth * (median - 0.5);\\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\\r\n  if (median < 0.01) {\\r\n    alpha = 0.0;\\r\n  } else if (median > 0.99) {\\r\n    alpha = 1.0;\\r\n  }\\r\n\\r\n  // NPM Textures, NPM outputs\\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\\r\n\\r\n}\\r\n`, AN = `// Mesh material default fragment\\r\nattribute vec2 aVertexPosition;\\r\nattribute vec2 aTextureCoord;\\r\n\\r\nuniform mat3 projectionMatrix;\\r\nuniform mat3 translationMatrix;\\r\nuniform mat3 uTextureMatrix;\\r\n\\r\nvarying vec2 vTextureCoord;\\r\n\\r\nvoid main(void)\\r\n{\\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\r\n\\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\\r\n}\\r\n`, J1 = [], Q1 = [], tw = [];\n(function(i) {\n  PN(t, i);\n  function t(e, r) {\n    r === void 0 && (r = {});\n    var n = i.call(this) || this;\n    n._tint = 16777215;\n    var s = Object.assign({}, t.styleDefaults, r), a = s.align, o = s.tint, u = s.maxWidth, l = s.letterSpacing, h = s.fontName, d = s.fontSize;\n    if (!ks.available[h])\n      throw new Error('Missing BitmapFont \"' + h + '\"');\n    return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = a, n._tint = o, n._font = void 0, n._fontName = h, n._fontSize = d, n.text = e, n._maxWidth = u, n._maxLineHeight = 0, n._letterSpacing = l, n._anchor = new Ou(function() {\n      n.dirty = !0;\n    }, n, 0, 0), n._roundPixels = gt.ROUND_PIXELS, n.dirty = !0, n._resolution = gt.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n;\n  }\n  return t.prototype.updateText = function() {\n    for (var e, r = ks.available[this._fontName], n = this.fontSize, s = n / r.size, a = new xe(), o = [], u = [], l = [], h = this._text.replace(/(?:\\r\\n|\\r)/g, `\n`) || \" \", d = ES(h), f = this._maxWidth * r.size / n, p = r.distanceFieldType === \"none\" ? J1 : Q1, v = null, g = 0, m = 0, y = 0, _ = -1, b = 0, w = 0, T = 0, x = 0, S = 0; S < d.length; S++) {\n      var C = d[S], M = Ip(C);\n      if (/(?:\\s)/.test(C) && (_ = S, b = g, x++), C === \"\\r\" || C === `\n`) {\n        u.push(g), l.push(-1), m = Math.max(m, g), ++y, ++w, a.x = 0, a.y += r.lineHeight, v = null, x = 0;\n        continue;\n      }\n      var I = r.chars[M];\n      if (I) {\n        v && I.kerning[v] && (a.x += I.kerning[v]);\n        var R = tw.pop() || {\n          texture: Ot.EMPTY,\n          line: 0,\n          charCode: 0,\n          prevSpaces: 0,\n          position: new xe()\n        };\n        R.texture = I.texture, R.line = y, R.charCode = M, R.position.x = a.x + I.xOffset + this._letterSpacing / 2, R.position.y = a.y + I.yOffset, R.prevSpaces = x, o.push(R), g = R.position.x + Math.max(I.xAdvance - I.xOffset, I.texture.orig.width), a.x += I.xAdvance + this._letterSpacing, T = Math.max(T, I.yOffset + I.texture.height), v = M, _ !== -1 && f > 0 && a.x > f && (++w, Bu(o, 1 + _ - w, 1 + S - _), S = _, _ = -1, u.push(b), l.push(o.length > 0 ? o[o.length - 1].prevSpaces : 0), m = Math.max(m, b), y++, a.x = 0, a.y += r.lineHeight, v = null, x = 0);\n      }\n    }\n    var N = d[d.length - 1];\n    N !== \"\\r\" && N !== `\n` && (/(?:\\s)/.test(N) && (g = b), u.push(g), m = Math.max(m, g), l.push(-1));\n    for (var A = [], S = 0; S <= y; S++) {\n      var U = 0;\n      this._align === \"right\" ? U = m - u[S] : this._align === \"center\" ? U = (m - u[S]) / 2 : this._align === \"justify\" && (U = l[S] < 0 ? 0 : (m - u[S]) / l[S]), A.push(U);\n    }\n    var B = o.length, G = {}, $ = [], Z = this._activePagesMeshData;\n    p.push.apply(p, Z);\n    for (var S = 0; S < B; S++) {\n      var H = o[S].texture, z = H.baseTexture.uid;\n      if (!G[z]) {\n        var X = p.pop();\n        if (!X) {\n          var ct = new s0(), it = void 0, lt = void 0;\n          r.distanceFieldType === \"none\" ? (it = new dc(Ot.EMPTY), lt = Et.NORMAL) : (it = new dc(Ot.EMPTY, { program: hh.from(AN, NN), uniforms: { uFWidth: 0 } }), lt = Et.NORMAL_NPM);\n          var et = new fc(ct, it);\n          et.blendMode = lt, X = {\n            index: 0,\n            indexCount: 0,\n            vertexCount: 0,\n            uvsCount: 0,\n            total: 0,\n            mesh: et,\n            vertices: null,\n            uvs: null,\n            indices: null\n          };\n        }\n        X.index = 0, X.indexCount = 0, X.vertexCount = 0, X.uvsCount = 0, X.total = 0;\n        var k = this._textureCache;\n        k[z] = k[z] || new Ot(H.baseTexture), X.mesh.texture = k[z], X.mesh.tint = this._tint, $.push(X), G[z] = X;\n      }\n      G[z].total++;\n    }\n    for (var S = 0; S < Z.length; S++)\n      $.indexOf(Z[S]) === -1 && this.removeChild(Z[S].mesh);\n    for (var S = 0; S < $.length; S++)\n      $[S].mesh.parent !== this && this.addChild($[S].mesh);\n    this._activePagesMeshData = $;\n    for (var S in G) {\n      var X = G[S], ft = X.total;\n      if (!(((e = X.indices) === null || e === void 0 ? void 0 : e.length) > 6 * ft) || X.vertices.length < fc.BATCHABLE_SIZE * 2)\n        X.vertices = new Float32Array(4 * 2 * ft), X.uvs = new Float32Array(4 * 2 * ft), X.indices = new Uint16Array(6 * ft);\n      else\n        for (var Q = X.total, St = X.vertices, at = Q * 4 * 2; at < St.length; at++)\n          St[at] = 0;\n      X.mesh.size = 6 * ft;\n    }\n    for (var S = 0; S < B; S++) {\n      var C = o[S], q = C.position.x + A[C.line] * (this._align === \"justify\" ? C.prevSpaces : 1);\n      this._roundPixels && (q = Math.round(q));\n      var bt = q * s, st = C.position.y * s, H = C.texture, W = G[H.baseTexture.uid], nt = H.frame, dt = H._uvs, V = W.index++;\n      W.indices[V * 6 + 0] = 0 + V * 4, W.indices[V * 6 + 1] = 1 + V * 4, W.indices[V * 6 + 2] = 2 + V * 4, W.indices[V * 6 + 3] = 0 + V * 4, W.indices[V * 6 + 4] = 2 + V * 4, W.indices[V * 6 + 5] = 3 + V * 4, W.vertices[V * 8 + 0] = bt, W.vertices[V * 8 + 1] = st, W.vertices[V * 8 + 2] = bt + nt.width * s, W.vertices[V * 8 + 3] = st, W.vertices[V * 8 + 4] = bt + nt.width * s, W.vertices[V * 8 + 5] = st + nt.height * s, W.vertices[V * 8 + 6] = bt, W.vertices[V * 8 + 7] = st + nt.height * s, W.uvs[V * 8 + 0] = dt.x0, W.uvs[V * 8 + 1] = dt.y0, W.uvs[V * 8 + 2] = dt.x1, W.uvs[V * 8 + 3] = dt.y1, W.uvs[V * 8 + 4] = dt.x2, W.uvs[V * 8 + 5] = dt.y2, W.uvs[V * 8 + 6] = dt.x3, W.uvs[V * 8 + 7] = dt.y3;\n    }\n    this._textWidth = m * s, this._textHeight = (a.y + r.lineHeight) * s;\n    for (var S in G) {\n      var X = G[S];\n      if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        for (var xt = 0, Dt = this._textWidth * this.anchor.x, Ct = this._textHeight * this.anchor.y, be = 0; be < X.total; be++)\n          X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct, X.vertices[xt++] -= Dt, X.vertices[xt++] -= Ct;\n      this._maxLineHeight = T * s;\n      var je = X.mesh.geometry.getBuffer(\"aVertexPosition\"), ee = X.mesh.geometry.getBuffer(\"aTextureCoord\"), de = X.mesh.geometry.getIndex();\n      je.data = X.vertices, ee.data = X.uvs, de.data = X.indices, je.update(), ee.update(), de.update();\n    }\n    for (var S = 0; S < o.length; S++)\n      tw.push(o[S]);\n    this._font = r, this.dirty = !1;\n  }, t.prototype.updateTransform = function() {\n    this.validate(), this.containerUpdateTransform();\n  }, t.prototype._render = function(e) {\n    this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);\n    var r = ks.available[this._fontName], n = r.distanceFieldRange, s = r.distanceFieldType, a = r.size;\n    if (s !== \"none\")\n      for (var o = this.worldTransform, u = o.a, l = o.b, h = o.c, d = o.d, f = Math.sqrt(u * u + l * l), p = Math.sqrt(h * h + d * d), v = (Math.abs(f) + Math.abs(p)) / 2, g = this.fontSize / a, m = 0, y = this._activePagesMeshData; m < y.length; m++) {\n        var _ = y[m];\n        _.mesh.shader.uniforms.uFWidth = v * n * g * this._resolution;\n      }\n    i.prototype._render.call(this, e);\n  }, t.prototype.getLocalBounds = function() {\n    return this.validate(), i.prototype.getLocalBounds.call(this);\n  }, t.prototype.validate = function() {\n    var e = ks.available[this._fontName];\n    if (!e)\n      throw new Error('Missing BitmapFont \"' + this._fontName + '\"');\n    this._font !== e && (this.dirty = !0), this.dirty && this.updateText();\n  }, Object.defineProperty(t.prototype, \"tint\", {\n    /**\n     * The tint of the BitmapText object.\n     * @default 0xffffff\n     */\n    get: function() {\n      return this._tint;\n    },\n    set: function(e) {\n      if (this._tint !== e) {\n        this._tint = e;\n        for (var r = 0; r < this._activePagesMeshData.length; r++)\n          this._activePagesMeshData[r].mesh.tint = e;\n      }\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"align\", {\n    /**\n     * The alignment of the BitmapText object.\n     * @member {string}\n     * @default 'left'\n     */\n    get: function() {\n      return this._align;\n    },\n    set: function(e) {\n      this._align !== e && (this._align = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontName\", {\n    /** The name of the BitmapFont. */\n    get: function() {\n      return this._fontName;\n    },\n    set: function(e) {\n      if (!ks.available[e])\n        throw new Error('Missing BitmapFont \"' + e + '\"');\n      this._fontName !== e && (this._fontName = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"fontSize\", {\n    /** The size of the font to display. */\n    get: function() {\n      var e;\n      return (e = this._fontSize) !== null && e !== void 0 ? e : ks.available[this._fontName].size;\n    },\n    set: function(e) {\n      this._fontSize !== e && (this._fontSize = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"anchor\", {\n    /**\n     * The anchor sets the origin point of the text.\n     *\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     */\n    get: function() {\n      return this._anchor;\n    },\n    set: function(e) {\n      typeof e == \"number\" ? this._anchor.set(e) : this._anchor.copyFrom(e);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"text\", {\n    /** The text of the BitmapText object. */\n    get: function() {\n      return this._text;\n    },\n    set: function(e) {\n      e = String(e ?? \"\"), this._text !== e && (this._text = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxWidth\", {\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting the value to 0.\n     */\n    get: function() {\n      return this._maxWidth;\n    },\n    set: function(e) {\n      this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"maxLineHeight\", {\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * i.e. when trying to vertically align.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._maxLineHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textWidth\", {\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._textWidth;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"letterSpacing\", {\n    /** Additional space between characters. */\n    get: function() {\n      return this._letterSpacing;\n    },\n    set: function(e) {\n      this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"roundPixels\", {\n    /**\n     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n     * The main disadvantage is movement of objects may appear less smooth.\n     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n     * @default PIXI.settings.ROUND_PIXELS\n     */\n    get: function() {\n      return this._roundPixels;\n    },\n    set: function(e) {\n      e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"textHeight\", {\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object.\n     * @readonly\n     */\n    get: function() {\n      return this.validate(), this._textHeight;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"resolution\", {\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     *\n     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.\n     * @default 1\n     */\n    get: function() {\n      return this._resolution;\n    },\n    set: function(e) {\n      this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0);\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.destroy = function(e) {\n    var r = this._textureCache, n = ks.available[this._fontName], s = n.distanceFieldType === \"none\" ? J1 : Q1;\n    s.push.apply(s, this._activePagesMeshData);\n    for (var a = 0, o = this._activePagesMeshData; a < o.length; a++) {\n      var u = o[a];\n      this.removeChild(u.mesh);\n    }\n    this._activePagesMeshData = [], s.filter(function(d) {\n      return r[d.mesh.texture.baseTexture.uid];\n    }).forEach(function(d) {\n      d.mesh.texture = Ot.EMPTY;\n    });\n    for (var l in r) {\n      var h = r[l];\n      h.destroy(), delete r[l];\n    }\n    this._font = null, this._textureCache = null, i.prototype.destroy.call(this, e);\n  }, t.styleDefaults = {\n    align: \"left\",\n    tint: 16777215,\n    maxWidth: 0,\n    letterSpacing: 0\n  }, t;\n})(ye);\nvar LN = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.add = function() {\n      Ft.setExtensionXhrType(\"fnt\", Ft.XHR_RESPONSE_TYPE.TEXT);\n    }, i.use = function(t, e) {\n      var r = wS(t.data);\n      if (!r) {\n        e();\n        return;\n      }\n      for (var n = i.getBaseUrl(this, t), s = r.parse(t.data), a = {}, o = function(g) {\n        a[g.metadata.pageFile] = g.texture, Object.keys(a).length === s.page.length && (t.bitmapFont = ks.install(s, a, !0), e());\n      }, u = 0; u < s.page.length; ++u) {\n        var l = s.page[u].file, h = n + l, d = !1;\n        for (var f in this.resources) {\n          var p = this.resources[f];\n          if (p.url === h) {\n            p.metadata.pageFile = l, p.texture ? o(p) : p.onAfterMiddleware.add(o), d = !0;\n            break;\n          }\n        }\n        if (!d) {\n          var v = {\n            crossOrigin: t.crossOrigin,\n            loadType: Ft.LOAD_TYPE.IMAGE,\n            metadata: Object.assign({ pageFile: l }, t.metadata.imageMetadata),\n            parentResource: t\n          };\n          this.add(h, v, o);\n        }\n      }\n    }, i.getBaseUrl = function(t, e) {\n      var r = e.isDataUrl ? \"\" : i.dirname(e.url);\n      return e.isDataUrl && (r === \".\" && (r = \"\"), t.baseUrl && r && t.baseUrl.charAt(t.baseUrl.length - 1) === \"/\" && (r += \"/\")), r = r.replace(t.baseUrl, \"\"), r && r.charAt(r.length - 1) !== \"/\" && (r += \"/\"), r;\n    }, i.dirname = function(t) {\n      var e = t.replace(/\\\\/g, \"/\").replace(/\\/$/, \"\").replace(/\\/[^\\/]*$/, \"\");\n      return e === t ? \".\" : e === \"\" ? \"/\" : e;\n    }, i.extension = fe.Loader, i;\n  }()\n);\n/*!\n * @pixi/filter-alpha - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-alpha is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Fy = function(i, t) {\n  return Fy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Fy(i, t);\n};\nfunction BN(i, t) {\n  Fy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar FN = `varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n`;\n(function(i) {\n  BN(t, i);\n  function t(e) {\n    e === void 0 && (e = 1);\n    var r = i.call(this, uS, FN, { uAlpha: 1 }) || this;\n    return r.alpha = e, r;\n  }\n  return Object.defineProperty(t.prototype, \"alpha\", {\n    /**\n     * Coefficient for alpha multiplication\n     * @default 1\n     */\n    get: function() {\n      return this.uniforms.uAlpha;\n    },\n    set: function(e) {\n      this.uniforms.uAlpha = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(rn);\n/*!\n * @pixi/filter-blur - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-blur is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Gy = function(i, t) {\n  return Gy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Gy(i, t);\n};\nfunction SS(i, t) {\n  Gy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar GN = `\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }`;\nfunction UN(i, t) {\n  var e = Math.ceil(i / 2), r = GN, n = \"\", s;\n  t ? s = \"vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);\" : s = \"vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);\";\n  for (var a = 0; a < i; a++) {\n    var o = s.replace(\"%index%\", a.toString());\n    o = o.replace(\"%sampleIndex%\", a - (e - 1) + \".0\"), n += o, n += `\n`;\n  }\n  return r = r.replace(\"%blur%\", n), r = r.replace(\"%size%\", i.toString()), r;\n}\nvar jN = {\n  5: [0.153388, 0.221461, 0.250301],\n  7: [0.071303, 0.131514, 0.189879, 0.214607],\n  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],\n  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],\n  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],\n  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]\n}, zN = [\n  \"varying vec2 vBlurTexCoords[%size%];\",\n  \"uniform sampler2D uSampler;\",\n  \"void main(void)\",\n  \"{\",\n  \"    gl_FragColor = vec4(0.0);\",\n  \"    %blur%\",\n  \"}\"\n].join(`\n`);\nfunction HN(i) {\n  for (var t = jN[i], e = t.length, r = zN, n = \"\", s = \"gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;\", a, o = 0; o < i; o++) {\n    var u = s.replace(\"%index%\", o.toString());\n    a = o, o >= e && (a = i - o - 1), u = u.replace(\"%value%\", t[a].toString()), n += u, n += `\n`;\n  }\n  return r = r.replace(\"%blur%\", n), r = r.replace(\"%size%\", i.toString()), r;\n}\nvar ew = (\n  /** @class */\n  function(i) {\n    SS(t, i);\n    function t(e, r, n, s, a) {\n      r === void 0 && (r = 8), n === void 0 && (n = 4), s === void 0 && (s = gt.FILTER_RESOLUTION), a === void 0 && (a = 5);\n      var o = this, u = UN(a, e), l = HN(a);\n      return o = i.call(\n        this,\n        // vertex shader\n        u,\n        // fragment shader\n        l\n      ) || this, o.horizontal = e, o.resolution = s, o._quality = 0, o.quality = n, o.blur = r, o;\n    }\n    return t.prototype.apply = function(e, r, n, s) {\n      if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / r.width) : this.uniforms.strength = 1 / n.height * (n.height / r.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / r.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / r.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)\n        e.applyFilter(this, r, n, s);\n      else {\n        var a = e.getFilterTexture(), o = e.renderer, u = r, l = a;\n        this.state.blend = !1, e.applyFilter(this, u, l, Wi.CLEAR);\n        for (var h = 1; h < this.passes - 1; h++) {\n          e.bindAndClear(u, Wi.BLIT), this.uniforms.uSampler = l;\n          var d = l;\n          l = u, u = d, o.shader.bind(this), o.geometry.draw(5);\n        }\n        this.state.blend = !0, e.applyFilter(this, l, n, s), e.returnFilterTexture(a);\n      }\n    }, Object.defineProperty(t.prototype, \"blur\", {\n      /**\n       * Sets the strength of both the blur.\n       * @default 16\n       */\n      get: function() {\n        return this.strength;\n      },\n      set: function(e) {\n        this.padding = 1 + Math.abs(e) * 2, this.strength = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"quality\", {\n      /**\n       * Sets the quality of the blur by modifying the number of passes. More passes means higher\n       * quality bluring but the lower the performance.\n       * @default 4\n       */\n      get: function() {\n        return this._quality;\n      },\n      set: function(e) {\n        this._quality = e, this.passes = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(rn)\n);\n(function(i) {\n  SS(t, i);\n  function t(e, r, n, s) {\n    e === void 0 && (e = 8), r === void 0 && (r = 4), n === void 0 && (n = gt.FILTER_RESOLUTION), s === void 0 && (s = 5);\n    var a = i.call(this) || this;\n    return a.blurXFilter = new ew(!0, e, r, n, s), a.blurYFilter = new ew(!1, e, r, n, s), a.resolution = n, a.quality = r, a.blur = e, a.repeatEdgePixels = !1, a;\n  }\n  return t.prototype.apply = function(e, r, n, s) {\n    var a = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);\n    if (a && o) {\n      var u = e.getFilterTexture();\n      this.blurXFilter.apply(e, r, u, Wi.CLEAR), this.blurYFilter.apply(e, u, n, s), e.returnFilterTexture(u);\n    } else\n      o ? this.blurYFilter.apply(e, r, n, s) : this.blurXFilter.apply(e, r, n, s);\n  }, t.prototype.updatePadding = function() {\n    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;\n  }, Object.defineProperty(t.prototype, \"blur\", {\n    /**\n     * Sets the strength of both the blurX and blurY properties simultaneously\n     * @default 2\n     */\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"quality\", {\n    /**\n     * Sets the number of passes for blur. More passes means higher quality bluring.\n     * @default 1\n     */\n    get: function() {\n      return this.blurXFilter.quality;\n    },\n    set: function(e) {\n      this.blurXFilter.quality = this.blurYFilter.quality = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurX\", {\n    /**\n     * Sets the strength of the blurX property\n     * @default 2\n     */\n    get: function() {\n      return this.blurXFilter.blur;\n    },\n    set: function(e) {\n      this.blurXFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blurY\", {\n    /**\n     * Sets the strength of the blurY property\n     * @default 2\n     */\n    get: function() {\n      return this.blurYFilter.blur;\n    },\n    set: function(e) {\n      this.blurYFilter.blur = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"blendMode\", {\n    /**\n     * Sets the blendmode of the filter\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    get: function() {\n      return this.blurYFilter.blendMode;\n    },\n    set: function(e) {\n      this.blurYFilter.blendMode = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"repeatEdgePixels\", {\n    /**\n     * If set to true the edge of the target will be clamped\n     * @default false\n     */\n    get: function() {\n      return this._repeatEdgePixels;\n    },\n    set: function(e) {\n      this._repeatEdgePixels = e, this.updatePadding();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(rn);\n/*!\n * @pixi/filter-color-matrix - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-color-matrix is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Uy = function(i, t) {\n  return Uy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Uy(i, t);\n};\nfunction $N(i, t) {\n  Uy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar VN = `varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n`, rw = (\n  /** @class */\n  function(i) {\n    $N(t, i);\n    function t() {\n      var e = this, r = {\n        m: new Float32Array([\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0,\n          0,\n          0,\n          0,\n          0,\n          1,\n          0\n        ]),\n        uAlpha: 1\n      };\n      return e = i.call(this, qb, VN, r) || this, e.alpha = 1, e;\n    }\n    return t.prototype._loadMatrix = function(e, r) {\n      r === void 0 && (r = !1);\n      var n = e;\n      r && (this._multiply(n, this.uniforms.m, e), n = this._colorMatrix(n)), this.uniforms.m = n;\n    }, t.prototype._multiply = function(e, r, n) {\n      return e[0] = r[0] * n[0] + r[1] * n[5] + r[2] * n[10] + r[3] * n[15], e[1] = r[0] * n[1] + r[1] * n[6] + r[2] * n[11] + r[3] * n[16], e[2] = r[0] * n[2] + r[1] * n[7] + r[2] * n[12] + r[3] * n[17], e[3] = r[0] * n[3] + r[1] * n[8] + r[2] * n[13] + r[3] * n[18], e[4] = r[0] * n[4] + r[1] * n[9] + r[2] * n[14] + r[3] * n[19] + r[4], e[5] = r[5] * n[0] + r[6] * n[5] + r[7] * n[10] + r[8] * n[15], e[6] = r[5] * n[1] + r[6] * n[6] + r[7] * n[11] + r[8] * n[16], e[7] = r[5] * n[2] + r[6] * n[7] + r[7] * n[12] + r[8] * n[17], e[8] = r[5] * n[3] + r[6] * n[8] + r[7] * n[13] + r[8] * n[18], e[9] = r[5] * n[4] + r[6] * n[9] + r[7] * n[14] + r[8] * n[19] + r[9], e[10] = r[10] * n[0] + r[11] * n[5] + r[12] * n[10] + r[13] * n[15], e[11] = r[10] * n[1] + r[11] * n[6] + r[12] * n[11] + r[13] * n[16], e[12] = r[10] * n[2] + r[11] * n[7] + r[12] * n[12] + r[13] * n[17], e[13] = r[10] * n[3] + r[11] * n[8] + r[12] * n[13] + r[13] * n[18], e[14] = r[10] * n[4] + r[11] * n[9] + r[12] * n[14] + r[13] * n[19] + r[14], e[15] = r[15] * n[0] + r[16] * n[5] + r[17] * n[10] + r[18] * n[15], e[16] = r[15] * n[1] + r[16] * n[6] + r[17] * n[11] + r[18] * n[16], e[17] = r[15] * n[2] + r[16] * n[7] + r[17] * n[12] + r[18] * n[17], e[18] = r[15] * n[3] + r[16] * n[8] + r[17] * n[13] + r[18] * n[18], e[19] = r[15] * n[4] + r[16] * n[9] + r[17] * n[14] + r[18] * n[19] + r[19], e;\n    }, t.prototype._colorMatrix = function(e) {\n      var r = new Float32Array(e);\n      return r[4] /= 255, r[9] /= 255, r[14] /= 255, r[19] /= 255, r;\n    }, t.prototype.brightness = function(e, r) {\n      var n = [\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(n, r);\n    }, t.prototype.tint = function(e, r) {\n      var n = e >> 16 & 255, s = e >> 8 & 255, a = e & 255, o = [\n        n / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        s / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        a / 255,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(o, r);\n    }, t.prototype.greyscale = function(e, r) {\n      var n = [\n        e,\n        e,\n        e,\n        0,\n        0,\n        e,\n        e,\n        e,\n        0,\n        0,\n        e,\n        e,\n        e,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(n, r);\n    }, t.prototype.blackAndWhite = function(e) {\n      var r = [\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0.3,\n        0.6,\n        0.1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.hue = function(e, r) {\n      e = (e || 0) / 180 * Math.PI;\n      var n = Math.cos(e), s = Math.sin(e), a = Math.sqrt, o = 1 / 3, u = a(o), l = n + (1 - n) * o, h = o * (1 - n) - u * s, d = o * (1 - n) + u * s, f = o * (1 - n) + u * s, p = n + o * (1 - n), v = o * (1 - n) - u * s, g = o * (1 - n) - u * s, m = o * (1 - n) + u * s, y = n + o * (1 - n), _ = [\n        l,\n        h,\n        d,\n        0,\n        0,\n        f,\n        p,\n        v,\n        0,\n        0,\n        g,\n        m,\n        y,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(_, r);\n    }, t.prototype.contrast = function(e, r) {\n      var n = (e || 0) + 1, s = -0.5 * (n - 1), a = [\n        n,\n        0,\n        0,\n        0,\n        s,\n        0,\n        n,\n        0,\n        0,\n        s,\n        0,\n        0,\n        n,\n        0,\n        s,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(a, r);\n    }, t.prototype.saturate = function(e, r) {\n      e === void 0 && (e = 0);\n      var n = e * 2 / 3 + 1, s = (n - 1) * -0.5, a = [\n        n,\n        s,\n        s,\n        0,\n        0,\n        s,\n        n,\n        s,\n        0,\n        0,\n        s,\n        s,\n        n,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(a, r);\n    }, t.prototype.desaturate = function() {\n      this.saturate(-1);\n    }, t.prototype.negative = function(e) {\n      var r = [\n        -1,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -1,\n        0,\n        1,\n        0,\n        0,\n        0,\n        -1,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.sepia = function(e) {\n      var r = [\n        0.393,\n        0.7689999,\n        0.18899999,\n        0,\n        0,\n        0.349,\n        0.6859999,\n        0.16799999,\n        0,\n        0,\n        0.272,\n        0.5339999,\n        0.13099999,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.technicolor = function(e) {\n      var r = [\n        1.9125277891456083,\n        -0.8545344976951645,\n        -0.09155508482755585,\n        0,\n        11.793603434377337,\n        -0.3087833385928097,\n        1.7658908555458428,\n        -0.10601743074722245,\n        0,\n        -70.35205161461398,\n        -0.231103377548616,\n        -0.7501899197440212,\n        1.847597816108189,\n        0,\n        30.950940869491138,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.polaroid = function(e) {\n      var r = [\n        1.438,\n        -0.062,\n        -0.062,\n        0,\n        0,\n        -0.122,\n        1.378,\n        -0.122,\n        0,\n        0,\n        -0.016,\n        -0.016,\n        1.483,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.toBGR = function(e) {\n      var r = [\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.kodachrome = function(e) {\n      var r = [\n        1.1285582396593525,\n        -0.3967382283601348,\n        -0.03992559172921793,\n        0,\n        63.72958762196502,\n        -0.16404339962244616,\n        1.0835251566291304,\n        -0.05498805115633132,\n        0,\n        24.732407896706203,\n        -0.16786010706155763,\n        -0.5603416277695248,\n        1.6014850761964943,\n        0,\n        35.62982807460946,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.browni = function(e) {\n      var r = [\n        0.5997023498159715,\n        0.34553243048391263,\n        -0.2708298674538042,\n        0,\n        47.43192855600873,\n        -0.037703249837783157,\n        0.8609577587992641,\n        0.15059552388459913,\n        0,\n        -36.96841498319127,\n        0.24113635128153335,\n        -0.07441037908422492,\n        0.44972182064877153,\n        0,\n        -7.562075277591283,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.vintage = function(e) {\n      var r = [\n        0.6279345635605994,\n        0.3202183420819367,\n        -0.03965408211312453,\n        0,\n        9.651285835294123,\n        0.02578397704808868,\n        0.6441188644374771,\n        0.03259127616149294,\n        0,\n        7.462829176470591,\n        0.0466055556782719,\n        -0.0851232987247891,\n        0.5241648018700465,\n        0,\n        5.159190588235296,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.colorTone = function(e, r, n, s, a) {\n      e = e || 0.2, r = r || 0.15, n = n || 16770432, s = s || 3375104;\n      var o = (n >> 16 & 255) / 255, u = (n >> 8 & 255) / 255, l = (n & 255) / 255, h = (s >> 16 & 255) / 255, d = (s >> 8 & 255) / 255, f = (s & 255) / 255, p = [\n        0.3,\n        0.59,\n        0.11,\n        0,\n        0,\n        o,\n        u,\n        l,\n        e,\n        0,\n        h,\n        d,\n        f,\n        r,\n        0,\n        o - h,\n        u - d,\n        l - f,\n        0,\n        0\n      ];\n      this._loadMatrix(p, a);\n    }, t.prototype.night = function(e, r) {\n      e = e || 0.1;\n      var n = [\n        e * -2,\n        -e,\n        0,\n        0,\n        0,\n        -e,\n        0,\n        e,\n        0,\n        0,\n        0,\n        e,\n        e * 2,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(n, r);\n    }, t.prototype.predator = function(e, r) {\n      var n = [\n        // row 1\n        11.224130630493164 * e,\n        -4.794486999511719 * e,\n        -2.8746118545532227 * e,\n        0 * e,\n        0.40342438220977783 * e,\n        // row 2\n        -3.6330697536468506 * e,\n        9.193157196044922 * e,\n        -2.951810836791992 * e,\n        0 * e,\n        -1.316135048866272 * e,\n        // row 3\n        -3.2184197902679443 * e,\n        -4.2375030517578125 * e,\n        7.476448059082031 * e,\n        0 * e,\n        0.8044459223747253 * e,\n        // row 4\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(n, r);\n    }, t.prototype.lsd = function(e) {\n      var r = [\n        2,\n        -0.4,\n        0.5,\n        0,\n        0,\n        -0.5,\n        2,\n        -0.4,\n        0,\n        0,\n        -0.4,\n        -0.5,\n        3,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(r, e);\n    }, t.prototype.reset = function() {\n      var e = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0\n      ];\n      this._loadMatrix(e, !1);\n    }, Object.defineProperty(t.prototype, \"matrix\", {\n      /**\n       * The matrix of the color matrix filter\n       * @member {number[]}\n       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]\n       */\n      get: function() {\n        return this.uniforms.m;\n      },\n      set: function(e) {\n        this.uniforms.m = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"alpha\", {\n      /**\n       * The opacity value to use when mixing the original and resultant colors.\n       *\n       * When the value is 0, the original color is used without modification.\n       * When the value is 1, the result color is used.\n       * When in the range (0, 1) the color is interpolated between the original and result by this amount.\n       * @default 1\n       */\n      get: function() {\n        return this.uniforms.uAlpha;\n      },\n      set: function(e) {\n        this.uniforms.uAlpha = e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(rn)\n);\nrw.prototype.grayscale = rw.prototype.greyscale;\n/*!\n * @pixi/filter-displacement - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-displacement is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar jy = function(i, t) {\n  return jy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, jy(i, t);\n};\nfunction XN(i, t) {\n  jy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar WN = `varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n`, YN = `attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n`;\n(function(i) {\n  XN(t, i);\n  function t(e, r) {\n    var n = this, s = new ar();\n    return e.renderable = !1, n = i.call(this, YN, WN, {\n      mapSampler: e._texture,\n      filterMatrix: s,\n      scale: { x: 1, y: 1 },\n      rotation: new Float32Array([1, 0, 0, 1])\n    }) || this, n.maskSprite = e, n.maskMatrix = s, r == null && (r = 20), n.scale = new xe(r, r), n;\n  }\n  return t.prototype.apply = function(e, r, n, s) {\n    this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;\n    var a = this.maskSprite.worldTransform, o = Math.sqrt(a.a * a.a + a.b * a.b), u = Math.sqrt(a.c * a.c + a.d * a.d);\n    o !== 0 && u !== 0 && (this.uniforms.rotation[0] = a.a / o, this.uniforms.rotation[1] = a.b / o, this.uniforms.rotation[2] = a.c / u, this.uniforms.rotation[3] = a.d / u), e.applyFilter(this, r, n, s);\n  }, Object.defineProperty(t.prototype, \"map\", {\n    /** The texture used for the displacement map. Must be power of 2 sized texture. */\n    get: function() {\n      return this.uniforms.mapSampler;\n    },\n    set: function(e) {\n      this.uniforms.mapSampler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(rn);\n/*!\n * @pixi/filter-fxaa - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-fxaa is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar zy = function(i, t) {\n  return zy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, zy(i, t);\n};\nfunction qN(i, t) {\n  zy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar ZN = `\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n`, KN = `varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it's\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n`;\n(function(i) {\n  qN(t, i);\n  function t() {\n    return i.call(this, ZN, KN) || this;\n  }\n  return t;\n})(rn);\n/*!\n * @pixi/filter-noise - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/filter-noise is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Hy = function(i, t) {\n  return Hy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Hy(i, t);\n};\nfunction JN(i, t) {\n  Hy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar QN = `precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n`;\n(function(i) {\n  JN(t, i);\n  function t(e, r) {\n    e === void 0 && (e = 0.5), r === void 0 && (r = Math.random());\n    var n = i.call(this, qb, QN, {\n      uNoise: 0,\n      uSeed: 0\n    }) || this;\n    return n.noise = e, n.seed = r, n;\n  }\n  return Object.defineProperty(t.prototype, \"noise\", {\n    /**\n     * The amount of noise to apply, this value should be in the range (0, 1].\n     * @default 0.5\n     */\n    get: function() {\n      return this.uniforms.uNoise;\n    },\n    set: function(e) {\n      this.uniforms.uNoise = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"seed\", {\n    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */\n    get: function() {\n      return this.uniforms.uSeed;\n    },\n    set: function(e) {\n      this.uniforms.uSeed = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t;\n})(rn);\n/*!\n * @pixi/mixin-cache-as-bitmap - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar TS = new ar();\nHe.prototype._cacheAsBitmap = !1;\nHe.prototype._cacheData = null;\nHe.prototype._cacheAsBitmapResolution = null;\nHe.prototype._cacheAsBitmapMultisample = ke.NONE;\nvar tA = (\n  /** @class */\n  function() {\n    function i() {\n      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;\n    }\n    return i;\n  }()\n);\nObject.defineProperties(He.prototype, {\n  /**\n   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution\n   * but can be overriden for performance. Lower values will reduce memory usage at the expense\n   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.\n   * @member {number} cacheAsBitmapResolution\n   * @memberof PIXI.DisplayObject#\n   * @default null\n   */\n  cacheAsBitmapResolution: {\n    get: function() {\n      return this._cacheAsBitmapResolution;\n    },\n    set: function(i) {\n      i !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = i, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's\n   * sample count is used.\n   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.\n   * @member {number} cacheAsBitmapMultisample\n   * @memberof PIXI.DisplayObject#\n   * @default PIXI.MSAA_QUALITY.NONE\n   */\n  cacheAsBitmapMultisample: {\n    get: function() {\n      return this._cacheAsBitmapMultisample;\n    },\n    set: function(i) {\n      i !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = i, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));\n    }\n  },\n  /**\n   * Set this to true if you want this display object to be cached as a bitmap.\n   * This basically takes a snap shot of the display object as it is at that moment. It can\n   * provide a performance benefit for complex static displayObjects.\n   * To remove simply set this property to `false`\n   *\n   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true\n   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   */\n  cacheAsBitmap: {\n    get: function() {\n      return this._cacheAsBitmap;\n    },\n    set: function(i) {\n      if (this._cacheAsBitmap !== i) {\n        this._cacheAsBitmap = i;\n        var t;\n        i ? (this._cacheData || (this._cacheData = new tA()), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea);\n      }\n    }\n  }\n});\nHe.prototype._renderCached = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t));\n};\nHe.prototype._initCachedDisplayObject = function(t) {\n  var e;\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var r = this.alpha;\n    this.alpha = 1, t.batch.flush();\n    var n = this.getLocalBounds(null, !0).clone();\n    if (this.filters && this.filters.length) {\n      var s = this.filters[0].padding;\n      n.pad(s);\n    }\n    n.ceil(gt.RESOLUTION);\n    var a = t.renderTexture.current, o = t.renderTexture.sourceFrame.clone(), u = t.renderTexture.destinationFrame.clone(), l = t.projection.transform, h = Si.create({\n      width: n.width,\n      height: n.height,\n      resolution: this.cacheAsBitmapResolution || t.resolution,\n      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : t.multisample\n    }), d = \"cacheAsBitmap_\" + Ko();\n    this._cacheData.textureCacheId = d, Kt.addToCache(h.baseTexture, d), Ot.addToCache(h, d);\n    var f = this.transform.localTransform.copyTo(TS).invert().translate(-n.x, -n.y);\n    this.render = this._cacheData.originalRender, t.render(this, { renderTexture: h, clear: !0, transform: f, skipUpdateTransform: !1 }), t.framebuffer.blit(), t.projection.transform = l, t.renderTexture.bind(a, o, u), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var p = new Ue(h);\n    p.transform.worldTransform = this.transform.worldTransform, p.anchor.x = -(n.x / n.width), p.anchor.y = -(n.y / n.height), p.alpha = r, p._bounds = this._bounds, this._cacheData.sprite = p, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = p.containsPoint.bind(p);\n  }\n};\nHe.prototype._renderCachedCanvas = function(t) {\n  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t));\n};\nHe.prototype._initCachedDisplayObjectCanvas = function(t) {\n  if (!(this._cacheData && this._cacheData.sprite)) {\n    var e = this.getLocalBounds(null, !0), r = this.alpha;\n    this.alpha = 1;\n    var n = t.context, s = t._projTransform;\n    e.ceil(gt.RESOLUTION);\n    var a = Si.create({ width: e.width, height: e.height }), o = \"cacheAsBitmap_\" + Ko();\n    this._cacheData.textureCacheId = o, Kt.addToCache(a.baseTexture, o), Ot.addToCache(a, o);\n    var u = TS;\n    this.transform.localTransform.copyTo(u), u.invert(), u.tx -= e.x, u.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, { renderTexture: a, clear: !0, transform: u, skipUpdateTransform: !1 }), t.context = n, t._projTransform = s, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;\n    var l = new Ue(a);\n    l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -(e.x / e.width), l.anchor.y = -(e.y / e.height), l.alpha = r, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l);\n  }\n};\nHe.prototype._calculateCachedBounds = function() {\n  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;\n};\nHe.prototype._getCachedLocalBounds = function() {\n  return this._cacheData.sprite.getLocalBounds(null);\n};\nHe.prototype._destroyCachedDisplayObject = function() {\n  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Kt.removeFromCache(this._cacheData.textureCacheId), Ot.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;\n};\nHe.prototype._cacheAsBitmapDestroy = function(t) {\n  this.cacheAsBitmap = !1, this.destroy(t);\n};\n/*!\n * @pixi/mixin-get-child-by-name - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-get-child-by-name is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nHe.prototype.name = null;\nye.prototype.getChildByName = function(t, e) {\n  for (var r = 0, n = this.children.length; r < n; r++)\n    if (this.children[r].name === t)\n      return this.children[r];\n  if (e)\n    for (var r = 0, n = this.children.length; r < n; r++) {\n      var s = this.children[r];\n      if (s.getChildByName) {\n        var a = s.getChildByName(t, !0);\n        if (a)\n          return a;\n      }\n    }\n  return null;\n};\n/*!\n * @pixi/mixin-get-global-position - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mixin-get-global-position is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nHe.prototype.getGlobalPosition = function(t, e) {\n  return t === void 0 && (t = new xe()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t;\n};\n/*!\n * @pixi/app - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/app is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nvar eA = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.init = function(t) {\n      var e = this;\n      Object.defineProperty(\n        this,\n        \"resizeTo\",\n        /**\n         * The HTML element or window to automatically resize the\n         * renderer's view element to match width and height.\n         * @member {Window|HTMLElement}\n         * @name resizeTo\n         * @memberof PIXI.Application#\n         */\n        {\n          set: function(r) {\n            globalThis.removeEventListener(\"resize\", this.queueResize), this._resizeTo = r, r && (globalThis.addEventListener(\"resize\", this.queueResize), this.resize());\n          },\n          get: function() {\n            return this._resizeTo;\n          }\n        }\n      ), this.queueResize = function() {\n        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame(function() {\n          return e.resize();\n        }));\n      }, this.cancelResize = function() {\n        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null);\n      }, this.resize = function() {\n        if (e._resizeTo) {\n          e.cancelResize();\n          var r, n;\n          if (e._resizeTo === globalThis.window)\n            r = globalThis.innerWidth, n = globalThis.innerHeight;\n          else {\n            var s = e._resizeTo, a = s.clientWidth, o = s.clientHeight;\n            r = a, n = o;\n          }\n          e.renderer.resize(r, n);\n        }\n      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null;\n    }, i.destroy = function() {\n      globalThis.removeEventListener(\"resize\", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;\n    }, i.extension = fe.Application, i;\n  }()\n), CS = (\n  /** @class */\n  function() {\n    function i(t) {\n      var e = this;\n      this.stage = new ye(), t = Object.assign({\n        forceCanvas: !1\n      }, t), this.renderer = Yb(t), i._plugins.forEach(function(r) {\n        r.init.call(e, t);\n      });\n    }\n    return i.registerPlugin = function(t) {\n      jr(\"6.5.0\", \"Application.registerPlugin() is deprecated, use extensions.add()\"), an.add({\n        type: fe.Application,\n        ref: t\n      });\n    }, i.prototype.render = function() {\n      this.renderer.render(this.stage);\n    }, Object.defineProperty(i.prototype, \"view\", {\n      /**\n       * Reference to the renderer's canvas element.\n       * @member {HTMLCanvasElement}\n       * @readonly\n       */\n      get: function() {\n        return this.renderer.view;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(i.prototype, \"screen\", {\n      /**\n       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n       * @member {PIXI.Rectangle}\n       * @readonly\n       */\n      get: function() {\n        return this.renderer.screen;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), i.prototype.destroy = function(t, e) {\n      var r = this, n = i._plugins.slice(0);\n      n.reverse(), n.forEach(function(s) {\n        s.destroy.call(r);\n      }), this.stage.destroy(e), this.stage = null, this.renderer.destroy(t), this.renderer = null;\n    }, i._plugins = [], i;\n  }()\n);\nan.handleByList(fe.Application, CS._plugins);\nan.add(eA);\n/*!\n * @pixi/mesh-extras - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/mesh-extras is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar $y = function(i, t) {\n  return $y = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, $y(i, t);\n};\nfunction ch(i, t) {\n  $y(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar rA = (\n  /** @class */\n  function(i) {\n    ch(t, i);\n    function t(e, r, n, s) {\n      e === void 0 && (e = 100), r === void 0 && (r = 100), n === void 0 && (n = 10), s === void 0 && (s = 10);\n      var a = i.call(this) || this;\n      return a.segWidth = n, a.segHeight = s, a.width = e, a.height = r, a.build(), a;\n    }\n    return t.prototype.build = function() {\n      for (var e = this.segWidth * this.segHeight, r = [], n = [], s = [], a = this.segWidth - 1, o = this.segHeight - 1, u = this.width / a, l = this.height / o, h = 0; h < e; h++) {\n        var d = h % this.segWidth, f = h / this.segWidth | 0;\n        r.push(d * u, f * l), n.push(d / a, f / o);\n      }\n      for (var p = a * o, h = 0; h < p; h++) {\n        var v = h % a, g = h / a | 0, m = g * this.segWidth + v, y = g * this.segWidth + v + 1, _ = (g + 1) * this.segWidth + v, b = (g + 1) * this.segWidth + v + 1;\n        s.push(m, y, _, y, b, _);\n      }\n      this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();\n    }, t;\n  }(s0)\n), iA = (\n  /** @class */\n  function(i) {\n    ch(t, i);\n    function t(e, r, n) {\n      e === void 0 && (e = 200), n === void 0 && (n = 0);\n      var s = i.call(this, new Float32Array(r.length * 4), new Float32Array(r.length * 4), new Uint16Array((r.length - 1) * 6)) || this;\n      return s.points = r, s._width = e, s.textureScale = n, s.build(), s;\n    }\n    return Object.defineProperty(t.prototype, \"width\", {\n      /**\n       * The width (i.e., thickness) of the rope.\n       * @readonly\n       */\n      get: function() {\n        return this._width;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype.build = function() {\n      var e = this.points;\n      if (e) {\n        var r = this.getBuffer(\"aVertexPosition\"), n = this.getBuffer(\"aTextureCoord\"), s = this.getIndex();\n        if (!(e.length < 1)) {\n          r.data.length / 4 !== e.length && (r.data = new Float32Array(e.length * 4), n.data = new Float32Array(e.length * 4), s.data = new Uint16Array((e.length - 1) * 6));\n          var a = n.data, o = s.data;\n          a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 1;\n          for (var u = 0, l = e[0], h = this._width * this.textureScale, d = e.length, f = 0; f < d; f++) {\n            var p = f * 4;\n            if (this.textureScale > 0) {\n              var v = l.x - e[f].x, g = l.y - e[f].y, m = Math.sqrt(v * v + g * g);\n              l = e[f], u += m / h;\n            } else\n              u = f / (d - 1);\n            a[p] = u, a[p + 1] = 0, a[p + 2] = u, a[p + 3] = 1;\n          }\n          for (var y = 0, f = 0; f < d - 1; f++) {\n            var p = f * 2;\n            o[y++] = p, o[y++] = p + 1, o[y++] = p + 2, o[y++] = p + 2, o[y++] = p + 1, o[y++] = p + 3;\n          }\n          n.update(), s.update(), this.updateVertices();\n        }\n      }\n    }, t.prototype.updateVertices = function() {\n      var e = this.points;\n      if (!(e.length < 1)) {\n        for (var r = e[0], n, s = 0, a = 0, o = this.buffers[0].data, u = e.length, l = 0; l < u; l++) {\n          var h = e[l], d = l * 4;\n          l < e.length - 1 ? n = e[l + 1] : n = h, a = -(n.x - r.x), s = n.y - r.y;\n          var f = Math.sqrt(s * s + a * a), p = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n          s /= f, a /= f, s *= p, a *= p, o[d] = h.x + s, o[d + 1] = h.y + a, o[d + 2] = h.x - s, o[d + 3] = h.y - a, r = h;\n        }\n        this.buffers[0].update();\n      }\n    }, t.prototype.update = function() {\n      this.textureScale > 0 ? this.build() : this.updateVertices();\n    }, t;\n  }(s0)\n);\n(function(i) {\n  ch(t, i);\n  function t(e, r, n) {\n    n === void 0 && (n = 0);\n    var s = this, a = new iA(e.height, r, n), o = new dc(e);\n    return n > 0 && (e.baseTexture.wrapMode = On.REPEAT), s = i.call(this, a, o) || this, s.autoUpdate = !0, s;\n  }\n  return t.prototype._render = function(e) {\n    var r = this.geometry;\n    (this.autoUpdate || r._width !== this.shader.texture.height) && (r._width = this.shader.texture.height, r.update()), i.prototype._render.call(this, e);\n  }, t;\n})(fc);\nvar nA = (\n  /** @class */\n  function(i) {\n    ch(t, i);\n    function t(e, r, n) {\n      var s = this, a = new rA(e.width, e.height, r, n), o = new dc(Ot.WHITE);\n      return s = i.call(this, a, o) || this, s.texture = e, s.autoResize = !0, s;\n    }\n    return t.prototype.textureUpdated = function() {\n      this._textureID = this.shader.texture._updateID;\n      var e = this.geometry, r = this.shader.texture, n = r.width, s = r.height;\n      this.autoResize && (e.width !== n || e.height !== s) && (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build());\n    }, Object.defineProperty(t.prototype, \"texture\", {\n      get: function() {\n        return this.shader.texture;\n      },\n      set: function(e) {\n        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once(\"update\", this.textureUpdated, this));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t.prototype._render = function(e) {\n      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), i.prototype._render.call(this, e);\n    }, t.prototype.destroy = function(e) {\n      this.shader.texture.off(\"update\", this.textureUpdated, this), i.prototype.destroy.call(this, e);\n    }, t;\n  }(fc)\n);\n(function(i) {\n  ch(t, i);\n  function t(e, r, n, s, a) {\n    e === void 0 && (e = Ot.EMPTY);\n    var o = this, u = new s0(r, n, s);\n    u.getBuffer(\"aVertexPosition\").static = !1;\n    var l = new dc(e);\n    return o = i.call(this, u, l, null, a) || this, o.autoUpdate = !0, o;\n  }\n  return Object.defineProperty(t.prototype, \"vertices\", {\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._render = function(e) {\n    this.autoUpdate && this.geometry.getBuffer(\"aVertexPosition\").update(), i.prototype._render.call(this, e);\n  }, t;\n})(fc);\nvar op = 10;\n(function(i) {\n  ch(t, i);\n  function t(e, r, n, s, a) {\n    r === void 0 && (r = op), n === void 0 && (n = op), s === void 0 && (s = op), a === void 0 && (a = op);\n    var o = i.call(this, Ot.WHITE, 4, 4) || this;\n    return o._origWidth = e.orig.width, o._origHeight = e.orig.height, o._width = o._origWidth, o._height = o._origHeight, o._leftWidth = r, o._rightWidth = s, o._topHeight = n, o._bottomHeight = a, o.texture = e, o;\n  }\n  return t.prototype.textureUpdated = function() {\n    this._textureID = this.shader.texture._updateID, this._refresh();\n  }, Object.defineProperty(t.prototype, \"vertices\", {\n    get: function() {\n      return this.geometry.getBuffer(\"aVertexPosition\").data;\n    },\n    set: function(e) {\n      this.geometry.getBuffer(\"aVertexPosition\").data = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype.updateHorizontalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[9] = e[11] = e[13] = e[15] = this._topHeight * r, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * r, e[25] = e[27] = e[29] = e[31] = this._height;\n  }, t.prototype.updateVerticalVertices = function() {\n    var e = this.vertices, r = this._getMinScale();\n    e[2] = e[10] = e[18] = e[26] = this._leftWidth * r, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * r, e[6] = e[14] = e[22] = e[30] = this._width;\n  }, t.prototype._getMinScale = function() {\n    var e = this._leftWidth + this._rightWidth, r = this._width > e ? 1 : this._width / e, n = this._topHeight + this._bottomHeight, s = this._height > n ? 1 : this._height / n, a = Math.min(r, s);\n    return a;\n  }, Object.defineProperty(t.prototype, \"width\", {\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function() {\n      return this._width;\n    },\n    set: function(e) {\n      this._width = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"height\", {\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    get: function() {\n      return this._height;\n    },\n    set: function(e) {\n      this._height = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"leftWidth\", {\n    /** The width of the left column. */\n    get: function() {\n      return this._leftWidth;\n    },\n    set: function(e) {\n      this._leftWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"rightWidth\", {\n    /** The width of the right column. */\n    get: function() {\n      return this._rightWidth;\n    },\n    set: function(e) {\n      this._rightWidth = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"topHeight\", {\n    /** The height of the top row. */\n    get: function() {\n      return this._topHeight;\n    },\n    set: function(e) {\n      this._topHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(t.prototype, \"bottomHeight\", {\n    /** The height of the bottom row. */\n    get: function() {\n      return this._bottomHeight;\n    },\n    set: function(e) {\n      this._bottomHeight = e, this._refresh();\n    },\n    enumerable: !1,\n    configurable: !0\n  }), t.prototype._refresh = function() {\n    var e = this.texture, r = this.geometry.buffers[1].data;\n    this._origWidth = e.orig.width, this._origHeight = e.orig.height;\n    var n = 1 / this._origWidth, s = 1 / this._origHeight;\n    r[0] = r[8] = r[16] = r[24] = 0, r[1] = r[3] = r[5] = r[7] = 0, r[6] = r[14] = r[22] = r[30] = 1, r[25] = r[27] = r[29] = r[31] = 1, r[2] = r[10] = r[18] = r[26] = n * this._leftWidth, r[4] = r[12] = r[20] = r[28] = 1 - n * this._rightWidth, r[9] = r[11] = r[13] = r[15] = s * this._topHeight, r[17] = r[19] = r[21] = r[23] = 1 - s * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();\n  }, t;\n})(nA);\n/*!\n * @pixi/sprite-animated - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar Vy = function(i, t) {\n  return Vy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, Vy(i, t);\n};\nfunction sA(i, t) {\n  Vy(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar iw = (\n  /** @class */\n  function(i) {\n    sA(t, i);\n    function t(e, r) {\n      r === void 0 && (r = !0);\n      var n = i.call(this, e[0] instanceof Ot ? e[0] : e[0].texture) || this;\n      return n._textures = null, n._durations = null, n._autoUpdate = r, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n;\n    }\n    return t.prototype.stop = function() {\n      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1));\n    }, t.prototype.play = function() {\n      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ge.shared.add(this.update, this, Cs.HIGH), this._isConnectedToTicker = !0));\n    }, t.prototype.gotoAndStop = function(e) {\n      this.stop();\n      var r = this.currentFrame;\n      this._currentTime = e, r !== this.currentFrame && this.updateTexture();\n    }, t.prototype.gotoAndPlay = function(e) {\n      var r = this.currentFrame;\n      this._currentTime = e, r !== this.currentFrame && this.updateTexture(), this.play();\n    }, t.prototype.update = function(e) {\n      if (this._playing) {\n        var r = this.animationSpeed * e, n = this.currentFrame;\n        if (this._durations !== null) {\n          var s = this._currentTime % 1 * this._durations[this.currentFrame];\n          for (s += r / 60 * 1e3; s < 0; )\n            this._currentTime--, s += this._durations[this.currentFrame];\n          var a = Math.sign(this.animationSpeed * e);\n          for (this._currentTime = Math.floor(this._currentTime); s >= this._durations[this.currentFrame]; )\n            s -= this._durations[this.currentFrame] * a, this._currentTime += a;\n          this._currentTime += s / this._durations[this.currentFrame];\n        } else\n          this._currentTime += r;\n        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > n && this.onLoop()), this.updateTexture());\n      }\n    }, t.prototype.updateTexture = function() {\n      var e = this.currentFrame;\n      this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));\n    }, t.prototype.destroy = function(e) {\n      this.stop(), i.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;\n    }, t.fromFrames = function(e) {\n      for (var r = [], n = 0; n < e.length; ++n)\n        r.push(Ot.from(e[n]));\n      return new t(r);\n    }, t.fromImages = function(e) {\n      for (var r = [], n = 0; n < e.length; ++n)\n        r.push(Ot.from(e[n]));\n      return new t(r);\n    }, Object.defineProperty(t.prototype, \"totalFrames\", {\n      /**\n       * The total number of frames in the AnimatedSprite. This is the same as number of textures\n       * assigned to the AnimatedSprite.\n       * @readonly\n       * @default 0\n       */\n      get: function() {\n        return this._textures.length;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"textures\", {\n      /** The array of textures used for this AnimatedSprite. */\n      get: function() {\n        return this._textures;\n      },\n      set: function(e) {\n        if (e[0] instanceof Ot)\n          this._textures = e, this._durations = null;\n        else {\n          this._textures = [], this._durations = [];\n          for (var r = 0; r < e.length; r++)\n            this._textures.push(e[r].texture), this._durations.push(e[r].time);\n        }\n        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"currentFrame\", {\n      /**\n       * The AnimatedSprites current frame index.\n       * @readonly\n       */\n      get: function() {\n        var e = Math.floor(this._currentTime) % this._textures.length;\n        return e < 0 && (e += this._textures.length), e;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"playing\", {\n      /**\n       * Indicates if the AnimatedSprite is currently playing.\n       * @readonly\n       */\n      get: function() {\n        return this._playing;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), Object.defineProperty(t.prototype, \"autoUpdate\", {\n      /** Whether to use PIXI.Ticker.shared to auto update animation time. */\n      get: function() {\n        return this._autoUpdate;\n      },\n      set: function(e) {\n        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (Ge.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ge.shared.add(this.update, this), this._isConnectedToTicker = !0));\n      },\n      enumerable: !1,\n      configurable: !0\n    }), t;\n  }(Ue)\n);\n/*!\n * pixi.js - v6.5.9\n * Compiled Wed, 25 Jan 2023 05:01:45 UTC\n *\n * pixi.js is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nan.add(\n  // Install renderer plugins\n  z2,\n  Z2,\n  W2,\n  zk,\n  mN,\n  Kb,\n  SN,\n  // Install loader plugins\n  LN,\n  dk,\n  Fk,\n  Gk,\n  _N,\n  // Install application plugins\n  GD,\n  nk\n);\nvar Bs;\nclass Ql {\n  constructor() {\n    // リソースリーク対策\n    E(this, Bs, []);\n  }\n  add(t, e, r, n = {}) {\n    if (t instanceof Kt) {\n      switch (e) {\n        case \"loaded\":\n        case \"update\":\n        case \"error\":\n        case \"dispose\":\n          t.on(e, r, n), c(this, Bs).push(() => t.off(e, r, n));\n          break;\n      }\n      return;\n    }\n    if (t instanceof $r) {\n      t.on(e, r, n), c(this, Bs).push(() => t.off(e, r, n));\n      return;\n    }\n    t.addEventListener(e, r, n), c(this, Bs).push(() => t.removeEventListener(e, r, { capture: n.capture ?? !1 }));\n  }\n  clear() {\n    for (const t of c(this, Bs))\n      t();\n    P(this, Bs, []);\n  }\n}\nBs = new WeakMap();\nvar vr = /* @__PURE__ */ ((i) => (i.DEFAULT = \"\", i.SP_GSM = \"png|jpg|jpeg|json|svg|webp|mp4|webm\", i.SCRIPT = \"sn|ssn\", i.FONT = \"woff2|woff|otf|ttf\", i.SOUND = \"mp3|m4a|ogg|aac|flac|wav\", i.HTML = \"htm|html\", i.CSS = \"css\", i.SN = \"sn\", i.PSD = \"psd\", i.TST_PNGPNG_ = \"png|png_\", i.TST_HH = \"hh\", i.TST_EEE = \"eee\", i.TST_GGG = \"ggg\", i.TST_PNGXML = \"png|xml\", i))(vr || {}), Ec, Sc, kv;\nclass aA {\n  constructor(t) {\n    K(this, \"oCfg\", {\n      save_ns: \"\",\n      // 扱うセーブデータを一意に識別するキーワード文字列\n      window: {\n        // アプリケーションウインドウサイズ\n        width: 300,\n        height: 300\n      },\n      book: {\n        // プロジェクトの詳細情報です\n        title: \"\",\n        //作品タイトル\n        creator: \"\",\n        //著作者。同人ならペンネーム\n        cre_url: \"\",\n        //著作者URL。ツイッターやメール、サイトなど\n        publisher: \"\",\n        //出版社。同人ならサークル名\n        pub_url: \"\",\n        //出版社URL。無ければ省略します\n        detail: \"\",\n        // 内容紹介。端的に記入\n        version: \"1.0\"\n      },\n      log: { max_len: 1024 },\n      // プレイヤーが読んだ文章を読み返せる履歴の長さ\n      init: {\n        bg_color: \"#000000\",\n        // 背景色\n        tagch_msecwait: 10,\n        // 通常文字表示待ち時間（未読／既読）\n        auto_msecpagewait: 3500,\n        // 自動文字表示、行クリック待ち時間（未読／既読）\n        escape: \"\"\n        // エスケープ文字\n      },\n      debug: {\n        devtool: !1,\n        token: !1,\n        tag: !1,\n        putCh: !1,\n        debugLog: !1,\n        baseTx: !1,\n        masume: !1,\n        // テキストレイヤ：ガイドマス目を表示するか\n        variable: !1\n      },\n      code: {},\n      // 暗号化しないフォルダ\n      debuger_token: \"\"\n      // デバッガとの接続トークン\n    });\n    K(this, \"userFnTail\", \"\");\n    // 4tst public\n    K(this, \"hPathFn2Exts\", {});\n    E(this, Ec, !1);\n    E(this, Sc, !1);\n    E(this, kv, /([^\\/\\s]+)\\.([^\\d]\\w+)/);\n    this.sys = t;\n  }\n  async load(t) {\n    var e, r, n, s;\n    if (this.oCfg.save_ns = (t == null ? void 0 : t.save_ns) ?? this.oCfg.save_ns, this.oCfg.window.width = Number(((e = t == null ? void 0 : t.window) == null ? void 0 : e.width) ?? this.oCfg.window.width), this.oCfg.window.height = Number(((r = t == null ? void 0 : t.window) == null ? void 0 : r.height) ?? this.oCfg.window.height), this.oCfg.book = { ...this.oCfg.book, ...t.book }, this.oCfg.log.max_len = ((s = (n = t.log) == null ? void 0 : n.max_len) == null ? void 0 : s.max_len) ?? this.oCfg.log.max_len, this.oCfg.init = { ...this.oCfg.init, ...t.init }, this.oCfg.debug = { ...this.oCfg.debug, ...t.debug }, this.oCfg.debuger_token = t.debuger_token, await this.sys.loadPath(this.hPathFn2Exts, this), P(this, Ec, this.matchPath(\n      \"^breakline$\",\n      \"png|jpg|jpeg|json|svg|webp|mp4|webm\"\n      /* SP_GSM */\n    ).length > 0), P(this, Sc, this.matchPath(\n      \"^breakpage$\",\n      \"png|jpg|jpeg|json|svg|webp|mp4|webm\"\n      /* SP_GSM */\n    ).length > 0), !!this.sys.crypto)\n      for (const a of Object.values(this.hPathFn2Exts))\n        for (const [o, u] of Object.entries(a)) {\n          if (o.slice(-10) !== \":RIPEMD160\")\n            continue;\n          const l = u.slice(u.lastIndexOf(\"/\") + 1), h = a[o.slice(0, -10)], f = await (await this.sys.fetch(h)).text(), p = this.sys.hash(f);\n          if (l !== p)\n            throw `ファイル改竄エラーです fn:${h}`;\n        }\n  }\n  get existsBreakline() {\n    return c(this, Ec);\n  }\n  get existsBreakpage() {\n    return c(this, Sc);\n  }\n  getNs() {\n    return `skynovel.${this.oCfg.save_ns} - `;\n  }\n  // 4 match 498 step(~1ms)  https://regex101.com/r/tpVgmI/1\n  searchPath(t, e = \"\") {\n    if (!t)\n      throw \"[searchPath] fnが空です\";\n    if (t.slice(0, 7) === \"http://\")\n      return t;\n    const r = t.match(c(this, kv));\n    let n = r ? r[1] : t;\n    const s = r ? r[2] : \"\";\n    if (this.userFnTail) {\n      const u = n + \"@@\" + this.userFnTail;\n      if (u in this.hPathFn2Exts) {\n        if (e === \"\")\n          n = u;\n        else\n          for (const l of Object.keys(this.hPathFn2Exts[u]))\n            if (`|${e}|`.indexOf(`|${l}|`) !== -1) {\n              n = u;\n              break;\n            }\n      }\n    }\n    const a = this.hPathFn2Exts[n];\n    if (!a)\n      throw `サーチパスに存在しないファイル【${t}】です`;\n    let o = \"\";\n    if (!s) {\n      const u = $t(a[\":cnt\"]);\n      if (e === \"\") {\n        if (u > 1)\n          throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n        return t;\n      }\n      const l = `|${e}|`;\n      if (u > 1) {\n        let h = 0;\n        for (const d of Object.keys(a))\n          if (l.indexOf(`|${d}|`) !== -1 && ++h > 1)\n            throw `指定ファイル【${t}】が複数マッチします。サーチ対象拡張子群【${e}】で絞り込むか、ファイル名を個別にして下さい。`;\n      }\n      for (let h of Object.keys(a))\n        if (l.indexOf(`|${h}|`) > -1)\n          return a[h];\n      throw `サーチ対象拡張子群【${e}】にマッチするファイルがサーチパスに存在しません。探索ファイル名=【${t}】`;\n    }\n    if (e !== \"\" && `|${e}|`.indexOf(`|${s}|`) === -1)\n      throw `指定ファイルの拡張子【${s}】は、サーチ対象拡張子群【${e}】にマッチしません。探索ファイル名=【${t}】`;\n    if (o = a[s], !o)\n      throw `サーチパスに存在しない拡張子【${s}】です。探索ファイル名=【${t}】、サーチ対象拡張子群【${e}】`;\n    return o;\n  }\n  matchPath(t, e = \"\") {\n    const r = [], n = new RegExp(t), s = new RegExp(e);\n    for (const [a, o] of Object.entries(this.hPathFn2Exts)) {\n      if (a.search(n) === -1)\n        continue;\n      if (e === \"\") {\n        r.push(o);\n        continue;\n      }\n      const u = {};\n      let l = !1;\n      for (const h of Object.keys(o))\n        h.search(s) !== -1 && (u[h] = a, l = !0);\n      l && r.push(u);\n    }\n    return r;\n  }\n  addPath(t, e) {\n    const r = {};\n    for (const [n, s] of Object.entries(e))\n      r[n] = (n.at(0) === \":\" ? \"\" : this.sys.cur) + s;\n    this.hPathFn2Exts[t] = r;\n  }\n}\nEc = new WeakMap(), Sc = new WeakMap(), kv = new WeakMap();\nclass rx extends aA {\n  constructor(t) {\n    super(t), this.sys = t;\n  }\n  static async generate(t) {\n    const e = new rx(t), r = t.cur + \"prj.json\", n = await (await t.fetch(r)).text(), s = JSON.parse(t.decStr(r, n));\n    return await e.load(s), e;\n  }\n  async load(t) {\n    await super.load(t), Y.stageW = this.oCfg.window.width, Y.stageH = this.oCfg.window.height, Y.debugLog = this.oCfg.debug.debugLog;\n  }\n  searchPath(t, e = vr.DEFAULT) {\n    return t.slice(0, 11) === \"downloads:/\" ? this.sys.path_downloads + t.slice(11) : t.slice(0, 10) === \"userdata:/\" ? this.sys.path_userdata + \"storage/\" + t.slice(10) : super.searchPath(t, e);\n  }\n}\nconst MS = /(?<name>[^\\s;\\]]+)/;\nfunction Rp(i) {\n  const t = MS.exec(i.slice(1, -1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${i}】異常です(タグ解析)`;\n  const r = e.name;\n  return [r, i.slice(1 + r.length, -1)];\n}\nfunction Dp(i) {\n  const t = MS.exec(i.slice(1)), e = t == null ? void 0 : t.groups;\n  if (!e)\n    throw `タグ記述【${i}】異常です(タグ解析)`;\n  return e.name;\n}\nfunction oA(i) {\n  const t = i.replaceAll(\"==\", \"＝\").replaceAll(\"!=\", \"≠\").split(\"=\"), e = t.length;\n  if (e < 2 || e > 3)\n    throw \"「&計算」書式では「=」指定が一つか二つ必要です\";\n  if (t[1].at(0) === \"&\")\n    throw \"「&計算」書式では「&」指定が不要です\";\n  return {\n    name: t[0].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    text: t[1].replaceAll(\"＝\", \"==\").replaceAll(\"≠\", \"!=\"),\n    cast: e === 3 ? t[2].trim() : void 0\n  };\n}\nvar ja, za, Tc, Cc, Mc, Er, Pc, Uu, kp;\nclass uA {\n  constructor() {\n    E(this, Uu);\n    E(this, ja, void 0);\n    E(this, za, void 0);\n    E(this, Tc, new RegExp(\"\"));\n    E(this, Cc, \"\");\n    E(this, Mc, \"\");\n    E(this, Er, void 0);\n    E(this, Pc, void 0);\n    this.setEscape(\"\");\n  }\n  setEscape(t) {\n    if (c(this, Er) && t in c(this, Er))\n      throw \"[エスケープ文字] char【\" + t + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    P(this, ja, new RegExp(\n      (t ? `\\\\${t}\\\\S|` : \"\") + // エスケープシーケンス\n      `\\\\n+|\\\\t+|\\\\[let_ml\\\\s+[^\\\\]]+\\\\].+?(?=\\\\[endlet_ml[\\\\]\\\\s])|\\\\[(?:(?=([^\"'#;\\\\]]+))\\\\1|([\"'#]).*?\\\\2|;[^\\\\n]*)*?]|;[^\\\\n]*|&[^&\\\\n]+&|&&?[^&;\\\\n\\\\t]+|^\\\\*[^\\\\s\\\\[&;\\\\\\\\]+|[^\\\\n\\\\t\\\\[;${t ? `\\\\${t}` : \"\"}]+`,\n      // 本文\n      \"gs\"\n    )), P(this, za, new RegExp(`[\\\\w\\\\s;[\\\\]*=&｜《》${t ? `\\\\${t}` : \"\"}]`)), P(this, Pc, new RegExp(`[\\\\n\\\\t;\\\\[*&${t ? `\\\\${t}` : \"\"}]`));\n  }\n  // 括弧マクロの定義\n  bracket2macro(t, e, r, n) {\n    const { name: s, text: a } = t;\n    if (!s)\n      throw \"[bracket2macro] nameは必須です\";\n    if (!a)\n      throw \"[bracket2macro] textは必須です\";\n    const o = a.at(0);\n    if (!o)\n      throw \"[bracket2macro] textは必須です\";\n    if (a.length !== 2)\n      throw \"[bracket2macro] textは括弧の前後を示す二文字を指定してください\";\n    if (!(s in e))\n      throw `[bracket2macro] 未定義のタグ又はマクロ[${s}]です`;\n    c(this, Er) ?? P(this, Er, {});\n    const u = a.charAt(1);\n    if (o in c(this, Er))\n      throw \"[bracket2macro] text【\" + o + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (u in c(this, Er))\n      throw \"[bracket2macro] text【\" + u + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (c(this, za).test(o))\n      throw \"[bracket2macro] text【\" + o + \"】は括弧マクロに使用できない文字です\";\n    if (c(this, za).test(u))\n      throw \"[bracket2macro] text【\" + u + \"】は括弧マクロに使用できない文字です\";\n    c(this, Er)[u] = \"0\", c(this, Er)[o] = `[${s} text=`, this.addC2M(`\\\\${o}[^\\\\${u}]*\\\\${u}`, `\\\\${o}\\\\${u}`), O(this, Uu, kp).call(this, r, n);\n  }\n  // 一文字マクロの定義\n  char2macro(t, e, r, n) {\n    const { char: s, name: a } = t;\n    if (!s)\n      throw \"[char2macro] charは必須です\";\n    if (c(this, Er) ?? P(this, Er, {}), s in c(this, Er))\n      throw \"[char2macro] char【\" + s + \"】が登録済みの括弧マクロまたは一文字マクロです\";\n    if (c(this, za).test(s))\n      throw \"[char2macro] char【\" + s + \"】は一文字マクロに使用できない文字です\";\n    if (!a)\n      throw \"[char2macro] nameは必須です\";\n    if (!(a in e))\n      throw `[char2macro] 未定義のタグ又はマクロ[${a}]です`;\n    c(this, Er)[s] = `[${a}]`, this.addC2M(`\\\\${s}`, `\\\\${s}`), O(this, Uu, kp).call(this, r, n);\n  }\n  addC2M(t, e) {\n    P(this, Cc, c(this, Cc) + `${t}|`), P(this, Mc, c(this, Mc) + `${e}`), P(this, Tc, new RegExp(\n      `(${c(this, Cc)}[^${c(this, Mc)}]+)`,\n      \"g\"\n    ));\n  }\n  resolveScript(t) {\n    var n;\n    const e = ((n = t.replaceAll(/(\\r\\n|\\r)/g, `\n`).match(c(this, ja))) == null ? void 0 : n.flatMap((s) => {\n      if (!this.testTagLetml(s))\n        return s;\n      const a = /^([^\\]]+?])(.*)$/s.exec(s);\n      if (!a)\n        return s;\n      const [, o, u] = a;\n      return [o, u];\n    })) ?? [], r = { aToken: e, len: e.length, aLNum: [] };\n    return O(this, Uu, kp).call(this, r), r;\n  }\n  testTagLetml(t) {\n    return /^\\[let_ml\\s/.test(t);\n  }\n  testTagEndLetml(t) {\n    return /^\\[endlet_ml\\s*]/.test(t);\n  }\n  analyzToken(t) {\n    return c(this, ja).lastIndex = 0, c(this, ja).exec(t);\n  }\n  testNoTxt(t) {\n    return c(this, Pc).test(t);\n  }\n  //4tst\n}\nja = new WeakMap(), za = new WeakMap(), Tc = new WeakMap(), Cc = new WeakMap(), Mc = new WeakMap(), Er = new WeakMap(), Pc = new WeakMap(), Uu = new WeakSet(), kp = function(t, e = 0) {\n  if (c(this, Er)) {\n    for (let r = t.len - 1; r >= e; --r) {\n      const n = t.aToken[r];\n      if (this.testNoTxt(n.at(0) ?? `\n`))\n        continue;\n      const s = t.aLNum[r], a = n.match(c(this, Tc));\n      if (!a)\n        continue;\n      let o = 1;\n      for (let u = a.length - 1; u >= 0; --u) {\n        let l = a[u];\n        const h = c(this, Er)[l.at(0) ?? \" \"];\n        h && (l = h + (h.at(-1) === \"]\" ? \"\" : `'${l.slice(1, -1)}']`)), t.aToken.splice(r, o, l), t.aLNum.splice(r, o, s), o = 0;\n      }\n    }\n    t.len = t.aToken.length;\n  }\n};\nvar Oc, ju, Np, Ha, zu;\nclass lA {\n  constructor() {\n    E(this, ju);\n    // 87 match 2725 step(0.5ms) PCRE2 https://regex101.com/r/aeN57J/1\n    /*\n    ;[^\\n]*\n    |\t(?<key>[^\\s=\"'#|;]+)\n    \t(?: \\s | ;[^\\n]*\\n)*\n    \t=\n    \t(?: \\s | ;[^\\n]*\\n)*\n    \t(?:\t(?<val> [^\\s\"'#|;]+)\n    \t|\t([\"'#]) (?<val2>.*?) \\3 )\n    \t(?: \\|\n    \t\t(?: (?<def> [^\\s\"'#;]+)\n    \t|\t([\"'#]) (?<def2>.*?) \\6 ) )?\n    |\t(?<literal>[^\\s;]+)\n    \t*/\n    E(this, Oc, /;[^\\n]*|(?<key>[^\\s=\"'#|;]+)(?:\\s|;[^\\n]*\\n)*=(?:\\s|;[^\\n]*\\n)*(?:(?<val>[^\\s\"'#|;]+)|([\"'#])(?<val2>.*?)\\3)(?:\\|(?:(?<def>[^\\s\"'#;]+)|([\"'#])(?<def2>.*?)\\6))?|(?<literal>[^\\s;]+)/g);\n    E(this, Ha, {});\n    E(this, zu, !1);\n  }\n  // 【属性 = 値 | 省略値】の分析\n  parse(t) {\n    P(this, Ha, {}), P(this, zu, !1);\n    for (const { groups: e } of t.matchAll(c(this, Oc))) {\n      const { key: r, val: n, val2: s, def: a, def2: o, literal: u } = e;\n      r ? c(this, Ha)[r] = {\n        val: n ?? s,\n        def: a ?? o\n      } : u && (u === \"*\" ? P(this, zu, !0) : c(this, Ha)[u] = { val: \"1\" });\n    }\n  }\n  // 属性と値の位置をまとめて返す\n  parseinDetail(t, e, r, n) {\n    const s = {}, a = t.slice(1 + e, -1);\n    for (const { groups: o, index: u, 0: l } of a.matchAll(c(this, Oc))) {\n      if (u === void 0)\n        continue;\n      const { key: h, val: d, val2: f, literal: p } = o;\n      if (p) {\n        if (p.at(-1) === \"=\") {\n          const _ = p.length - 1, { ch: b } = O(this, ju, Np).call(this, e, r, n, a, u + _);\n          s[p.slice(0, -1)] = {\n            k_ln: r,\n            k_ch: b - _,\n            v_ln: r,\n            v_ch: b + 1,\n            //\tv_ch: ch +1+lenNm +literal.length +1,\n            v_len: 0\n          };\n        }\n        continue;\n      }\n      if (!h)\n        continue;\n      const { ln: v, ch: g } = O(this, ju, Np).call(this, e, r, n, a, u), { ln: m, ch: y } = O(this, ju, Np).call(this, e, r, n, a, u + l.lastIndexOf(d ?? f) - (d ? 0 : 1));\n      s[h] = { k_ln: v, k_ch: g, v_ln: m, v_ch: y, v_len: d ? d.length : f.length + 2 };\n    }\n    return s;\n  }\n  get hPrm() {\n    return c(this, Ha);\n  }\n  get isKomeParam() {\n    return c(this, zu);\n  }\n}\nOc = new WeakMap(), ju = new WeakSet(), Np = function(t, e, r, n, s) {\n  const o = n.slice(0, s).split(`\n`), u = o.length;\n  return {\n    ln: e + u - 1,\n    ch: u < 2 ? r + 1 + t + s : o.at(-1).length\n  };\n}, Ha = new WeakMap(), zu = new WeakMap();\nvar pe = {}, hA = {\n  get exports() {\n    return pe;\n  },\n  set exports(i) {\n    pe = i;\n  }\n};\n(function(i, t) {\n  (function(e, r) {\n    i.exports = r();\n  })(typeof self < \"u\" ? self : Cp, function() {\n    return function(e) {\n      var r = {};\n      function n(s) {\n        if (r[s])\n          return r[s].exports;\n        var a = r[s] = { i: s, l: !1, exports: {} };\n        return e[s].call(a.exports, a, a.exports, n), a.l = !0, a.exports;\n      }\n      return n.m = e, n.c = r, n.d = function(s, a, o) {\n        n.o(s, a) || Object.defineProperty(s, a, { configurable: !1, enumerable: !0, get: o });\n      }, n.r = function(s) {\n        Object.defineProperty(s, \"__esModule\", { value: !0 });\n      }, n.n = function(s) {\n        var a = s && s.__esModule ? function() {\n          return s.default;\n        } : function() {\n          return s;\n        };\n        return n.d(a, \"a\", a), a;\n      }, n.o = function(s, a) {\n        return Object.prototype.hasOwnProperty.call(s, a);\n      }, n.p = \"\", n(n.s = 0);\n    }([function(e, r, n) {\n      function s(D) {\n        if (!(this instanceof s))\n          return new s(D);\n        this._ = D;\n      }\n      var a = s.prototype;\n      function o(D, L) {\n        for (var j = 0; j < D; j++)\n          L(j);\n      }\n      function u(D, L, j) {\n        return function(J, rt) {\n          o(rt.length, function(ot) {\n            J(rt[ot], ot, rt);\n          });\n        }(function(J, rt, ot) {\n          L = D(L, J, rt, ot);\n        }, j), L;\n      }\n      function l(D, L) {\n        return u(function(j, J, rt, ot) {\n          return j.concat([D(J, rt, ot)]);\n        }, [], L);\n      }\n      function h(D, L) {\n        var j = { v: 0, buf: L };\n        return o(D, function() {\n          var J;\n          j = { v: j.v << 1 | (J = j.buf, J[0] >> 7), buf: function(rt) {\n            var ot = u(function(ut, Lt, we, wr) {\n              return ut.concat(we === wr.length - 1 ? Buffer.from([Lt, 0]).readUInt16BE(0) : wr.readUInt16BE(we));\n            }, [], rt);\n            return Buffer.from(l(function(ut) {\n              return (ut << 1 & 65535) >> 8;\n            }, ot));\n          }(j.buf) };\n        }), j;\n      }\n      function d() {\n        return typeof Buffer < \"u\";\n      }\n      function f() {\n        if (!d())\n          throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\");\n      }\n      function p(D) {\n        f();\n        var L = u(function(ot, ut) {\n          return ot + ut;\n        }, 0, D);\n        if (L % 8 != 0)\n          throw new Error(\"The bits [\" + D.join(\", \") + \"] add up to \" + L + \" which is not an even number of bytes; the total should be divisible by 8\");\n        var j, J = L / 8, rt = (j = function(ot) {\n          return ot > 48;\n        }, u(function(ot, ut) {\n          return ot || (j(ut) ? ut : ot);\n        }, null, D));\n        if (rt)\n          throw new Error(rt + \" bit range requested exceeds 48 bit (6 byte) Number max.\");\n        return new s(function(ot, ut) {\n          var Lt = J + ut;\n          return Lt > ot.length ? C(ut, J.toString() + \" bytes\") : S(Lt, u(function(we, wr) {\n            var lr = h(wr, we.buf);\n            return { coll: we.coll.concat(lr.v), buf: lr.buf };\n          }, { coll: [], buf: ot.slice(ut, Lt) }, D).coll);\n        });\n      }\n      function v(D, L) {\n        return new s(function(j, J) {\n          return f(), J + L > j.length ? C(J, L + \" bytes for \" + D) : S(J + L, j.slice(J, J + L));\n        });\n      }\n      function g(D, L) {\n        if (typeof (j = L) != \"number\" || Math.floor(j) !== j || L < 0 || L > 6)\n          throw new Error(D + \" requires integer length in range [0, 6].\");\n        var j;\n      }\n      function m(D) {\n        return g(\"uintBE\", D), v(\"uintBE(\" + D + \")\", D).map(function(L) {\n          return L.readUIntBE(0, D);\n        });\n      }\n      function y(D) {\n        return g(\"uintLE\", D), v(\"uintLE(\" + D + \")\", D).map(function(L) {\n          return L.readUIntLE(0, D);\n        });\n      }\n      function _(D) {\n        return g(\"intBE\", D), v(\"intBE(\" + D + \")\", D).map(function(L) {\n          return L.readIntBE(0, D);\n        });\n      }\n      function b(D) {\n        return g(\"intLE\", D), v(\"intLE(\" + D + \")\", D).map(function(L) {\n          return L.readIntLE(0, D);\n        });\n      }\n      function w(D) {\n        return D instanceof s;\n      }\n      function T(D) {\n        return {}.toString.call(D) === \"[object Array]\";\n      }\n      function x(D) {\n        return d() && Buffer.isBuffer(D);\n      }\n      function S(D, L) {\n        return { status: !0, index: D, value: L, furthest: -1, expected: [] };\n      }\n      function C(D, L) {\n        return T(L) || (L = [L]), { status: !1, index: -1, value: null, furthest: D, expected: L };\n      }\n      function M(D, L) {\n        if (!L || D.furthest > L.furthest)\n          return D;\n        var j = D.furthest === L.furthest ? function(J, rt) {\n          if (function() {\n            if (s._supportsSet !== void 0)\n              return s._supportsSet;\n            var zn = typeof Set < \"u\";\n            return s._supportsSet = zn, zn;\n          }() && Array.from) {\n            for (var ot = new Set(J), ut = 0; ut < rt.length; ut++)\n              ot.add(rt[ut]);\n            var Lt = Array.from(ot);\n            return Lt.sort(), Lt;\n          }\n          for (var we = {}, wr = 0; wr < J.length; wr++)\n            we[J[wr]] = !0;\n          for (var lr = 0; lr < rt.length; lr++)\n            we[rt[lr]] = !0;\n          var jn = [];\n          for (var Xr in we)\n            ({}).hasOwnProperty.call(we, Xr) && jn.push(Xr);\n          return jn.sort(), jn;\n        }(D.expected, L.expected) : L.expected;\n        return { status: D.status, index: D.index, value: D.value, furthest: L.furthest, expected: j };\n      }\n      var I = {};\n      function R(D, L) {\n        if (x(D))\n          return { offset: L, line: -1, column: -1 };\n        D in I || (I[D] = {});\n        for (var j = I[D], J = 0, rt = 0, ot = 0, ut = L; ut >= 0; ) {\n          if (ut in j) {\n            J = j[ut].line, ot === 0 && (ot = j[ut].lineStart);\n            break;\n          }\n          (D.charAt(ut) === `\n` || D.charAt(ut) === \"\\r\" && D.charAt(ut + 1) !== `\n`) && (rt++, ot === 0 && (ot = ut + 1)), ut--;\n        }\n        var Lt = J + rt, we = L - ot;\n        return j[L] = { line: Lt, lineStart: ot }, { offset: L, line: Lt + 1, column: we + 1 };\n      }\n      function N(D) {\n        if (!w(D))\n          throw new Error(\"not a parser: \" + D);\n      }\n      function A(D, L) {\n        return typeof D == \"string\" ? D.charAt(L) : D[L];\n      }\n      function U(D) {\n        if (typeof D != \"number\")\n          throw new Error(\"not a number: \" + D);\n      }\n      function B(D) {\n        if (typeof D != \"function\")\n          throw new Error(\"not a function: \" + D);\n      }\n      function G(D) {\n        if (typeof D != \"string\")\n          throw new Error(\"not a string: \" + D);\n      }\n      var $ = 2, Z = 3, H = 8, z = 5 * H, X = 4 * H, ct = \"  \";\n      function it(D, L) {\n        return new Array(L + 1).join(D);\n      }\n      function lt(D, L, j) {\n        var J = L - D.length;\n        return J <= 0 ? D : it(j, J) + D;\n      }\n      function et(D, L, j, J) {\n        return { from: D - L > 0 ? D - L : 0, to: D + j > J ? J : D + j };\n      }\n      function k(D, L) {\n        var j, J, rt, ot, ut, Lt = L.index, we = Lt.offset, wr = 1;\n        if (we === D.length)\n          return \"Got the end of the input\";\n        if (x(D)) {\n          var lr = we - we % H, jn = we - lr, Xr = et(lr, z, X + H, D.length), zn = l(function(er) {\n            return l(function(cu) {\n              return lt(cu.toString(16), 2, \"0\");\n            }, er);\n          }, function(er, cu) {\n            var fu = er.length, ya = [], du = 0;\n            if (fu <= cu)\n              return [er.slice()];\n            for (var pu = 0; pu < fu; pu++)\n              ya[du] || ya.push([]), ya[du].push(er[pu]), (pu + 1) % cu == 0 && du++;\n            return ya;\n          }(D.slice(Xr.from, Xr.to).toJSON().data, H));\n          ot = function(er) {\n            return er.from === 0 && er.to === 1 ? { from: er.from, to: er.to } : { from: er.from / H, to: Math.floor(er.to / H) };\n          }(Xr), J = lr / H, j = 3 * jn, jn >= 4 && (j += 1), wr = 2, rt = l(function(er) {\n            return er.length <= 4 ? er.join(\" \") : er.slice(0, 4).join(\" \") + \"  \" + er.slice(4).join(\" \");\n          }, zn), (ut = (8 * (ot.to > 0 ? ot.to - 1 : ot.to)).toString(16).length) < 2 && (ut = 2);\n        } else {\n          var hu = D.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);\n          j = Lt.column - 1, J = Lt.line - 1, ot = et(J, $, Z, hu.length), rt = hu.slice(ot.from, ot.to), ut = ot.to.toString().length;\n        }\n        var HP = J - ot.from;\n        return x(D) && (ut = (8 * (ot.to > 0 ? ot.to - 1 : ot.to)).toString(16).length) < 2 && (ut = 2), u(function(er, cu, fu) {\n          var ya, du = fu === HP, pu = du ? \"> \" : ct;\n          return ya = x(D) ? lt((8 * (ot.from + fu)).toString(16), ut, \"0\") : lt((ot.from + fu + 1).toString(), ut, \" \"), [].concat(er, [pu + ya + \" | \" + cu], du ? [ct + it(\" \", ut) + \" | \" + lt(\"\", j, \" \") + it(\"^\", wr)] : []);\n        }, [], rt).join(`\n`);\n      }\n      function ft(D, L) {\n        return [`\n`, \"-- PARSING FAILED \" + it(\"-\", 50), `\n\n`, k(D, L), `\n\n`, (j = L.expected, j.length === 1 ? `Expected:\n\n` + j[0] : `Expected one of the following: \n\n` + j.join(\", \")), `\n`].join(\"\");\n        var j;\n      }\n      function Q(D) {\n        return D.flags !== void 0 ? D.flags : [D.global ? \"g\" : \"\", D.ignoreCase ? \"i\" : \"\", D.multiline ? \"m\" : \"\", D.unicode ? \"u\" : \"\", D.sticky ? \"y\" : \"\"].join(\"\");\n      }\n      function St() {\n        for (var D = [].slice.call(arguments), L = D.length, j = 0; j < L; j += 1)\n          N(D[j]);\n        return s(function(J, rt) {\n          for (var ot, ut = new Array(L), Lt = 0; Lt < L; Lt += 1) {\n            if (!(ot = M(D[Lt]._(J, rt), ot)).status)\n              return ot;\n            ut[Lt] = ot.value, rt = ot.index;\n          }\n          return M(S(rt, ut), ot);\n        });\n      }\n      function at() {\n        var D = [].slice.call(arguments);\n        if (D.length === 0)\n          throw new Error(\"seqMap needs at least one argument\");\n        var L = D.pop();\n        return B(L), St.apply(null, D).map(function(j) {\n          return L.apply(null, j);\n        });\n      }\n      function q() {\n        var D = [].slice.call(arguments), L = D.length;\n        if (L === 0)\n          return V(\"zero alternates\");\n        for (var j = 0; j < L; j += 1)\n          N(D[j]);\n        return s(function(J, rt) {\n          for (var ot, ut = 0; ut < D.length; ut += 1)\n            if ((ot = M(D[ut]._(J, rt), ot)).status)\n              return ot;\n          return ot;\n        });\n      }\n      function bt(D, L) {\n        return st(D, L).or(dt([]));\n      }\n      function st(D, L) {\n        return N(D), N(L), at(D, L.then(D).many(), function(j, J) {\n          return [j].concat(J);\n        });\n      }\n      function W(D) {\n        G(D);\n        var L = \"'\" + D + \"'\";\n        return s(function(j, J) {\n          var rt = J + D.length, ot = j.slice(J, rt);\n          return ot === D ? S(rt, ot) : C(J, L);\n        });\n      }\n      function nt(D, L) {\n        (function(rt) {\n          if (!(rt instanceof RegExp))\n            throw new Error(\"not a regexp: \" + rt);\n          for (var ot = Q(rt), ut = 0; ut < ot.length; ut++) {\n            var Lt = ot.charAt(ut);\n            if (Lt !== \"i\" && Lt !== \"m\" && Lt !== \"u\" && Lt !== \"s\")\n              throw new Error('unsupported regexp flag \"' + Lt + '\": ' + rt);\n          }\n        })(D), arguments.length >= 2 ? U(L) : L = 0;\n        var j = function(rt) {\n          return RegExp(\"^(?:\" + rt.source + \")\", Q(rt));\n        }(D), J = \"\" + D;\n        return s(function(rt, ot) {\n          var ut = j.exec(rt.slice(ot));\n          if (ut) {\n            if (0 <= L && L <= ut.length) {\n              var Lt = ut[0], we = ut[L];\n              return S(ot + Lt.length, we);\n            }\n            return C(ot, \"valid match group (0 to \" + ut.length + \") in \" + J);\n          }\n          return C(ot, J);\n        });\n      }\n      function dt(D) {\n        return s(function(L, j) {\n          return S(j, D);\n        });\n      }\n      function V(D) {\n        return s(function(L, j) {\n          return C(j, D);\n        });\n      }\n      function xt(D) {\n        if (w(D))\n          return s(function(L, j) {\n            var J = D._(L, j);\n            return J.index = j, J.value = \"\", J;\n          });\n        if (typeof D == \"string\")\n          return xt(W(D));\n        if (D instanceof RegExp)\n          return xt(nt(D));\n        throw new Error(\"not a string, regexp, or parser: \" + D);\n      }\n      function Dt(D) {\n        return N(D), s(function(L, j) {\n          var J = D._(L, j), rt = L.slice(j, J.index);\n          return J.status ? C(j, 'not \"' + rt + '\"') : S(j, null);\n        });\n      }\n      function Ct(D) {\n        return B(D), s(function(L, j) {\n          var J = A(L, j);\n          return j < L.length && D(J) ? S(j + 1, J) : C(j, \"a character/byte matching \" + D);\n        });\n      }\n      function be(D, L) {\n        arguments.length < 2 && (L = D, D = void 0);\n        var j = s(function(J, rt) {\n          return j._ = L()._, j._(J, rt);\n        });\n        return D ? j.desc(D) : j;\n      }\n      function je() {\n        return V(\"fantasy-land/empty\");\n      }\n      a.parse = function(D) {\n        if (typeof D != \"string\" && !x(D))\n          throw new Error(\".parse must be called with a string or Buffer as its argument\");\n        var L, j = this.skip(se)._(D, 0);\n        return L = j.status ? { status: !0, value: j.value } : { status: !1, index: R(D, j.furthest), expected: j.expected }, delete I[D], L;\n      }, a.tryParse = function(D) {\n        var L = this.parse(D);\n        if (L.status)\n          return L.value;\n        var j = ft(D, L), J = new Error(j);\n        throw J.type = \"ParsimmonError\", J.result = L, J;\n      }, a.assert = function(D, L) {\n        return this.chain(function(j) {\n          return D(j) ? dt(j) : V(L);\n        });\n      }, a.or = function(D) {\n        return q(this, D);\n      }, a.trim = function(D) {\n        return this.wrap(D, D);\n      }, a.wrap = function(D, L) {\n        return at(D, this, L, function(j, J) {\n          return J;\n        });\n      }, a.thru = function(D) {\n        return D(this);\n      }, a.then = function(D) {\n        return N(D), St(this, D).map(function(L) {\n          return L[1];\n        });\n      }, a.many = function() {\n        var D = this;\n        return s(function(L, j) {\n          for (var J = [], rt = void 0; ; ) {\n            if (!(rt = M(D._(L, j), rt)).status)\n              return M(S(j, J), rt);\n            if (j === rt.index)\n              throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");\n            j = rt.index, J.push(rt.value);\n          }\n        });\n      }, a.tieWith = function(D) {\n        return G(D), this.map(function(L) {\n          if (function(rt) {\n            if (!T(rt))\n              throw new Error(\"not an array: \" + rt);\n          }(L), L.length) {\n            G(L[0]);\n            for (var j = L[0], J = 1; J < L.length; J++)\n              G(L[J]), j += D + L[J];\n            return j;\n          }\n          return \"\";\n        });\n      }, a.tie = function() {\n        return this.tieWith(\"\");\n      }, a.times = function(D, L) {\n        var j = this;\n        return arguments.length < 2 && (L = D), U(D), U(L), s(function(J, rt) {\n          for (var ot = [], ut = void 0, Lt = void 0, we = 0; we < D; we += 1) {\n            if (Lt = M(ut = j._(J, rt), Lt), !ut.status)\n              return Lt;\n            rt = ut.index, ot.push(ut.value);\n          }\n          for (; we < L && (Lt = M(ut = j._(J, rt), Lt), ut.status); we += 1)\n            rt = ut.index, ot.push(ut.value);\n          return M(S(rt, ot), Lt);\n        });\n      }, a.result = function(D) {\n        return this.map(function() {\n          return D;\n        });\n      }, a.atMost = function(D) {\n        return this.times(0, D);\n      }, a.atLeast = function(D) {\n        return at(this.times(D), this.many(), function(L, j) {\n          return L.concat(j);\n        });\n      }, a.map = function(D) {\n        B(D);\n        var L = this;\n        return s(function(j, J) {\n          var rt = L._(j, J);\n          return rt.status ? M(S(rt.index, D(rt.value)), rt) : rt;\n        });\n      }, a.contramap = function(D) {\n        B(D);\n        var L = this;\n        return s(function(j, J) {\n          var rt = L.parse(D(j.slice(J)));\n          return rt.status ? S(J + j.length, rt.value) : rt;\n        });\n      }, a.promap = function(D, L) {\n        return B(D), B(L), this.contramap(D).map(L);\n      }, a.skip = function(D) {\n        return St(this, D).map(function(L) {\n          return L[0];\n        });\n      }, a.mark = function() {\n        return at(ee, this, ee, function(D, L, j) {\n          return { start: D, value: L, end: j };\n        });\n      }, a.node = function(D) {\n        return at(ee, this, ee, function(L, j, J) {\n          return { name: D, value: j, start: L, end: J };\n        });\n      }, a.sepBy = function(D) {\n        return bt(this, D);\n      }, a.sepBy1 = function(D) {\n        return st(this, D);\n      }, a.lookahead = function(D) {\n        return this.skip(xt(D));\n      }, a.notFollowedBy = function(D) {\n        return this.skip(Dt(D));\n      }, a.desc = function(D) {\n        T(D) || (D = [D]);\n        var L = this;\n        return s(function(j, J) {\n          var rt = L._(j, J);\n          return rt.status || (rt.expected = D), rt;\n        });\n      }, a.fallback = function(D) {\n        return this.or(dt(D));\n      }, a.ap = function(D) {\n        return at(D, this, function(L, j) {\n          return L(j);\n        });\n      }, a.chain = function(D) {\n        var L = this;\n        return s(function(j, J) {\n          var rt = L._(j, J);\n          return rt.status ? M(D(rt.value)._(j, rt.index), rt) : rt;\n        });\n      }, a.concat = a.or, a.empty = je, a.of = dt, a[\"fantasy-land/ap\"] = a.ap, a[\"fantasy-land/chain\"] = a.chain, a[\"fantasy-land/concat\"] = a.concat, a[\"fantasy-land/empty\"] = a.empty, a[\"fantasy-land/of\"] = a.of, a[\"fantasy-land/map\"] = a.map;\n      var ee = s(function(D, L) {\n        return S(L, R(D, L));\n      }), de = s(function(D, L) {\n        return L >= D.length ? C(L, \"any character/byte\") : S(L + 1, A(D, L));\n      }), ue = s(function(D, L) {\n        return S(D.length, D.slice(L));\n      }), se = s(function(D, L) {\n        return L < D.length ? C(L, \"EOF\") : S(L, null);\n      }), ne = nt(/[0-9]/).desc(\"a digit\"), Ht = nt(/[0-9]*/).desc(\"optional digits\"), xr = nt(/[a-z]/i).desc(\"a letter\"), uu = nt(/[a-z]*/i).desc(\"optional letters\"), gh = nt(/\\s*/).desc(\"optional whitespace\"), w0 = nt(/\\s+/).desc(\"whitespace\"), mh = W(\"\\r\"), lu = W(`\n`), Ad = W(`\\r\n`), Ld = q(Ad, lu, mh).desc(\"newline\"), E0 = q(Ld, se);\n      s.all = ue, s.alt = q, s.any = de, s.cr = mh, s.createLanguage = function(D) {\n        var L = {};\n        for (var j in D)\n          ({}).hasOwnProperty.call(D, j) && function(J) {\n            L[J] = be(function() {\n              return D[J](L);\n            });\n          }(j);\n        return L;\n      }, s.crlf = Ad, s.custom = function(D) {\n        return s(D(S, C));\n      }, s.digit = ne, s.digits = Ht, s.empty = je, s.end = E0, s.eof = se, s.fail = V, s.formatError = ft, s.index = ee, s.isParser = w, s.lazy = be, s.letter = xr, s.letters = uu, s.lf = lu, s.lookahead = xt, s.makeFailure = C, s.makeSuccess = S, s.newline = Ld, s.noneOf = function(D) {\n        return Ct(function(L) {\n          return D.indexOf(L) < 0;\n        }).desc(\"none of '\" + D + \"'\");\n      }, s.notFollowedBy = Dt, s.of = dt, s.oneOf = function(D) {\n        for (var L = D.split(\"\"), j = 0; j < L.length; j++)\n          L[j] = \"'\" + L[j] + \"'\";\n        return Ct(function(J) {\n          return D.indexOf(J) >= 0;\n        }).desc(L);\n      }, s.optWhitespace = gh, s.Parser = s, s.range = function(D, L) {\n        return Ct(function(j) {\n          return D <= j && j <= L;\n        }).desc(D + \"-\" + L);\n      }, s.regex = nt, s.regexp = nt, s.sepBy = bt, s.sepBy1 = st, s.seq = St, s.seqMap = at, s.seqObj = function() {\n        for (var D, L = {}, j = 0, J = (D = arguments, Array.prototype.slice.call(D)), rt = J.length, ot = 0; ot < rt; ot += 1) {\n          var ut = J[ot];\n          if (!w(ut)) {\n            if (T(ut) && ut.length === 2 && typeof ut[0] == \"string\" && w(ut[1])) {\n              var Lt = ut[0];\n              if (Object.prototype.hasOwnProperty.call(L, Lt))\n                throw new Error(\"seqObj: duplicate key \" + Lt);\n              L[Lt] = !0, j++;\n              continue;\n            }\n            throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\");\n          }\n        }\n        if (j === 0)\n          throw new Error(\"seqObj expects at least one named parser, found zero\");\n        return s(function(we, wr) {\n          for (var lr, jn = {}, Xr = 0; Xr < rt; Xr += 1) {\n            var zn, hu;\n            if (T(J[Xr]) ? (zn = J[Xr][0], hu = J[Xr][1]) : (zn = null, hu = J[Xr]), !(lr = M(hu._(we, wr), lr)).status)\n              return lr;\n            zn && (jn[zn] = lr.value), wr = lr.index;\n          }\n          return M(S(wr, jn), lr);\n        });\n      }, s.string = W, s.succeed = dt, s.takeWhile = function(D) {\n        return B(D), s(function(L, j) {\n          for (var J = j; J < L.length && D(A(L, J)); )\n            J++;\n          return S(J, L.slice(j, J));\n        });\n      }, s.test = Ct, s.whitespace = w0, s[\"fantasy-land/empty\"] = je, s[\"fantasy-land/of\"] = dt, s.Binary = { bitSeq: p, bitSeqObj: function(D) {\n        f();\n        var L = {}, j = 0, J = l(function(ot) {\n          if (T(ot)) {\n            var ut = ot;\n            if (ut.length !== 2)\n              throw new Error(\"[\" + ut.join(\", \") + \"] should be length 2, got length \" + ut.length);\n            if (G(ut[0]), U(ut[1]), Object.prototype.hasOwnProperty.call(L, ut[0]))\n              throw new Error(\"duplicate key in bitSeqObj: \" + ut[0]);\n            return L[ut[0]] = !0, j++, ut;\n          }\n          return U(ot), [null, ot];\n        }, D);\n        if (j < 1)\n          throw new Error(\"bitSeqObj expects at least one named pair, got [\" + D.join(\", \") + \"]\");\n        var rt = l(function(ot) {\n          return ot[0];\n        }, J);\n        return p(l(function(ot) {\n          return ot[1];\n        }, J)).map(function(ot) {\n          return u(function(ut, Lt) {\n            return Lt[0] !== null && (ut[Lt[0]] = Lt[1]), ut;\n          }, {}, l(function(ut, Lt) {\n            return [ut, ot[Lt]];\n          }, rt));\n        });\n      }, byte: function(D) {\n        if (f(), U(D), D > 255)\n          throw new Error(\"Value specified to byte constructor (\" + D + \"=0x\" + D.toString(16) + \") is larger in value than a single byte.\");\n        var L = (D > 15 ? \"0x\" : \"0x0\") + D.toString(16);\n        return s(function(j, J) {\n          var rt = A(j, J);\n          return rt === D ? S(J + 1, rt) : C(J, L);\n        });\n      }, buffer: function(D) {\n        return v(\"buffer\", D).map(function(L) {\n          return Buffer.from(L);\n        });\n      }, encodedString: function(D, L) {\n        return v(\"string\", L).map(function(j) {\n          return j.toString(D);\n        });\n      }, uintBE: m, uint8BE: m(1), uint16BE: m(2), uint32BE: m(4), uintLE: y, uint8LE: y(1), uint16LE: y(2), uint32LE: y(4), intBE: _, int8BE: _(1), int16BE: _(2), int32BE: _(4), intLE: b, int8LE: b(1), int16LE: b(2), int32LE: b(4), floatBE: v(\"floatBE\", 4).map(function(D) {\n        return D.readFloatBE(0);\n      }), floatLE: v(\"floatLE\", 4).map(function(D) {\n        return D.readFloatLE(0);\n      }), doubleBE: v(\"doubleBE\", 8).map(function(D) {\n        return D.readDoubleBE(0);\n      }), doubleLE: v(\"doubleLE\", 8).map(function(D) {\n        return D.readDoubleLE(0);\n      }) }, e.exports = s;\n    }]);\n  });\n})(hA);\nvar $a, Rt, kt, Fs, Gs, _u, Nv, Ic, Xy, Av, Lv, PS;\nconst Zx = class {\n  constructor(t, e = \"\\\\\") {\n    E(this, Rt);\n    E(this, Gs);\n    E(this, Ic);\n    E(this, $a, null);\n    E(this, Fs, {\n      \"!num!\": (t) => t.shift(),\n      \"!str!\": (t) => O(this, Ic, Xy).call(this, t.shift()),\n      \"!bool!\": (t) => t.shift(),\n      // 論理 NOT\n      \"!\": (t) => {\n        const e = t.shift();\n        return e[0] === \"!bool!\" ? !e[1] : String(O(this, Rt, kt).call(this, e)) !== \"true\";\n      },\n      // チルダ演算子（ビット反転）\n      \"~\": (t) => ~Number(O(this, Rt, kt).call(this, t.shift())),\n      // 乗算、除算、剰余\n      \"**\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) ** Number(O(this, Rt, kt).call(this, t.shift())),\n      \"*\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) * Number(O(this, Rt, kt).call(this, t.shift())),\n      \"/\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) / Number(O(this, Rt, kt).call(this, t.shift())),\n      \"¥\": (t) => Math.floor(c(this, Fs)[\"/\"](t)),\n      \"%\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) % Number(O(this, Rt, kt).call(this, t.shift())),\n      // 加算、減算、文字列の連結\n      \"+\": (t) => {\n        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) === \"[object String]\" || Object.prototype.toString.call(r) === \"[object String]\" ? String(e) + String(r) : Number(e) + Number(r);\n      },\n      \"-\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) - Number(O(this, Rt, kt).call(this, t.shift())),\n      // 関数\n      int: (t) => $t(O(this, Gs, _u).call(this, t.shift())),\n      parseInt: (t) => $t(c(this, Fs).Number(t)),\n      Number: (t) => {\n        const e = O(this, Rt, kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) !== \"[object String]\" ? Number(e) : O(this, Gs, _u).call(this, c(this, $a).parse(String(e)).value);\n      },\n      ceil: (t) => Math.ceil(O(this, Gs, _u).call(this, t.shift())),\n      floor: (t) => Math.floor(O(this, Gs, _u).call(this, t.shift())),\n      round: (t) => Math.round(O(this, Gs, _u).call(this, t.shift())),\n      isNaN: (t) => isNaN(Number(O(this, Rt, kt).call(this, t.shift()))),\n      // ビットシフト\n      \"<<\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) << Number(O(this, Rt, kt).call(this, t.shift())),\n      \">>\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >> Number(O(this, Rt, kt).call(this, t.shift())),\n      \">>>\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >>> Number(O(this, Rt, kt).call(this, t.shift())),\n      // 等値、非等値、厳密等価、厳密非等価\n      \"<\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) < Number(O(this, Rt, kt).call(this, t.shift())),\n      \"<=\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) <= Number(O(this, Rt, kt).call(this, t.shift())),\n      \">\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) > Number(O(this, Rt, kt).call(this, t.shift())),\n      \">=\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) >= Number(O(this, Rt, kt).call(this, t.shift())),\n      // 小なり、以下、大なり、以上\n      \"==\": (t) => {\n        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());\n        return e == null && r == null && (!e || !r) ? e == r : String(e) === String(r);\n      },\n      \"!=\": (t) => !c(this, Fs)[\"==\"](t),\n      \"===\": (t) => {\n        const e = O(this, Rt, kt).call(this, t.shift()), r = O(this, Rt, kt).call(this, t.shift());\n        return Object.prototype.toString.call(e) != Object.prototype.toString.call(r) ? !1 : String(e) === String(r);\n      },\n      \"!==\": (t) => !c(this, Fs)[\"===\"](t),\n      // ビット演算子\n      \"&\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) & Number(O(this, Rt, kt).call(this, t.shift())),\n      \"^\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) ^ Number(O(this, Rt, kt).call(this, t.shift())),\n      \"|\": (t) => Number(O(this, Rt, kt).call(this, t.shift())) | Number(O(this, Rt, kt).call(this, t.shift())),\n      // 論理 AND,OR\n      \"&&\": (t) => String(O(this, Rt, kt).call(this, t.shift())) === \"true\" && String(O(this, Rt, kt).call(this, t.shift())) === \"true\",\n      \"||\": (t) => String(O(this, Rt, kt).call(this, t.shift())) === \"true\" || String(O(this, Rt, kt).call(this, t.shift())) === \"true\",\n      // 条件\n      \"?\": (t) => {\n        const e = t.shift();\n        let r = !1;\n        if (e[0] === \"!bool!\")\n          r = !!e[1];\n        else {\n          const s = String(O(this, Rt, kt).call(this, e));\n          r = s !== \"true\" && s !== \"false\" ? $t(s) !== 0 : s === \"true\";\n        }\n        const n = t.shift();\n        if (n[0] !== \":\")\n          throw Error(\"(PropParser)三項演算子の文法エラーです。: が見つかりません\");\n        return O(this, Rt, kt).call(this, n[r ? 1 : 2]);\n      },\n      \":\": () => {\n        throw Error(\"(PropParser)三項演算子の文法エラーです。? が見つかりません\");\n      }\n    });\n    E(this, Nv, /(\\$((tmp|sys|save|mp):)?[^\\s!--\\/:-@[-^`{-~]+|\\#\\{[^\\}]+})/g);\n    K(this, \"getValAmpersand\", (t) => t.at(0) === \"&\" ? String(this.parse(t.slice(1))) : t);\n    this.val = t;\n    function r(m) {\n      const y = [];\n      for (const _ of m)\n        y.push(\n          (_ instanceof RegExp ? pe.regex(_) : pe.string(_)).trim(pe.optWhitespace)\n        );\n      return pe.alt.apply(null, y);\n    }\n    function n(m, y) {\n      const _ = pe.lazy(() => pe.seq(m, _).or(y));\n      return _;\n    }\n    function s(m, y) {\n      let _ = pe.lazy(\n        () => y.chain(\n          (b) => pe.seq(\n            m,\n            pe.of(b),\n            _\n          ).or(pe.of(b))\n        )\n      );\n      return _;\n    }\n    function a(m, y) {\n      return pe.seqMap(\n        y,\n        pe.seq(m, y).many(),\n        (_, b) => b.reduce((w, T) => [T[0], w, T[1]], _)\n      );\n    }\n    const o = pe.alt(\n      pe.alt(\n        pe.regex(/-?(0|[1-9][0-9]*)\\.[0-9]+/),\n        pe.regex(/0x[0-9a-fA-F]+/)\n      ).map(Number),\n      pe.alt(\n        pe.regex(/-?(0|[1-9][0-9]*)/)\n      ).map((m) => $t(m))\n    ).map((m) => [\"!num!\", m]).desc(\"number\"), u = pe.string(\"null\").map(() => [\"!str!\", null]), l = pe.regex(/(true|false)/).map((m) => [\"!bool!\", m === \"true\"]).desc(\"boolean\"), h = pe.regex(new RegExp(`(?:\"(?:\\\\${e}[\"'#\\\\n]|[^\"])*\"|'(?:\\\\${e}[\"'#\\\\n]|[^'])*'|\\\\#(?:\\\\${e}[\"'#\\\\n]|[^#])*\\\\#)`)).map((m) => [\"!str!\", m.slice(1, -1).replaceAll(e, \"\")]).desc(\"string\"), d = /\\[[^\\]]+\\]/g, f = pe.regex(/-?(?:(?:tmp|sys|save|mp):)?[^\\s!-\\/:-@[-^`{-~]+(?:\\.[^\\s!-\\/:-@[-^`{-~]+|\\[[^\\]]+\\])*(?:@str)?/).map((m) => {\n      const y = String(m).replaceAll(\n        d,\n        (b) => \".\" + this.parse(b.slice(1, -1))\n      );\n      if (y.at(0) === \"-\") {\n        const b = this.val.getVal(y.slice(1));\n        if (b == null || String(b) === \"null\")\n          throw Error(\"(PropParser)数値以外に-符号がついています\");\n        return [\"!num!\", -Number(b)];\n      }\n      const _ = this.val.getVal(y);\n      return _ == null ? [\"!str!\", _] : typeof _ == \"boolean\" ? [\"!bool!\", _] : Object.prototype.toString.call(_) === \"[object String]\" ? [\"!str!\", String(_)] : [\"!num!\", Number(_)];\n    }).desc(\"string\"), p = pe.lazy(\n      () => pe.string(\"(\").then(c(this, $a)).skip(pe.string(\")\")).or(o).or(u).or(l).or(h).or(f)\n    ), g = [\n      // 優先順位：19（メンバーへのアクセス、計算値によるメンバーへのアクセス）\n      // a.b  a[b]\n      { type: n, ops: r([/[A-Za-z_][A-Za-z0-9_]*(?=\\()/]) },\n      // ++ --\t\t// 優先順位：17（後置インクリメント・デクリメント）\n      { type: n, ops: r([/(!(?!=)|~)/]) },\n      // 優先順位：16\n      //\t{type: PREFIX, ops: ope([/(!(?!=)|++|--)/])},\n      // 「n!」階乗演算子は優先順位がよく判らないし、使わない・ミスも考え無いほうが\n      //\t\t// 優先順位：16（前置インクリメント・デクリメント）\n      { type: s, ops: r([\"**\"]) },\n      { type: a, ops: r([\"*\", \"/\", \"¥\", \"%\"]) },\n      { type: a, ops: r([\"+\", \"-\"]) },\n      { type: a, ops: r([/(>>>|<<|>>)/]) },\n      { type: a, ops: r([/(<=|<|>=|>)/]) },\n      { type: a, ops: r([/(===|!==|==|!=)/]) },\n      { type: a, ops: r([/&(?!&)/]) },\n      { type: a, ops: r([\"^\"]) },\n      { type: a, ops: r([/\\|(?!\\|)/]) },\n      { type: a, ops: r([\"&&\"]) },\n      { type: a, ops: r([\"||\"]) },\n      { type: s, ops: r([\":\"]) },\n      { type: s, ops: r([\"?\"]) }\n    ].reduce(\n      (m, y) => y.type(y.ops, m),\n      p\n    );\n    P(this, $a, g.trim(pe.optWhitespace));\n  }\n  parse(t) {\n    const e = c(this, $a).parse(t);\n    if (!e.status)\n      throw Error(\"(PropParser)文法エラー【\" + t + \"】\");\n    const r = e.value;\n    return r[0] === \"!str!\" ? O(this, Ic, Xy).call(this, r[1]) : O(this, Rt, kt).call(this, r);\n  }\n  // 522 match 18413 step(~10ms) https://regex101.com/r/tmCKuE/1\n  // →これは改良しようがない。いい意味で改善の余地なし\n  static getValName(t) {\n    var o;\n    const e = c(this, Av).exec(t.trim()), r = e == null ? void 0 : e.groups;\n    if (!r)\n      return null;\n    const { scope: n = \"tmp\", name: s, at: a = \"\" } = r;\n    return {\n      scope: n,\n      name: O(o = Zx, Lv, PS).call(o, s),\n      at: a\n    };\n  }\n};\nlet Fa = Zx;\n$a = new WeakMap(), Rt = new WeakSet(), kt = function(t) {\n  const e = t.shift();\n  if (e instanceof Array)\n    return O(this, Rt, kt).call(this, e);\n  const r = c(this, Fs)[e];\n  return r ? r(t) : Object(null);\n}, Fs = new WeakMap(), Gs = new WeakSet(), _u = function(t) {\n  const e = O(this, Rt, kt).call(this, t);\n  if (Object.prototype.toString.call(e) !== \"[object Number]\")\n    throw Error(\"(PropParser)引数【\" + e + \"】が数値ではありません\");\n  return Number(e);\n}, Nv = new WeakMap(), Ic = new WeakSet(), Xy = function(t) {\n  return t == null ? t : String(t).replaceAll(c(this, Nv), (e) => e.at(0) === \"$\" ? this.val.getVal(e.slice(1)) : this.parse(e.slice(2, -1)));\n}, Av = new WeakMap(), Lv = new WeakSet(), PS = function(t) {\n  let e = 0, r = 0;\n  for (; ; ) {\n    if (e = t.indexOf('[\"'), e < 0) {\n      if (e = t.indexOf(\"['\"), e < 0)\n        break;\n      r = t.indexOf(\"']\", e + 2);\n    } else\n      r = t.indexOf('\"]', e + 2);\n    if (r < 0)\n      break;\n    t = t.slice(0, e) + \".\" + t.slice(e + 2, r) + t.slice(r + 2), e = r - 2;\n  }\n  return t;\n}, E(Fa, Lv), E(Fa, Av, /^((?<scope>\\w+?):)?(?<name>[^\\s :@]+)(?<at>\\@str)?$/);\nvar Di, Va, Hu, ki, Rc, Bv, OS, Fv, IS, Gv, RS, Uv, DS;\nconst oe = class {\n  constructor(t, e, r) {\n    E(this, Bv);\n    E(this, Fv);\n    // ログ出力\n    E(this, Rc, !0);\n    this.sys = t, P(oe, Di, r), P(oe, Va, e), P(oe, Hu, e.title), oe.myTrace = O(oe, Gv, RS), e.log = (n) => O(this, Bv, OS).call(this, n), e.trace = (n) => O(this, Fv, IS).call(this, n), P(oe, ki, document.createElement(\"span\")), c(oe, ki).hidden = !0, c(oe, ki).textContent = \"\", c(oe, ki).style.cssText = `\tz-index: ${Number.MAX_SAFE_INTEGER};\n\t\t\tposition: absolute; left: 0; top: 0;\n\t\t\tcolor: black;\n\t\t\tbackground-color: rgba(255, 255, 255, 0.7);`, document.body.appendChild(c(oe, ki));\n  }\n  destroy() {\n    P(oe, Hu, () => !1), document.body.removeChild(c(oe, ki)), oe.myTrace = oe.trace_beforeNew;\n  }\n  // private禁止、galleryでエラーになる\n  static trace_beforeNew(t, e = \"E\") {\n    let r = `{${e}} ` + t, n = \"\";\n    switch (e) {\n      case \"D\":\n        n = `color:#${Y.isDarkMode ? \"49F\" : \"05A\"};`;\n        break;\n      case \"W\":\n        n = \"color:#FF8800;\";\n        break;\n      case \"F\":\n        n = \"color:#BB0000;\";\n        break;\n      case \"ET\":\n        throw r;\n      case \"E\":\n        console.error(\"%c\" + r, \"color:#FF3300;\");\n        return;\n      default:\n        n = \"color:black;\", r = \" \" + r;\n    }\n    console.info(\"%c\" + r, n);\n  }\n};\nlet zt = oe;\nDi = new WeakMap(), Va = new WeakMap(), Hu = new WeakMap(), ki = new WeakMap(), Rc = new WeakMap(), Bv = new WeakSet(), OS = function(t) {\n  let e = \"\";\n  return c(this, Rc) && (P(this, Rc, !1), e = `== ${bs.description} ==\n`), this.sys.appendFile(\n    this.sys.path_downloads + \"log.txt\",\n    `${e}--- ${rc(\"-\", \"_\", \"\")} [fn:${c(oe, Di).scriptFn} line:${c(oe, Di).lineNum}] prj:${this.sys.cur}\n${t.text || `(text is ${t.text})`}\n`,\n    (r) => {\n      r && console.log(r);\n    }\n  ), !1;\n}, Fv = new WeakSet(), IS = function(t) {\n  return oe.myTrace(t.text || `(text is ${t.text})`, \"I\"), !1;\n}, Gv = new WeakSet(), RS = function(t, e = \"E\") {\n  var s, a;\n  let r = `{${e}} ` + oe.strPos() + t;\n  O(s = oe, Uv, DS).call(s, r, e);\n  let n = \"\";\n  switch (e) {\n    case \"D\":\n      n = `color:#${Y.isDarkMode ? \"49F\" : \"05A\"};`;\n      break;\n    case \"W\":\n      n = \"color:#F80;\";\n      break;\n    case \"F\":\n      n = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      if (c(a = oe, Hu).call(a, { text: t }), c(this, Va).dump_lay({}), c(this, Va).dump_val({}), c(oe, Di).dumpErrForeLine(), c(this, Va).dump_stack({}), e === \"ET\")\n        throw r;\n      console.error(\"%c\" + r, \"color:#F30;\");\n      return;\n    default:\n      n = \"\", r = \" \" + r;\n  }\n  console.info(\"%c\" + r, n);\n}, Uv = new WeakSet(), DS = function(t, e) {\n  let r = \"\";\n  switch (e) {\n    case \"D\":\n      r = \"color:#05A;\";\n      break;\n    case \"W\":\n      r = \"color:#F80;\";\n      break;\n    case \"F\":\n      r = \"color:#B00;\";\n      break;\n    case \"ET\":\n    case \"E\":\n      r = \"color:#F30;\";\n      break;\n    default:\n      r = \"\";\n  }\n  c(oe, ki).innerHTML += `<span style='${r}'>${t}</span><br/>`, c(oe, ki).hidden = !1;\n}, E(zt, Gv), E(zt, Uv), E(zt, Di, void 0), E(zt, Va, void 0), E(zt, Hu, void 0), E(zt, ki, void 0), K(zt, \"myTrace\", oe.trace_beforeNew), K(zt, \"strPos\", () => c(oe, Di) && c(oe, Di).lineNum > 0 ? `(fn:${c(oe, Di).scriptFn} line:${c(oe, Di).lineNum}) ` : \"\");\nclass nw {\n  constructor() {\n    K(this, \"hAreas\", /* @__PURE__ */ Object.create(null));\n  }\n  clear() {\n    this.hAreas = {};\n  }\n  search(t) {\n    return Object.entries(this.hAreas).some(([e, r]) => t >= parseInt(e) && t <= r);\n  }\n  record(t) {\n    if (!this.search(t)) {\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (r + 1 === t) {\n          String(t + 1) in this.hAreas ? (this.hAreas[e] = this.hAreas[t + 1], delete this.hAreas[t + 1]) : this.hAreas[e] = t;\n          return;\n        }\n      if (String(t + 1) in this.hAreas) {\n        this.hAreas[t] = this.hAreas[t + 1], delete this.hAreas[t + 1];\n        return;\n      }\n      this.hAreas[t] = t;\n    }\n  }\n  erase(t) {\n    if (this.search(t)) {\n      if (String(t) in this.hAreas) {\n        this.hAreas[t] > t && (this.hAreas[t + 1] = this.hAreas[t]), delete this.hAreas[t];\n        return;\n      }\n      for (const [e, r] of Object.entries(this.hAreas))\n        if (!(t < parseInt(e) || r < t)) {\n          if (this.hAreas[e] === t) {\n            this.hAreas[e] = t - 1;\n            return;\n          }\n          this.hAreas[t + 1] = r, this.hAreas[e] = t - 1;\n          return;\n        }\n    }\n  }\n  get count() {\n    return Object.keys(this.hAreas).length;\n  }\n  // 4tst\n  toString() {\n    let t = \",\";\n    for (const e of Object.keys(this.hAreas).map((r) => parseInt(r)).sort((r, n) => r - n))\n      t += e === this.hAreas[e] ? \",\" + e : \",\" + e + \"~\" + this.hAreas[e];\n    return t.slice(1);\n  }\n}\nvar rr, fi, Me, Yn, We, qr, un, Dc, jv, kc, Wy, Nc, Ac, zv, kS, Hv, NS, di, on, $v, AS, Vv, LS, Xv, BS, Wv, FS, Yv, GS, qv, US, Zv, jS, Kv, zS, $u, Lp, Lc, Yy, Bc, Xa, Fc, qy, Jv, Qv, Vu, Gc, Xu, Bp, tg, HS, eg, $S, Uc, Zy, jc, Ky, rg, VS, ig, XS, Wu, Fp;\nconst Nu = class {\n  constructor(t, e) {\n    E(this, kc);\n    //\t// しおり\n    // しおりの複写\n    E(this, zv);\n    // しおりの消去\n    E(this, Hv);\n    //\t//\t変数操作\n    // 変数代入・演算\n    E(this, di);\n    // 絶対値\n    E(this, $v);\n    // 文字列から一字取りだし\n    E(this, Vv);\n    // 文字列で検索\n    E(this, Xv);\n    // 文字列の長さ\n    E(this, Wv);\n    // 正規表現で置換\n    E(this, Yv);\n    // 四捨五入\n    E(this, qv);\n    // 正規表現で検索\n    E(this, Zv);\n    // 文字列から抜きだし\n    E(this, Kv);\n    //\t// デバッグ・その他\n    // システム変数の全消去\n    E(this, $u);\n    // ゲーム変数の全消去\n    E(this, Lc);\n    E(this, Fc);\n    E(this, Xu);\n    E(this, tg);\n    E(this, eg);\n    E(this, Uc);\n    E(this, jc);\n    E(this, rg);\n    E(this, ig);\n    E(this, Wu);\n    E(this, rr, { sys: {}, save: {}, tmp: {}, mp: {} });\n    E(this, fi, c(this, rr).save);\n    E(this, Me, c(this, rr).tmp);\n    E(this, Yn, void 0);\n    E(this, We, { sys: {}, mark: {}, kidoku: {} });\n    E(this, qr, void 0);\n    E(this, un, {});\n    E(this, Dc, void 0);\n    E(this, jv, {\n      auth: (t, e) => O(this, kc, Wy).call(this, e.hBreakpoint.aData),\n      var: (t, e) => c(this, Yn).send2Dbg(e.ri, { v: c(this, rr)[e.scope] ?? {} }),\n      set_var: (t, e) => {\n        try {\n          c(this, Bc).call(this, e.nm, e.val), c(this, Yn).send2Dbg(e.ri, {});\n        } catch {\n        }\n      },\n      set_data_break: (t, e) => {\n        O(this, kc, Wy).call(this, e.a), c(this, Yn).send2Dbg(e.ri, {});\n      },\n      disconnect: (t) => P(Nu, Xa, {})\n    });\n    E(this, Nc, () => {\n    });\n    E(this, Ac, (t) => {\n    });\n    K(this, \"getMark\", (t) => c(this, We).mark[t]);\n    K(this, \"getAreaKidoku\", (t) => c(this, un)[t]);\n    E(this, Bc, (t, e, r = !0) => {\n      if (!t)\n        throw \"[変数に値セット] nameは必須です\";\n      if (e == null)\n        throw \"[変数に値セット] textは必須です（空文字はOK）\";\n      const n = Fa.getValName(t);\n      if (n === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const s = c(this, rr)[n.scope];\n      if (!s)\n        throw \"[変数に値セット] scopeが異常【\" + n.scope + \"】です\";\n      const a = n.name;\n      if (a.slice(0, 6) === \"const.\" && a in s)\n        throw \"[変数に値セット] 変数【\" + a + \"】は書き換え不可です\";\n      this.setVal_Nochk(n.scope, a, e, r);\n    });\n    K(this, \"getVal\", (t, e) => {\n      if (!t)\n        throw \"[変数参照] nameは必須です\";\n      const r = Fa.getValName(t);\n      if (r === null)\n        throw \"[変数参照] name(\" + t + \")が変数名として異常です\";\n      const n = c(this, rr)[r.scope];\n      if (!n)\n        throw \"[変数参照] scopeが異常【\" + r.scope + \"】です\";\n      const s = r.name;\n      let a = n[s];\n      if (!(s in n)) {\n        a = e;\n        let o = \"\";\n        const u = s.split(\".\"), l = u.length;\n        for (let h = 0; h < l; ++h, o += \".\") {\n          if (o += u[h], !(o in n))\n            continue;\n          let d = JSON.parse(n[o]);\n          if (Object.prototype.toString.call(d) !== \"[object Object]\") {\n            if (h + 1 === l) {\n              a = d;\n              break;\n            }\n            continue;\n          }\n          let f = h;\n          for (; ++f < l; ) {\n            if (!(u[f] in d)) {\n              a = e;\n              break;\n            }\n            if (d = d[u[f]], Object.prototype.toString.call(d) !== \"[object Object]\" || f + 1 === l) {\n              a = d;\n              break;\n            }\n          }\n          a instanceof Object && (a = JSON.stringify(a));\n          break;\n        }\n      }\n      return a instanceof Function && (a = a()), r.at === \"@str\" ? a : O(this, Fc, qy).call(this, a);\n    });\n    E(this, Jv, /^-?[\\d\\.]+$/);\n    // 変数のダンプ\n    E(this, Qv, () => {\n      const t = { tmp: {}, sys: {}, save: {}, mp: {} };\n      for (let e in t) {\n        const r = c(this, rr)[e], n = t[e];\n        for (let [s, a] of Object.entries(r))\n          n[s] = Object.prototype.toString.call(a) === \"[object Function]\" ? a() : a;\n      }\n      return console.info(\"🥟 [dump_val]\", t), !1;\n    });\n    E(this, Vu, !1);\n    E(this, Gc, {\n      // sys\n      \"sys:sn.tagCh.doWait\": (t) => O(this, Xu, Bp).call(this, t),\n      \"sys:sn.tagCh.doWait_Kidoku\": (t) => O(this, Xu, Bp).call(this, t),\n      \"sys:sn.tagCh.msecWait\": (t) => O(this, tg, HS).call(this, t),\n      \"sys:sn.tagCh.msecWait_Kidoku\": (t) => O(this, eg, $S).call(this, t),\n      \"sys:sn.tagCh.canskip\": (t) => O(this, Xu, Bp).call(this, t),\n      \"sys:sn.auto.msecPageWait\": (t) => O(this, Uc, Zy).call(this, t),\n      \"sys:sn.auto.msecPageWait_Kidoku\": (t) => O(this, Uc, Zy).call(this, t),\n      \"sys:sn.auto.msecLineWait\": (t) => O(this, jc, Ky).call(this, t),\n      \"sys:sn.auto.msecLineWait_Kidoku\": (t) => O(this, jc, Ky).call(this, t),\n      // save\n      \"save:sn.doRecLog\": (t) => {\n        c(this, Ac).call(this, P(this, Vu, O(this, rg, VS).call(this, t)));\n      },\n      \"save:sn.userFnTail\": (t, e) => {\n        if (e.includes(\"@\"))\n          throw \"この変数では文字「@」は禁止です\";\n        this.cfg.userFnTail = e;\n      },\n      // tmp\n      \"tmp:sn.tagL.enabled\": (t) => O(this, ig, XS).call(this, t),\n      \"tmp:sn.skip.all\": (t) => O(this, Wu, Fp).call(this, t),\n      \"tmp:sn.skip.enabled\": (t) => O(this, Wu, Fp).call(this, t),\n      \"tmp:sn.auto.enabled\": (t) => O(this, Wu, Fp).call(this, t),\n      \"tmp:flash.desktop.NativeApplication.nativeApplication.systemIdleMode\": () => {\n      }\n    });\n    if (this.cfg = t, e.let = (s) => O(this, di, on).call(this, s), e.let_abs = (s) => O(this, $v, AS).call(this, s), e.let_char_at = (s) => O(this, Vv, LS).call(this, s), e.let_index_of = (s) => O(this, Xv, BS).call(this, s), e.let_length = (s) => O(this, Wv, FS).call(this, s), e.let_replace = (s) => O(this, Yv, GS).call(this, s), e.let_round = (s) => O(this, qv, US).call(this, s), e.let_search = (s) => O(this, Zv, jS).call(this, s), e.let_substr = (s) => O(this, Kv, zS).call(this, s), e.clearsysvar = () => O(this, $u, Lp).call(this), e.clearvar = () => O(this, Lc, Yy).call(this), e.dump_val = () => c(this, Qv).call(this), e.copybookmark = (s) => O(this, zv, kS).call(this, s), e.erasebookmark = (s) => O(this, Hv, NS).call(this, s), c(this, fi)[\"sn.userFnTail\"] = \"\", this.defTmp(\"const.sn.bookmark.json\", () => {\n      const s = [];\n      for (const a of Object.keys(c(this, We).mark).sort()) {\n        const o = { ...c(this, We).mark[a].json };\n        o.place = a, s.push(o);\n      }\n      return JSON.stringify(s);\n    }), c(this, Me)[\"const.sn.isFirstBoot\"] = !0, c(this, Me)[\"sn.tagL.enabled\"] = !0, c(this, Me)[\"sn.skip.all\"] = !1, c(this, Me)[\"sn.skip.enabled\"] = !1, c(this, Me)[\"sn.auto.enabled\"] = !1, c(this, Me)[\"const.sn.last_page_text\"] = \"\", c(this, Me)[\"const.sn.displayState\"] = !1, c(this, Me)[\"const.Date.getTime\"] = () => (/* @__PURE__ */ new Date()).getTime(), c(this, Me)[\"const.Date.getDateStr\"] = () => rc(), c(this, Me)[\"const.sn.platform\"] = JSON.stringify(bs), O(this, $u, Lp).call(this), O(this, Lc, Yy).call(this), c(this, Me)[\"const.sn.config.window.width\"] = t.oCfg.window.width, c(this, Me)[\"const.sn.config.window.height\"] = t.oCfg.window.height, c(this, Me)[\"const.sn.config.book.title\"] = t.oCfg.book.title, c(this, Me)[\"const.sn.config.book.version\"] = t.oCfg.book.version, c(this, Me)[\"const.sn.Math.PI\"] = Math.PI, typeof window > \"u\")\n      return;\n    const r = window, n = r.AudioContext ?? r.webkitAudioContext;\n    c(this, Me)[\"const.sn.needClick2Play\"] = () => new n().state === \"suspended\";\n  }\n  setSys(t) {\n    P(this, Yn, t), t.initVal(c(this, We), c(this, Me), (e) => {\n      this.updateData(e), sessionStorage.clear();\n      const r = this.cfg.getNs();\n      P(this, Nc, this.cfg.oCfg.debug.variable ? () => {\n        const s = {};\n        for (const [d, f] of Object.entries(c(this, qr)))\n          s[\"sys:\" + d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"sys\"] = JSON.stringify(s);\n        const a = {};\n        for (const [d, f] of Object.entries(c(this, fi)))\n          a[\"save:\" + d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"save\"] = JSON.stringify(a);\n        const o = {};\n        for (const [d, f] of Object.entries(c(this, Me)))\n          o[d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"tmp\"] = JSON.stringify(o);\n        const u = {};\n        for (const [d, f] of Object.entries(c(this, rr).mp))\n          u[d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"mp\"] = JSON.stringify(u);\n        const l = {};\n        for (const [d, f] of Object.entries(c(this, We).mark))\n          l[d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"mark\"] = JSON.stringify(l);\n        const h = {};\n        for (const [d, f] of Object.entries(c(this, We).kidoku))\n          h[d] = f instanceof Function ? f() : f;\n        sessionStorage[r + \"kidoku\"] = JSON.stringify(h), t.flush();\n      } : () => t.flush()), P(this, Dc, (s, a) => t.callHook(s, a)), t.addHook((s, a) => {\n        var o, u;\n        return (u = (o = c(this, jv))[s]) == null ? void 0 : u.call(o, s, a);\n      });\n      const n = this.getVal(\"sys:sn.tagCh.msecWait\", -1);\n      (c(this, Me)[\"const.sn.isFirstBoot\"] || n === -1) && O(this, $u, Lp).call(this);\n    });\n  }\n  updateData(t) {\n    P(this, We, t), P(this, qr, c(this, rr).sys = c(this, We).sys), P(this, un, {});\n    for (const [e, r] of Object.entries(c(this, We).kidoku)) {\n      const n = new nw();\n      n.hAreas = { ...r }, c(this, un)[e] = n;\n    }\n  }\n  flush() {\n    c(this, Nc).call(this);\n  }\n  // 先にこのメソッドへの参照を配ってしまうので、中身を入れ替える\n  setDoRecProc(t) {\n    P(this, Ac, t);\n  }\n  defTmp(t, e) {\n    c(this, Me)[t] = e;\n  }\n  cloneMp() {\n    return { ...c(this, rr).mp };\n  }\n  setMp(t) {\n    c(this, rr).mp = t;\n  }\n  setMark(t, e) {\n    c(this, We).mark[t] = e, this.flush();\n  }\n  cloneSave() {\n    return { ...c(this, rr).save };\n  }\n  mark2save(t) {\n    P(this, fi, c(this, rr).save = { ...t.hSave }), P(this, Vu, c(this, fi)[\"sn.doRecLog\"] ?? !1);\n  }\n  // 既読系\n  loadScrWork(t) {\n    t in c(this, un) || (c(this, un)[t] = new nw());\n  }\n  saveKidoku() {\n    for (const [t, { hAreas: e }] of Object.entries(c(this, un)))\n      c(this, We).kidoku[t] = { ...e };\n    this.flush();\n  }\n  setVal_Nochk(t, e, r, n = !1) {\n    var o, u;\n    const s = c(this, rr)[t];\n    n && (r = O(this, Fc, qy).call(this, r));\n    const a = t + \":\" + e;\n    if (a in c(Nu, Xa)) {\n      const l = s[e], h = r;\n      l != h && c(this, Dc).call(this, \"data_break\", {\n        dataId: a,\n        old_v: l,\n        new_v: h\n      });\n    }\n    s[e] = r, (u = (o = c(this, Gc))[a]) == null || u.call(o, e, r);\n  }\n  doRecLog() {\n    return c(this, Vu);\n  }\n  defValTrg(t, e) {\n    c(this, Gc)[t] = e;\n  }\n};\nlet Ap = Nu;\nrr = new WeakMap(), fi = new WeakMap(), Me = new WeakMap(), Yn = new WeakMap(), We = new WeakMap(), qr = new WeakMap(), un = new WeakMap(), Dc = new WeakMap(), jv = new WeakMap(), kc = new WeakSet(), Wy = function(t) {\n  P(Nu, Xa, {});\n  for (const e of t)\n    c(Nu, Xa)[e.dataId] = 1;\n}, Nc = new WeakMap(), Ac = new WeakMap(), zv = new WeakSet(), kS = function(t) {\n  if (!(\"from\" in t))\n    throw \"fromは必須です\";\n  if (!(\"to\" in t))\n    throw \"toは必須です\";\n  const e = Number(t.from), r = Number(t.to);\n  if (e === r)\n    return !1;\n  if (!(e in c(this, We).mark))\n    throw `from:${e} のセーブデータは存在しません`;\n  return this.setMark(r, { ...c(this, We).mark[e] }), c(this, Yn).copyBMFolder(e, r), !1;\n}, Hv = new WeakSet(), NS = function(t) {\n  const { place: e } = t;\n  if (!e)\n    throw \"placeは必須です\";\n  return delete c(this, We).mark[e], this.flush(), c(this, Yn).eraseBMFolder(e), !1;\n}, di = new WeakSet(), on = function(t) {\n  if (!t.name)\n    throw \"nameは必須です\";\n  let e = !0;\n  if (t.cast)\n    switch (t.cast) {\n      case \"num\":\n        tt(t, \"text\", NaN);\n        break;\n      case \"int\":\n        t.text = String($t(tt(t, \"text\", NaN)));\n        break;\n      case \"uint\":\n        t.text = String(ni(tt(t, \"text\", NaN)));\n        break;\n      case \"bool\":\n        vt(t, \"text\", !1);\n        break;\n      case \"str\":\n        e = !1;\n        break;\n      default:\n        throw \"cast【\" + t.cast + \"】は未定義です\";\n    }\n  return c(this, Bc).call(this, t.name, t.text, e), !1;\n}, $v = new WeakSet(), AS = function(t) {\n  const e = tt(t, \"text\", 0);\n  return t.text = String(e < 0 ? -e : e), O(this, di, on).call(this, t), !1;\n}, Vv = new WeakSet(), LS = function(t) {\n  return t.text = (t.text ?? \"\").charAt(tt(t, \"pos\", 0)), O(this, di, on).call(this, t), !1;\n}, Xv = new WeakSet(), BS = function(t) {\n  const { val: e } = t;\n  if (!e)\n    throw \"valは必須です\";\n  const r = tt(t, \"start\", 0);\n  return t.text = String((t.text ?? \"\").indexOf(e, r)), O(this, di, on).call(this, t), !1;\n}, Wv = new WeakSet(), FS = function(t) {\n  return t.text = String((t.text ?? \"\").length), O(this, di, on).call(this, t), !1;\n}, Yv = new WeakSet(), GS = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String(t.text ?? \"\").replace(r, String(t.val)), O(this, di, on).call(this, t), !1;\n}, qv = new WeakSet(), US = function(t) {\n  const e = tt(t, \"text\", 0);\n  return t.text = String(Math.round(e)), O(this, di, on).call(this, t), !1;\n}, Zv = new WeakSet(), jS = function(t) {\n  if (!t.reg)\n    throw \"regは必須です\";\n  const { flags: e } = t, r = e ? new RegExp(t.reg, e) : new RegExp(t.reg);\n  return t.text = String((t.text ?? \"\").search(r)), O(this, di, on).call(this, t), !1;\n}, Kv = new WeakSet(), zS = function(t) {\n  const e = tt(t, \"pos\", 0);\n  return t.text = t.len !== \"all\" ? (t.text ?? \"\").slice(e, e + $t(tt(t, \"len\", 1))) : (t.text ?? \"\").slice(e), O(this, di, on).call(this, t), !1;\n}, $u = new WeakSet(), Lp = function() {\n  const t = P(this, qr, c(this, rr).sys = c(this, We).sys = {});\n  typeof process < \"u\" || (this.setVal_Nochk(\"sys\", \"const.sn.window.x\", 0), this.setVal_Nochk(\"sys\", \"const.sn.window.y\", 0)), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.doWait_Kidoku\", !0), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.msecWait_Kidoku\", this.cfg.oCfg.init.tagch_msecwait), this.setVal_Nochk(\"sys\", \"sn.tagCh.canskip\", !0), this.setVal_Nochk(\"sys\", \"sn.skip.mode\", \"s\"), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait\", tt(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecPageWait_Kidoku\", tt(t, \"sn.auto.msecPageWait\", this.cfg.oCfg.init.auto_msecpagewait ?? 3500)), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait\", 500), this.setVal_Nochk(\"sys\", \"sn.auto.msecLineWait_Kidoku\", 500), this.setVal_Nochk(\"sys\", \"const.sn.sound.BGM.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SE.volume\", 1), this.setVal_Nochk(\"sys\", \"const.sn.sound.SYS.volume\", 1);\n  for (const [r, n] of Object.entries(c(this, We).kidoku))\n    n.hAreas = {}, c(this, un)[r].clear();\n  return this.setVal_Nochk(\"sys\", \"TextLayer.Back.Alpha\", 0.5), c(this, rr).mark = c(this, We).mark = {}, this.setVal_Nochk(\"sys\", \"const.sn.save.place\", 1), this.flush(), !1;\n}, Lc = new WeakSet(), Yy = function() {\n  const t = c(this, fi)[\"const.sn.mesLayer\"] ?? \"\", e = c(this, fi)[\"sn.doRecLog\"] ?? !1, r = c(this, fi)[\"const.sn.sLog\"] ?? \"[]\";\n  return P(this, fi, c(this, rr).save = {}), this.setVal_Nochk(\"save\", \"const.sn.mesLayer\", t), this.setVal_Nochk(\"save\", \"sn.doRecLog\", e), this.setVal_Nochk(\"save\", \"const.sn.sLog\", r), !1;\n}, Bc = new WeakMap(), Xa = new WeakMap(), Fc = new WeakSet(), qy = function(t) {\n  const e = t;\n  if (e === \"true\")\n    return !0;\n  if (e === \"false\")\n    return !1;\n  if (e === \"null\")\n    return null;\n  if (e !== \"undefined\")\n    return c(this, Jv).test(e) ? parseFloat(e) : t;\n}, Jv = new WeakMap(), Qv = new WeakMap(), Vu = new WeakMap(), Gc = new WeakMap(), Xu = new WeakSet(), Bp = function(t) {\n  vt(c(this, qr), t, !0);\n}, tg = new WeakSet(), HS = function(t) {\n  tt(c(this, qr), t, 10), c(this, qr)[\"sn.tagCh.doWait\"];\n}, eg = new WeakSet(), $S = function(t) {\n  tt(\n    c(this, qr),\n    t,\n    this.cfg.oCfg.init.tagch_msecwait === void 0 ? 10 : this.cfg.oCfg.init.tagch_msecwait\n  ), c(this, qr)[\"sn.tagCh.doWait_Kidoku\"];\n}, Uc = new WeakSet(), Zy = function(t) {\n  tt(\n    c(this, qr),\n    t,\n    this.cfg.oCfg.init.auto_msecpagewait === void 0 ? 3500 : this.cfg.oCfg.init.auto_msecpagewait\n  );\n}, jc = new WeakSet(), Ky = function(t) {\n  tt(c(this, qr), t, 500);\n}, rg = new WeakSet(), VS = function(t) {\n  return vt(c(this, fi), t, !0);\n}, ig = new WeakSet(), XS = function(t) {\n  vt(c(this, Me), t, !0);\n}, Wu = new WeakSet(), Fp = function(t) {\n  vt(c(this, Me), t, !1);\n}, // reload 再生成 Main に受け渡すため static\nE(Ap, Xa, {});\nvar Zt = Object.freeze({\n  Linear: Object.freeze({\n    None: function(i) {\n      return i;\n    },\n    In: function(i) {\n      return this.None(i);\n    },\n    Out: function(i) {\n      return this.None(i);\n    },\n    InOut: function(i) {\n      return this.None(i);\n    }\n  }),\n  Quadratic: Object.freeze({\n    In: function(i) {\n      return i * i;\n    },\n    Out: function(i) {\n      return i * (2 - i);\n    },\n    InOut: function(i) {\n      return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);\n    }\n  }),\n  Cubic: Object.freeze({\n    In: function(i) {\n      return i * i * i;\n    },\n    Out: function(i) {\n      return --i * i * i + 1;\n    },\n    InOut: function(i) {\n      return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);\n    }\n  }),\n  Quartic: Object.freeze({\n    In: function(i) {\n      return i * i * i * i;\n    },\n    Out: function(i) {\n      return 1 - --i * i * i * i;\n    },\n    InOut: function(i) {\n      return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);\n    }\n  }),\n  Quintic: Object.freeze({\n    In: function(i) {\n      return i * i * i * i * i;\n    },\n    Out: function(i) {\n      return --i * i * i * i * i + 1;\n    },\n    InOut: function(i) {\n      return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);\n    }\n  }),\n  Sinusoidal: Object.freeze({\n    In: function(i) {\n      return 1 - Math.sin((1 - i) * Math.PI / 2);\n    },\n    Out: function(i) {\n      return Math.sin(i * Math.PI / 2);\n    },\n    InOut: function(i) {\n      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - i)));\n    }\n  }),\n  Exponential: Object.freeze({\n    In: function(i) {\n      return i === 0 ? 0 : Math.pow(1024, i - 1);\n    },\n    Out: function(i) {\n      return i === 1 ? 1 : 1 - Math.pow(2, -10 * i);\n    },\n    InOut: function(i) {\n      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2) < 1 ? 0.5 * Math.pow(1024, i - 1) : 0.5 * (-Math.pow(2, -10 * (i - 1)) + 2);\n    }\n  }),\n  Circular: Object.freeze({\n    In: function(i) {\n      return 1 - Math.sqrt(1 - i * i);\n    },\n    Out: function(i) {\n      return Math.sqrt(1 - --i * i);\n    },\n    InOut: function(i) {\n      return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);\n    }\n  }),\n  Elastic: Object.freeze({\n    In: function(i) {\n      return i === 0 ? 0 : i === 1 ? 1 : -Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI);\n    },\n    Out: function(i) {\n      return i === 0 ? 0 : i === 1 ? 1 : Math.pow(2, -10 * i) * Math.sin((i - 0.1) * 5 * Math.PI) + 1;\n    },\n    InOut: function(i) {\n      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2, i < 1 ? -0.5 * Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) + 1);\n    }\n  }),\n  Back: Object.freeze({\n    In: function(i) {\n      var t = 1.70158;\n      return i === 1 ? 1 : i * i * ((t + 1) * i - t);\n    },\n    Out: function(i) {\n      var t = 1.70158;\n      return i === 0 ? 0 : --i * i * ((t + 1) * i + t) + 1;\n    },\n    InOut: function(i) {\n      var t = 2.5949095;\n      return (i *= 2) < 1 ? 0.5 * (i * i * ((t + 1) * i - t)) : 0.5 * ((i -= 2) * i * ((t + 1) * i + t) + 2);\n    }\n  }),\n  Bounce: Object.freeze({\n    In: function(i) {\n      return 1 - Zt.Bounce.Out(1 - i);\n    },\n    Out: function(i) {\n      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;\n    },\n    InOut: function(i) {\n      return i < 0.5 ? Zt.Bounce.In(i * 2) * 0.5 : Zt.Bounce.Out(i * 2 - 1) * 0.5 + 0.5;\n    }\n  }),\n  generatePow: function(i) {\n    return i === void 0 && (i = 4), i = i < Number.EPSILON ? Number.EPSILON : i, i = i > 1e4 ? 1e4 : i, {\n      In: function(t) {\n        return Math.pow(t, i);\n      },\n      Out: function(t) {\n        return 1 - Math.pow(1 - t, i);\n      },\n      InOut: function(t) {\n        return t < 0.5 ? Math.pow(t * 2, i) / 2 : (1 - Math.pow(2 - t * 2, i)) / 2 + 0.5;\n      }\n    };\n  }\n}), Ph;\ntypeof self > \"u\" && typeof process < \"u\" && process.hrtime ? Ph = function() {\n  var i = process.hrtime();\n  return i[0] * 1e3 + i[1] / 1e6;\n} : typeof self < \"u\" && self.performance !== void 0 && self.performance.now !== void 0 ? Ph = self.performance.now.bind(self.performance) : Date.now !== void 0 ? Ph = Date.now : Ph = function() {\n  return (/* @__PURE__ */ new Date()).getTime();\n};\nvar Oh = Ph, cA = (\n  /** @class */\n  function() {\n    function i() {\n      this._tweens = {}, this._tweensAddedDuringUpdate = {};\n    }\n    return i.prototype.getAll = function() {\n      var t = this;\n      return Object.keys(this._tweens).map(function(e) {\n        return t._tweens[e];\n      });\n    }, i.prototype.removeAll = function() {\n      this._tweens = {};\n    }, i.prototype.add = function(t) {\n      this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t;\n    }, i.prototype.remove = function(t) {\n      delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()];\n    }, i.prototype.update = function(t, e) {\n      t === void 0 && (t = Oh()), e === void 0 && (e = !1);\n      var r = Object.keys(this._tweens);\n      if (r.length === 0)\n        return !1;\n      for (; r.length > 0; ) {\n        this._tweensAddedDuringUpdate = {};\n        for (var n = 0; n < r.length; n++) {\n          var s = this._tweens[r[n]], a = !e;\n          s && s.update(t, a) === !1 && !e && delete this._tweens[r[n]];\n        }\n        r = Object.keys(this._tweensAddedDuringUpdate);\n      }\n      return !0;\n    }, i;\n  }()\n), Iu = {\n  Linear: function(i, t) {\n    var e = i.length - 1, r = e * t, n = Math.floor(r), s = Iu.Utils.Linear;\n    return t < 0 ? s(i[0], i[1], r) : t > 1 ? s(i[e], i[e - 1], e - r) : s(i[n], i[n + 1 > e ? e : n + 1], r - n);\n  },\n  Bezier: function(i, t) {\n    for (var e = 0, r = i.length - 1, n = Math.pow, s = Iu.Utils.Bernstein, a = 0; a <= r; a++)\n      e += n(1 - t, r - a) * n(t, a) * i[a] * s(r, a);\n    return e;\n  },\n  CatmullRom: function(i, t) {\n    var e = i.length - 1, r = e * t, n = Math.floor(r), s = Iu.Utils.CatmullRom;\n    return i[0] === i[e] ? (t < 0 && (n = Math.floor(r = e * (1 + t))), s(i[(n - 1 + e) % e], i[n], i[(n + 1) % e], i[(n + 2) % e], r - n)) : t < 0 ? i[0] - (s(i[0], i[0], i[1], i[1], -r) - i[0]) : t > 1 ? i[e] - (s(i[e], i[e], i[e - 1], i[e - 1], r - e) - i[e]) : s(i[n ? n - 1 : 0], i[n], i[e < n + 1 ? e : n + 1], i[e < n + 2 ? e : n + 2], r - n);\n  },\n  Utils: {\n    Linear: function(i, t, e) {\n      return (t - i) * e + i;\n    },\n    Bernstein: function(i, t) {\n      var e = Iu.Utils.Factorial;\n      return e(i) / e(t) / e(i - t);\n    },\n    Factorial: function() {\n      var i = [1];\n      return function(t) {\n        var e = 1;\n        if (i[t])\n          return i[t];\n        for (var r = t; r > 1; r--)\n          e *= r;\n        return i[t] = e, e;\n      };\n    }(),\n    CatmullRom: function(i, t, e, r, n) {\n      var s = (e - i) * 0.5, a = (r - t) * 0.5, o = n * n, u = n * o;\n      return (2 * t - 2 * e + s + a) * u + (-3 * t + 3 * e - 2 * s - a) * o + s * n + t;\n    }\n  }\n}, fA = (\n  /** @class */\n  function() {\n    function i() {\n    }\n    return i.nextId = function() {\n      return i._nextId++;\n    }, i._nextId = 0, i;\n  }()\n), Jy = new cA(), Tn = (\n  /** @class */\n  function() {\n    function i(t, e) {\n      e === void 0 && (e = Jy), this._object = t, this._group = e, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Zt.Linear.None, this._interpolationFunction = Iu.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = fA.nextId(), this._isChainStopped = !1, this._goToEnd = !1;\n    }\n    return i.prototype.getId = function() {\n      return this._id;\n    }, i.prototype.isPlaying = function() {\n      return this._isPlaying;\n    }, i.prototype.isPaused = function() {\n      return this._isPaused;\n    }, i.prototype.to = function(t, e) {\n      return this._valuesEnd = Object.create(t), e !== void 0 && (this._duration = e), this;\n    }, i.prototype.duration = function(t) {\n      return t === void 0 && (t = 1e3), this._duration = t, this;\n    }, i.prototype.start = function(t, e) {\n      if (t === void 0 && (t = Oh()), e === void 0 && (e = !1), this._isPlaying)\n        return this;\n      if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed) {\n        this._reversed = !1;\n        for (var r in this._valuesStartRepeat)\n          this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];\n      }\n      return this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = t, this._startTime += this._delayTime, this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, e), this;\n    }, i.prototype.startFromCurrentValues = function(t) {\n      return this.start(t, !0);\n    }, i.prototype._setupProperties = function(t, e, r, n, s) {\n      for (var a in r) {\n        var o = t[a], u = Array.isArray(o), l = u ? \"array\" : typeof o, h = !u && Array.isArray(r[a]);\n        if (!(l === \"undefined\" || l === \"function\")) {\n          if (h) {\n            var d = r[a];\n            if (d.length === 0)\n              continue;\n            d = d.map(this._handleRelativeValue.bind(this, o)), e[a] === void 0 && (r[a] = [o].concat(d));\n          }\n          if ((l === \"object\" || u) && o && !h) {\n            e[a] = u ? [] : {};\n            for (var f in o)\n              e[a][f] = o[f];\n            n[a] = u ? [] : {}, this._setupProperties(o, e[a], r[a], n[a], s);\n          } else\n            (typeof e[a] > \"u\" || s) && (e[a] = o), u || (e[a] *= 1), h ? n[a] = r[a].slice().reverse() : n[a] = e[a] || 0;\n        }\n      }\n    }, i.prototype.stop = function() {\n      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;\n    }, i.prototype.end = function() {\n      return this._goToEnd = !0, this.update(1 / 0), this;\n    }, i.prototype.pause = function(t) {\n      return t === void 0 && (t = Oh()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = t, this._group && this._group.remove(this), this);\n    }, i.prototype.resume = function(t) {\n      return t === void 0 && (t = Oh()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += t - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this);\n    }, i.prototype.stopChainedTweens = function() {\n      for (var t = 0, e = this._chainedTweens.length; t < e; t++)\n        this._chainedTweens[t].stop();\n      return this;\n    }, i.prototype.group = function(t) {\n      return t === void 0 && (t = Jy), this._group = t, this;\n    }, i.prototype.delay = function(t) {\n      return t === void 0 && (t = 0), this._delayTime = t, this;\n    }, i.prototype.repeat = function(t) {\n      return t === void 0 && (t = 0), this._initialRepeat = t, this._repeat = t, this;\n    }, i.prototype.repeatDelay = function(t) {\n      return this._repeatDelayTime = t, this;\n    }, i.prototype.yoyo = function(t) {\n      return t === void 0 && (t = !1), this._yoyo = t, this;\n    }, i.prototype.easing = function(t) {\n      return t === void 0 && (t = Zt.Linear.None), this._easingFunction = t, this;\n    }, i.prototype.interpolation = function(t) {\n      return t === void 0 && (t = Iu.Linear), this._interpolationFunction = t, this;\n    }, i.prototype.chain = function() {\n      for (var t = [], e = 0; e < arguments.length; e++)\n        t[e] = arguments[e];\n      return this._chainedTweens = t, this;\n    }, i.prototype.onStart = function(t) {\n      return this._onStartCallback = t, this;\n    }, i.prototype.onEveryStart = function(t) {\n      return this._onEveryStartCallback = t, this;\n    }, i.prototype.onUpdate = function(t) {\n      return this._onUpdateCallback = t, this;\n    }, i.prototype.onRepeat = function(t) {\n      return this._onRepeatCallback = t, this;\n    }, i.prototype.onComplete = function(t) {\n      return this._onCompleteCallback = t, this;\n    }, i.prototype.onStop = function(t) {\n      return this._onStopCallback = t, this;\n    }, i.prototype.update = function(t, e) {\n      if (t === void 0 && (t = Oh()), e === void 0 && (e = !0), this._isPaused)\n        return !0;\n      var r, n, s = this._startTime + this._duration;\n      if (!this._goToEnd && !this._isPlaying) {\n        if (t > s)\n          return !1;\n        e && this.start(t, !0);\n      }\n      if (this._goToEnd = !1, t < this._startTime)\n        return !0;\n      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), n = (t - this._startTime) / this._duration, n = this._duration === 0 || n > 1 ? 1 : n;\n      var a = this._easingFunction(n);\n      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, a), this._onUpdateCallback && this._onUpdateCallback(this._object, n), n === 1)\n        if (this._repeat > 0) {\n          isFinite(this._repeat) && this._repeat--;\n          for (r in this._valuesStartRepeat)\n            !this._yoyo && typeof this._valuesEnd[r] == \"string\" && (this._valuesStartRepeat[r] = // eslint-disable-next-line\n            // @ts-ignore FIXME?\n            this._valuesStartRepeat[r] + parseFloat(this._valuesEnd[r])), this._yoyo && this._swapEndStartRepeatValues(r), this._valuesStart[r] = this._valuesStartRepeat[r];\n          return this._yoyo && (this._reversed = !this._reversed), this._repeatDelayTime !== void 0 ? this._startTime = t + this._repeatDelayTime : this._startTime = t + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;\n        } else {\n          this._onCompleteCallback && this._onCompleteCallback(this._object);\n          for (var o = 0, u = this._chainedTweens.length; o < u; o++)\n            this._chainedTweens[o].start(this._startTime + this._duration, !1);\n          return this._isPlaying = !1, !1;\n        }\n      return !0;\n    }, i.prototype._updateProperties = function(t, e, r, n) {\n      for (var s in r)\n        if (e[s] !== void 0) {\n          var a = e[s] || 0, o = r[s], u = Array.isArray(t[s]), l = Array.isArray(o), h = !u && l;\n          h ? t[s] = this._interpolationFunction(o, n) : typeof o == \"object\" && o ? this._updateProperties(t[s], a, o, n) : (o = this._handleRelativeValue(a, o), typeof o == \"number\" && (t[s] = a + (o - a) * n));\n        }\n    }, i.prototype._handleRelativeValue = function(t, e) {\n      return typeof e != \"string\" ? e : e.charAt(0) === \"+\" || e.charAt(0) === \"-\" ? t + parseFloat(e) : parseFloat(e);\n    }, i.prototype._swapEndStartRepeatValues = function(t) {\n      var e = this._valuesStartRepeat[t], r = this._valuesEnd[t];\n      typeof r == \"string\" ? this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(r) : this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = e;\n    }, i;\n  }()\n), kn = Jy;\nkn.getAll.bind(kn);\nvar dA = kn.removeAll.bind(kn);\nkn.add.bind(kn);\nvar pA = kn.remove.bind(kn), vA = kn.update.bind(kn), zc;\nconst ng = class {\n  static ease(t) {\n    if (!t)\n      return (e) => Zt.Linear.None(e);\n    if (!(t in c(ng, zc)))\n      throw \"異常なease指定です\";\n    return c(ng, zc)[t];\n  }\n};\nlet ws = ng;\nzc = new WeakMap(), E(ws, zc, {\n  \"Back.In\": (t) => Zt.Back.In(t),\n  \"Back.InOut\": (t) => Zt.Back.InOut(t),\n  \"Back.Out\": (t) => Zt.Back.Out(t),\n  \"Bounce.In\": (t) => Zt.Bounce.In(t),\n  \"Bounce.InOut\": (t) => Zt.Bounce.InOut(t),\n  \"Bounce.Out\": (t) => Zt.Bounce.Out(t),\n  \"Circular.In\": (t) => Zt.Circular.In(t),\n  \"Circular.InOut\": (t) => Zt.Circular.InOut(t),\n  \"Circular.Out\": (t) => Zt.Circular.Out(t),\n  \"Cubic.In\": (t) => Zt.Cubic.In(t),\n  \"Cubic.InOut\": (t) => Zt.Cubic.InOut(t),\n  \"Cubic.Out\": (t) => Zt.Cubic.Out(t),\n  \"Elastic.In\": (t) => Zt.Elastic.In(t),\n  \"Elastic.InOut\": (t) => Zt.Elastic.InOut(t),\n  \"Elastic.Out\": (t) => Zt.Elastic.Out(t),\n  \"Exponential.In\": (t) => Zt.Exponential.In(t),\n  \"Exponential.InOut\": (t) => Zt.Exponential.InOut(t),\n  \"Exponential.Out\": (t) => Zt.Exponential.Out(t),\n  \"Linear.None\": (t) => Zt.Linear.None(t),\n  \"Quadratic.In\": (t) => Zt.Quadratic.In(t),\n  \"Quadratic.InOut\": (t) => Zt.Quadratic.InOut(t),\n  \"Quadratic.Out\": (t) => Zt.Quadratic.Out(t),\n  \"Quartic.In\": (t) => Zt.Quartic.In(t),\n  \"Quartic.InOut\": (t) => Zt.Quartic.InOut(t),\n  \"Quartic.Out\": (t) => Zt.Quartic.Out(t),\n  \"Quintic.In\": (t) => Zt.Quintic.In(t),\n  \"Quintic.InOut\": (t) => Zt.Quintic.InOut(t),\n  \"Quintic.Out\": (t) => Zt.Quintic.Out(t),\n  \"Sinusoidal.In\": (t) => Zt.Sinusoidal.In(t),\n  \"Sinusoidal.InOut\": (t) => Zt.Sinusoidal.InOut(t),\n  \"Sinusoidal.Out\": (t) => Zt.Sinusoidal.Out(t)\n});\n/*!\n * @pixi/sound - v4.3.3\n * https://github.com/pixijs/pixi-sound\n * Compiled Fri, 10 Mar 2023 17:19:30 UTC\n *\n * @pixi/sound is licensed under the MIT license.\n * http://www.opensource.org/licenses/mit-license\n */\nvar WS;\nfunction Ae() {\n  return WS;\n}\nvar YS = function(i, t) {\n  return (YS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n  })(i, t);\n};\nfunction ri(i, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  function e() {\n    this.constructor = i;\n  }\n  YS(i, t), i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar tu = function() {\n  return (tu = Object.assign || function(i) {\n    for (var t, e = 1, r = arguments.length; e < r; e++)\n      for (var n in t = arguments[e])\n        Object.prototype.hasOwnProperty.call(t, n) && (i[n] = t[n]);\n    return i;\n  }).apply(this, arguments);\n}, ix = [\"mp3\", \"ogg\", \"oga\", \"opus\", \"mpeg\", \"wav\", \"m4a\", \"aiff\", \"wma\", \"mid\", \"caf\"], a0 = {};\nfunction qS(i) {\n  var t = tu({ m4a: \"audio/mp4\", oga: \"audio/ogg\", opus: 'audio/ogg; codecs=\"opus\"', caf: 'audio/x-caf; codecs=\"opus\"' }, i || {}), e = document.createElement(\"audio\"), r = {}, n = /^no$/;\n  ix.forEach(function(s) {\n    var a = e.canPlayType(\"audio/\".concat(s)).replace(n, \"\"), o = t[s] ? e.canPlayType(t[s]).replace(n, \"\") : \"\";\n    r[s] = !!a || !!o;\n  }), Object.assign(a0, r);\n}\nqS();\nvar gA = /\\.(\\{([^\\}]+)\\})(\\?.*)?$/;\nfunction nx(i) {\n  var t = gA, e = typeof i == \"string\" ? i : i.url;\n  if (!t.test(e))\n    return e;\n  for (var r = t.exec(e), n = r[2].split(\",\"), s = n[n.length - 1], a = 0, o = n.length; a < o; a++) {\n    var u = n[a];\n    if (a0[u]) {\n      s = u;\n      break;\n    }\n  }\n  var l = e.replace(r[1], s);\n  if (typeof i != \"string\") {\n    var h = i;\n    h.extension = s, h.url = l;\n  }\n  return l;\n}\nvar ey = ix.filter(function(i) {\n  return a0[i];\n}), Qy = function() {\n  function i() {\n  }\n  return i.add = function() {\n    i.setLegacy(Ae().useLegacy);\n  }, i.setLegacy = function(t) {\n    t ? ey.forEach(function(e) {\n      Ft.setExtensionXhrType(e, Ft.XHR_RESPONSE_TYPE.DEFAULT), Ft.setExtensionLoadType(e, Ft.LOAD_TYPE.AUDIO);\n    }) : ey.forEach(function(e) {\n      Ft.setExtensionXhrType(e, Ft.XHR_RESPONSE_TYPE.BUFFER), Ft.setExtensionLoadType(e, Ft.LOAD_TYPE.XHR);\n    });\n  }, i.pre = function(t, e) {\n    nx(t), e();\n  }, i.use = function(t, e) {\n    t.data && ey.indexOf(t.extension) > -1 ? t.sound = Ae().add(t.name, { loaded: e, preload: !0, url: t.url, source: t.data }) : e();\n  }, i.extension = \"loader\", i;\n}(), mA = 0, yA = function(i) {\n  function t(e) {\n    var r = i.call(this) || this;\n    return r.id = mA++, r.init(e), r;\n  }\n  return ri(t, i), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n    }\n    return this;\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._source.currentTime / this._duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype._onPlay = function() {\n    this._playing = !0;\n  }, t.prototype._onPause = function() {\n    this._playing = !1;\n  }, t.prototype.init = function(e) {\n    this._playing = !1, this._duration = e.source.duration;\n    var r = this._source = e.source.cloneNode(!1);\n    r.src = e.parent.url, r.onplay = this._onPlay.bind(this), r.onpause = this._onPause.bind(this), e.context.on(\"refresh\", this.refresh, this), e.context.on(\"refreshPaused\", this.refreshPaused, this), this._media = e;\n  }, t.prototype._internalStop = function() {\n    this._source && this._playing && (this._source.onended = null, this._source.pause());\n  }, t.prototype.stop = function() {\n    this._internalStop(), this._source && this.emit(\"stop\");\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    var e = this._media.context, r = this._media.parent;\n    this._source.loop = this._loop || r.loop;\n    var n = e.volume * (e.muted ? 0 : 1), s = r.volume * (r.muted ? 0 : 1), a = this._volume * (this._muted ? 0 : 1);\n    this._source.volume = a * n * s, this._source.playbackRate = this._speed * e.speed * r.speed;\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, n = this._paused || r.paused || e.paused;\n    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._source.currentTime, end: this._end, volume: this._volume, speed: this._speed, loop: this._loop })), this.emit(\"pause\", n));\n  }, t.prototype.play = function(e) {\n    var r = this, n = e.start, s = e.end, a = e.speed, o = e.loop, u = e.volume, l = e.muted;\n    this._speed = a, this._volume = u, this._loop = !!o, this._muted = l, this.refresh(), this.loop && s !== null && (this.loop = !1), this._start = n, this._end = s || this._duration, this._start = Math.max(0, this._start - t.PADDING), this._end = Math.min(this._end + t.PADDING, this._duration), this._source.onloadedmetadata = function() {\n      r._source && (r._source.currentTime = n, r._source.onloadedmetadata = null, r.emit(\"progress\", n, r._duration), Ge.shared.add(r._onUpdate, r));\n    }, this._source.onended = this._onComplete.bind(this), this._source.play(), this.emit(\"start\");\n  }, t.prototype._onUpdate = function() {\n    this.emit(\"progress\", this.progress, this._duration), this._source.currentTime >= this._end && !this._source.loop && this._onComplete();\n  }, t.prototype._onComplete = function() {\n    Ge.shared.remove(this._onUpdate, this), this._internalStop(), this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t.prototype.destroy = function() {\n    Ge.shared.remove(this._onUpdate, this), this.removeAllListeners();\n    var e = this._source;\n    e && (e.onended = null, e.onplay = null, e.onpause = null, this._internalStop()), this._source = null, this._speed = 1, this._volume = 1, this._loop = !1, this._end = null, this._start = 0, this._duration = 0, this._playing = !1, this._pausedReal = !1, this._paused = !1, this._muted = !1, this._media && (this._media.context.off(\"refresh\", this.refresh, this), this._media.context.off(\"refreshPaused\", this.refreshPaused, this), this._media = null);\n  }, t.prototype.toString = function() {\n    return \"[HTMLAudioInstance id=\".concat(this.id, \"]\");\n  }, t.PADDING = 0.1, t;\n}($r), _A = function(i) {\n  function t() {\n    return i !== null && i.apply(this, arguments) || this;\n  }\n  return ri(t, i), t.prototype.init = function(e) {\n    this.parent = e, this._source = e.options.source || new Audio(), e.url && (this._source.src = e.url);\n  }, t.prototype.create = function() {\n    return new yA(this);\n  }, Object.defineProperty(t.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && this._source.readyState === 4;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"duration\", { get: function() {\n    return this._source.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this.removeAllListeners(), this.parent = null, this._source && (this._source.src = \"\", this._source.load(), this._source = null);\n  }, Object.defineProperty(t.prototype, \"source\", { get: function() {\n    return this._source;\n  }, enumerable: !1, configurable: !0 }), t.prototype.load = function(e) {\n    var r = this._source, n = this.parent;\n    if (r.readyState !== 4)\n      if (n.url) {\n        r.src = n.url;\n        var s = function() {\n          u(), n.isLoaded = !0;\n          var h = n.autoPlayStart();\n          e && e(null, n, h);\n        }, a = function() {\n          u(), e && e(new Error(\"Sound loading has been aborted\"));\n        }, o = function() {\n          u();\n          var h = \"Failed to load audio element (code: \".concat(r.error.code, \")\");\n          e && e(new Error(h));\n        }, u = function() {\n          r.removeEventListener(\"canplaythrough\", s), r.removeEventListener(\"load\", s), r.removeEventListener(\"abort\", a), r.removeEventListener(\"error\", o);\n        };\n        r.addEventListener(\"canplaythrough\", s, !1), r.addEventListener(\"load\", s, !1), r.addEventListener(\"abort\", a, !1), r.addEventListener(\"error\", o, !1), r.load();\n      } else\n        e(new Error(\"sound.url or sound.source must be set\"));\n    else {\n      n.isLoaded = !0;\n      var l = n.autoPlayStart();\n      e && setTimeout(function() {\n        e(null, n, l);\n      }, 0);\n    }\n  }, t;\n}($r), bA = function() {\n  function i(t, e) {\n    this.parent = t, Object.assign(this, e), this.duration = this.end - this.start;\n  }\n  return i.prototype.play = function(t) {\n    return this.parent.play({ complete: t, speed: this.speed || this.parent.speed, end: this.end, start: this.start, loop: this.loop });\n  }, i.prototype.destroy = function() {\n    this.parent = null;\n  }, i;\n}(), ci = function() {\n  function i() {\n  }\n  return i.setParamValue = function(t, e) {\n    if (t.setValueAtTime) {\n      var r = Ae().context;\n      t.setValueAtTime(e, r.audioContext.currentTime);\n    } else\n      t.value = e;\n    return e;\n  }, i;\n}(), xA = 0, wA = function(i) {\n  function t(e) {\n    var r = i.call(this) || this;\n    return r.id = xA++, r._media = null, r._paused = !1, r._muted = !1, r._elapsed = 0, r.init(e), r;\n  }\n  return ri(t, i), t.prototype.set = function(e, r) {\n    if (this[e] === void 0)\n      throw new Error(\"Property with name \".concat(e, \" does not exist.\"));\n    switch (e) {\n      case \"speed\":\n        this.speed = r;\n        break;\n      case \"volume\":\n        this.volume = r;\n        break;\n      case \"muted\":\n        this.muted = r;\n        break;\n      case \"loop\":\n        this.loop = r;\n        break;\n      case \"paused\":\n        this.paused = r;\n    }\n    return this;\n  }, t.prototype.stop = function() {\n    this._source && (this._internalStop(), this.emit(\"stop\"));\n  }, Object.defineProperty(t.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(e) {\n    this._speed = e, this.refresh(), this._update(!0);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(e) {\n    this._volume = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(e) {\n    this._muted = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(e) {\n    this._loop = e, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(e) {\n    var r;\n    this._filters && ((r = this._filters) === null || r === void 0 || r.filter(function(n) {\n      return n;\n    }).forEach(function(n) {\n      return n.disconnect();\n    }), this._filters = null, this._source.connect(this._gain)), this._filters = e != null && e.length ? e.slice(0) : null, this.refresh();\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    if (this._source) {\n      var e = this._media.context, r = this._media.parent;\n      this._source.loop = this._loop || r.loop;\n      var n = e.volume * (e.muted ? 0 : 1), s = r.volume * (r.muted ? 0 : 1), a = this._volume * (this._muted ? 0 : 1);\n      ci.setParamValue(this._gain.gain, a * s * n), ci.setParamValue(this._source.playbackRate, this._speed * r.speed * e.speed), this.applyFilters();\n    }\n  }, t.prototype.applyFilters = function() {\n    var e;\n    if (!((e = this._filters) === null || e === void 0) && e.length) {\n      this._source.disconnect();\n      var r = this._source;\n      this._filters.forEach(function(n) {\n        r.connect(n.destination), r = n;\n      }), r.connect(this._gain);\n    }\n  }, t.prototype.refreshPaused = function() {\n    var e = this._media.context, r = this._media.parent, n = this._paused || r.paused || e.paused;\n    n !== this._pausedReal && (this._pausedReal = n, n ? (this._internalStop(), this.emit(\"paused\")) : (this.emit(\"resumed\"), this.play({ start: this._elapsed % this._duration, end: this._end, speed: this._speed, loop: this._loop, volume: this._volume })), this.emit(\"pause\", n));\n  }, t.prototype.play = function(e) {\n    var r = e.start, n = e.end, s = e.speed, a = e.loop, o = e.volume, u = e.muted, l = e.filters;\n    this._paused = !1;\n    var h = this._media.nodes.cloneBufferSource(), d = h.source, f = h.gain;\n    this._source = d, this._gain = f, this._speed = s, this._volume = o, this._loop = !!a, this._muted = u, this._filters = l, this.refresh();\n    var p = this._source.buffer.duration;\n    this._duration = p, this._end = n, this._lastUpdate = this._now(), this._elapsed = r, this._source.onended = this._onComplete.bind(this), this._loop ? (this._source.loopEnd = n, this._source.loopStart = r, this._source.start(0, r)) : n ? this._source.start(0, r, n - r) : this._source.start(0, r), this.emit(\"start\"), this._update(!0), this.enableTicker(!0);\n  }, t.prototype.enableTicker = function(e) {\n    Ge.shared.remove(this._updateListener, this), e && Ge.shared.add(this._updateListener, this);\n  }, Object.defineProperty(t.prototype, \"progress\", { get: function() {\n    return this._progress;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    this._paused = e, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    var e;\n    this.removeAllListeners(), this._internalStop(), this._gain && (this._gain.disconnect(), this._gain = null), this._media && (this._media.context.events.off(\"refresh\", this.refresh, this), this._media.context.events.off(\"refreshPaused\", this.refreshPaused, this), this._media = null), (e = this._filters) === null || e === void 0 || e.forEach(function(r) {\n      return r.disconnect();\n    }), this._filters = null, this._end = null, this._speed = 1, this._volume = 1, this._loop = !1, this._elapsed = 0, this._duration = 0, this._paused = !1, this._muted = !1, this._pausedReal = !1;\n  }, t.prototype.toString = function() {\n    return \"[WebAudioInstance id=\".concat(this.id, \"]\");\n  }, t.prototype._now = function() {\n    return this._media.context.audioContext.currentTime;\n  }, t.prototype._updateListener = function() {\n    this._update();\n  }, t.prototype._update = function(e) {\n    if (e === void 0 && (e = !1), this._source) {\n      var r = this._now(), n = r - this._lastUpdate;\n      if (n > 0 || e) {\n        var s = this._source.playbackRate.value;\n        this._elapsed += n * s, this._lastUpdate = r;\n        var a = this._duration, o = void 0;\n        if (this._source.loopStart) {\n          var u = this._source.loopEnd - this._source.loopStart;\n          o = (this._source.loopStart + this._elapsed % u) / a;\n        } else\n          o = this._elapsed % a / a;\n        this._progress = o, this.emit(\"progress\", this._progress, a);\n      }\n    }\n  }, t.prototype.init = function(e) {\n    this._media = e, e.context.events.on(\"refresh\", this.refresh, this), e.context.events.on(\"refreshPaused\", this.refreshPaused, this);\n  }, t.prototype._internalStop = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.stop(0), this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n      this._source = null;\n    }\n  }, t.prototype._onComplete = function() {\n    if (this._source) {\n      this.enableTicker(!1), this._source.onended = null, this._source.disconnect();\n      try {\n        this._source.buffer = null;\n      } catch {\n      }\n    }\n    this._source = null, this._progress = 1, this.emit(\"progress\", 1, this._duration), this.emit(\"end\", this);\n  }, t;\n}($r), ZS = function() {\n  function i(t, e) {\n    this._output = e, this._input = t;\n  }\n  return Object.defineProperty(i.prototype, \"destination\", { get: function() {\n    return this._input;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"filters\", { get: function() {\n    return this._filters;\n  }, set: function(t) {\n    var e = this;\n    if (this._filters && (this._filters.forEach(function(n) {\n      n && n.disconnect();\n    }), this._filters = null, this._input.connect(this._output)), t && t.length) {\n      this._filters = t.slice(0), this._input.disconnect();\n      var r = null;\n      t.forEach(function(n) {\n        r === null ? e._input.connect(n.destination) : r.connect(n.destination), r = n;\n      }), r.connect(this._output);\n    }\n  }, enumerable: !1, configurable: !0 }), i.prototype.destroy = function() {\n    this.filters = null, this._input = null, this._output = null;\n  }, i;\n}(), EA = function(i) {\n  function t(e) {\n    var r = this, n = e.audioContext, s = n.createBufferSource(), a = n.createGain(), o = n.createAnalyser();\n    return s.connect(o), o.connect(a), a.connect(e.destination), (r = i.call(this, o, a) || this).context = e, r.bufferSource = s, r.gain = a, r.analyser = o, r;\n  }\n  return ri(t, i), Object.defineProperty(t.prototype, \"script\", { get: function() {\n    return this._script || (this._script = this.context.audioContext.createScriptProcessor(t.BUFFER_SIZE), this._script.connect(this.context.destination)), this._script;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    i.prototype.destroy.call(this), this.bufferSource.disconnect(), this._script && this._script.disconnect(), this.gain.disconnect(), this.analyser.disconnect(), this.bufferSource = null, this._script = null, this.gain = null, this.analyser = null, this.context = null;\n  }, t.prototype.cloneBufferSource = function() {\n    var e = this.bufferSource, r = this.context.audioContext.createBufferSource();\n    r.buffer = e.buffer, ci.setParamValue(r.playbackRate, e.playbackRate.value), r.loop = e.loop;\n    var n = this.context.audioContext.createGain();\n    return r.connect(n), n.connect(this.destination), { source: r, gain: n };\n  }, Object.defineProperty(t.prototype, \"bufferSize\", { get: function() {\n    return this.script.bufferSize;\n  }, enumerable: !1, configurable: !0 }), t.BUFFER_SIZE = 0, t;\n}(ZS), t_ = function() {\n  function i() {\n  }\n  return i.prototype.init = function(t) {\n    this.parent = t, this._nodes = new EA(this.context), this._source = this._nodes.bufferSource, this.source = t.options.source;\n  }, i.prototype.destroy = function() {\n    this.parent = null, this._nodes.destroy(), this._nodes = null;\n    try {\n      this._source.buffer = null;\n    } catch {\n    }\n    this._source = null, this.source = null;\n  }, i.prototype.create = function() {\n    return new wA(this);\n  }, Object.defineProperty(i.prototype, \"context\", { get: function() {\n    return this.parent.context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"isPlayable\", { get: function() {\n    return !!this._source && !!this._source.buffer;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"filters\", { get: function() {\n    return this._nodes.filters;\n  }, set: function(t) {\n    this._nodes.filters = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"duration\", { get: function() {\n    return this._source.buffer.duration;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"buffer\", { get: function() {\n    return this._source.buffer;\n  }, set: function(t) {\n    this._source.buffer = t;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"nodes\", { get: function() {\n    return this._nodes;\n  }, enumerable: !1, configurable: !0 }), i.prototype.load = function(t) {\n    this.source ? this._decode(this.source, t) : this.parent.url ? this._loadUrl(t) : t && t(new Error(\"sound.url or sound.source must be set\"));\n  }, i.prototype._loadUrl = function(t) {\n    var e = this, r = new XMLHttpRequest(), n = this.parent.url;\n    r.open(\"GET\", n, !0), r.responseType = \"arraybuffer\", r.onload = function() {\n      e.source = r.response, e._decode(r.response, t);\n    }, r.send();\n  }, i.prototype._decode = function(t, e) {\n    var r = this, n = function(s, a) {\n      if (s)\n        e && e(s);\n      else {\n        r.parent.isLoaded = !0, r.buffer = a;\n        var o = r.parent.autoPlayStart();\n        e && e(null, r.parent, o);\n      }\n    };\n    t instanceof AudioBuffer ? n(null, t) : this.parent.context.decode(t, n);\n  }, i;\n}(), Fu = function() {\n  function i(t, e) {\n    this.media = t, this.options = e, this._instances = [], this._sprites = {}, this.media.init(this);\n    var r = e.complete;\n    this._autoPlayOptions = r ? { complete: r } : null, this.isLoaded = !1, this.isPlaying = !1, this.autoPlay = e.autoPlay, this.singleInstance = e.singleInstance, this.preload = e.preload || this.autoPlay, this.url = e.url, this.speed = e.speed, this.volume = e.volume, this.loop = e.loop, e.sprites && this.addSprites(e.sprites), this.preload && this._preload(e.loaded);\n  }\n  return i.from = function(t) {\n    var e = {};\n    return typeof t == \"string\" ? e.url = t : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? e.source = t : e = t, (e = tu({ autoPlay: !1, singleInstance: !1, url: null, source: null, preload: !1, volume: 1, speed: 1, complete: null, loaded: null, loop: !1 }, e)).url && (e.url = nx(e.url)), Object.freeze(e), new i(Ae().useLegacy ? new _A() : new t_(), e);\n  }, Object.defineProperty(i.prototype, \"context\", { get: function() {\n    return Ae().context;\n  }, enumerable: !1, configurable: !0 }), i.prototype.pause = function() {\n    return this.isPlaying = !1, this.paused = !0, this;\n  }, i.prototype.resume = function() {\n    return this.isPlaying = this._instances.length > 0, this.paused = !1, this;\n  }, Object.defineProperty(i.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(t) {\n    this._paused = t, this.refreshPaused();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"speed\", { get: function() {\n    return this._speed;\n  }, set: function(t) {\n    this._speed = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"filters\", { get: function() {\n    return this.media.filters;\n  }, set: function(t) {\n    this.media.filters = t;\n  }, enumerable: !1, configurable: !0 }), i.prototype.addSprites = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var n in t)\n        r[n] = this.addSprites(n, t[n]);\n      return r;\n    }\n    var s = new bA(this, e);\n    return this._sprites[t] = s, s;\n  }, i.prototype.destroy = function() {\n    this._removeInstances(), this.removeSprites(), this.media.destroy(), this.media = null, this._sprites = null, this._instances = null;\n  }, i.prototype.removeSprites = function(t) {\n    if (t) {\n      var e = this._sprites[t];\n      e !== void 0 && (e.destroy(), delete this._sprites[t]);\n    } else\n      for (var r in this._sprites)\n        this.removeSprites(r);\n    return this;\n  }, Object.defineProperty(i.prototype, \"isPlayable\", { get: function() {\n    return this.isLoaded && this.media && this.media.isPlayable;\n  }, enumerable: !1, configurable: !0 }), i.prototype.stop = function() {\n    if (!this.isPlayable)\n      return this.autoPlay = !1, this._autoPlayOptions = null, this;\n    this.isPlaying = !1;\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._instances[t].stop();\n    return this;\n  }, i.prototype.play = function(t, e) {\n    var r, n = this;\n    if (typeof t == \"string\" ? r = { sprite: a = t, loop: this.loop, complete: e } : typeof t == \"function\" ? (r = {}).complete = t : r = t, (r = tu({ complete: null, loaded: null, sprite: null, end: null, start: 0, volume: 1, speed: 1, muted: !1, loop: !1 }, r || {})).sprite) {\n      var s = r.sprite, a = this._sprites[s];\n      r.start = a.start + (r.start || 0), r.end = a.end, r.speed = a.speed || 1, r.loop = a.loop || r.loop, delete r.sprite;\n    }\n    if (r.offset && (r.start = r.offset), !this.isLoaded)\n      return new Promise(function(u, l) {\n        n.autoPlay = !0, n._autoPlayOptions = r, n._preload(function(h, d, f) {\n          h ? l(h) : (r.loaded && r.loaded(h, d, f), u(f));\n        });\n      });\n    (this.singleInstance || r.singleInstance) && this._removeInstances();\n    var o = this._createInstance();\n    return this._instances.push(o), this.isPlaying = !0, o.once(\"end\", function() {\n      r.complete && r.complete(n), n._onComplete(o);\n    }), o.once(\"stop\", function() {\n      n._onComplete(o);\n    }), o.play(r), o;\n  }, i.prototype.refresh = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refresh();\n  }, i.prototype.refreshPaused = function() {\n    for (var t = this._instances.length, e = 0; e < t; e++)\n      this._instances[e].refreshPaused();\n  }, Object.defineProperty(i.prototype, \"volume\", { get: function() {\n    return this._volume;\n  }, set: function(t) {\n    this._volume = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"muted\", { get: function() {\n    return this._muted;\n  }, set: function(t) {\n    this._muted = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"loop\", { get: function() {\n    return this._loop;\n  }, set: function(t) {\n    this._loop = t, this.refresh();\n  }, enumerable: !1, configurable: !0 }), i.prototype._preload = function(t) {\n    this.media.load(t);\n  }, Object.defineProperty(i.prototype, \"instances\", { get: function() {\n    return this._instances;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"sprites\", { get: function() {\n    return this._sprites;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"duration\", { get: function() {\n    return this.media.duration;\n  }, enumerable: !1, configurable: !0 }), i.prototype.autoPlayStart = function() {\n    var t;\n    return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;\n  }, i.prototype._removeInstances = function() {\n    for (var t = this._instances.length - 1; t >= 0; t--)\n      this._poolInstance(this._instances[t]);\n    this._instances.length = 0;\n  }, i.prototype._onComplete = function(t) {\n    if (this._instances) {\n      var e = this._instances.indexOf(t);\n      e > -1 && this._instances.splice(e, 1), this.isPlaying = this._instances.length > 0;\n    }\n    this._poolInstance(t);\n  }, i.prototype._createInstance = function() {\n    if (i._pool.length > 0) {\n      var t = i._pool.pop();\n      return t.init(this.media), t;\n    }\n    return this.media.create();\n  }, i.prototype._poolInstance = function(t) {\n    t.destroy(), i._pool.indexOf(t) < 0 && i._pool.push(t);\n  }, i._pool = [], i;\n}(), SA = function(i) {\n  function t() {\n    var e = i !== null && i.apply(this, arguments) || this;\n    return e.speed = 1, e.muted = !1, e.volume = 1, e.paused = !1, e;\n  }\n  return ri(t, i), t.prototype.refresh = function() {\n    this.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.emit(\"refreshPaused\");\n  }, Object.defineProperty(t.prototype, \"filters\", { get: function() {\n    return null;\n  }, set: function(e) {\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this.paused;\n  }, t.prototype.destroy = function() {\n    this.removeAllListeners();\n  }, t;\n}($r), sw = function(i) {\n  function t() {\n    var e = this, r = window, n = new t.AudioContext(), s = n.createDynamicsCompressor(), a = n.createAnalyser();\n    return a.connect(s), s.connect(n.destination), (e = i.call(this, a, s) || this)._ctx = n, e._offlineCtx = new t.OfflineAudioContext(1, 2, r.OfflineAudioContext ? Math.max(8e3, Math.min(96e3, n.sampleRate)) : 44100), e.compressor = s, e.analyser = a, e.events = new $r(), e.volume = 1, e.speed = 1, e.muted = !1, e.paused = !1, e._locked = n.state === \"suspended\" && (\"ontouchstart\" in globalThis || \"onclick\" in globalThis), e._locked && (e._unlock(), e._unlock = e._unlock.bind(e), document.addEventListener(\"mousedown\", e._unlock, !0), document.addEventListener(\"touchstart\", e._unlock, !0), document.addEventListener(\"touchend\", e._unlock, !0)), e.onFocus = e.onFocus.bind(e), e.onBlur = e.onBlur.bind(e), globalThis.addEventListener(\"focus\", e.onFocus), globalThis.addEventListener(\"blur\", e.onBlur), e;\n  }\n  return ri(t, i), t.prototype.onFocus = function() {\n    var e = this._ctx.state;\n    e !== \"suspended\" && e !== \"interrupted\" && this._locked || this._ctx.resume();\n  }, t.prototype.onBlur = function() {\n    this._locked || this._ctx.suspend();\n  }, t.prototype._unlock = function() {\n    this._locked && (this.playEmptySound(), this._ctx.state === \"running\" && (document.removeEventListener(\"mousedown\", this._unlock, !0), document.removeEventListener(\"touchend\", this._unlock, !0), document.removeEventListener(\"touchstart\", this._unlock, !0), this._locked = !1));\n  }, t.prototype.playEmptySound = function() {\n    var e = this._ctx.createBufferSource();\n    e.buffer = this._ctx.createBuffer(1, 1, 22050), e.connect(this._ctx.destination), e.start(0, 0, 0), e.context.state === \"suspended\" && e.context.resume();\n  }, Object.defineProperty(t, \"AudioContext\", { get: function() {\n    var e = window;\n    return e.AudioContext || e.webkitAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, \"OfflineAudioContext\", { get: function() {\n    var e = window;\n    return e.OfflineAudioContext || e.webkitOfflineAudioContext || null;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    i.prototype.destroy.call(this);\n    var e = this._ctx;\n    e.close !== void 0 && e.close(), globalThis.removeEventListener(\"focus\", this.onFocus), globalThis.removeEventListener(\"blur\", this.onBlur), this.events.removeAllListeners(), this.analyser.disconnect(), this.compressor.disconnect(), this.analyser = null, this.compressor = null, this.events = null, this._offlineCtx = null, this._ctx = null;\n  }, Object.defineProperty(t.prototype, \"audioContext\", { get: function() {\n    return this._ctx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"offlineContext\", { get: function() {\n    return this._offlineCtx;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"paused\", { get: function() {\n    return this._paused;\n  }, set: function(e) {\n    e && this._ctx.state === \"running\" ? this._ctx.suspend() : e || this._ctx.state !== \"suspended\" || this._ctx.resume(), this._paused = e;\n  }, enumerable: !1, configurable: !0 }), t.prototype.refresh = function() {\n    this.events.emit(\"refresh\");\n  }, t.prototype.refreshPaused = function() {\n    this.events.emit(\"refreshPaused\");\n  }, t.prototype.toggleMute = function() {\n    return this.muted = !this.muted, this.refresh(), this.muted;\n  }, t.prototype.togglePause = function() {\n    return this.paused = !this.paused, this.refreshPaused(), this._paused;\n  }, t.prototype.decode = function(e, r) {\n    var n = function(a) {\n      r(new Error((a == null ? void 0 : a.message) || \"Unable to decode file\"));\n    }, s = this._offlineCtx.decodeAudioData(e, function(a) {\n      r(null, a);\n    }, n);\n    s && s.catch(n);\n  }, t;\n}(ZS), TA = function() {\n  function i() {\n    this.init();\n  }\n  return i.prototype.init = function() {\n    return this.supported && (this._webAudioContext = new sw()), this._htmlAudioContext = new SA(), this._sounds = {}, this.useLegacy = !this.supported, this;\n  }, Object.defineProperty(i.prototype, \"context\", { get: function() {\n    return this._context;\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"filtersAll\", { get: function() {\n    return this.useLegacy ? [] : this._context.filters;\n  }, set: function(t) {\n    this.useLegacy || (this._context.filters = t);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"supported\", { get: function() {\n    return sw.AudioContext !== null;\n  }, enumerable: !1, configurable: !0 }), i.prototype.add = function(t, e) {\n    if (typeof t == \"object\") {\n      var r = {};\n      for (var n in t) {\n        var s = this._getOptions(t[n], e);\n        r[n] = this.add(n, s);\n      }\n      return r;\n    }\n    if (e instanceof Fu)\n      return this._sounds[t] = e, e;\n    var a = this._getOptions(e), o = Fu.from(a);\n    return this._sounds[t] = o, o;\n  }, i.prototype._getOptions = function(t, e) {\n    var r;\n    return r = typeof t == \"string\" ? { url: t } : t instanceof ArrayBuffer || t instanceof AudioBuffer || t instanceof HTMLAudioElement ? { source: t } : t, r = tu(tu({}, r), e || {});\n  }, Object.defineProperty(i.prototype, \"useLegacy\", { get: function() {\n    return this._useLegacy;\n  }, set: function(t) {\n    Qy.setLegacy(t), this._useLegacy = t, this._context = !t && this.supported ? this._webAudioContext : this._htmlAudioContext;\n  }, enumerable: !1, configurable: !0 }), i.prototype.remove = function(t) {\n    return this.exists(t, !0), this._sounds[t].destroy(), delete this._sounds[t], this;\n  }, Object.defineProperty(i.prototype, \"volumeAll\", { get: function() {\n    return this._context.volume;\n  }, set: function(t) {\n    this._context.volume = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(i.prototype, \"speedAll\", { get: function() {\n    return this._context.speed;\n  }, set: function(t) {\n    this._context.speed = t, this._context.refresh();\n  }, enumerable: !1, configurable: !0 }), i.prototype.togglePauseAll = function() {\n    return this._context.togglePause();\n  }, i.prototype.pauseAll = function() {\n    return this._context.paused = !0, this._context.refreshPaused(), this;\n  }, i.prototype.resumeAll = function() {\n    return this._context.paused = !1, this._context.refreshPaused(), this;\n  }, i.prototype.toggleMuteAll = function() {\n    return this._context.toggleMute();\n  }, i.prototype.muteAll = function() {\n    return this._context.muted = !0, this._context.refresh(), this;\n  }, i.prototype.unmuteAll = function() {\n    return this._context.muted = !1, this._context.refresh(), this;\n  }, i.prototype.removeAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].destroy(), delete this._sounds[t];\n    return this;\n  }, i.prototype.stopAll = function() {\n    for (var t in this._sounds)\n      this._sounds[t].stop();\n    return this;\n  }, i.prototype.exists = function(t, e) {\n    return !!this._sounds[t];\n  }, i.prototype.find = function(t) {\n    return this.exists(t, !0), this._sounds[t];\n  }, i.prototype.play = function(t, e) {\n    return this.find(t).play(e);\n  }, i.prototype.stop = function(t) {\n    return this.find(t).stop();\n  }, i.prototype.pause = function(t) {\n    return this.find(t).pause();\n  }, i.prototype.resume = function(t) {\n    return this.find(t).resume();\n  }, i.prototype.volume = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.volume = e), r.volume;\n  }, i.prototype.speed = function(t, e) {\n    var r = this.find(t);\n    return e !== void 0 && (r.speed = e), r.speed;\n  }, i.prototype.duration = function(t) {\n    return this.find(t).duration;\n  }, i.prototype.close = function() {\n    return this.removeAll(), this._sounds = null, this._webAudioContext && (this._webAudioContext.destroy(), this._webAudioContext = null), this._htmlAudioContext && (this._htmlAudioContext.destroy(), this._htmlAudioContext = null), this._context = null, this;\n  }, i;\n}(), Is = function() {\n  function i(t, e) {\n    this.init(t, e);\n  }\n  return i.prototype.init = function(t, e) {\n    this.destination = t, this.source = e || t;\n  }, i.prototype.connect = function(t) {\n    this.source.connect(t);\n  }, i.prototype.disconnect = function() {\n    this.source.disconnect();\n  }, i.prototype.destroy = function() {\n    this.disconnect(), this.destination = null, this.source = null;\n  }, i;\n}(), up = { __proto__: null, Filter: Is, EqualizerFilter: function(i) {\n  function t(e, r, n, s, a, o, u, l, h, d) {\n    e === void 0 && (e = 0), r === void 0 && (r = 0), n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = 0), o === void 0 && (o = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), d === void 0 && (d = 0);\n    var f = this;\n    if (!Ae().useLegacy) {\n      var p = [{ f: t.F32, type: \"lowshelf\", gain: e }, { f: t.F64, type: \"peaking\", gain: r }, { f: t.F125, type: \"peaking\", gain: n }, { f: t.F250, type: \"peaking\", gain: s }, { f: t.F500, type: \"peaking\", gain: a }, { f: t.F1K, type: \"peaking\", gain: o }, { f: t.F2K, type: \"peaking\", gain: u }, { f: t.F4K, type: \"peaking\", gain: l }, { f: t.F8K, type: \"peaking\", gain: h }, { f: t.F16K, type: \"highshelf\", gain: d }].map(function(m) {\n        var y = Ae().context.audioContext.createBiquadFilter();\n        return y.type = m.type, ci.setParamValue(y.Q, 1), y.frequency.value = m.f, ci.setParamValue(y.gain, m.gain), y;\n      });\n      (f = i.call(this, p[0], p[p.length - 1]) || this).bands = p, f.bandsMap = {};\n      for (var v = 0; v < f.bands.length; v++) {\n        var g = f.bands[v];\n        v > 0 && f.bands[v - 1].connect(g), f.bandsMap[g.frequency.value] = g;\n      }\n      return f;\n    }\n    f = i.call(this, null) || this;\n  }\n  return ri(t, i), t.prototype.setGain = function(e, r) {\n    if (r === void 0 && (r = 0), !this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    ci.setParamValue(this.bandsMap[e].gain, r);\n  }, t.prototype.getGain = function(e) {\n    if (!this.bandsMap[e])\n      throw new Error(\"No band found for frequency \".concat(e));\n    return this.bandsMap[e].gain.value;\n  }, Object.defineProperty(t.prototype, \"f32\", { get: function() {\n    return this.getGain(t.F32);\n  }, set: function(e) {\n    this.setGain(t.F32, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f64\", { get: function() {\n    return this.getGain(t.F64);\n  }, set: function(e) {\n    this.setGain(t.F64, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f125\", { get: function() {\n    return this.getGain(t.F125);\n  }, set: function(e) {\n    this.setGain(t.F125, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f250\", { get: function() {\n    return this.getGain(t.F250);\n  }, set: function(e) {\n    this.setGain(t.F250, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f500\", { get: function() {\n    return this.getGain(t.F500);\n  }, set: function(e) {\n    this.setGain(t.F500, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f1k\", { get: function() {\n    return this.getGain(t.F1K);\n  }, set: function(e) {\n    this.setGain(t.F1K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f2k\", { get: function() {\n    return this.getGain(t.F2K);\n  }, set: function(e) {\n    this.setGain(t.F2K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f4k\", { get: function() {\n    return this.getGain(t.F4K);\n  }, set: function(e) {\n    this.setGain(t.F4K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f8k\", { get: function() {\n    return this.getGain(t.F8K);\n  }, set: function(e) {\n    this.setGain(t.F8K, e);\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"f16k\", { get: function() {\n    return this.getGain(t.F16K);\n  }, set: function(e) {\n    this.setGain(t.F16K, e);\n  }, enumerable: !1, configurable: !0 }), t.prototype.reset = function() {\n    this.bands.forEach(function(e) {\n      ci.setParamValue(e.gain, 0);\n    });\n  }, t.prototype.destroy = function() {\n    this.bands.forEach(function(e) {\n      e.disconnect();\n    }), this.bands = null, this.bandsMap = null;\n  }, t.F32 = 32, t.F64 = 64, t.F125 = 125, t.F250 = 250, t.F500 = 500, t.F1K = 1e3, t.F2K = 2e3, t.F4K = 4e3, t.F8K = 8e3, t.F16K = 16e3, t;\n}(Is), DistortionFilter: function(i) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!Ae().useLegacy) {\n      var n = Ae().context.audioContext.createWaveShaper();\n      return (r = i.call(this, n) || this)._distortion = n, r.amount = e, r;\n    }\n    r = i.call(this, null) || this;\n  }\n  return ri(t, i), Object.defineProperty(t.prototype, \"amount\", { get: function() {\n    return this._amount;\n  }, set: function(e) {\n    this._amount = e;\n    for (var r, n = 1e3 * e, s = 44100, a = new Float32Array(s), o = Math.PI / 180, u = 0; u < s; ++u)\n      r = 2 * u / s - 1, a[u] = (3 + n) * r * 20 * o / (Math.PI + n * Math.abs(r));\n    this._distortion.curve = a, this._distortion.oversample = \"4x\";\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._distortion = null, i.prototype.destroy.call(this);\n  }, t;\n}(Is), StereoFilter: function(i) {\n  function t(e) {\n    e === void 0 && (e = 0);\n    var r = this;\n    if (!Ae().useLegacy) {\n      var n, s, a, o = Ae().context.audioContext;\n      return o.createStereoPanner ? a = n = o.createStereoPanner() : ((s = o.createPanner()).panningModel = \"equalpower\", a = s), (r = i.call(this, a) || this)._stereo = n, r._panner = s, r.pan = e, r;\n    }\n    r = i.call(this, null) || this;\n  }\n  return ri(t, i), Object.defineProperty(t.prototype, \"pan\", { get: function() {\n    return this._pan;\n  }, set: function(e) {\n    this._pan = e, this._stereo ? ci.setParamValue(this._stereo.pan, e) : this._panner.setPosition(e, 0, 1 - Math.abs(e));\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    i.prototype.destroy.call(this), this._stereo = null, this._panner = null;\n  }, t;\n}(Is), ReverbFilter: function(i) {\n  function t(e, r, n) {\n    e === void 0 && (e = 3), r === void 0 && (r = 2), n === void 0 && (n = !1);\n    var s = this;\n    if (!Ae().useLegacy)\n      return (s = i.call(this, null) || this)._seconds = s._clamp(e, 1, 50), s._decay = s._clamp(r, 0, 100), s._reverse = n, s._rebuild(), s;\n    s = i.call(this, null) || this;\n  }\n  return ri(t, i), t.prototype._clamp = function(e, r, n) {\n    return Math.min(n, Math.max(r, e));\n  }, Object.defineProperty(t.prototype, \"seconds\", { get: function() {\n    return this._seconds;\n  }, set: function(e) {\n    this._seconds = this._clamp(e, 1, 50), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"decay\", { get: function() {\n    return this._decay;\n  }, set: function(e) {\n    this._decay = this._clamp(e, 0, 100), this._rebuild();\n  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, \"reverse\", { get: function() {\n    return this._reverse;\n  }, set: function(e) {\n    this._reverse = e, this._rebuild();\n  }, enumerable: !1, configurable: !0 }), t.prototype._rebuild = function() {\n    for (var e, r = Ae().context.audioContext, n = r.sampleRate, s = n * this._seconds, a = r.createBuffer(2, s, n), o = a.getChannelData(0), u = a.getChannelData(1), l = 0; l < s; l++)\n      e = this._reverse ? s - l : l, o[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay), u[l] = (2 * Math.random() - 1) * Math.pow(1 - e / s, this._decay);\n    var h = Ae().context.audioContext.createConvolver();\n    h.buffer = a, this.init(h);\n  }, t;\n}(Is), MonoFilter: function(i) {\n  function t() {\n    var e = this;\n    if (!Ae().useLegacy) {\n      var r = Ae().context.audioContext, n = r.createChannelSplitter(), s = r.createChannelMerger();\n      return s.connect(n), (e = i.call(this, s, n) || this)._merger = s, e;\n    }\n    e = i.call(this, null) || this;\n  }\n  return ri(t, i), t.prototype.destroy = function() {\n    this._merger.disconnect(), this._merger = null, i.prototype.destroy.call(this);\n  }, t;\n}(Is), StreamFilter: function(i) {\n  function t() {\n    var e = this;\n    if (!Ae().useLegacy) {\n      var r = Ae().context.audioContext, n = r.createMediaStreamDestination(), s = r.createMediaStreamSource(n.stream);\n      return (e = i.call(this, n, s) || this)._stream = n.stream, e;\n    }\n    e = i.call(this, null) || this;\n  }\n  return ri(t, i), Object.defineProperty(t.prototype, \"stream\", { get: function() {\n    return this._stream;\n  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {\n    this._stream = null, i.prototype.destroy.call(this);\n  }, t;\n}(Is), TelephoneFilter: function(i) {\n  function t() {\n    if (!Ae().useLegacy) {\n      var e = Ae().context.audioContext, r = e.createBiquadFilter(), n = e.createBiquadFilter(), s = e.createBiquadFilter(), a = e.createBiquadFilter();\n      return r.type = \"lowpass\", ci.setParamValue(r.frequency, 2e3), n.type = \"lowpass\", ci.setParamValue(n.frequency, 2e3), s.type = \"highpass\", ci.setParamValue(s.frequency, 500), a.type = \"highpass\", ci.setParamValue(a.frequency, 500), r.connect(n), n.connect(s), s.connect(a), i.call(this, r, a) || this;\n    }\n    i.call(this, null);\n  }\n  return ri(t, i), t;\n}(Is) }, aw = 0, CA = { __proto__: null, playOnce: function(i, t) {\n  var e = \"alias\".concat(aw++);\n  return Ae().add(e, { url: i, preload: !0, autoPlay: !0, loaded: function(r) {\n    r && (Ae().remove(e), t && t(r));\n  }, complete: function() {\n    Ae().remove(e), t && t(null);\n  } }), e;\n}, get PLAY_ID() {\n  return aw;\n}, render: function(i, t) {\n  var e = document.createElement(\"canvas\");\n  t = tu({ width: 512, height: 128, fill: \"black\" }, t || {}), e.width = t.width, e.height = t.height;\n  var r = Kt.from(e);\n  if (!(i.media instanceof t_))\n    return r;\n  var n = i.media, s = e.getContext(\"2d\");\n  s.fillStyle = t.fill;\n  for (var a = n.buffer.getChannelData(0), o = Math.ceil(a.length / t.width), u = t.height / 2, l = 0; l < t.width; l++) {\n    for (var h = 1, d = -1, f = 0; f < o; f++) {\n      var p = a[l * o + f];\n      p < h && (h = p), p > d && (d = p);\n    }\n    s.fillRect(l, (1 + h) * u, 1, Math.max(1, (d - h) * u));\n  }\n  return r;\n}, resolveUrl: nx, sineTone: function(i, t) {\n  i === void 0 && (i = 200), t === void 0 && (t = 1);\n  var e = Fu.from({ singleInstance: !0 });\n  if (!(e.media instanceof t_))\n    return e;\n  for (var r = e.media, n = e.context.audioContext.createBuffer(1, 48e3 * t, 48e3), s = n.getChannelData(0), a = 0; a < s.length; a++) {\n    var o = i * (a / n.sampleRate) * Math.PI;\n    s[a] = 2 * Math.sin(o);\n  }\n  return r.buffer = n, e.isLoaded = !0, e;\n}, validateFormats: qS, supported: a0, extensions: ix }, Vn = function(i) {\n  return WS = i, i;\n}(new TA());\n\"extensions\" in N2 ? an.add(Qy) : ii.registerPlugin(Qy);\nvar Ie, hr, Us, sg, KS, Yu, Up, ag, JS, og, QS, Hc, e_, Wa, Ih, $c, r_, qu, Zu, jp, Vc, i_, Xc, Ku, zp, ug, tT, ln, Ns, lg, eT, Wc, n_, Ya, Rh, hg, rT, Yc, s_, cg, iT, fg, nT, Ju, Hp;\nconst ec = class {\n  constructor(t, e, r, n, s) {\n    // 音量設定（独自拡張）\n    E(this, sg);\n    E(this, Yu);\n    // BGM/効果音のフェードアウト（loadから使うのでマクロ化禁止）\n    E(this, ag);\n    // 効果音のフェードアウト（loadから使うのでマクロ化禁止）\n    E(this, og);\n    // BGMのフェード（loadから使うのでマクロ化禁止）\n    E(this, Hc);\n    // 効果音のフェード\n    E(this, Wa);\n    // BGM の演奏\n    E(this, $c);\n    E(this, Zu);\n    E(this, Vc);\n    // 全効果音再生の停止\n    E(this, Ku);\n    // BGM 演奏の停止（loadから使うのでマクロ化禁止）\n    E(this, ug);\n    // 効果音再生の停止\n    E(this, ln);\n    // BGM フェードの終了待ち\n    E(this, lg);\n    // 効果音フェードの終了待ち\n    E(this, Wc);\n    // 音声フェードの停止\n    E(this, Ya);\n    // BGM 再生の終了待ち\n    E(this, hg);\n    // 効果音再生の終了待ち\n    E(this, Yc);\n    // 再生トラックの交換\n    E(this, cg);\n    E(this, fg);\n    E(this, Ju);\n    E(this, Ie, {});\n    E(this, hr, {});\n    E(this, Us, void 0);\n    E(this, Xc, () => {\n      Vn.volumeAll = Number(this.val.getVal(\"sys:sn.sound.global_volume\", 1)), P(this, Xc, () => {\n      });\n    });\n    this.cfg = t, this.val = r, this.main = n, this.sys = s, e.volume = (a) => O(this, sg, KS).call(this, a), e.fadebgm = (a) => O(this, Hc, e_).call(this, a), e.fadeoutbgm = (a) => O(this, ag, JS).call(this, a), e.fadeoutse = (a) => O(this, og, QS).call(this, a), e.fadese = (a) => O(this, Wa, Ih).call(this, a), e.playbgm = (a) => O(this, $c, r_).call(this, a), e.playse = (a) => O(this, Zu, jp).call(this, a), e.stop_allse = () => O(this, Ku, zp).call(this), e.stopbgm = (a) => O(this, ug, tT).call(this, a), e.stopse = (a) => O(this, ln, Ns).call(this, a), e.wb = (a) => O(this, lg, eT).call(this, a), e.wf = (a) => O(this, Wc, n_).call(this, a), e.stopfadese = (a) => O(this, Ya, Rh).call(this, a), e.wl = (a) => O(this, hg, rT).call(this, a), e.ws = (a) => O(this, Yc, s_).call(this, a), e.xchgbuf = (a) => O(this, cg, iT).call(this, a), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", \"{}\"), r.setVal_Nochk(\"tmp\", \"const.sn.sound.codecs\", JSON.stringify(CA.supported));\n  }\n  setEvtMng(t) {\n    P(this, Us, t);\n  }\n  setNoticeChgVolume(t, e) {\n    this.val.defValTrg(\"sys:sn.sound.global_volume\", (r, n) => t(Vn.volumeAll = Number(n))), this.val.defValTrg(\"sys:sn.sound.movie_volume\", (r, n) => e(Number(n))), this.val.setVal_Nochk(\"sys\", \"sn.sound.global_volume\", this.val.getVal(\"sys:sn.sound.global_volume\", 1)), this.val.setVal_Nochk(\"sys\", \"sn.sound.movie_volume\", this.val.getVal(\"sys:sn.sound.movie_volume\", 1));\n  }\n  clearCache() {\n    Vn.removeAll();\n  }\n  // しおりの読込（BGM状態復元）\n  playLoopFromSaveObj() {\n    const t = String(this.val.getVal(\"save:const.sn.loopPlaying\", \"{}\"));\n    if (this.val.flush(), t === \"{}\") {\n      O(this, Ku, zp).call(this);\n      return;\n    }\n    P(this, hr, JSON.parse(t));\n    const e = Object.keys(c(this, hr)).map((r) => () => {\n      const n = \"save:const.sn.sound.\" + r + \".\", s = {\n        fn: String(this.val.getVal(n + \"fn\")),\n        buf: r,\n        join: !1,\n        loop: !0,\n        volume: Number(this.val.getVal(n + \"volume\")),\n        start_ms: Number(this.val.getVal(n + \"start_ms\")),\n        end_ms: Number(this.val.getVal(n + \"end_ms\")),\n        ret_ms: Number(this.val.getVal(n + \"ret_ms\"))\n      };\n      s.buf === \"BGM\" ? O(this, $c, r_).call(this, s) : O(this, Zu, jp).call(this, s);\n    });\n    O(this, Ku, zp).call(this);\n    for (const r of e)\n      r();\n  }\n};\nlet Gp = ec;\nIe = new WeakMap(), hr = new WeakMap(), Us = new WeakMap(), sg = new WeakSet(), KS = function(t) {\n  const { buf: e = \"SE\" } = t, r = \"const.sn.sound.\" + e + \".volume\", n = O(this, Yu, Up).call(this, t, 1);\n  return Number(this.val.getVal(\"sys:\" + r)) === n ? !1 : (this.val.setVal_Nochk(\"sys\", r, n), this.val.flush(), t.time = 0, t.volume = Number(this.val.getVal(\"save:\" + r)), O(this, Wa, Ih).call(this, t));\n}, Yu = new WeakSet(), Up = function(t, e) {\n  const r = tt(t, \"volume\", e);\n  return r < 0 ? 0 : r > 1 ? 1 : r;\n}, ag = new WeakSet(), JS = function(t) {\n  return t.volume = 0, O(this, Hc, e_).call(this, t);\n}, og = new WeakSet(), QS = function(t) {\n  return t.volume = 0, O(this, Wa, Ih).call(this, t);\n}, Hc = new WeakSet(), e_ = function(t) {\n  return t.buf = \"BGM\", O(this, Wa, Ih).call(this, t);\n}, Wa = new WeakSet(), Ih = function(t) {\n  O(this, Ya, Rh).call(this, t);\n  const { buf: e = \"SE\" } = t, r = c(this, Ie)[e];\n  if (!(r != null && r.playing()) || !r.snd)\n    return !1;\n  const n = \"const.sn.sound.\" + e + \".\", s = n + \"volume\", a = O(this, Yu, Up).call(this, t, NaN);\n  this.val.setVal_Nochk(\"save\", s, a);\n  const o = a * Number(this.val.getVal(\"sys:\" + s, 1)), u = vt(t, \"stop\", a === 0);\n  u && (O(this, Ju, Hp).call(this, e), this.val.setVal_Nochk(\"save\", n + \"fn\", \"\")), this.val.flush();\n  const l = tt(t, \"time\", NaN), h = tt(t, \"delay\", 0);\n  if (l === 0 && h === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || c(this, Us).isSkippingByKeyDown())\n    return r.snd.volume = o, u && O(this, ln, Ns).call(this, t), !1;\n  const d = tt(t, \"repeat\", 1);\n  return r.updFade = (f) => r.snd.volume = f, r.twFade = new Tn({ v: r.snd.volume }).to({ v: o }, l).delay(h).easing(ws.ease(t.ease)).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(vt(t, \"yoyo\", !1)).onUpdate(({ v: f }) => r.updFade(f)).onComplete(() => {\n    const f = c(this, Ie)[r.now_buf];\n    (f == null ? void 0 : f.twFade) !== void 0 && (f.updFade = () => {\n    }, pA(f.twFade), delete f.twFade, u && (t.buf = r.now_buf, O(this, ln, Ns).call(this, t)), f.resumeFade && this.main.resume());\n  }).start(), !1;\n}, $c = new WeakSet(), r_ = function(t) {\n  return t.buf = \"BGM\", t.canskip = !1, vt(t, \"loop\", !0), O(this, Zu, jp).call(this, t);\n}, qu = new WeakMap(), Zu = new WeakSet(), jp = function(t) {\n  const { buf: e = \"SE\", fn: r } = t;\n  if (O(this, ln, Ns).call(this, { buf: e }), !r)\n    throw `[playse] fnは必須です buf:${e}`;\n  if (vt(t, \"canskip\", !0) && c(this, Us).isSkippingByKeyDown())\n    return !1;\n  const n = vt(t, \"loop\", !1);\n  O(this, fg, nT).call(this, e, n);\n  const s = \"const.sn.sound.\" + e + \".\";\n  this.val.setVal_Nochk(\"save\", s + \"fn\", r);\n  const a = O(this, Yu, Up).call(this, t, 1);\n  this.val.setVal_Nochk(\"save\", s + \"volume\", a);\n  const o = a * Number(this.val.getVal(\"sys:\" + s + \"volume\", 1)), u = tt(t, \"start_ms\", 0), l = tt(t, \"end_ms\", c(ec, qu)), h = tt(t, \"ret_ms\", 0), d = tt(t, \"pan\", 0), f = tt(t, \"speed\", 1);\n  if (u < 0)\n    throw `[playse] start_ms:${u} が負の値です`;\n  if (h < 0)\n    throw `[playse] ret_ms:${h} が負の値です`;\n  if (l > 0) {\n    if (u >= l)\n      throw `[playse] start_ms:${u} >= end_ms:${l} は異常値です`;\n    if (h >= l)\n      throw `[playse] ret_ms:${h} >= end_ms:${l} は異常値です`;\n  }\n  this.val.setVal_Nochk(\"save\", s + \"start_ms\", u), this.val.setVal_Nochk(\"save\", s + \"end_ms\", l), this.val.setVal_Nochk(\"save\", s + \"ret_ms\", h), this.val.flush();\n  const p = Vn.find(r), v = c(this, Ie)[e] = {\n    now_buf: e,\n    snd: p,\n    loop: n,\n    start_ms: u,\n    end_ms: l,\n    ret_ms: h,\n    resume: !1,\n    pan: d,\n    playing: () => !0,\n    // [ws]的にはここでtrueが欲しい\n    updFade: () => {\n    },\n    onend: () => {\n      const _ = v.now_buf, b = c(this, Ie)[_];\n      if (!b)\n        return;\n      delete c(this, Ie)[_], b.playing = () => !1;\n      const w = \"const.sn.sound.\" + _ + \".\";\n      this.val.setVal_Nochk(\"tmp\", w + \"playing\", !1), t.buf = _, O(this, Ya, Rh).call(this, t), b.resume && this.main.resume();\n    }\n  };\n  this.val.setVal_Nochk(\"tmp\", s + \"playing\", !0);\n  const g = {\n    loop: n,\n    speed: f,\n    volume: o,\n    loaded: (_, b) => {\n      if (_) {\n        this.main.errScript(`Sound ロード失敗ですa fn:${r} ${_}`, !1);\n        return;\n      }\n      if (!b)\n        return;\n      const w = c(this, Ie)[v.now_buf];\n      w && (w.snd = b);\n    }\n  };\n  let m = \"\";\n  if (u > 0 || l < c(ec, qu)) {\n    m = `${r};${u};${l};${h}`;\n    const _ = (g.sprites ?? (g.sprites = {}))[m] = {\n      start: u / 1e3,\n      end: l / 1e3\n    };\n    g.preload = !0;\n    const b = g.loaded;\n    g.loaded = (w, T) => {\n      b(w, T);\n      const x = T, S = x.duration;\n      if (_.end < 0) {\n        if (_.end += S, x.removeSprites(m), x.addSprites(m, _), _.start >= _.end)\n          throw `[playse] start_ms:${u} >= end_ms:${l}(${_.end * 1e3}) は異常値です`;\n        if (h >= _.end * 1e3)\n          throw `[playse] ret_ms:${h} >= end_ms:${l}(${_.end * 1e3}) は異常値です`;\n      }\n      if (_.start >= S)\n        throw `[playse] start_ms:${u} >= 音声ファイル再生時間:${S} は異常値です`;\n      if (l !== c(ec, qu) && _.end >= S)\n        throw `[playse] end_ms:${l} >= 音声ファイル再生時間:${S} は異常値です`;\n      x.play(m, g.complete);\n    };\n  } else\n    g.autoPlay = !0;\n  if (n ? h !== 0 && (g.loop = !1, g.complete = async (_) => {\n    const b = _.duration, w = h / 1e3, T = l / 1e3;\n    if (w >= b)\n      throw `[playse] ret_ms:${h} >= 音声ファイル再生時間:${b} は異常値です`;\n    await Vn.play(r, {\n      // 一周目はループなし、なのでキャッシュされてる\n      start: w,\n      end: T < 0 ? T + b : T,\n      // 負の値は末尾から\n      speed: f,\n      loop: !0,\n      volume: o,\n      //\tsprite\t: sp_nm2,\t// err\n      //-\tmuted?: boolean;\n      filters: v.pan !== 0 ? [new up.StereoFilter(v.pan)] : []\n      //-\tcomplete?: CompleteCallback;\n      //-\tloaded?: LoadedCallback;\n      //-\tsingleInstance?: boolean;\n    });\n    const x = c(this, Ie)[v.now_buf];\n    x && (x.snd = Vn.find(r));\n  }) : g.complete = () => {\n    var _;\n    return (_ = c(this, Ie)[v.now_buf]) == null ? void 0 : _.onend();\n  }, c(this, Xc).call(this), p) {\n    if (p.volume = o, m)\n      O(this, Vc, i_).call(this, e, r, g);\n    else if (p.isPlayable) {\n      const _ = p.options.source;\n      !(_ instanceof ArrayBuffer) || _.byteLength === 0 ? p.play(g) : v.snd = Fu.from({\n        ...g,\n        url: p.options.url,\n        source: _\n      }), p.filters = [new up.StereoFilter(d)];\n    }\n    return !1;\n  }\n  const y = vt(t, \"join\", !0);\n  if (y) {\n    const _ = g.loaded;\n    g.loaded = (b, w) => {\n      _ == null || _(b, w), this.main.resume();\n    };\n  }\n  return O(this, Vc, i_).call(this, e, r, g), y;\n}, Vc = new WeakSet(), i_ = function(t, e, r) {\n  const n = this.cfg.searchPath(e, vr.SOUND);\n  if (n.slice(-4) !== \".bin\") {\n    r.url = n;\n    const s = Fu.from(r);\n    if (t) {\n      const a = c(this, Ie)[t];\n      if (!a)\n        return;\n      a.snd = s, a.pan !== 0 && (s.filters = [new up.StereoFilter(a.pan)]);\n    }\n    r.loop || Vn.add(e, s);\n    return;\n  }\n  new ii().add({ name: e, url: n, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER }).use((s, a) => {\n    this.sys.dec(s.extension, s.data).then((o) => {\n      s.data = o, a == null || a();\n    }).catch((o) => this.main.errScript(`Sound ロード失敗ですc fn:${s.name} ${o}`, !1));\n  }).load((s, a) => {\n    var u;\n    r.source = (u = a[e]) == null ? void 0 : u.data;\n    const o = Fu.from(r);\n    if (t) {\n      const l = c(this, Ie)[t];\n      if (!l)\n        return;\n      l.snd = o, l.pan !== 0 && (o.filters = [new up.StereoFilter(l.pan)]);\n    }\n    r.loop || Vn.add(e, o);\n  });\n}, Xc = new WeakMap(), Ku = new WeakSet(), zp = function() {\n  for (const t of Object.keys(c(this, Ie)))\n    O(this, ln, Ns).call(this, { buf: t });\n  return P(this, Ie, {}), Vn.stopAll(), !1;\n}, ug = new WeakSet(), tT = function(t) {\n  return t.buf = \"BGM\", O(this, ln, Ns).call(this, t);\n}, ln = new WeakSet(), Ns = function(t) {\n  var n;\n  const { buf: e = \"SE\" } = t;\n  O(this, Ju, Hp).call(this, e);\n  const r = c(this, Ie)[e];\n  return r && ((n = r.snd) == null || n.stop(), r.onend()), !1;\n}, lg = new WeakSet(), eT = function(t) {\n  return t.buf = \"BGM\", O(this, Wc, n_).call(this, t);\n}, Wc = new WeakSet(), n_ = function(t) {\n  const { buf: e = \"SE\" } = t, r = c(this, Ie)[e];\n  return !(r != null && r.twFade) || !r.playing() ? !1 : r.resumeFade = c(this, Us).waitEvent(\n    () => O(this, Ya, Rh).call(this, t),\n    vt(t, \"canskip\", !0),\n    vt(t, \"global\", !1)\n  );\n}, Ya = new WeakSet(), Rh = function(t) {\n  var r, n;\n  const { buf: e = \"SE\" } = t;\n  return (n = (r = c(this, Ie)[e]) == null ? void 0 : r.twFade) == null || n.stop().end(), !1;\n}, hg = new WeakSet(), rT = function(t) {\n  return t.buf = \"BGM\", O(this, Yc, s_).call(this, t);\n}, Yc = new WeakSet(), s_ = function(t) {\n  const { buf: e = \"SE\" } = t, r = c(this, Ie)[e];\n  return !(r != null && r.playing()) || r.loop ? !1 : r.resume = c(this, Us).waitEvent(\n    () => {\n      t.buf = r.now_buf, O(this, ln, Ns).call(this, t);\n      const n = c(this, Ie)[t.buf];\n      !(n != null && n.playing()) || n.loop || n.onend();\n    },\n    vt(t, \"canskip\", !1),\n    vt(t, \"global\", !1)\n  );\n}, cg = new WeakSet(), iT = function(t) {\n  const { buf: e = \"SE\", buf2: r = \"SE\" } = t;\n  if (e === r)\n    return !1;\n  const n = c(this, Ie)[e];\n  n && (n.now_buf = r);\n  const s = c(this, Ie)[r];\n  s && (s.now_buf = e), [c(this, Ie)[e], c(this, Ie)[r]] = [s, n];\n  const a = \"const.sn.sound.\" + e + \".\", o = Number(this.val.getVal(\"save:\" + a + \"volume\")), u = Number(this.val.getVal(\"save:\" + a + \"fn\")), l = String(this.val.getVal(\"tmp:\" + a + \"playing\")) === \"true\", h = \"const.sn.sound.\" + r + \".\", d = Number(this.val.getVal(\"save:\" + h + \"volume\")), f = Number(this.val.getVal(\"save:\" + h + \"fn\")), p = String(this.val.getVal(\"tmp:\" + h + \"playing\")) === \"true\";\n  return this.val.setVal_Nochk(\"save\", a + \"volume\", d), this.val.setVal_Nochk(\"save\", h + \"volume\", o), this.val.setVal_Nochk(\"save\", a + \"fn\", f), this.val.setVal_Nochk(\"save\", h + \"fn\", u), this.val.setVal_Nochk(\"tmp\", a + \"playing\", p), this.val.setVal_Nochk(\"tmp\", h + \"playing\", l), e in c(this, hr) == r in c(this, hr) && (e in c(this, hr) ? (delete c(this, hr)[e], c(this, hr)[r] = 0) : (delete c(this, hr)[r], c(this, hr)[e] = 0), this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(c(this, hr)))), this.val.flush(), !1;\n}, fg = new WeakSet(), nT = function(t, e) {\n  if (!e) {\n    O(this, Ju, Hp).call(this, t);\n    return;\n  }\n  c(this, hr)[t] = 0, this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(c(this, hr))), this.val.flush();\n}, Ju = new WeakSet(), Hp = function(t) {\n  delete c(this, hr)[t], this.val.setVal_Nochk(\"save\", \"const.sn.loopPlaying\", JSON.stringify(c(this, hr))), this.val.flush();\n}, // 効果音の再生\nE(Gp, qu, 999e3);\nvar ve;\nconst Kx = class {\n  constructor(t, e, r, n, s, a, o, u) {\n    E(this, ve, void 0);\n    K(this, \"lay\", (t) => this.getPage(t).lay(t));\n    K(this, \"getPage\", (t) => Kx.argChk_page(t, \"fore\") !== \"back\" ? c(this, ve).fore : c(this, ve).back);\n    this.cls = e, this.hArg = s, this.sys = a, this.val = o, this.ret = u;\n    const l = a.hFactoryCls[e];\n    if (!l)\n      throw `属性 class【${e}】が不正です`;\n    const h = l(), d = l();\n    h.layname = d.layname = t;\n    const f = s[\":id_tag\"] = `layer:${t} cls:${e} page:`;\n    h.spLay.name = h.name = f + \"A\", h.spLay.name = d.name = f + \"B\", r.addChild(h.spLay), n.addChild(d.spLay), vt(s, \"visible\", !0), vt(s, \"visible\", !0), u.isWait = h.lay(s) || d.lay(s), P(this, ve, { fore: h, back: d });\n    const p = `const.sn.lay.${t}`;\n    o.setVal_Nochk(\"tmp\", p, !0), o.defTmp(p + \".fore.alpha\", () => c(this, ve).fore.alpha), o.defTmp(p + \".back.alpha\", () => c(this, ve).back.alpha), o.defTmp(p + \".fore.height\", () => c(this, ve).fore.height), o.defTmp(p + \".back.height\", () => c(this, ve).back.height), o.defTmp(p + \".fore.visible\", () => c(this, ve).fore.spLay.visible), o.defTmp(p + \".back.visible\", () => c(this, ve).back.spLay.visible), o.defTmp(p + \".fore.width\", () => c(this, ve).fore.width), o.defTmp(p + \".back.width\", () => c(this, ve).back.width), o.defTmp(p + \".fore.x\", () => c(this, ve).fore.x), o.defTmp(p + \".back.x\", () => c(this, ve).back.x), o.defTmp(p + \".fore.y\", () => c(this, ve).fore.y), o.defTmp(p + \".back.y\", () => c(this, ve).back.y);\n  }\n  destroy() {\n    c(this, ve).fore.destroy(), c(this, ve).back.destroy();\n  }\n  static argChk_page(t, e) {\n    const r = t.page ?? e;\n    if (r === \"fore\" || r === \"back\")\n      return t.page = r;\n    throw Error(\"属性 page【\" + r + \"】が不正です\");\n  }\n  get fore() {\n    return c(this, ve).fore;\n  }\n  get back() {\n    return c(this, ve).back;\n  }\n  transPage(t) {\n    [c(this, ve).back, c(this, ve).fore] = [c(this, ve).fore, c(this, ve).back], c(this, ve).back.copy(c(this, ve).fore, t);\n  }\n};\nlet Yh = Kx;\nve = new WeakMap();\nvar dg, pg;\nconst Wn = class {\n  constructor() {\n    K(this, \"layname\", \"\");\n    K(this, \"name_\", \"\");\n    K(this, \"spLay\", new Ue(Ot.EMPTY));\n  }\n  set name(t) {\n    this.name_ = t;\n  }\n  get name() {\n    return this.name_;\n  }\n  // tsy用\n  get alpha() {\n    return this.spLay.alpha;\n  }\n  set alpha(t) {\n    this.spLay.alpha = t;\n  }\n  get height() {\n    return this.spLay.height;\n  }\n  get rotation() {\n    return this.spLay.angle;\n  }\n  set rotation(t) {\n    this.spLay.angle = t;\n  }\n  get scale_x() {\n    return this.spLay.scale.x;\n  }\n  set scale_x(t) {\n    this.spLay.scale.x = t;\n  }\n  get scale_y() {\n    return this.spLay.scale.y;\n  }\n  set scale_y(t) {\n    this.spLay.scale.y = t;\n  }\n  get width() {\n    return this.spLay.width;\n  }\n  get x() {\n    return this.spLay.x;\n  }\n  set x(t) {\n    this.spLay.x = t;\n  }\n  get y() {\n    return this.spLay.y;\n  }\n  set y(t) {\n    this.spLay.y = t;\n  }\n  destroy() {\n  }\n  lay(t) {\n    return \"alpha\" in t && (this.spLay.alpha = tt(t, \"alpha\", 1)), Wn.setBlendmode(this.spLay, t), (\"pivot_x\" in t || \"pivot_y\" in t) && this.spLay.pivot.set(\n      tt(t, \"pivot_x\", this.spLay.pivot.x),\n      tt(t, \"pivot_y\", this.spLay.pivot.y)\n    ), \"rotation\" in t && (this.spLay.angle = tt(t, \"rotation\", 0)), (\"scale_x\" in t || \"scale_y\" in t) && this.spLay.scale.set(\n      tt(t, \"scale_x\", this.spLay.scale.x),\n      tt(t, \"scale_y\", this.spLay.scale.y)\n    ), \"visible\" in t && (this.spLay.visible = vt(t, \"visible\", !0)), !1;\n  }\n  static setBlendmodeParentOnly(t, e) {\n    const { blendmode: r } = e;\n    if (!r)\n      return;\n    const n = Wn.getBlendmodeNum(r);\n    t instanceof Ue && (t.blendMode = n);\n  }\n  static setBlendmode(t, e) {\n    const { blendmode: r } = e;\n    if (!r)\n      return;\n    const n = Wn.getBlendmodeNum(r);\n    t instanceof Ue && (t.blendMode = n);\n    for (const s of t.children)\n      s instanceof Ue && (s.blendMode = n);\n  }\n  static getBlendmodeNum(t) {\n    if (!t)\n      return Et.NORMAL;\n    const e = c(Wn, dg)[t];\n    if (e !== void 0)\n      return e;\n    throw `${t} はサポートされない blendmode です`;\n  }\n  static getNum2Blendmode(t) {\n    return c(Wn, pg)[t] ?? \"normal\";\n  }\n  // アニメ・動画があるか\n  get containMovement() {\n    return !1;\n  }\n  renderStart() {\n  }\n  renderEnd() {\n  }\n  clearLay(t) {\n    this.spLay.alpha = 1, this.spLay.blendMode = Et.NORMAL, this.spLay.pivot.set(0, 0), this.spLay.angle = 0, this.spLay.scale.set(1, 1), vt(t, \"filter\", !1) && (this.spLay.filters = []);\n  }\n  copy(t, e) {\n    const r = this.name_;\n    this.playback(t.record(), e), this.name = r;\n  }\n  record() {\n    return {\n      name: this.name_,\n      idx: this.spLay.parent.getChildIndex(this.spLay),\n      alpha: this.spLay.alpha,\n      blendMode: this.spLay.blendMode,\n      rotation: this.spLay.angle,\n      scale_x: this.spLay.scale.x,\n      scale_y: this.spLay.scale.y,\n      pivot_x: this.spLay.pivot.x,\n      pivot_y: this.spLay.pivot.y,\n      x: this.spLay.x,\n      y: this.spLay.y,\n      visible: this.spLay.visible\n    };\n  }\n  playback(t, e) {\n    this.name = t.name, this.clearLay({ filter: \"true\" }), this.spLay.alpha = t.alpha, this.spLay.blendMode = t.blendMode, this.spLay.angle = t.rotation, this.spLay.scale.set(t.scale_x, t.scale_y), this.spLay.pivot.set(t.pivot_x, t.pivot_y), this.spLay.position.set(t.x, t.y), this.spLay.visible = t.visible;\n  }\n  snapshot(t, e) {\n    t.render(this.spLay, { clear: !1 }), e();\n  }\n  snapshot_end() {\n  }\n  makeDesignCast(t) {\n  }\n  makeDesignCastChildren(t) {\n  }\n  showDesignCast() {\n  }\n  showDesignCastChildren() {\n  }\n  cvsResize() {\n  }\n  cvsResizeChildren() {\n  }\n  dump() {\n    return ` \"idx\":${this.spLay.parent.getChildIndex(this.spLay)}, \"visible\":\"${this.spLay.visible}\", \"left\":${this.spLay.x}, \"top\":${this.spLay.y}, \"alpha\":${this.spLay.alpha}, \"rotation\":${this.spLay.angle}, \"name\":\"${this.name_}\", \"scale_x\":${this.spLay.scale.x}, \"scale_y\":${this.spLay.scale.y}`;\n  }\n  static setXY(t, e, r, n = !1, s = !1) {\n    if (e.pos) {\n      Wn.setXYByPos(t, e.pos, r);\n      return;\n    }\n    const a = t.getBounds(), o = r.scale.x < 0 ? -r.scale.x : r.scale.x, u = o === 1 ? a.width : a.width * o, l = r.scale.y < 0 ? -r.scale.y : r.scale.y, h = l === 1 ? a.height : a.height * l;\n    let d = r.x;\n    \"left\" in e ? (d = tt(e, \"left\", 0), d > -1 && d < 1 && (d *= Y.stageW)) : \"center\" in e ? (d = tt(e, \"center\", 0), d > -1 && d < 1 && (d *= Y.stageW), d = d - (s ? u / 3 : u) / 2) : \"right\" in e ? (d = tt(e, \"right\", 0), d > -1 && d < 1 && (d *= Y.stageW), d = d - (s ? u / 3 : u)) : \"s_right\" in e && (d = tt(e, \"s_right\", 0), d > -1 && d < 1 && (d *= Y.stageW), d = Y.stageW - d - (s ? u / 3 : u)), r.x = $t(r.scale.x < 0 ? d + (s ? u / 3 : u) : d);\n    let f = r.y;\n    \"top\" in e ? (f = tt(e, \"top\", 0), f > -1 && f < 1 && (f *= Y.stageH)) : \"middle\" in e ? (f = tt(e, \"middle\", 0), f > -1 && f < 1 && (f *= Y.stageH), f = f - h / 2) : \"bottom\" in e ? (f = tt(e, \"bottom\", 0), f > -1 && f < 1 && (f *= Y.stageH), f = f - h) : \"s_bottom\" in e && (f = tt(e, \"s_bottom\", 0), f > -1 && f < 1 && (f *= Y.stageH), f = Y.stageH - f - h), r.y = $t(r.scale.y < 0 ? f + h : f), n && !(\"left\" in e) && !(\"center\" in e) && !(\"right\" in e) && !(\"s_right\" in e) && !(\"top\" in e) && !(\"middle\" in e) && !(\"bottom\" in e) && !(\"s_bottom\" in e) && Wn.setXYByPos(t, \"c\", r);\n  }\n  static setXYByPos(t, e, r) {\n    if (e === \"stay\")\n      return;\n    if (t === void 0)\n      throw \"setXYByPos base === undefined\";\n    if (r === void 0)\n      throw \"setXYByPos result === undefined\";\n    const n = t.getBounds(), s = r.scale.x < 0 ? -r.scale.x : r.scale.x, a = s === 1 ? n.width : n.width * s, o = r.scale.y < 0 ? -r.scale.y : r.scale.y, u = o === 1 ? n.height : n.height * o;\n    let l = 0;\n    !e || e === \"c\" ? l = Y.stageW * 0.5 : e === \"r\" ? l = Y.stageW - a * 0.5 : e === \"l\" ? l = a * 0.5 : l = $t(e), r.x = $t(l - a * 0.5), r.y = Y.stageH - u, r.scale.x < 0 && (r.x += a), r.scale.y < 0 && (r.y += u);\n  }\n  static setXYCenter(t) {\n    const e = t.getBounds();\n    t.x = (Y.stageW - e.width) * 0.5, t.y = (Y.stageH - e.height) * 0.5;\n  }\n};\nlet _r = Wn;\ndg = new WeakMap(), pg = new WeakMap(), E(_r, dg, {\n  normal: Et.NORMAL,\n  add: Et.ADD,\n  multiply: Et.MULTIPLY,\n  screen: Et.SCREEN\n  /*\n  \t\t'overlay'\t\t: BLEND_MODES.OVERLAY,\n  \t\t'darken'\t\t: BLEND_MODES.DARKEN,\n  \t\t'lighten'\t\t: BLEND_MODES.LIGHTEN,\n  \t\t'color_dodge'\t: BLEND_MODES.COLOR_DODGE,\n  \t\t'color_burn'\t: BLEND_MODES.COLOR_BURN,\n  \t\t'hard_light'\t: BLEND_MODES.HARD_LIGHT,\n  \t\t'soft_light'\t: BLEND_MODES.SOFT_LIGHT,\n  \t\t'difference'\t: BLEND_MODES.DIFFERENCE,\n  \t\t'exclusion'\t\t: BLEND_MODES.EXCLUSION,\n  \t\t'hue'\t\t\t: BLEND_MODES.HUE,\n  \t\t'saturation'\t: BLEND_MODES.SATURATION,\n  \t\t'color'\t\t\t: BLEND_MODES.COLOR,\n  \t\t'luminosity'\t: BLEND_MODES.LUMINOSITY,\n  \n  \t\t'normal_npm'\t: BLEND_MODES.NORMAL_NPM,\n  \t\t'add_npm'\t\t: BLEND_MODES.ADD_NPM,\n  \t\t'screen_npm'\t: BLEND_MODES.SCREEN_NPM,\n  \t\t'none'\t\t\t: BLEND_MODES.NONE,\n  \t\t'src_in'\t\t: BLEND_MODES.SRC_IN,\n  \t\t'src_out'\t\t: BLEND_MODES.SRC_OUT,\n  \t\t'src_atop'\t\t: BLEND_MODES.SRC_ATOP,\n  \t\t'dst_over'\t\t: BLEND_MODES.DST_OVER,\n  \t\t'dst_in'\t\t: BLEND_MODES.DST_IN,\n  \t\t'dst_out'\t\t: BLEND_MODES.DST_OUT,\n  \t\t'dst_atop'\t\t: BLEND_MODES.DST_ATOP,\n  \t\t'subtract'\t\t: BLEND_MODES.SUBTRACT,\n  \t\t'src_over'\t\t: BLEND_MODES.SRC_OVER,\n  \t\t'erase'\t\t\t: BLEND_MODES.ERASE,\n  \t\t'xor'\t\t\t: BLEND_MODES.XOR,\n  */\n}), E(_r, pg, {\n  0: \"normal\",\n  1: \"add\",\n  2: \"multiply\",\n  3: \"screen\"\n});\nfunction MA(i) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  return t.map(function(r) {\n    return r.split(\" \").map(function(n) {\n      return n ? \"\" + i + n : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\nfunction PA(i, t) {\n  return t.replace(/([^}{]*){/gm, function(e, r) {\n    return r.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + i + \"$1\") + \"{\";\n  });\n}\nfunction Es(i, t) {\n  return function(e) {\n    e && (i[t] = e);\n  };\n}\nfunction sT(i, t, e) {\n  return function(r) {\n    r && (i[t][e] = r);\n  };\n}\nfunction ow(i, t) {\n  return function(e) {\n    var r = e.prototype;\n    i.forEach(function(n) {\n      t(r, n);\n    });\n  };\n}\nfunction OA(i, t) {\n  return t === void 0 && (t = {}), function(e, r) {\n    i.forEach(function(n) {\n      var s = t[n] || n;\n      s in e || (e[s] = function() {\n        for (var a, o = [], u = 0; u < arguments.length; u++)\n          o[u] = arguments[u];\n        var l = (a = this[r])[n].apply(a, o);\n        return l === this[r] ? this : l;\n      });\n    });\n  };\n}\nvar IA = \"function\", RA = \"object\", DA = \"string\", kA = \"number\", aT = \"undefined\", oT = typeof window !== aT, NA = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: '\"',\n  close: '\"'\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: '\\\\\"',\n  close: '\\\\\"'\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}], Je = 1e-7, lp = {\n  cm: function(i) {\n    return i * 96 / 2.54;\n  },\n  mm: function(i) {\n    return i * 96 / 254;\n  },\n  in: function(i) {\n    return i * 96;\n  },\n  pt: function(i) {\n    return i * 96 / 72;\n  },\n  pc: function(i) {\n    return i * 96 / 6;\n  },\n  \"%\": function(i, t) {\n    return i * t / 100;\n  },\n  vw: function(i, t) {\n    return t === void 0 && (t = window.innerWidth), i / 100 * t;\n  },\n  vh: function(i, t) {\n    return t === void 0 && (t = window.innerHeight), i / 100 * t;\n  },\n  vmax: function(i, t) {\n    return t === void 0 && (t = Math.max(window.innerWidth, window.innerHeight)), i / 100 * t;\n  },\n  vmin: function(i, t) {\n    return t === void 0 && (t = Math.min(window.innerWidth, window.innerHeight)), i / 100 * t;\n  }\n};\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction AA() {\n  for (var i = 0, t = 0, e = arguments.length; t < e; t++)\n    i += arguments[t].length;\n  for (var r = Array(i), n = 0, t = 0; t < e; t++)\n    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)\n      r[n] = s[a];\n  return r;\n}\nfunction Pa(i, t, e, r) {\n  return (i * r + t * e) / (e + r);\n}\nfunction o0(i) {\n  return typeof i === aT;\n}\nfunction ca(i) {\n  return i && typeof i === RA;\n}\nfunction tr(i) {\n  return Array.isArray(i);\n}\nfunction Vr(i) {\n  return typeof i === DA;\n}\nfunction pc(i) {\n  return typeof i === kA;\n}\nfunction sx(i) {\n  return typeof i === IA;\n}\nfunction LA(i, t) {\n  var e = i === \"\" || i == \" \", r = t === \"\" || t == \" \";\n  return r && e || i === t;\n}\nfunction uT(i, t, e, r, n) {\n  var s = ax(i, t, e);\n  return s ? e : BA(i, t, e + 1, r, n);\n}\nfunction ax(i, t, e) {\n  if (!i.ignore)\n    return null;\n  var r = t.slice(Math.max(e - 3, 0), e + 3).join(\"\");\n  return new RegExp(i.ignore).exec(r);\n}\nfunction BA(i, t, e, r, n) {\n  for (var s = function(l) {\n    var h = t[l].trim();\n    if (h === i.close && !ax(i, t, l))\n      return {\n        value: l\n      };\n    var d = l, f = nn(n, function(p) {\n      var v = p.open;\n      return v === h;\n    });\n    if (f && (d = uT(f, t, l, r, n)), d === -1)\n      return a = l, \"break\";\n    l = d, a = l;\n  }, a, o = e; o < r; ++o) {\n    var u = s(o);\n    if (o = a, typeof u == \"object\")\n      return u.value;\n    if (u === \"break\")\n      break;\n  }\n  return -1;\n}\nfunction ox(i, t) {\n  var e = Vr(t) ? {\n    separator: t\n  } : t, r = e.separator, n = r === void 0 ? \",\" : r, s = e.isSeparateFirst, a = e.isSeparateOnlyOpenClose, o = e.isSeparateOpenClose, u = o === void 0 ? a : o, l = e.openCloseCharacters, h = l === void 0 ? NA : l, d = h.map(function(S) {\n    var C = S.open, M = S.close;\n    return C === M ? C : C + \"|\" + M;\n  }).join(\"|\"), f = \"(\\\\s*\" + n + \"\\\\s*|\" + d + \"|\\\\s+)\", p = new RegExp(f, \"g\"), v = i.split(p).filter(function(S) {\n    return S && S !== \"undefined\";\n  }), g = v.length, m = [], y = [];\n  function _() {\n    return y.length ? (m.push(y.join(\"\")), y = [], !0) : !1;\n  }\n  for (var b = function(S) {\n    var C = v[S].trim(), M = S, I = nn(h, function(A) {\n      var U = A.open;\n      return U === C;\n    }), R = nn(h, function(A) {\n      var U = A.close;\n      return U === C;\n    });\n    if (I) {\n      if (M = uT(I, v, S, g, h), M !== -1 && u)\n        return _() && s || (m.push(v.slice(S, M + 1).join(\"\")), S = M, s) ? (w = S, \"break\") : (w = S, \"continue\");\n    } else if (R && !ax(R, v, S)) {\n      var N = AA(h);\n      return N.splice(h.indexOf(R), 1), {\n        value: ox(i, {\n          separator: n,\n          isSeparateFirst: s,\n          isSeparateOnlyOpenClose: a,\n          isSeparateOpenClose: u,\n          openCloseCharacters: N\n        })\n      };\n    } else if (LA(C, n) && !a)\n      return _(), s ? (w = S, \"break\") : (w = S, \"continue\");\n    M === -1 && (M = g - 1), y.push(v.slice(S, M + 1).join(\"\")), S = M, w = S;\n  }, w, T = 0; T < g; ++T) {\n    var x = b(T);\n    if (T = w, typeof x == \"object\")\n      return x.value;\n    if (x === \"break\")\n      break;\n  }\n  return y.length && m.push(y.join(\"\")), m;\n}\nfunction fa(i) {\n  return ox(i, \"\");\n}\nfunction Ga(i) {\n  return ox(i, \",\");\n}\nfunction lT(i) {\n  var t = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(i);\n  return !t || t.length < 4 ? {} : {\n    prefix: t[1],\n    value: t[2],\n    suffix: t[3]\n  };\n}\nfunction Ed(i) {\n  var t = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(i);\n  if (!t)\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  var e = t[1], r = t[2], n = t[3];\n  return {\n    prefix: e,\n    unit: n,\n    value: parseFloat(r)\n  };\n}\nfunction FA(i) {\n  return i.replace(/[\\s-_]+([^\\s-_])/g, function(t, e) {\n    return e.toUpperCase();\n  });\n}\nfunction $p(i, t) {\n  return t === void 0 && (t = \"-\"), i.replace(/([a-z])([A-Z])/g, function(e, r, n) {\n    return \"\" + r + t + n.toLowerCase();\n  });\n}\nfunction vc() {\n  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();\n}\nfunction Ms(i, t, e) {\n  e === void 0 && (e = -1);\n  for (var r = i.length, n = 0; n < r; ++n)\n    if (t(i[n], n, i))\n      return n;\n  return e;\n}\nfunction nn(i, t, e) {\n  var r = Ms(i, t);\n  return r > -1 ? i[r] : e;\n}\nvar hT = /* @__PURE__ */ function() {\n  var i = vc(), t = oT && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return t ? t.bind(window) : function(e) {\n    var r = vc(), n = setTimeout(function() {\n      e(r - i);\n    }, 1e3 / 60);\n    return n;\n  };\n}(), GA = /* @__PURE__ */ function() {\n  var i = oT && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return i ? i.bind(window) : function(t) {\n    clearTimeout(t);\n  };\n}();\nfunction Ps(i) {\n  return Object.keys(i);\n}\nfunction UA(i) {\n  var t = Ps(i);\n  return t.map(function(e) {\n    return i[e];\n  });\n}\nfunction Te(i, t) {\n  var e = Ed(i), r = e.value, n = e.unit;\n  if (ca(t)) {\n    var s = t[n];\n    if (s) {\n      if (sx(s))\n        return s(r);\n      if (lp[n])\n        return lp[n](r, s);\n    }\n  } else if (n === \"%\")\n    return r * t / 100;\n  return lp[n] ? lp[n](r) : r;\n}\nfunction a_(i, t, e) {\n  return Math.max(t, Math.min(i, e));\n}\nfunction uw(i, t, e, r) {\n  return r === void 0 && (r = i[0] / i[1]), [[Gt(t[0], Je), Gt(t[0] / r, Je)], [Gt(t[1] * r, Je), Gt(t[1], Je)]].filter(function(n) {\n    return n.every(function(s, a) {\n      var o = t[a], u = Gt(o, Je);\n      return e ? s <= o || s <= u : s >= o || s >= u;\n    });\n  })[0] || i;\n}\nfunction jA(i, t, e, r) {\n  if (!r)\n    return i.map(function(p, v) {\n      return a_(p, t[v], e[v]);\n    });\n  var n = i[0], s = i[1], a = r === !0 ? n / s : r, o = uw(i, t, !1, a), u = o[0], l = o[1], h = uw(i, e, !0, a), d = h[0], f = h[1];\n  return n < u || s < l ? (n = u, s = l) : (n > d || s > f) && (n = d, s = f), [n, s];\n}\nfunction zA(i) {\n  for (var t = i.length, e = 0, r = t - 1; r >= 0; --r)\n    e += i[r];\n  return e;\n}\nfunction o_(i) {\n  for (var t = i.length, e = 0, r = t - 1; r >= 0; --r)\n    e += i[r];\n  return t ? e / t : 0;\n}\nfunction $e(i, t) {\n  var e = t[0] - i[0], r = t[1] - i[1], n = Math.atan2(r, e);\n  return n >= 0 ? n : n + Math.PI * 2;\n}\nfunction HA(i) {\n  return [0, 1].map(function(t) {\n    return o_(i.map(function(e) {\n      return e[t];\n    }));\n  });\n}\nfunction u_(i) {\n  var t = HA(i), e = $e(t, i[0]), r = $e(t, i[1]);\n  return e < r && r - e < Math.PI || e > r && r - e < -Math.PI ? 1 : -1;\n}\nfunction Zi(i, t) {\n  return Math.sqrt(Math.pow((t ? t[0] : 0) - i[0], 2) + Math.pow((t ? t[1] : 0) - i[1], 2));\n}\nfunction Gt(i, t) {\n  if (!t)\n    return i;\n  var e = 1 / t;\n  return Math.round(i / t) / e;\n}\nfunction lw(i, t) {\n  return i.forEach(function(e, r) {\n    i[r] = Gt(i[r], t);\n  }), i;\n}\nfunction $A(i) {\n  return i.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction cT(i, t) {\n  i.indexOf(t) === -1 && i.push(t);\n}\nfunction sr(i, t) {\n  return i.classList ? i.classList.contains(t) : !!i.className.match(new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\"));\n}\nfunction fT(i, t) {\n  i.classList ? i.classList.add(t) : i.className += \" \" + t;\n}\nfunction dT(i, t) {\n  if (i.classList)\n    i.classList.remove(t);\n  else {\n    var e = new RegExp(\"(\\\\s|^)\" + t + \"(\\\\s|$)\");\n    i.className = i.className.replace(e, \" \");\n  }\n}\nfunction Dr(i, t, e, r) {\n  i.addEventListener(t, e, r);\n}\nfunction gr(i, t, e, r) {\n  i.removeEventListener(t, e, r);\n}\nvar VA = /* @__PURE__ */ function() {\n  function i() {\n    this.keys = [], this.values = [];\n  }\n  var t = i.prototype;\n  return t.get = function(e) {\n    return this.values[this.keys.indexOf(e)];\n  }, t.set = function(e, r) {\n    var n = this.keys, s = this.values, a = n.indexOf(e), o = a === -1 ? n.length : a;\n    n[o] = e, s[o] = r;\n  }, i;\n}(), XA = /* @__PURE__ */ function() {\n  function i() {\n    this.object = {};\n  }\n  var t = i.prototype;\n  return t.get = function(e) {\n    return this.object[e];\n  }, t.set = function(e, r) {\n    this.object[e] = r;\n  }, i;\n}(), WA = typeof Map == \"function\", YA = /* @__PURE__ */ function() {\n  function i() {\n  }\n  var t = i.prototype;\n  return t.connect = function(e, r) {\n    this.prev = e, this.next = r, e && (e.next = this), r && (r.prev = this);\n  }, t.disconnect = function() {\n    var e = this.prev, r = this.next;\n    e && (e.next = r), r && (r.prev = e);\n  }, t.getIndex = function() {\n    for (var e = this, r = -1; e; )\n      e = e.prev, ++r;\n    return r;\n  }, i;\n}();\nfunction qA(i, t) {\n  var e = [], r = [];\n  return i.forEach(function(n) {\n    var s = n[0], a = n[1], o = new YA();\n    e[s] = o, r[a] = o;\n  }), e.forEach(function(n, s) {\n    n.connect(e[s - 1]);\n  }), i.filter(function(n, s) {\n    return !t[s];\n  }).map(function(n, s) {\n    var a = n[0], o = n[1];\n    if (a === o)\n      return [0, 0];\n    var u = e[a], l = r[o - 1], h = u.getIndex();\n    u.disconnect(), l ? u.connect(l, l.next) : u.connect(void 0, e[0]);\n    var d = u.getIndex();\n    return [h, d];\n  });\n}\nvar ZA = /* @__PURE__ */ function() {\n  function i(e, r, n, s, a, o, u, l) {\n    this.prevList = e, this.list = r, this.added = n, this.removed = s, this.changed = a, this.maintained = o, this.changedBeforeAdded = u, this.fixed = l;\n  }\n  var t = i.prototype;\n  return Object.defineProperty(t, \"ordered\", {\n    get: function() {\n      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(t, \"pureChanged\", {\n    get: function() {\n      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), t.caculateOrdered = function() {\n    var e = qA(this.changedBeforeAdded, this.fixed), r = this.changed, n = [];\n    this.cacheOrdered = e.filter(function(s, a) {\n      var o = s[0], u = s[1], l = r[a], h = l[0], d = l[1];\n      if (o !== u)\n        return n.push([h, d]), !0;\n    }), this.cachePureChanged = n;\n  }, i;\n}();\nfunction Sd(i, t, e) {\n  var r = WA ? Map : e ? XA : VA, n = e || function(_) {\n    return _;\n  }, s = [], a = [], o = [], u = i.map(n), l = t.map(n), h = new r(), d = new r(), f = [], p = [], v = {}, g = [], m = 0, y = 0;\n  return u.forEach(function(_, b) {\n    h.set(_, b);\n  }), l.forEach(function(_, b) {\n    d.set(_, b);\n  }), u.forEach(function(_, b) {\n    var w = d.get(_);\n    typeof w > \"u\" ? (++y, a.push(b)) : v[w] = y;\n  }), l.forEach(function(_, b) {\n    var w = h.get(_);\n    typeof w > \"u\" ? (s.push(b), ++m) : (o.push([w, b]), y = v[b] || 0, f.push([w - y, b - m]), p.push(b === w), w !== b && g.push([w, b]));\n  }), a.reverse(), new ZA(i, t, s, a, g, o, f, p);\n}\nvar KA = /* @__PURE__ */ function() {\n  function i(e, r) {\n    e === void 0 && (e = []), this.findKeyCallback = r, this.list = [].slice.call(e);\n  }\n  var t = i.prototype;\n  return t.update = function(e) {\n    var r = [].slice.call(e), n = Sd(this.list, r, this.findKeyCallback);\n    return this.list = r, n;\n  }, i;\n}(), l_ = function(i, t) {\n  return l_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n  }, l_(i, t);\n};\nfunction Td(i, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  l_(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar Pn = function() {\n  return Pn = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, Pn.apply(this, arguments);\n};\nfunction pT(i, t) {\n  var e = {};\n  for (var r in i)\n    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);\n  if (i != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)\n      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);\n  return e;\n}\nfunction hw(i, t, e) {\n  if (e || arguments.length === 2)\n    for (var r = 0, n = t.length, s; r < n; r++)\n      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);\n  return i.concat(s || Array.prototype.slice.call(t));\n}\nfunction cw(i) {\n  var t = 0;\n  return i.map(function(e) {\n    return e == null ? \"$compat\".concat(++t) : \"\".concat(e);\n  });\n}\nfunction vT(i) {\n  var t = [];\n  return i.forEach(function(e) {\n    t = t.concat(tr(e) ? vT(e) : e);\n  }), t;\n}\nfunction ry(i, t) {\n  if (!t)\n    return i;\n  for (var e in t)\n    o0(i[e]) && (i[e] = t[e]);\n  return i;\n}\nfunction Ev(i, t) {\n  if (i === t)\n    return !1;\n  for (var e in i)\n    if (!(e in t))\n      return !0;\n  for (var e in t)\n    if (i[e] !== t[e])\n      return !0;\n  return !1;\n}\nfunction fw(i) {\n  var t = i.className, e = pT(i, [\"className\"]);\n  return t != null && (e.class = t), delete e.style, delete e.children, e;\n}\nfunction dw(i) {\n  var t = {}, e = {};\n  for (var r in i)\n    r.indexOf(\"on\") === 0 ? e[r] = i[r] : t[r] = i[r];\n  return [t, e];\n}\nfunction ux(i) {\n  if (!i)\n    return null;\n  var t = i.b;\n  return t instanceof Node ? t : ux(i.c);\n}\nfunction gT(i) {\n  var t = i.parentNode;\n  t && t.removeChild(i);\n}\nfunction mT(i) {\n  i.forEach(function(t) {\n    t();\n  });\n}\nfunction JA() {\n  return this.constructor(this.props, this.context);\n}\nvar lx = 0, yT = null, u0 = /* @__PURE__ */ function() {\n  function i(e, r, n, s, a, o, u) {\n    u === void 0 && (u = {}), this.t = e, this.d = r, this.k = n, this.i = s, this.c = a, this.ref = o, this.ps = u, this.typ = \"prov\", this._ps = [], this._cs = {}, this._hyd = null, this._sel = !1;\n  }\n  var t = i.prototype;\n  return t.s = function() {\n    return !0;\n  }, t.u = function(e, r, n, s, a) {\n    var o = this, u = o.d, l = UA(r).filter(function(v) {\n      return v.$_req;\n    }), h = vT(l.map(function(v) {\n      return v.$_subs;\n    })), d = nn(h, function(v) {\n      return v.d === u;\n    });\n    if (o.b && !Vr(n) && !a && !o.s(n.props, s) && !d) {\n      var f = h.reduce(function(v, g) {\n        var m = g.d;\n        return v[0] ? v[0].d === m && v.push(g) : m > u && v.push(g), v;\n      }, []);\n      return f.forEach(function(v) {\n        Cd(v, v._ps, [v.o], e, r, !0);\n      }), !1;\n    }\n    o.o = n, o.ss(s);\n    var p = o.ps;\n    return Vr(n) || (o.ps = n.props, o.ref = n.ref), hx(this), o.r(e, r, o.b ? p : {}, s), !0;\n  }, t.md = function() {\n    this.rr();\n  }, t.ss = function() {\n  }, t.ud = function() {\n    this.rr();\n  }, t.rr = function() {\n    var e = this, r = e.ref, n = e.fr;\n    r && r(n ? n.current : e.b);\n  }, i;\n}();\nfunction _T() {\n  return yT;\n}\nfunction QA() {\n  return lx;\n}\nfunction tL(i) {\n  lx = i;\n}\nfunction hx(i) {\n  yT = i, lx = 0;\n}\nvar cx = /* @__PURE__ */ function() {\n  function i(e, r) {\n    e === void 0 && (e = {}), this.props = e, this.context = r, this.state = {}, this.$_timer = 0, this.$_state = {}, this.$_subs = [], this.$_cs = {};\n  }\n  var t = i.prototype;\n  return t.render = function() {\n    return null;\n  }, t.shouldComponentUpdate = function(e, r) {\n    return this.props !== e || this.state !== r;\n  }, t.setState = function(e, r, n) {\n    var s = this;\n    s.$_timer || (s.$_state = {}), clearTimeout(s.$_timer), s.$_timer = 0, s.$_state = Pn(Pn({}, s.$_state), e), n ? s.$_setState(r, n) : s.$_timer = window.setTimeout(function() {\n      s.$_timer = 0, s.$_setState(r, n);\n    });\n  }, t.forceUpdate = function(e) {\n    this.setState({}, e, !0);\n  }, t.componentDidMount = function() {\n  }, t.componentDidUpdate = function(e, r) {\n  }, t.componentWillUnmount = function() {\n  }, t.$_setState = function(e, r) {\n    var n = [], s = this.$_p, a = Cd(s.c, [s], [s.o], n, s._cs, Pn(Pn({}, this.state), this.$_state), r);\n    a && (e && n.push(e), mT(n), hx(null));\n  }, i;\n}(), bT = /* @__PURE__ */ function(i) {\n  Td(t, i);\n  function t() {\n    return i !== null && i.apply(this, arguments) || this;\n  }\n  var e = t.prototype;\n  return e.shouldComponentUpdate = function(r, n) {\n    return Ev(this.props, r) || Ev(this.state, n);\n  }, t;\n}(cx);\nfunction xT(i) {\n  var t = function(e) {\n    t.current = e;\n  };\n  return t.current = i, t;\n}\nfunction eL(i) {\n  return i._fr = !0, i;\n}\nfunction rL(i, t, e, r) {\n  var n, s;\n  return !((n = i == null ? void 0 : i.prototype) === null || n === void 0) && n.render ? s = new i(t, e) : (s = new cx(t, e), s.constructor = i, i._fr ? (r.fr = xT(), s.render = function() {\n    return this.constructor(this.props, r.fr);\n  }) : s.render = JA), s.$_p = r, s;\n}\nvar iL = /* @__PURE__ */ function(i) {\n  Td(t, i);\n  function t(r, n, s, a, o, u, l) {\n    l === void 0 && (l = {});\n    var h = i.call(this, r, n, s, a, o, u, ry(l, r.defaultProps)) || this;\n    return h.typ = \"comp\", h._usefs = [], h._uefs = [], h._defs = [], h;\n  }\n  var e = t.prototype;\n  return e.s = function(r, n) {\n    var s = this.b;\n    return s.shouldComponentUpdate(ry(r, this.t.defaultProps), n || s.state) !== !1;\n  }, e.r = function(r, n, s) {\n    var a, o, u = this, l = u.t;\n    u.ps = ry(u.ps, u.t.defaultProps);\n    var h = u.ps, d = !u.b, f = l.contextType, p = u.b, v = f == null ? void 0 : f.get(u);\n    u._cs = n, d ? (p = rL(l, h, v, u), u.b = p) : (p.props = h, p.context = v);\n    var g = p.state;\n    u._usefs = [], u._uefs = [];\n    var m = p.render();\n    ((o = (a = m == null ? void 0 : m.props) === null || a === void 0 ? void 0 : a.children) === null || o === void 0 ? void 0 : o.length) === 0 && (m.props.children = u.ps.children);\n    var y = Pn(Pn({}, n), p.$_cs);\n    Cd(u, u._ps, m ? [m] : [], r, y), d ? u._uefs.push(function() {\n      f == null || f.register(u), p.componentDidMount();\n    }) : u._uefs.push(function() {\n      p.componentDidUpdate(s, g);\n    }), r.push(function() {\n      u._usefs.forEach(function(_) {\n        _();\n      }), d ? u.md() : u.ud(), u._defs = u._uefs.map(function(_) {\n        return _();\n      });\n    });\n  }, e.ss = function(r) {\n    var n = this.b;\n    !n || !r || (n.state = r);\n  }, e.un = function() {\n    var r, n = this;\n    n._ps.forEach(function(a) {\n      a.un();\n    });\n    var s = n.t;\n    (r = s.contextType) === null || r === void 0 || r.unregister(n), clearTimeout(n.b.$_timer), n._defs.forEach(function(a) {\n      a && a();\n    }), n.b.componentWillUnmount();\n  }, t;\n}(u0);\nfunction nL(i, t, e) {\n  var r = fx(fw(i), fw(t)), n = r.added, s = r.removed, a = r.changed;\n  for (var o in n)\n    e.setAttribute(o, n[o]);\n  for (var u in a)\n    e.setAttribute(u, a[u][1]);\n  for (var l in s)\n    e.removeAttribute(l);\n}\nfunction sL(i, t, e) {\n  var r = fx(i, t), n = r.added, s = r.removed;\n  for (var a in s)\n    e.e(a, !0);\n  for (var o in n)\n    e.e(o);\n}\nfunction fx(i, t) {\n  var e = Ps(i), r = Ps(t), n = Sd(e, r, function(u) {\n    return u;\n  }), s = {}, a = {}, o = {};\n  return n.added.forEach(function(u) {\n    var l = r[u];\n    s[l] = t[l];\n  }), n.removed.forEach(function(u) {\n    var l = e[u];\n    a[l] = i[l];\n  }), n.maintained.forEach(function(u) {\n    var l = u[0], h = e[l], d = [i[h], t[h]];\n    i[h] !== t[h] && (o[h] = d);\n  }), {\n    added: s,\n    removed: a,\n    changed: o\n  };\n}\nfunction aL(i, t, e) {\n  var r = e.style, n = fx(i, t), s = n.added, a = n.removed, o = n.changed;\n  for (var u in s) {\n    var l = $p(u, \"-\");\n    r.setProperty(l, s[u]);\n  }\n  for (var u in o) {\n    var h = $p(u, \"-\");\n    r.setProperty(h, o[u][1]);\n  }\n  for (var u in a) {\n    var d = $p(u, \"-\");\n    r.removeProperty(d);\n  }\n}\nfunction oL(i) {\n  return i.replace(/^on/g, \"\").toLowerCase();\n}\nvar uL = /* @__PURE__ */ function(i) {\n  Td(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.typ = \"elem\", r._es = {}, r._svg = !1, r;\n  }\n  var e = t.prototype;\n  return e.e = function(r, n) {\n    var s = this, a = s._es, o = s.b, u = oL(r);\n    n ? (gr(o, u, a[r]), delete a[r]) : (a[r] = function(l) {\n      var h, d;\n      (d = (h = s.ps)[r]) === null || d === void 0 || d.call(h, l);\n    }, Dr(o, u, a[r]));\n  }, e.s = function(r) {\n    return Ev(this.ps, r);\n  }, e.r = function(r, n, s) {\n    var a, o = this, u = !o.b, l = o.ps;\n    if (u) {\n      var h = !1;\n      if (o._svg || o.t === \"svg\")\n        h = !0;\n      else {\n        var d = ux(o.c);\n        h = d && d.ownerSVGElement;\n      }\n      o._svg = h;\n      var f = l.portalContainer;\n      if (!f) {\n        f = (a = o._hyd) === null || a === void 0 ? void 0 : a.splice(0, 1)[0];\n        var p = o.t;\n        f ? o._hyd = [].slice.call(f.children) : h ? f = document.createElementNS(\"http://www.w3.org/2000/svg\", p) : f = document.createElement(p);\n      }\n      o.b = f;\n    }\n    Cd(o, o._ps, l.children, r, n);\n    var v = o.b, g = dw(s), m = g[0], y = g[1], _ = dw(l), b = _[0], w = _[1];\n    return nL(m, b, v), sL(y, w, o), aL(s.style || {}, l.style || {}, v), r.push(function() {\n      u ? o.md() : o.ud();\n    }), !0;\n  }, e.un = function() {\n    var r = this, n = r._es, s = r.b;\n    for (var a in n)\n      gr(s, a, n[a]);\n    r._ps.forEach(function(o) {\n      o.un();\n    }), r._es = {}, !r.ps.portalContainer && !r._sel && (console.log(s), gT(s));\n  }, t;\n}(u0);\nfunction gc(i) {\n  if (!i || i instanceof Node)\n    return i;\n  var t = i.$_p._ps;\n  return t.length ? gc(t[0].b) : null;\n}\nfunction wT(i) {\n  if (i) {\n    if (i.b && i.b instanceof Node)\n      return i;\n    var t = i._ps;\n    return t.length ? wT(t[0]) : null;\n  }\n}\nfunction Ki(i, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var n = t || {}, s = n.key, a = n.ref, o = pT(n, [\"key\", \"ref\"]);\n  return {\n    type: i,\n    key: s,\n    ref: a,\n    props: Pn(Pn({}, o), {\n      children: $A(e).filter(function(u) {\n        return u != null && u !== !1;\n      })\n    })\n  };\n}\nvar ET = /* @__PURE__ */ function(i) {\n  Td(t, i);\n  function t(r, n) {\n    n === void 0 && (n = 0);\n    var s = i.call(this, \"container\", n, \"container\", 0, null) || this;\n    return s.typ = \"container\", s.b = r, s;\n  }\n  var e = t.prototype;\n  return e.r = function() {\n    return !0;\n  }, e.un = function() {\n  }, t;\n}(u0), lL = /* @__PURE__ */ function(i) {\n  Td(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.typ = \"text\", r;\n  }\n  var e = t.prototype;\n  return e.r = function(r) {\n    var n, s = this, a = !s.b;\n    if (a) {\n      var o = (n = s._hyd) === null || n === void 0 ? void 0 : n.splice(0, 1)[0];\n      s.b = o || document.createTextNode(s.t.replace(\"text_\", \"\"));\n    }\n    return r.push(function() {\n      a ? s.md() : s.ud();\n    }), !0;\n  }, e.un = function() {\n    gT(this.b);\n  }, t;\n}(u0);\nfunction hL(i, t, e) {\n  var r = e.map(function(u) {\n    return Vr(u) ? null : u.key;\n  }), n = cw(t.map(function(u) {\n    return u.k;\n  })), s = cw(r), a = Sd(n, s, function(u) {\n    return u;\n  });\n  a.removed.forEach(function(u) {\n    t.splice(u, 1)[0].un();\n  }), a.ordered.forEach(function(u) {\n    var l = u[0], h = u[1], d = t.splice(l, 1)[0];\n    t.splice(h, 0, d);\n    var f = gc(d.b), p = gc(t[h + 1] && t[h + 1].b);\n    f && f.parentNode.insertBefore(f, p);\n  }), a.added.forEach(function(u) {\n    t.splice(u, 0, pw(e[u], r[u], u, i));\n  });\n  var o = a.maintained.filter(function(u) {\n    u[0];\n    var l = u[1], h = e[l], d = t[l], f = Vr(h) ? \"text_\".concat(h) : h.type;\n    return f !== d.t ? (d.un(), t.splice(l, 1, pw(h, r[l], l, i)), !0) : (d.i = l, !1);\n  });\n  return hw(hw([], a.added, !0), o.map(function(u) {\n    u[0];\n    var l = u[1];\n    return l;\n  }), !0);\n}\nfunction cL(i, t) {\n  for (var e = i._ps, r = e.length, n = t.i + 1; n < r; ++n) {\n    var s = gc(e[n].b);\n    if (s)\n      return s;\n  }\n  return null;\n}\nfunction pw(i, t, e, r) {\n  var n = r.d + 1;\n  if (Vr(i) || pc(i))\n    return new lL(\"text_\".concat(i), n, t, e, r, null, {});\n  var s = i.type, a = typeof s == \"string\" ? uL : iL;\n  return new a(s, n, t, e, r, i.ref, i.props);\n}\nfunction Cd(i, t, e, r, n, s, a) {\n  var o = hL(i, t, e), u = i._hyd, l = t.filter(function(d, f) {\n    return d._hyd = u, d.u(r, n, e[f], s, a);\n  });\n  i.typ === \"container\" && i._sel && t.forEach(function(d) {\n    var f = wT(d);\n    f && (f._sel = !0);\n  }), i._hyd = null;\n  var h = ux(i);\n  return h && o.reverse().forEach(function(d) {\n    var f = t[d], p = gc(f.b);\n    if (p && h !== p && !p.parentNode) {\n      var v = cL(i, f);\n      h.insertBefore(p, v);\n    }\n  }), l.length > 0;\n}\nfunction fL(i, t, e, r) {\n  e === void 0 && (e = t.__CROACT__), r === void 0 && (r = {});\n  var n = !!e;\n  e || (e = new ET(t));\n  var s = [];\n  return Cd(e, e._ps, i ? [i] : [], s, r, void 0, void 0), mT(s), hx(null), n || (t.__CROACT__ = e), e;\n}\nfunction vw(i, t, e) {\n  return !e && i && (e = new ET(t.parentElement), e._hyd = [t], e._sel = !0), fL(i, t, e), e;\n}\nfunction ST(i) {\n  var t = _T(), e = t._hs || (t._hs = []), r = QA(), n = e[r];\n  if (tL(r + 1), n) {\n    if (!Ev(n.deps, i.deps))\n      return n.updated = !1, n;\n    e[r] = i;\n  } else\n    e.push(i);\n  return i.value = i.func(), i.updated = !0, i;\n}\nfunction dL(i, t) {\n  var e = ST({\n    func: i,\n    deps: t\n  });\n  return e.value;\n}\nfunction pL(i) {\n  return dL(function() {\n    return xT(i);\n  }, []);\n}\nfunction TT(i, t, e) {\n  var r = _T(), n = ST({\n    func: function() {\n      return i;\n    },\n    deps: t\n  }), s = e ? r._usefs : r._uefs;\n  n.updated ? s.push(function() {\n    return n.effect && n.effect(), n.effect = i(), n.effect;\n  }) : s.push(function() {\n    return n.effect;\n  });\n}\nfunction vL(i, t, e) {\n  TT(function() {\n    i == null || i(t());\n  }, e, !0);\n}\nfunction dx(i, t) {\n  for (var e = i.length, r = 0; r < e; ++r)\n    if (t(i[r], r))\n      return !0;\n  return !1;\n}\nfunction CT(i, t) {\n  for (var e = i.length, r = 0; r < e; ++r)\n    if (t(i[r], r))\n      return i[r];\n  return null;\n}\nfunction MT(i) {\n  var t = i;\n  if (typeof t > \"u\") {\n    if (typeof navigator > \"u\" || !navigator)\n      return \"\";\n    t = navigator.userAgent || \"\";\n  }\n  return t.toLowerCase();\n}\nfunction px(i, t) {\n  try {\n    return new RegExp(i, \"g\").exec(t);\n  } catch {\n    return null;\n  }\n}\nfunction gL() {\n  if (typeof navigator > \"u\" || !navigator || !navigator.userAgentData)\n    return !1;\n  var i = navigator.userAgentData, t = i.brands || i.uaList;\n  return !!(t && t.length);\n}\nfunction mL(i, t) {\n  var e = px(\"(\" + i + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", t);\n  return e ? e[3] : \"\";\n}\nfunction h_(i) {\n  return i.replace(/_/g, \".\");\n}\nfunction Dh(i, t) {\n  var e = null, r = \"-1\";\n  return dx(i, function(n) {\n    var s = px(\"(\" + n.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", t);\n    return !s || n.brand ? !1 : (e = n, r = s[3] || \"-1\", n.versionAlias ? r = n.versionAlias : n.versionTest && (r = mL(n.versionTest.toLowerCase(), t) || r), r = h_(r), !0);\n  }), {\n    preset: e,\n    version: r\n  };\n}\nfunction Th(i, t) {\n  var e = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  return dx(i, function(r) {\n    var n = PT(t, r);\n    return n ? (e.brand = r.id, e.version = r.versionAlias || n.version, e.version !== \"-1\") : !1;\n  }), e;\n}\nfunction PT(i, t) {\n  return CT(i, function(e) {\n    var r = e.brand;\n    return px(\"\" + t.test, r.toLowerCase());\n  });\n}\nvar c_ = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}], OT = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: !0\n}], f_ = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}], IT = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}], RT = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\nfunction DT(i) {\n  return !!Dh(IT, i).preset;\n}\nfunction yL(i) {\n  var t = MT(i), e = !!/mobi/g.exec(t), r = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: DT(t),\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webkit: !1,\n    webkitVersion: \"-1\"\n  }, n = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  }, s = Dh(c_, t), a = s.preset, o = s.version, u = Dh(RT, t), l = u.preset, h = u.version, d = Dh(OT, t);\n  if (r.chromium = !!d.preset, r.chromiumVersion = d.version, !r.chromium) {\n    var f = Dh(f_, t);\n    r.webkit = !!f.preset, r.webkitVersion = f.version;\n  }\n  return l && (n.name = l.id, n.version = h, n.majorVersion = parseInt(h, 10)), a && (r.name = a.id, r.version = o, r.webview && n.name === \"ios\" && r.name !== \"safari\" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {\n    browser: r,\n    os: n,\n    isMobile: e,\n    isHints: !1\n  };\n}\nfunction _L(i) {\n  var t = navigator.userAgentData, e = (t.uaList || t.brands).slice(), r = i && i.fullVersionList, n = t.mobile || !1, s = e[0], a = (i && i.platform || t.platform || navigator.platform).toLowerCase(), o = {\n    name: s.brand,\n    version: s.version,\n    majorVersion: -1,\n    webkit: !1,\n    webkitVersion: \"-1\",\n    chromium: !1,\n    chromiumVersion: \"-1\",\n    webview: !!Th(IT, e).brand || DT(MT())\n  }, u = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  o.webkit = !o.chromium && dx(f_, function(v) {\n    return PT(e, v);\n  });\n  var l = Th(OT, e);\n  if (o.chromium = !!l.brand, o.chromiumVersion = l.version, !o.chromium) {\n    var h = Th(f_, e);\n    o.webkit = !!h.brand, o.webkitVersion = h.version;\n  }\n  var d = CT(RT, function(v) {\n    return new RegExp(\"\" + v.test, \"g\").exec(a);\n  });\n  if (u.name = d ? d.id : \"\", i && (u.version = i.platformVersion), r && r.length) {\n    var f = Th(c_, r);\n    o.name = f.brand || o.name, o.version = f.version || o.version;\n  } else {\n    var p = Th(c_, e);\n    o.name = p.brand || o.name, o.version = p.brand && i ? i.uaFullVersion : p.version;\n  }\n  return o.webkit && (u.name = n ? \"ios\" : \"mac\"), u.name === \"ios\" && o.webview && (o.version = \"-1\"), u.version = h_(u.version), o.version = h_(o.version), u.majorVersion = parseInt(u.version, 10), o.majorVersion = parseInt(o.version, 10), {\n    browser: o,\n    os: u,\n    isMobile: n,\n    isHints: !0\n  };\n}\nfunction bL(i) {\n  return typeof i > \"u\" && gL() ? _L() : yL(i);\n}\nfunction xL(i, t, e, r, n, s) {\n  for (var a = 0; a < n; ++a) {\n    var o = e + a * n, u = r + a * n;\n    i[o] += i[u] * s, t[o] += t[u] * s;\n  }\n}\nfunction wL(i, t, e, r, n) {\n  for (var s = 0; s < n; ++s) {\n    var a = e + s * n, o = r + s * n, u = i[a], l = t[a];\n    i[a] = i[o], i[o] = u, t[a] = t[o], t[o] = l;\n  }\n}\nfunction EL(i, t, e, r, n) {\n  for (var s = 0; s < r; ++s) {\n    var a = e + s * r;\n    i[a] /= n, t[a] /= n;\n  }\n}\nfunction kT(i, t, e) {\n  e === void 0 && (e = Math.sqrt(i.length));\n  for (var r = i.slice(), n = 0; n < e; ++n)\n    r[n * e + t - 1] = 0, r[(t - 1) * e + n] = 0;\n  return r[(t - 1) * (e + 1)] = 1, r;\n}\nfunction Nn(i, t) {\n  t === void 0 && (t = Math.sqrt(i.length));\n  for (var e = i.slice(), r = Oe(t), n = 0; n < t; ++n) {\n    var s = t * n + n;\n    if (!Gt(e[s], Je)) {\n      for (var a = n + 1; a < t; ++a)\n        if (e[t * n + a]) {\n          wL(e, r, n, a, t);\n          break;\n        }\n    }\n    if (!Gt(e[s], Je))\n      return [];\n    EL(e, r, n, t, e[s]);\n    for (var a = 0; a < t; ++a) {\n      var o = a, u = a + n * t, l = e[u];\n      !Gt(l, Je) || n === a || xL(e, r, o, n, t, -l);\n    }\n  }\n  return r;\n}\nfunction SL(i, t) {\n  t === void 0 && (t = Math.sqrt(i.length));\n  for (var e = [], r = 0; r < t; ++r)\n    for (var n = 0; n < t; ++n)\n      e[n * t + r] = i[t * r + n];\n  return e;\n}\nfunction NT(i, t) {\n  t === void 0 && (t = Math.sqrt(i.length));\n  for (var e = [], r = i[t * t - 1], n = 0; n < t - 1; ++n)\n    e[n] = i[t * (t - 1) + n] / r;\n  return e[t - 1] = 0, e;\n}\nfunction TL(i, t) {\n  for (var e = Oe(t), r = 0; r < t - 1; ++r)\n    e[t * (t - 1) + r] = i[r] || 0;\n  return e;\n}\nfunction eu(i, t) {\n  for (var e = i.slice(), r = i.length; r < t - 1; ++r)\n    e[r] = 0;\n  return e[t - 1] = 1, e;\n}\nfunction An(i, t, e) {\n  if (t === void 0 && (t = Math.sqrt(i.length)), t === e)\n    return i;\n  for (var r = Oe(e), n = Math.min(t, e), s = 0; s < n - 1; ++s) {\n    for (var a = 0; a < n - 1; ++a)\n      r[s * e + a] = i[s * t + a];\n    r[(s + 1) * e - 1] = i[(s + 1) * t - 1], r[(e - 1) * e + s] = i[(t - 1) * t + s];\n  }\n  return r[e * e - 1] = i[t * t - 1], r;\n}\nfunction d_(i) {\n  for (var t = [], e = 1; e < arguments.length; e++)\n    t[e - 1] = arguments[e];\n  var r = Oe(i);\n  return t.forEach(function(n) {\n    r = _e(r, n, i);\n  }), r;\n}\nfunction _e(i, t, e) {\n  e === void 0 && (e = Math.sqrt(i.length));\n  var r = [], n = i.length / e, s = t.length / n;\n  if (n) {\n    if (!s)\n      return i;\n  } else\n    return t;\n  for (var a = 0; a < e; ++a)\n    for (var o = 0; o < s; ++o) {\n      r[o * e + a] = 0;\n      for (var u = 0; u < n; ++u)\n        r[o * e + a] += i[u * e + a] * t[o * n + u];\n    }\n  return r;\n}\nfunction Jt(i, t) {\n  for (var e = Math.min(i.length, t.length), r = i.slice(), n = 0; n < e; ++n)\n    r[n] = r[n] + t[n];\n  return r;\n}\nfunction Mt(i, t) {\n  for (var e = Math.min(i.length, t.length), r = i.slice(), n = 0; n < e; ++n)\n    r[n] = r[n] - t[n];\n  return r;\n}\nfunction CL(i, t) {\n  return t === void 0 && (t = i.length === 6), t ? [i[0], i[1], 0, i[2], i[3], 0, i[4], i[5], 1] : i;\n}\nfunction AT(i, t) {\n  return t === void 0 && (t = i.length === 9), t ? [i[0], i[1], i[3], i[4], i[6], i[7]] : i;\n}\nfunction br(i, t, e) {\n  e === void 0 && (e = t.length);\n  var r = _e(i, t, e), n = r[e - 1];\n  return r.map(function(s) {\n    return s / n;\n  });\n}\nfunction ML(i, t) {\n  return _e(i, [1, 0, 0, 0, 0, Math.cos(t), Math.sin(t), 0, 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction PL(i, t) {\n  return _e(i, [Math.cos(t), 0, -Math.sin(t), 0, 0, 1, 0, 0, Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1], 4);\n}\nfunction OL(i, t) {\n  return _e(i, Pd(t, 4));\n}\nfunction hp(i, t) {\n  var e = t[0], r = e === void 0 ? 1 : e, n = t[1], s = n === void 0 ? 1 : n, a = t[2], o = a === void 0 ? 1 : a;\n  return _e(i, [r, 0, 0, 0, 0, s, 0, 0, 0, 0, o, 0, 0, 0, 0, 1], 4);\n}\nfunction Md(i, t) {\n  return br(Pd(t, 3), eu(i, 3));\n}\nfunction iy(i, t) {\n  var e = t[0], r = e === void 0 ? 0 : e, n = t[1], s = n === void 0 ? 0 : n, a = t[2], o = a === void 0 ? 0 : a;\n  return _e(i, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, s, o, 1], 4);\n}\nfunction gw(i, t) {\n  return _e(i, t, 4);\n}\nfunction Pd(i, t) {\n  var e = Math.cos(i), r = Math.sin(i), n = Oe(t);\n  return n[0] = e, n[1] = r, n[t] = -r, n[t + 1] = e, n;\n}\nfunction Oe(i) {\n  for (var t = i * i, e = [], r = 0; r < t; ++r)\n    e[r] = r % (i + 1) ? 0 : 1;\n  return e;\n}\nfunction Sv(i, t) {\n  for (var e = Oe(t), r = Math.min(i.length, t - 1), n = 0; n < r; ++n)\n    e[(t + 1) * n] = i[n];\n  return e;\n}\nfunction mc(i, t) {\n  for (var e = Oe(t), r = Math.min(i.length, t - 1), n = 0; n < r; ++n)\n    e[t * (t - 1) + n] = i[n];\n  return e;\n}\nfunction vx(i, t, e, r, n, s, a, o) {\n  var u = i[0], l = i[1], h = t[0], d = t[1], f = e[0], p = e[1], v = r[0], g = r[1], m = n[0], y = n[1], _ = s[0], b = s[1], w = a[0], T = a[1], x = o[0], S = o[1], C = [u, 0, h, 0, f, 0, v, 0, l, 0, d, 0, p, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, u, 0, h, 0, f, 0, v, 0, l, 0, d, 0, p, 0, g, 0, 1, 0, 1, 0, 1, 0, 1, -m * u, -y * u, -_ * h, -b * h, -w * f, -T * f, -x * v, -S * v, -m * l, -y * l, -_ * d, -b * d, -w * p, -T * p, -x * g, -S * g], M = Nn(C, 8);\n  if (!M.length)\n    return [];\n  var I = _e(M, [m, y, _, b, w, T, x, S], 8);\n  return I[8] = 1, An(SL(I), 3, 4);\n}\nfunction IL() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\nfunction gx(i) {\n  return bu(Da(i));\n}\nfunction RL(i, t) {\n  var e = br(i, [t[0], t[1] || 0, t[2] || 0, 1], 4), r = e[3] || 1;\n  return [e[0] / r, e[1] / r, e[2] / r];\n}\nfunction bu(i) {\n  var t = IL();\n  return i.forEach(function(e) {\n    var r = e.matrixFunction, n = e.functionValue;\n    r && (t = r(t, n));\n  }), t;\n}\nfunction Da(i) {\n  var t = tr(i) ? i : fa(i);\n  return t.map(function(e) {\n    var r = lT(e), n = r.prefix, s = r.value, a = null, o = n, u = \"\";\n    if (n === \"translate\" || n === \"translateX\" || n === \"translate3d\") {\n      var l = Ga(s).map(function(I) {\n        return parseFloat(I);\n      }), h = l[0], d = l[1], f = d === void 0 ? 0 : d, p = l[2], v = p === void 0 ? 0 : p;\n      a = iy, u = [h, f, v];\n    } else if (n === \"translateY\") {\n      var f = parseFloat(s);\n      a = iy, u = [0, f, 0];\n    } else if (n === \"translateZ\") {\n      var v = parseFloat(s);\n      a = iy, u = [0, 0, v];\n    } else if (n === \"scale\" || n === \"scale3d\") {\n      var g = Ga(s).map(function(I) {\n        return parseFloat(I);\n      }), m = g[0], y = g[1], _ = y === void 0 ? m : y, b = g[2], w = b === void 0 ? 1 : b;\n      a = hp, u = [m, _, w];\n    } else if (n === \"scaleX\") {\n      var m = parseFloat(s);\n      a = hp, u = [m, 1, 1];\n    } else if (n === \"scaleY\") {\n      var _ = parseFloat(s);\n      a = hp, u = [1, _, 1];\n    } else if (n === \"scaleZ\") {\n      var w = parseFloat(s);\n      a = hp, u = [1, 1, w];\n    } else if (n === \"rotate\" || n === \"rotateZ\" || n === \"rotateX\" || n === \"rotateY\") {\n      var T = Ed(s), x = T.unit, S = T.value, C = x === \"rad\" ? S : S * Math.PI / 180;\n      n === \"rotate\" || n === \"rotateZ\" ? (o = \"rotateZ\", a = OL) : n === \"rotateX\" ? a = ML : n === \"rotateY\" && (a = PL), u = C;\n    } else if (n === \"matrix3d\")\n      a = gw, u = Ga(s).map(function(I) {\n        return parseFloat(I);\n      });\n    else if (n === \"matrix\") {\n      var M = Ga(s).map(function(I) {\n        return parseFloat(I);\n      });\n      a = gw, u = [M[0], M[1], 0, 0, M[2], M[3], 0, 0, 0, 0, 1, 0, M[4], M[5], 0, 1];\n    } else\n      o = \"\";\n    return {\n      name: n,\n      functionName: o,\n      value: s,\n      matrixFunction: a,\n      functionValue: u\n    };\n  });\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar p_ = function(i, t) {\n  return p_ = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, p_(i, t);\n};\nfunction DL(i, t) {\n  p_(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar LT = typeof Map == \"function\" ? void 0 : function() {\n  var i = 0;\n  return function(t) {\n    return t.__DIFF_KEY__ || (t.__DIFF_KEY__ = ++i);\n  };\n}(), kL = /* @__PURE__ */ function(i) {\n  DL(t, i);\n  function t(e) {\n    return e === void 0 && (e = []), i.call(this, e, LT) || this;\n  }\n  return t;\n}(KA);\nfunction NL(i, t) {\n  return Sd(i, t, LT);\n}\nconst BT = kL;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar v_ = function() {\n  return v_ = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, v_.apply(this, arguments);\n};\nfunction AL() {\n  for (var i = 0, t = 0, e = arguments.length; t < e; t++)\n    i += arguments[t].length;\n  for (var r = Array(i), n = 0, t = 0; t < e; t++)\n    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)\n      r[n] = s[a];\n  return r;\n}\nvar LL = /* @__PURE__ */ function() {\n  function i() {\n    this._events = {};\n  }\n  var t = i.prototype;\n  return t.on = function(e, r) {\n    if (ca(e))\n      for (var n in e)\n        this.on(n, e[n]);\n    else\n      this._addEvent(e, r, {});\n    return this;\n  }, t.off = function(e, r) {\n    if (!e)\n      this._events = {};\n    else if (ca(e))\n      for (var n in e)\n        this.off(n);\n    else if (!r)\n      this._events[e] = [];\n    else {\n      var s = this._events[e];\n      if (s) {\n        var a = Ms(s, function(o) {\n          return o.listener === r;\n        });\n        a > -1 && s.splice(a, 1);\n      }\n    }\n    return this;\n  }, t.once = function(e, r) {\n    var n = this;\n    return r && this._addEvent(e, r, {\n      once: !0\n    }), new Promise(function(s) {\n      n._addEvent(e, s, {\n        once: !0\n      });\n    });\n  }, t.emit = function(e, r) {\n    var n = this;\n    r === void 0 && (r = {});\n    var s = this._events[e];\n    if (!e || !s)\n      return !0;\n    var a = !1;\n    return r.eventType = e, r.stop = function() {\n      a = !0;\n    }, r.currentTarget = this, AL(s).forEach(function(o) {\n      o.listener(r), o.once && n.off(e, o.listener);\n    }), !a;\n  }, t.trigger = function(e, r) {\n    return r === void 0 && (r = {}), this.emit(e, r);\n  }, t._addEvent = function(e, r, n) {\n    var s = this._events;\n    s[e] = s[e] || [];\n    var a = s[e];\n    a.push(v_({\n      listener: r\n    }, n));\n  }, i;\n}();\nconst l0 = LL;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar g_ = function(i, t) {\n  return g_ = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, g_(i, t);\n};\nfunction BL(i, t) {\n  g_(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar Ru = function() {\n  return Ru = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, Ru.apply(this, arguments);\n};\nfunction FL(i) {\n  var t = i.container;\n  return t === document.body ? [t.scrollLeft || document.documentElement.scrollLeft, t.scrollTop || document.documentElement.scrollTop] : [t.scrollLeft, t.scrollTop];\n}\nfunction mw(i, t) {\n  return i.addEventListener(\"scroll\", t), function() {\n    i.removeEventListener(\"scroll\", t);\n  };\n}\nfunction cp(i) {\n  if (i) {\n    if (Vr(i))\n      return document.querySelector(i);\n  } else\n    return null;\n  if (sx(i))\n    return i();\n  if (i instanceof Element)\n    return i;\n  if (\"current\" in i)\n    return i.current;\n  if (\"value\" in i)\n    return i.value;\n}\nvar GL = /* @__PURE__ */ function(i) {\n  BL(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {\n      var n = r._currentOptions;\n      r._lock || !n || r.emit(\"scrollDrag\", {\n        next: function(s) {\n          r.checkScroll({\n            container: n.container,\n            inputEvent: s\n          });\n        }\n      });\n    }, r;\n  }\n  var e = t.prototype;\n  return e.dragStart = function(r, n) {\n    var s = cp(n.container);\n    if (!s) {\n      this._flag = !1;\n      return;\n    }\n    var a = 0, o = 0, u = 0, l = 0;\n    if (s === document.body)\n      u = window.innerWidth, l = window.innerHeight;\n    else {\n      var h = s.getBoundingClientRect();\n      a = h.top, o = h.left, u = h.width, l = h.height;\n    }\n    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {\n      top: a,\n      left: o,\n      width: u,\n      height: l\n    }, this._prevScrollPos = this._getScrollPosition([0, 0], n), this._currentOptions = n, this._registerScrollEvent(n);\n  }, e.drag = function(r, n) {\n    if (clearTimeout(this._timer), !!this._flag) {\n      var s = r.clientX, a = r.clientY, o = n.threshold, u = o === void 0 ? 0 : o, l = this, h = l._startRect, d = l._startPos;\n      this._currentOptions = n;\n      var f = [0, 0];\n      return h.top > a - u ? (d[1] > h.top || a < d[1]) && (f[1] = -1) : h.top + h.height < a + u && (d[1] < h.top + h.height || a > d[1]) && (f[1] = 1), h.left > s - u ? (d[0] > h.left || s < d[0]) && (f[0] = -1) : h.left + h.width < s + u && (d[0] < h.left + h.width || s > d[0]) && (f[0] = 1), !f[0] && !f[1] ? !1 : this._continueDrag(Ru(Ru({}, n), {\n        direction: f,\n        inputEvent: r,\n        isDrag: !0\n      }));\n    }\n  }, e.checkScroll = function(r) {\n    var n = this;\n    if (this._isWait)\n      return !1;\n    var s = r.prevScrollPos, a = s === void 0 ? this._prevScrollPos : s, o = r.direction, u = r.throttleTime, l = u === void 0 ? 0 : u, h = r.inputEvent, d = r.isDrag, f = this._getScrollPosition(o || [0, 0], r), p = f[0] - a[0], v = f[1] - a[1], g = o || [p ? Math.abs(p) / p : 0, v ? Math.abs(v) / v : 0];\n    return this._prevScrollPos = f, this._lock = !1, !p && !v ? !1 : (this.emit(\"move\", {\n      offsetX: g[0] ? p : 0,\n      offsetY: g[1] ? v : 0,\n      inputEvent: h\n    }), l && d && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n      n._continueDrag(r);\n    }, l)), !0);\n  }, e.dragEnd = function() {\n    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();\n  }, e._getScrollPosition = function(r, n) {\n    var s = n.container, a = n.getScrollPosition, o = a === void 0 ? FL : a;\n    return o({\n      container: cp(s),\n      direction: r\n    });\n  }, e._continueDrag = function(r) {\n    var n = this, s, a = r.container, o = r.direction, u = r.throttleTime, l = r.useScroll, h = r.isDrag, d = r.inputEvent;\n    if (!(!this._flag || h && this._isWait)) {\n      var f = vc(), p = Math.max(u + this._prevTime - f, 0);\n      if (p > 0)\n        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {\n          n._continueDrag(r);\n        }, p), !1;\n      this._prevTime = f;\n      var v = this._getScrollPosition(o, r);\n      this._prevScrollPos = v, h && (this._isWait = !0), l || (this._lock = !0);\n      var g = {\n        container: cp(a),\n        direction: o,\n        inputEvent: d\n      };\n      return (s = r.requestScroll) === null || s === void 0 || s.call(r, g), this.emit(\"scroll\", g), this._isWait = !1, l || this.checkScroll(Ru(Ru({}, r), {\n        prevScrollPos: v,\n        direction: o,\n        inputEvent: d\n      }));\n    }\n  }, e._registerScrollEvent = function(r) {\n    this._unregisterScrollEvent();\n    var n = r.checkScrollEvent;\n    if (n) {\n      var s = n === !0 ? mw : n, a = cp(r.container);\n      n === !0 && (a === document.body || a === document.documentElement) ? this._unregister = mw(window, this._onScroll) : this._unregister = s(a, this._onScroll);\n    }\n  }, e._unregisterScrollEvent = function() {\n    var r;\n    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;\n  }, t;\n}(l0);\nconst UL = GL;\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction jL() {\n  for (var i = 0, t = 0, e = arguments.length; t < e; t++)\n    i += arguments[t].length;\n  for (var r = Array(i), n = 0, t = 0; t < e; t++)\n    for (var s = arguments[t], a = 0, o = s.length; a < o; a++, n++)\n      r[n] = s[a];\n  return r;\n}\nfunction Fr(i) {\n  return Gt(i, Je);\n}\nfunction zL(i, t) {\n  return i.every(function(e, r) {\n    return Fr(e - t[r]) === 0;\n  });\n}\nfunction HL(i, t) {\n  return !Fr(i[0] - t[0]) && !Fr(i[1] - t[1]);\n}\nfunction FT(i) {\n  return i.length < 3 ? 0 : Math.abs(zA(i.map(function(t, e) {\n    var r = i[e + 1] || i[0];\n    return t[0] * r[1] - r[0] * t[1];\n  }))) / 2;\n}\nfunction yw(i, t) {\n  var e = t.width, r = t.height, n = t.left, s = t.top, a = ru(i), o = a.minX, u = a.minY, l = a.maxX, h = a.maxY, d = e / (l - o), f = r / (h - u);\n  return i.map(function(p) {\n    return [n + (p[0] - o) * d, s + (p[1] - u) * f];\n  });\n}\nfunction ru(i) {\n  var t = i.map(function(r) {\n    return r[0];\n  }), e = i.map(function(r) {\n    return r[1];\n  });\n  return {\n    minX: Math.min.apply(Math, t),\n    minY: Math.min.apply(Math, e),\n    maxX: Math.max.apply(Math, t),\n    maxY: Math.max.apply(Math, e)\n  };\n}\nfunction m_(i, t, e) {\n  var r = i[0], n = i[1], s = ru(t), a = s.minX, o = s.maxX, u = [[a, n], [o, n]], l = Tv(u[0], u[1]), h = y_(t), d = [];\n  if (h.forEach(function(v) {\n    var g = Tv(v[0], v[1]), m = v[0];\n    if (zL(l, g))\n      d.push({\n        pos: i,\n        line: v,\n        type: \"line\"\n      });\n    else {\n      var y = GT(mx(l, g), [u, v]);\n      y.forEach(function(_) {\n        v.some(function(b) {\n          return HL(b, _);\n        }) ? d.push({\n          pos: _,\n          line: v,\n          type: \"point\"\n        }) : Fr(m[1] - n) !== 0 && d.push({\n          pos: _,\n          line: v,\n          type: \"intersection\"\n        });\n      });\n    }\n  }), !e && nn(d, function(v) {\n    return v[0] === r;\n  }))\n    return !0;\n  var f = 0, p = {};\n  return d.forEach(function(v) {\n    var g = v.pos, m = v.type, y = v.line;\n    if (!(g[0] > r))\n      if (m === \"intersection\")\n        ++f;\n      else {\n        if (m === \"line\")\n          return;\n        if (m === \"point\") {\n          var _ = nn(y, function(T) {\n            return T[1] !== n;\n          }), b = p[g[0]], w = _[1] > n ? 1 : -1;\n          b ? b !== w && ++f : p[g[0]] = w;\n        }\n      }\n  }), f % 2 === 1;\n}\nfunction Tv(i, t) {\n  var e = i[0], r = i[1], n = t[0], s = t[1], a = n - e, o = s - r;\n  Math.abs(a) < Je && (a = 0), Math.abs(o) < Je && (o = 0);\n  var u = 0, l = 0, h = 0;\n  return a ? o ? (u = -o / a, l = 1, h = -u * e - r) : (l = 1, h = -r) : o && (u = -1, h = e), [u, l, h];\n}\nfunction mx(i, t) {\n  var e = i[0], r = i[1], n = i[2], s = t[0], a = t[1], o = t[2], u = e === 0 && s === 0, l = r === 0 && a === 0, h = [];\n  if (u && l)\n    return [];\n  if (u) {\n    var d = -n / r, f = -o / a;\n    return d !== f ? [] : [[-1 / 0, d], [1 / 0, d]];\n  } else if (l) {\n    var p = -n / e, v = -o / s;\n    return p !== v ? [] : [[p, -1 / 0], [p, 1 / 0]];\n  } else if (e === 0) {\n    var g = -n / r, m = -(a * g + o) / s;\n    h = [[m, g]];\n  } else if (s === 0) {\n    var g = -o / a, m = -(r * g + n) / e;\n    h = [[m, g]];\n  } else if (r === 0) {\n    var m = -n / e, g = -(s * m + o) / a;\n    h = [[m, g]];\n  } else if (a === 0) {\n    var m = -o / s, g = -(e * m + n) / r;\n    h = [[m, g]];\n  } else {\n    var m = (r * o - a * n) / (a * e - r * s), g = -(e * m + n) / r;\n    h = [[m, g]];\n  }\n  return h.map(function(y) {\n    return [y[0], y[1]];\n  });\n}\nfunction GT(i, t) {\n  var e = t.map(function(d) {\n    return [0, 1].map(function(f) {\n      return [Math.min(d[0][f], d[1][f]), Math.max(d[0][f], d[1][f])];\n    });\n  }), r = [];\n  if (i.length === 2) {\n    var n = i[0], s = n[0], a = n[1];\n    if (Fr(s - i[1][0])) {\n      if (!Fr(a - i[1][1])) {\n        var l = Math.max.apply(Math, e.map(function(d) {\n          return d[0][0];\n        })), h = Math.min.apply(Math, e.map(function(d) {\n          return d[0][1];\n        }));\n        if (Fr(l - h) > 0)\n          return [];\n        r = [[l, a], [h, a]];\n      }\n    } else {\n      var o = Math.max.apply(Math, e.map(function(d) {\n        return d[1][0];\n      })), u = Math.min.apply(Math, e.map(function(d) {\n        return d[1][1];\n      }));\n      if (Fr(o - u) > 0)\n        return [];\n      r = [[s, o], [s, u]];\n    }\n  }\n  return r.length || (r = i.filter(function(d) {\n    var f = d[0], p = d[1];\n    return e.every(function(v) {\n      return 0 <= Fr(f - v[0][0]) && 0 <= Fr(v[0][1] - f) && 0 <= Fr(p - v[1][0]) && 0 <= Fr(v[1][1] - p);\n    });\n  })), r.map(function(d) {\n    return [Fr(d[0]), Fr(d[1])];\n  });\n}\nfunction y_(i) {\n  return jL(i.slice(1), [i[0]]).map(function(t, e) {\n    return [i[e], t];\n  });\n}\nfunction $L(i, t) {\n  var e = i.slice(), r = t.slice();\n  u_(e) === -1 && e.reverse(), u_(r) === -1 && r.reverse();\n  var n = y_(e), s = y_(r), a = n.map(function(h) {\n    return Tv(h[0], h[1]);\n  }), o = s.map(function(h) {\n    return Tv(h[0], h[1]);\n  }), u = [];\n  a.forEach(function(h, d) {\n    var f = n[d], p = [];\n    o.forEach(function(v, g) {\n      var m = mx(h, v), y = GT(m, [f, s[g]]);\n      p.push.apply(p, y.map(function(_) {\n        return {\n          index1: d,\n          index2: g,\n          pos: _,\n          type: \"intersection\"\n        };\n      }));\n    }), p.sort(function(v, g) {\n      return Zi(f[0], v.pos) - Zi(f[0], g.pos);\n    }), u.push.apply(u, p), m_(f[1], r) && u.push({\n      index1: d,\n      index2: -1,\n      pos: f[1],\n      type: \"inside\"\n    });\n  }), s.forEach(function(h, d) {\n    if (m_(h[1], e)) {\n      var f = !1, p = Ms(u, function(v) {\n        var g = v.index2;\n        return g === d ? (f = !0, !1) : !!f;\n      });\n      p === -1 && (f = !1, p = Ms(u, function(v) {\n        var g = v.index1, m = v.index2;\n        return g === -1 && m + 1 === d ? (f = !0, !1) : !!f;\n      })), p === -1 ? u.push({\n        index1: -1,\n        index2: d,\n        pos: h[1],\n        type: \"inside\"\n      }) : u.splice(p, 0, {\n        index1: -1,\n        index2: d,\n        pos: h[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var l = {};\n  return u.filter(function(h) {\n    var d = h.pos, f = d[0] + \"x\" + d[1];\n    return l[f] ? !1 : (l[f] = !0, !0);\n  });\n}\nfunction VL(i, t) {\n  var e = $L(i, t);\n  return e.map(function(r) {\n    var n = r.pos;\n    return n;\n  });\n}\nfunction XL(i, t) {\n  var e = VL(i, t);\n  return FT(e);\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar __ = function(i, t) {\n  return __ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      r.hasOwnProperty(n) && (e[n] = r[n]);\n  }, __(i, t);\n};\nfunction WL(i, t) {\n  __(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar Xe = function() {\n  return Xe = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, Xe.apply(this, arguments);\n};\nfunction YL(i, t) {\n  var e = t[0] - i[0], r = t[1] - i[1], n = Math.atan2(r, e);\n  return n >= 0 ? n : n + Math.PI * 2;\n}\nfunction ny(i) {\n  return YL([\n    i[0].clientX,\n    i[0].clientY\n  ], [\n    i[1].clientX,\n    i[1].clientY\n  ]) / Math.PI * 180;\n}\nfunction qL(i) {\n  return i.touches && i.touches.length >= 2;\n}\nfunction fp(i) {\n  return i ? i.touches ? KL(i.touches) : [UT(i)] : [];\n}\nfunction ZL(i) {\n  return i && (i.type.indexOf(\"mouse\") > -1 || \"button\" in i);\n}\nfunction _w(i, t, e) {\n  var r = e.length, n = qh(i, r), s = n.clientX, a = n.clientY, o = n.originalClientX, u = n.originalClientY, l = qh(t, r), h = l.clientX, d = l.clientY, f = qh(e, r), p = f.clientX, v = f.clientY, g = s - h, m = a - d, y = s - p, _ = a - v;\n  return {\n    clientX: o,\n    clientY: u,\n    deltaX: g,\n    deltaY: m,\n    distX: y,\n    distY: _\n  };\n}\nfunction sy(i) {\n  return Math.sqrt(Math.pow(i[0].clientX - i[1].clientX, 2) + Math.pow(i[0].clientY - i[1].clientY, 2));\n}\nfunction KL(i) {\n  for (var t = Math.min(i.length, 2), e = [], r = 0; r < t; ++r)\n    e.push(UT(i[r]));\n  return e;\n}\nfunction UT(i) {\n  return {\n    clientX: i.clientX,\n    clientY: i.clientY\n  };\n}\nfunction qh(i, t) {\n  t === void 0 && (t = i.length);\n  for (var e = {\n    clientX: 0,\n    clientY: 0,\n    originalClientX: 0,\n    originalClientY: 0\n  }, r = 0; r < t; ++r) {\n    var n = i[r];\n    e.originalClientX += \"originalClientX\" in n ? n.originalClientX : n.clientX, e.originalClientY += \"originalClientY\" in n ? n.originalClientY : n.clientY, e.clientX += n.clientX, e.clientY += n.clientY;\n  }\n  return t ? {\n    clientX: e.clientX / t,\n    clientY: e.clientY / t,\n    originalClientX: e.originalClientX / t,\n    originalClientY: e.originalClientY / t\n  } : e;\n}\nvar ay = /* @__PURE__ */ function() {\n  function i(t) {\n    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = t, this.prevClients = t, this.length = t.length;\n  }\n  return i.prototype.getAngle = function(t) {\n    return t === void 0 && (t = this.prevClients), ny(t);\n  }, i.prototype.getRotation = function(t) {\n    return t === void 0 && (t = this.prevClients), ny(t) - ny(this.startClients);\n  }, i.prototype.getPosition = function(t, e) {\n    t === void 0 && (t = this.prevClients);\n    var r = _w(t || this.prevClients, this.prevClients, this.startClients), n = r.deltaX, s = r.deltaY;\n    return this.movement += Math.sqrt(n * n + s * s), this.prevClients = t, r;\n  }, i.prototype.getPositions = function(t) {\n    t === void 0 && (t = this.prevClients);\n    var e = this.prevClients;\n    return this.startClients.map(function(r, n) {\n      return _w([t[n]], [e[n]], [r]);\n    });\n  }, i.prototype.getMovement = function(t) {\n    var e = this.movement;\n    if (!t)\n      return e;\n    var r = qh(t, this.length), n = qh(this.prevClients, this.length), s = r.clientX - n.clientX, a = r.clientY - n.clientY;\n    return Math.sqrt(s * s + a * a) + e;\n  }, i.prototype.getDistance = function(t) {\n    return t === void 0 && (t = this.prevClients), sy(t);\n  }, i.prototype.getScale = function(t) {\n    return t === void 0 && (t = this.prevClients), sy(t) / sy(this.startClients);\n  }, i.prototype.move = function(t, e) {\n    this.startClients.forEach(function(r) {\n      r.clientX -= t, r.clientY -= e;\n    }), this.prevClients.forEach(function(r) {\n      r.clientX -= t, r.clientY -= e;\n    });\n  }, i;\n}(), bw = [\"textarea\", \"input\"], JL = /* @__PURE__ */ function(i) {\n  WL(t, i);\n  function t(e, r) {\n    r === void 0 && (r = {});\n    var n = i.call(this) || this;\n    n.options = {}, n.flag = !1, n.pinchFlag = !1, n.data = {}, n.isDrag = !1, n.isPinch = !1, n.isMouse = !1, n.isTouch = !1, n.clientStores = [], n.targets = [], n.prevTime = 0, n.doubleFlag = !1, n._dragFlag = !1, n._isTrusted = !1, n._isMouseEvent = !1, n._isSecondaryButton = !1, n._preventMouseEvent = !1, n._prevInputEvent = null, n.onDragStart = function(d, f) {\n      if (f === void 0 && (f = !0), !(!n.flag && d.cancelable === !1)) {\n        var p = n.options, v = p.container, g = p.pinchOutside, m = p.preventWheelClick, y = p.preventRightClick, _ = p.preventDefault, b = p.checkInput, w = p.preventClickEventOnDragStart, T = p.preventClickEventOnDrag, x = p.preventClickEventByCondition, S = n.isTouch, C = !n.flag;\n        if (n._isSecondaryButton = d.which === 3 || d.button === 2, m && (d.which === 2 || d.button === 1) || y && (d.which === 3 || d.button === 2))\n          return n.stop(), !1;\n        if (C) {\n          var M = document.activeElement, I = d.target;\n          if (I) {\n            var R = I.tagName.toLowerCase(), N = bw.indexOf(R) > -1, A = I.isContentEditable;\n            if (N || A) {\n              if (b || M === I || M && A && M.isContentEditable && M.contains(I))\n                return !1;\n            } else if ((_ || d.type === \"touchstart\") && M) {\n              var U = M.tagName.toLowerCase();\n              (M.isContentEditable || bw.indexOf(U) > -1) && M.blur();\n            }\n            (w || T || x) && Dr(window, \"click\", n._onClick, !0);\n          }\n          n.clientStores = [new ay(fp(d))], n.flag = !0, n.isDrag = !1, n._isTrusted = f, n._dragFlag = !0, n._prevInputEvent = d, n.data = {}, n.doubleFlag = vc() - n.prevTime < 200, n._isMouseEvent = ZL(d), !n._isMouseEvent && n._preventMouseEvent && (n._preventMouseEvent = !1);\n          var B = n._preventMouseEvent || n.emit(\"dragStart\", Xe(Xe({ data: n.data, datas: n.data, inputEvent: d, isMouseEvent: n._isMouseEvent, isSecondaryButton: n._isSecondaryButton, isTrusted: f, isDouble: n.doubleFlag }, n.getCurrentStore().getPosition()), { preventDefault: function() {\n            d.preventDefault();\n          }, preventDrag: function() {\n            n._dragFlag = !1;\n          } }));\n          B === !1 && n.stop(), n._isMouseEvent && n.flag && _ && d.preventDefault();\n        }\n        if (!n.flag)\n          return !1;\n        var G = 0;\n        if (C ? (n._attchDragEvent(), S && g && (G = setTimeout(function() {\n          Dr(v, \"touchstart\", n.onDragStart, {\n            passive: !1\n          });\n        }))) : S && g && gr(v, \"touchstart\", n.onDragStart), n.flag && qL(d)) {\n          if (clearTimeout(G), C && d.touches.length !== d.changedTouches.length)\n            return;\n          n.pinchFlag || n.onPinchStart(d);\n        }\n      }\n    }, n.onDrag = function(d, f) {\n      if (n.flag) {\n        var p = n.options.preventDefault;\n        !n._isMouseEvent && p && d.preventDefault(), n._prevInputEvent = d;\n        var v = fp(d), g = n.moveClients(v, d, !1);\n        if (n._dragFlag) {\n          if (n.pinchFlag || g.deltaX || g.deltaY) {\n            var m = n._preventMouseEvent || n.emit(\"drag\", Xe(Xe({}, g), { isScroll: !!f, inputEvent: d }));\n            if (m === !1) {\n              n.stop();\n              return;\n            }\n          }\n          n.pinchFlag && n.onPinch(d, v);\n        }\n        n.getCurrentStore().getPosition(v, !0);\n      }\n    }, n.onDragEnd = function(d) {\n      if (n.flag) {\n        var f = n.options, p = f.pinchOutside, v = f.container, g = f.preventClickEventOnDrag, m = f.preventClickEventOnDragStart, y = f.preventClickEventByCondition, _ = n.isDrag;\n        (g || m || y) && requestAnimationFrame(function() {\n          n._allowClickEvent();\n        }), !y && !m && g && !_ && n._allowClickEvent(), n.isTouch && p && gr(v, \"touchstart\", n.onDragStart), n.pinchFlag && n.onPinchEnd(d);\n        var b = d != null && d.touches ? fp(d) : [], w = b.length;\n        w === 0 || !n.options.keepDragging ? n.flag = !1 : n._addStore(new ay(b));\n        var T = n._getPosition(), x = vc(), S = !_ && n.doubleFlag;\n        n._prevInputEvent = null, n.prevTime = _ || S ? 0 : x, n.flag || (n._dettachDragEvent(), n._preventMouseEvent || n.emit(\"dragEnd\", Xe({ data: n.data, datas: n.data, isDouble: S, isDrag: _, isClick: !_, isMouseEvent: n._isMouseEvent, isSecondaryButton: n._isSecondaryButton, inputEvent: d, isTrusted: n._isTrusted }, T)), n.clientStores = [], n._isMouseEvent || (n._preventMouseEvent = !0, requestAnimationFrame(function() {\n          requestAnimationFrame(function() {\n            n._preventMouseEvent = !1;\n          });\n        })));\n      }\n    }, n.onBlur = function() {\n      n.onDragEnd();\n    }, n._allowClickEvent = function() {\n      gr(window, \"click\", n._onClick, !0);\n    }, n._onClick = function(d) {\n      n._allowClickEvent(), n._preventMouseEvent = !1;\n      var f = n.options.preventClickEventByCondition;\n      f != null && f(d) || (d.stopPropagation(), d.preventDefault());\n    }, n._onContextMenu = function(d) {\n      var f = n.options;\n      f.preventRightClick ? n.onDragEnd(d) : d.preventDefault();\n    }, n._passCallback = function() {\n    };\n    var s = [].concat(e);\n    n.options = Xe({ checkInput: !1, container: s.length > 1 ? window : s[0], preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: [\"touch\", \"mouse\"] }, r);\n    var a = n.options, o = a.container, u = a.events, l = a.checkWindowBlur;\n    if (n.isTouch = u.indexOf(\"touch\") > -1, n.isMouse = u.indexOf(\"mouse\") > -1, n.targets = s, n.isMouse && (s.forEach(function(d) {\n      Dr(d, \"mousedown\", n.onDragStart), Dr(d, \"mousemove\", n._passCallback);\n    }), Dr(o, \"contextmenu\", n._onContextMenu)), l && Dr(window, \"blur\", n.onBlur), n.isTouch) {\n      var h = {\n        passive: !1\n      };\n      s.forEach(function(d) {\n        Dr(d, \"touchstart\", n.onDragStart, h), Dr(d, \"touchmove\", n._passCallback, h);\n      });\n    }\n    return n;\n  }\n  return t.prototype.stop = function() {\n    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._allowClickEvent(), this._dettachDragEvent();\n  }, t.prototype.getMovement = function(e) {\n    return this.getCurrentStore().getMovement(e) + this.clientStores.slice(1).reduce(function(r, n) {\n      return r + n.movement;\n    }, 0);\n  }, t.prototype.isDragging = function() {\n    return this.isDrag;\n  }, t.prototype.isFlag = function() {\n    return this.flag;\n  }, t.prototype.isPinchFlag = function() {\n    return this.pinchFlag;\n  }, t.prototype.isDoubleFlag = function() {\n    return this.doubleFlag;\n  }, t.prototype.isPinching = function() {\n    return this.isPinch;\n  }, t.prototype.scrollBy = function(e, r, n, s) {\n    s === void 0 && (s = !0), this.flag && (this.clientStores[0].move(e, r), s && this.onDrag(n, !0));\n  }, t.prototype.move = function(e, r) {\n    var n = e[0], s = e[1], a = this.getCurrentStore(), o = a.prevClients;\n    return this.moveClients(o.map(function(u) {\n      var l = u.clientX, h = u.clientY;\n      return {\n        clientX: l + n,\n        clientY: h + s,\n        originalClientX: l,\n        originalClientY: h\n      };\n    }), r, !0);\n  }, t.prototype.triggerDragStart = function(e) {\n    this.onDragStart(e, !1);\n  }, t.prototype.setEventData = function(e) {\n    var r = this.data;\n    for (var n in e)\n      r[n] = e[n];\n    return this;\n  }, t.prototype.setEventDatas = function(e) {\n    return this.setEventData(e);\n  }, t.prototype.getCurrentEvent = function(e) {\n    return e === void 0 && (e = this._prevInputEvent), Xe(Xe({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: e });\n  }, t.prototype.getEventData = function() {\n    return this.data;\n  }, t.prototype.getEventDatas = function() {\n    return this.data;\n  }, t.prototype.unset = function() {\n    var e = this, r = this.targets, n = this.options.container;\n    this.off(), gr(window, \"blur\", this.onBlur), this.isMouse && (r.forEach(function(s) {\n      gr(s, \"mousedown\", e.onDragStart);\n    }), gr(n, \"contextmenu\", this._onContextMenu)), this.isTouch && (r.forEach(function(s) {\n      gr(s, \"touchstart\", e.onDragStart);\n    }), gr(n, \"touchstart\", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();\n  }, t.prototype.onPinchStart = function(e) {\n    var r = this, n = this.options.pinchThreshold;\n    if (!(this.isDrag && this.getMovement() > n)) {\n      var s = new ay(fp(e));\n      this.pinchFlag = !0, this._addStore(s);\n      var a = this.emit(\"pinchStart\", Xe(Xe({ data: this.data, datas: this.data, angle: s.getAngle(), touches: this.getCurrentStore().getPositions() }, s.getPosition()), { inputEvent: e, isTrusted: this._isTrusted, preventDefault: function() {\n        e.preventDefault();\n      }, preventDrag: function() {\n        r._dragFlag = !1;\n      } }));\n      a === !1 && (this.pinchFlag = !1);\n    }\n  }, t.prototype.onPinch = function(e, r) {\n    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {\n      var n = this.getCurrentStore();\n      this.isPinch = !0, this.emit(\"pinch\", Xe(Xe({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: n.getAngle(r), rotation: n.getRotation(r), touches: n.getPositions(r), scale: n.getScale(r), distance: n.getDistance(r) }, n.getPosition(r)), { inputEvent: e, isTrusted: this._isTrusted }));\n    }\n  }, t.prototype.onPinchEnd = function(e) {\n    if (this.pinchFlag) {\n      var r = this.isPinch;\n      this.isPinch = !1, this.pinchFlag = !1;\n      var n = this.getCurrentStore();\n      this.emit(\"pinchEnd\", Xe(Xe({ data: this.data, datas: this.data, isPinch: r, touches: n.getPositions() }, n.getPosition()), { inputEvent: e }));\n    }\n  }, t.prototype.getCurrentStore = function() {\n    return this.clientStores[0];\n  }, t.prototype.moveClients = function(e, r, n) {\n    var s = this._getPosition(e, n), a = this.isDrag;\n    (s.deltaX || s.deltaY) && (this.isDrag = !0);\n    var o = !1;\n    return !a && this.isDrag && (o = !0), Xe(Xe({ data: this.data, datas: this.data }, s), { movement: this.getMovement(e), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: o });\n  }, t.prototype._addStore = function(e) {\n    this.clientStores.splice(0, 0, e);\n  }, t.prototype._getPosition = function(e, r) {\n    var n = this.getCurrentStore(), s = n.getPosition(e, r), a = this.clientStores.slice(1).reduce(function(l, h) {\n      var d = h.getPosition();\n      return l.distX += d.distX, l.distY += d.distY, l;\n    }, s), o = a.distX, u = a.distY;\n    return Xe(Xe({}, s), { distX: o, distY: u });\n  }, t.prototype._attchDragEvent = function() {\n    var e = this.options.container, r = {\n      passive: !1\n    };\n    this.isMouse && (Dr(e, \"mousemove\", this.onDrag), Dr(e, \"mouseup\", this.onDragEnd)), this.isTouch && (Dr(e, \"touchmove\", this.onDrag, r), Dr(e, \"touchend\", this.onDragEnd, r), Dr(e, \"touchcancel\", this.onDragEnd, r));\n  }, t.prototype._dettachDragEvent = function() {\n    var e = this.options.container;\n    this.isMouse && (gr(e, \"mousemove\", this.onDrag), gr(e, \"mouseup\", this.onDragEnd)), this.isTouch && (gr(e, \"touchstart\", this.onDragStart), gr(e, \"touchmove\", this.onDrag), gr(e, \"touchend\", this.onDragEnd), gr(e, \"touchcancel\", this.onDragEnd));\n  }, t;\n}(l0);\nfunction QL(i) {\n  for (var t = 5381, e = i.length; e; )\n    t = t * 33 ^ i.charCodeAt(--e);\n  return t >>> 0;\n}\nvar tB = QL;\nfunction eB(i) {\n  return tB(i).toString(36);\n}\nfunction rB(i) {\n  if (i && i.getRootNode) {\n    var t = i.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction iB(i, t, e) {\n  return e.original ? t : t.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function(r, n) {\n    var s = n.trim();\n    return (s ? Ga(s) : [\"\"]).map(function(a) {\n      var o = a.trim();\n      return o.indexOf(\"@\") === 0 ? o : o.indexOf(\":global\") > -1 ? o.replace(/\\:global/g, \"\") : o.indexOf(\":host\") > -1 ? \"\" + o.replace(/\\:host/g, \".\" + i) : o ? \".\" + i + \" \" + o : \".\" + i;\n    }).join(\", \") + \" {\";\n  });\n}\nfunction nB(i, t, e, r) {\n  var n = document.createElement(\"style\");\n  return n.setAttribute(\"type\", \"text/css\"), n.setAttribute(\"data-styled-id\", i), e.nonce && n.setAttribute(\"nonce\", e.nonce), n.innerHTML = iB(i, t, e), (r || document.head || document.body).appendChild(n), n;\n}\nfunction sB(i) {\n  var t = \"rCS\" + eB(i), e = 0, r;\n  return {\n    className: t,\n    inject: function(n, s) {\n      s === void 0 && (s = {});\n      var a = rB(n), o = e === 0, u;\n      return (a || o) && (u = nB(t, i, s, a)), o && (r = u), a || ++e, {\n        destroy: function() {\n          a ? (a.removeChild(u), u = null) : (e > 0 && --e, e === 0 && r && (r.parentNode.removeChild(r), r = null));\n        }\n      };\n    }\n  };\n}\nvar b_ = function() {\n  return b_ = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, b_.apply(this, arguments);\n};\nfunction aB(i, t) {\n  var e = {};\n  for (var r in i)\n    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);\n  if (i != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)\n      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);\n  return e;\n}\nfunction jT(i, t) {\n  var e = sB(t), r = e.className;\n  return eL(function(n, s) {\n    var a = n.className, o = a === void 0 ? \"\" : a;\n    n.cspNonce;\n    var u = aB(n, [\"className\", \"cspNonce\"]), l = pL();\n    return vL(s, function() {\n      return l.current;\n    }, []), TT(function() {\n      var h = e.inject(l.current, {\n        nonce: n.cspNonce\n      });\n      return function() {\n        h.destroy();\n      };\n    }, []), Ki(i, b_({\n      ref: l,\n      \"data-styled-id\": r,\n      className: \"\".concat(o, \" \").concat(r)\n    }, u));\n  });\n}\nvar x_ = function(i, t) {\n  return x_ = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n  }, x_(i, t);\n};\nfunction Od(i, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  x_(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar F = function() {\n  return F = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, F.apply(this, arguments);\n};\nfunction oB(i, t) {\n  var e = {};\n  for (var r in i)\n    Object.prototype.hasOwnProperty.call(i, r) && t.indexOf(r) < 0 && (e[r] = i[r]);\n  if (i != null && typeof Object.getOwnPropertySymbols == \"function\")\n    for (var n = 0, r = Object.getOwnPropertySymbols(i); n < r.length; n++)\n      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(i, r[n]) && (e[r[n]] = i[r[n]]);\n  return e;\n}\nfunction uB(i, t, e, r) {\n  var n = arguments.length, s = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, a;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    s = Reflect.decorate(i, t, e, r);\n  else\n    for (var o = i.length - 1; o >= 0; o--)\n      (a = i[o]) && (s = (n < 3 ? a(s) : n > 3 ? a(t, e, s) : a(t, e)) || s);\n  return n > 3 && s && Object.defineProperty(t, e, s), s;\n}\nfunction Tt(i, t, e) {\n  if (e || arguments.length === 2)\n    for (var r = 0, n = t.length, s; r < n; r++)\n      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);\n  return i.concat(s || Array.prototype.slice.call(t));\n}\nfunction Id(i, t) {\n  return F({\n    events: [],\n    props: [],\n    name: i\n  }, t);\n}\nvar lB = [\"n\", \"w\", \"s\", \"e\"], yx = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\nfunction hB(i, t) {\n  return 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"'.concat(32 * i, 'px\" height=\"').concat(32 * i, 'px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(').concat(t, 'deg);transform-origin: 16px 16px\"></path></svg>');\n}\nfunction cB(i) {\n  var t = hB(1, i), e = Math.round(i / 45) * 45 % 180, r = \"ns-resize\";\n  return e === 135 ? r = \"nwse-resize\" : e === 45 ? r = \"nesw-resize\" : e === 90 && (r = \"ew-resize\"), \"cursor:\".concat(r, \";cursor: url('\").concat(t, \"') 16 16, \").concat(r, \";\");\n}\nvar fh = bL(), zT = fh.browser.webkit, HT = zT && function() {\n  var i = typeof window > \"u\" ? {\n    userAgent: \"\"\n  } : window.navigator, t = /applewebkit\\/([^\\s]+)/g.exec(i.userAgent.toLowerCase());\n  return t ? parseFloat(t[1]) < 605 : !1;\n}(), $T = fh.browser.name, VT = parseInt(fh.browser.version, 10), fB = $T === \"chrome\", dB = fh.browser.chromium, pB = parseInt(fh.browser.chromiumVersion, 10) || 0, vB = fB && VT >= 109 || dB && pB >= 109, gB = $T === \"firefox\", mB = parseInt(fh.browser.webkitVersion, 10) >= 612 || VT >= 15, _x = \"moveable-\", yB = yx.map(function(i) {\n  var t = \"\", e = \"\", r = \"center\", n = \"center\";\n  return i.indexOf(\"n\") > -1 && (t = \"top: -20px;\", n = \"bottom\"), i.indexOf(\"s\") > -1 && (t = \"top: 0px;\", n = \"top\"), i.indexOf(\"w\") > -1 && (e = \"left: -20px;\", r = \"right\"), i.indexOf(\"e\") > -1 && (e = \"left: 0px;\", r = \"left\"), '.around-control[data-direction*=\"'.concat(i, `\"] {\n        `).concat(e).concat(t, `\n        transform-origin: `).concat(r, \" \").concat(n, `;\n    }`);\n}).join(`\n`), _B = `\n{\nposition: absolute;\nwidth: 1px;\nheight: 1px;\nleft: 0;\ntop: 0;\nz-index: 3000;\n--moveable-color: #4af;\n--zoom: 1;\n--zoompx: 1px;\nwill-change: transform;\noutline: 1px solid transparent;\n}\n.control-box {\nz-index: 0;\n}\n.line, .control {\nposition: absolute;\nleft: 0;\ntop: 0;\nwill-change: transform;\n}\n.control {\nwidth: 14px;\nheight: 14px;\nborder-radius: 50%;\nborder: 2px solid #fff;\nbox-sizing: border-box;\nbackground: #4af;\nbackground: var(--moveable-color);\nmargin-top: -7px;\nmargin-left: -7px;\nborder: 2px solid #fff;\nz-index: 10;\n}\n.around-control {\nposition: absolute;\nwill-change: transform;\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\nheight: calc(var(--moveable-control-padding, 20) * 1px);\nleft: -10px;\ntop: -10px;\nbox-sizing: border-box;\nbackground: transparent;\nz-index: 8;\ncursor: alias;\ntransform-origin: center center;\n}\n`.concat(yB, `\n.padding {\nposition: absolute;\ntop: 0px;\nleft: 0px;\nwidth: 100px;\nheight: 100px;\ntransform-origin: 0 0;\n}\n.line {\nwidth: 1px;\nheight: 1px;\nbackground: #4af;\nbackground: var(--moveable-color);\ntransform-origin: 0px 50%;\n}\n.line.edge {\nz-index: 1;\nbackground: transparent;\n}\n.line.dashed {\nbox-sizing: border-box;\nbackground: transparent;\n}\n.line.dashed.horizontal {\nborder-top: 1px dashed #4af;\nborder-top-color: #4af;\nborder-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\nborder-left: 1px dashed #4af;\nborder-left-color: #4af;\nborder-left-color: var(--moveable-color);\n}\n.line.vertical {\ntransform: translateX(-50%);\n}\n.line.horizontal {\ntransform: translateY(-50%);\n}\n.line.vertical.bold {\nwidth: 2px;\n}\n.line.horizontal.bold {\nheight: 2px;\n}\n\n.control.origin {\nborder-color: #f55;\nbackground: #fff;\nwidth: 12px;\nheight: 12px;\nmargin-top: -6px;\nmargin-left: -6px;\npointer-events: none;\n}\n`).concat([0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(i) {\n  return `\n.direction[data-rotation=\"`.concat(i, '\"], :global .view-control-rotation').concat(i, ` {\n`).concat(cB(i), `\n}\n`);\n}).join(`\n`), `\n\n.line.direction:before {\ncontent: \"\";\nposition: absolute;\nwidth: 100%;\nheight: calc(var(--moveable-line-padding, 0) * 1px);\nbottom: 0;\nleft: 0;\n}\n.group {\nz-index: -1;\n}\n.area {\nposition: absolute;\n}\n.area-pieces {\nposition: absolute;\ntop: 0;\nleft: 0;\ndisplay: none;\n}\n.area.avoid, .area.pass {\npointer-events: none;\n}\n.area.avoid+.area-pieces {\ndisplay: block;\n}\n.area-piece {\nposition: absolute;\n}\n\n`).concat(HT ? `:global svg *:before {\ncontent:\"\";\ntransform-origin: inherit;\n}` : \"\", `\n`), bB = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]], w_ = 1e-4, Rr = 1e-7, dp = 1e-9, E_ = Math.pow(10, 10), xw = -E_, xB = {\n  n: [0, -1],\n  e: [1, 0],\n  s: [0, 1],\n  w: [-1, 0],\n  nw: [-1, -1],\n  ne: [1, -1],\n  sw: [-1, 1],\n  se: [1, 1]\n}, bx = {\n  n: [0, 1],\n  e: [1, 3],\n  s: [3, 2],\n  w: [2, 0],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n}, XT = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n}, WT = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\", \"getManager\", \"forceUpdate\", \"waitToChangeTarget\", \"updateSelectors\", \"getTargets\", \"stopDrag\"];\nfunction Rd(i, t, e, r, n, s) {\n  var a, o;\n  s === void 0 && (s = \"draggable\");\n  var u = (o = (a = t.gestos[s]) === null || a === void 0 ? void 0 : a.move(e, i.inputEvent)) !== null && o !== void 0 ? o : {}, l = u.originalDatas || u.datas, h = l[s] || (l[s] = {});\n  return F(F({}, n ? gC(t, u) : u), {\n    isPinch: !!r,\n    parentEvent: !0,\n    datas: h,\n    originalDatas: i.originalDatas\n  });\n}\nvar th = /* @__PURE__ */ function() {\n  function i(e) {\n    var r;\n    e === void 0 && (e = \"draggable\"), this.ableName = e, this.prevX = 0, this.prevY = 0, this.startX = 0, this.startY = 0, this.isDrag = !1, this.isFlag = !1, this.datas = {\n      draggable: {}\n    }, this.datas = (r = {}, r[e] = {}, r);\n  }\n  var t = i.prototype;\n  return t.dragStart = function(e, r) {\n    this.isDrag = !1, this.isFlag = !1;\n    var n = r.originalDatas;\n    return this.datas = n, n[this.ableName] || (n[this.ableName] = {}), F(F({}, this.move(e, r.inputEvent)), {\n      type: \"dragstart\"\n    });\n  }, t.drag = function(e, r) {\n    return this.move([e[0] - this.prevX, e[1] - this.prevY], r);\n  }, t.move = function(e, r) {\n    var n, s, a = !1;\n    if (!this.isFlag)\n      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], n = e[0], s = e[1], this.isFlag = !0;\n    else {\n      var o = this.isDrag;\n      n = this.prevX + e[0], s = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !o && this.isDrag && (a = !0);\n    }\n    return this.prevX = n, this.prevY = s, {\n      type: \"drag\",\n      clientX: n,\n      clientY: s,\n      inputEvent: r,\n      isFirstDrag: a,\n      isDrag: this.isDrag,\n      distX: n - this.startX,\n      distY: s - this.startY,\n      deltaX: e[0],\n      deltaY: e[1],\n      datas: this.datas[this.ableName],\n      originalDatas: this.datas,\n      parentEvent: !0,\n      parentGesto: this\n    };\n  }, i;\n}();\nfunction YT(i, t) {\n  var e = t.clientX, r = t.clientY, n = t.datas, s = i.state, a = s.moveableClientRect, o = s.rootMatrix, u = s.is3d, l = s.pos1, h = a.left, d = a.top, f = u ? 4 : 3, p = Mt(ih(o, [e - h, r - d], f), l), v = p[0], g = p[1], m = Un({\n    datas: n,\n    distX: v,\n    distY: g\n  }), y = m[0], _ = m[1];\n  return [y, _];\n}\nfunction ou(i, t) {\n  var e = t.datas, r = i.state, n = r.allMatrix, s = r.beforeMatrix, a = r.is3d, o = r.left, u = r.top, l = r.origin, h = r.offsetMatrix, d = r.targetMatrix, f = r.transformOrigin, p = a ? 4 : 3;\n  e.is3d = a, e.matrix = n, e.targetMatrix = d, e.beforeMatrix = s, e.offsetMatrix = h, e.transformOrigin = f, e.inverseMatrix = Nn(n, p), e.inverseBeforeMatrix = Nn(s, p), e.absoluteOrigin = eu(Jt([o, u], l), p), e.startDragBeforeDist = br(e.inverseBeforeMatrix, e.absoluteOrigin, p), e.startDragDist = br(e.inverseMatrix, e.absoluteOrigin, p);\n}\nfunction wB(i) {\n  return Gu(i.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\nfunction h0(i, t) {\n  var e = i.datas, r = i.originalDatas.beforeRenderable, n = e.transformIndex, s = r.nextTransforms, a = s.length, o = r.nextTransformAppendedIndexes, u = -1;\n  n === -1 ? (t === \"translate\" ? u = 0 : t === \"rotate\" && (u = Ms(s, function(f) {\n    return f.match(/scale\\(/g);\n  })), u === -1 && (u = s.length), e.transformIndex = u) : nn(o, function(f) {\n    return f.index === n && f.functionName === t;\n  }) ? u = n : u = n + o.filter(function(f) {\n    return f.index < n;\n  }).length;\n  var l = KB(s, u), h = l.targetFunction, d = t === \"rotate\" ? \"rotateZ\" : t;\n  e.beforeFunctionTexts = l.beforeFunctionTexts, e.afterFunctionTexts = l.afterFunctionTexts, e.beforeTransform = l.beforeFunctionMatrix, e.beforeTransform2 = l.beforeFunctionMatrix2, e.targetTansform = l.targetFunctionMatrix, e.afterTransform = l.afterFunctionMatrix, e.afterTransform2 = l.afterFunctionMatrix2, e.targetAllTransform = l.allFunctionMatrix, h.functionName === d ? (e.afterFunctionTexts.splice(0, 1), e.isAppendTransform = !1) : a > u && (e.isAppendTransform = !0, r.nextTransformAppendedIndexes = Tt(Tt([], o, !0), [{\n    functionName: t,\n    index: u,\n    isAppend: !0\n  }], !1));\n}\nfunction c0(i, t, e) {\n  return \"\".concat(i.beforeFunctionTexts.join(\" \"), \" \").concat(i.isAppendTransform ? e : t, \" \").concat(i.afterFunctionTexts.join(\" \"));\n}\nfunction EB(i) {\n  var t = i.datas, e = i.distX, r = i.distY, n = ZT({\n    datas: t,\n    distX: e,\n    distY: r\n  }), s = n[0], a = n[1], o = qT(t, TL([s, a], 4));\n  return br(o, eu([0, 0, 0], 4), 4);\n}\nfunction qT(i, t, e) {\n  var r = i.beforeTransform, n = i.afterTransform, s = i.beforeTransform2, a = i.afterTransform2, o = i.targetAllTransform, u = e ? _e(o, t, 4) : _e(t, o, 4), l = _e(Nn(e ? s : r, 4), u, 4), h = _e(l, Nn(e ? a : n, 4), 4);\n  return h;\n}\nfunction ZT(i) {\n  var t = i.datas, e = i.distX, r = i.distY, n = t.inverseBeforeMatrix, s = t.is3d, a = t.startDragBeforeDist, o = t.absoluteOrigin, u = s ? 4 : 3;\n  return Mt(br(n, Jt(o, [e, r]), u), a);\n}\nfunction Un(i, t) {\n  var e = i.datas, r = i.distX, n = i.distY, s = e.inverseBeforeMatrix, a = e.inverseMatrix, o = e.is3d, u = e.startDragBeforeDist, l = e.startDragDist, h = e.absoluteOrigin, d = o ? 4 : 3;\n  return Mt(br(t ? s : a, Jt(h, [r, n]), d), t ? u : l);\n}\nfunction SB(i, t) {\n  var e = i.datas, r = i.distX, n = i.distY, s = e.beforeMatrix, a = e.matrix, o = e.is3d, u = e.startDragBeforeDist, l = e.startDragDist, h = e.absoluteOrigin, d = o ? 4 : 3;\n  return Mt(br(t ? s : a, Jt(t ? u : l, [r, n]), d), h);\n}\nfunction TB(i, t, e, r, n, s) {\n  return r === void 0 && (r = t), n === void 0 && (n = e), s === void 0 && (s = [0, 0]), i ? i.map(function(a, o) {\n    var u = Ed(a), l = u.value, h = u.unit, d = o ? n : r, f = o ? e : t;\n    if (a === \"%\" || isNaN(l)) {\n      var p = d ? s[o] / d : 0;\n      return f * p;\n    } else if (h !== \"%\")\n      return l;\n    return f * l / 100;\n  }) : s;\n}\nfunction KT(i) {\n  var t = [];\n  return i[1] >= 0 && (i[0] >= 0 && t.push(3), i[0] <= 0 && t.push(2)), i[1] <= 0 && (i[0] >= 0 && t.push(1), i[0] <= 0 && t.push(0)), t;\n}\nfunction CB(i, t) {\n  return KT(t).map(function(e) {\n    return i[e];\n  });\n}\nfunction ze(i, t) {\n  var e = (t[0] + 1) / 2, r = (t[1] + 1) / 2, n = [Pa(i[0][0], i[1][0], e, 1 - e), Pa(i[0][1], i[1][1], e, 1 - e)], s = [Pa(i[2][0], i[3][0], e, 1 - e), Pa(i[2][1], i[3][1], e, 1 - e)];\n  return [Pa(n[0], s[0], r, 1 - r), Pa(n[1], s[1], r, 1 - r)];\n}\nfunction MB(i, t, e, r, n, s) {\n  var a = da(t, e, r, n), o = ze(a, s), u = i[0] - o[0], l = i[1] - o[1];\n  return [u, l];\n}\nfunction Dd(i, t, e, r) {\n  return _e(i, Zh(t, r, e), r);\n}\nfunction PB(i, t, e) {\n  var r = i.transformOrigin, n = i.offsetMatrix, s = i.is3d, a = s ? 4 : 3, o;\n  if (Vr(e)) {\n    var u = t.beforeTransform, l = t.afterTransform;\n    o = An(_e(_e(u, gx([e]), 4), l, 4), 4, a);\n  } else\n    o = e;\n  return Dd(n, o, r, a);\n}\nfunction OB(i, t) {\n  var e = i.transformOrigin, r = i.offsetMatrix, n = i.is3d, s = i.targetMatrix, a = i.targetAllTransform, o = n ? 4 : 3;\n  return Dd(r, _e(a || s, Sv(t, o), o), e, o);\n}\nfunction f0(i) {\n  var t = dh(i);\n  return {\n    setTransform: function(e, r) {\n      r === void 0 && (r = -1), t.startTransforms = tr(e) ? e : fa(e), S_(i, r);\n    },\n    setTransformIndex: function(e) {\n      S_(i, e);\n    }\n  };\n}\nfunction d0(i, t) {\n  var e = dh(i), r = e.startTransforms;\n  S_(i, Ms(r, function(n) {\n    return n.indexOf(\"\".concat(t, \"(\")) === 0;\n  }));\n}\nfunction S_(i, t) {\n  var e = dh(i), r = i.datas;\n  if (r.transformIndex = t, t !== -1) {\n    var n = e.startTransforms[t];\n    if (n) {\n      var s = Da([n]);\n      r.startValue = s[0].functionValue;\n    }\n  }\n}\nfunction xx(i, t) {\n  var e = dh(i);\n  e.nextTransforms = fa(t);\n}\nfunction dh(i) {\n  return i.originalDatas.beforeRenderable;\n}\nfunction JT(i) {\n  var t = i.originalDatas.beforeRenderable;\n  return t.nextTransforms;\n}\nfunction pp(i) {\n  return JT(i).join(\" \");\n}\nfunction vp(i) {\n  return dh(i).nextStyle;\n}\nfunction QT(i, t, e, r, n) {\n  xx(n, t);\n  var s = Or.drag(i, Rd(n, i.state, e, r, !1)), a = s ? s.transform : t;\n  return F(F({\n    transform: t,\n    drag: s\n  }, Ir({\n    transform: a\n  }, n)), {\n    afterTransform: a\n  });\n}\nfunction wx(i, t, e, r) {\n  var n = PB(i.state, r, t), s = rC(i, e, n);\n  return s;\n}\nfunction tC(i, t, e, r, n) {\n  var s = wx(i, t, e, n), a = i.state, o = a.left, u = a.top, l = i.props.groupable, h = l ? o : 0, d = l ? u : 0, f = Mt(r, s);\n  return Mt(f, [h, d]);\n}\nfunction IB(i, t, e, r, n) {\n  var s = tC(i, \"scale(\".concat(t.join(\", \"), \")\"), e, r, n);\n  return s;\n}\nfunction eC(i, t, e) {\n  return [-1 + i[0] / (t / 2), -1 + i[1] / (e / 2)];\n}\nfunction rC(i, t, e) {\n  e === void 0 && (e = i.state.allMatrix);\n  var r = i.state, n = r.width, s = r.height, a = r.is3d, o = a ? 4 : 3, u = [n / 2 * (1 + t[0]), s / 2 * (1 + t[1])];\n  return nr(e, u, o);\n}\nfunction RB(i, t, e) {\n  var r = e.fixedDirection, n = e.fixedPosition;\n  return tC(i, \"rotate(\".concat(t, \"deg)\"), r, n, e);\n}\nfunction DB(i, t, e, r, n, s) {\n  var a = i.props.groupable, o = i.state, u = o.transformOrigin, l = o.offsetMatrix, h = o.is3d, d = o.width, f = o.height, p = o.left, v = o.top, g = s.fixedDirection, m = s.nextTargetMatrix || o.targetMatrix, y = h ? 4 : 3, _ = TB(n, t, e, d, f, u), b = a ? p : 0, w = a ? v : 0, T = Dd(l, m, _, y), x = MB(r, T, t, e, y, g);\n  return Mt(x, [b, w]);\n}\nfunction kB(i, t) {\n  return ze(Ci(i.state), t);\n}\nfunction NB(i, t) {\n  var e = i.targetGesto, r = i.controlGesto, n;\n  return e != null && e.isFlag() && (n = e.getEventData()[t]), !n && (r != null && r.isFlag()) && (n = r.getEventData()[t]), n || {};\n}\nfunction AB(i) {\n  if (i && i.getRootNode) {\n    var t = i.getRootNode();\n    if (t.nodeType === 11)\n      return t;\n  }\n}\nfunction iC(i, t, e) {\n  for (var r = i, n = [], s = document.documentElement || document.body, a = !e && i === t || i === s, o = a, u = !1, l = 3, h, d, f, p = !1, v = yc(t, t, !0).offsetParent, g = 1; r && !o; ) {\n    o = a;\n    var m = ui(r), y = m(\"position\"), _ = m(\"scale\"), b = sC(r), w = y === \"fixed\", T = CL(GB(b)), x = void 0, S = !1, C = !1, M = 0, I = 0, R = 0, N = 0, A = {\n      hasTransform: !1,\n      fixedContainer: null\n    };\n    w && (p = !0, A = $B(r), v = A.fixedContainer);\n    var U = T.length;\n    !u && U === 16 && (u = !0, l = 4, T_(n), f && (f = An(f, 3, 4))), u && U === 9 && (T = An(T, 3, 4));\n    var B = HB(r, i), G = B.tagName, $ = B.hasOffset, Z = B.isSVG, H = B.origin, z = B.targetOrigin, X = B.offset, ct = X[0], it = X[1];\n    G === \"svg\" && f && (n.push({\n      type: \"target\",\n      target: r,\n      matrix: VB(r, l)\n    }), n.push({\n      type: \"offset\",\n      target: r,\n      matrix: Oe(l)\n    }));\n    var lt = parseFloat(m(\"zoom\")) || 1;\n    if (w)\n      x = A.fixedContainer, S = !0;\n    else {\n      var et = yc(r, t, !1, !0, m), k = et.offsetZoom;\n      if (x = et.offsetParent, S = et.isEnd, C = et.isStatic, g *= k, (et.isCustomElement || k !== 1) && C)\n        ct -= x.offsetLeft, it -= x.offsetTop;\n      else if (gB || vB) {\n        var ft = et.parentSlotElement;\n        if (ft) {\n          for (var Q = x, St = 0, at = 0; Q && AB(Q); )\n            St += Q.offsetLeft, at += Q.offsetTop, Q = Q.offsetParent;\n          ct -= St, it -= at;\n        }\n      }\n    }\n    if (zT && !mB && $ && !Z && C && (y === \"relative\" || y === \"static\") && (ct -= x.offsetLeft, it -= x.offsetTop, a = a || S), w)\n      $ && A.hasTransform && (R = x.clientLeft, N = x.clientTop);\n    else if ($ && v !== x && (M = x.clientLeft, I = x.clientTop), $ && x === s) {\n      var q = aC(r, !1);\n      ct += q[0], it += q[1];\n    }\n    if (n.push({\n      type: \"target\",\n      target: r,\n      matrix: Zh(T, l, H)\n    }), _ && _ !== \"1\" && _ !== \"none\") {\n      var bt = _.split(\" \").map(function(Ct) {\n        return parseFloat(Ct);\n      }), st = bt[0], W = bt[1], nt = W === void 0 ? st : W, dt = Sv([st, nt], l);\n      n.push({\n        type: \"offset\",\n        target: r,\n        matrix: Oe(l)\n      }), n.push({\n        type: \"target\",\n        target: r,\n        matrix: Zh(dt, l, H)\n      });\n    }\n    if ($) {\n      var V = r === i, xt = V ? 0 : r.scrollLeft, Dt = V ? 0 : r.scrollTop;\n      n.push({\n        type: \"offset\",\n        target: r,\n        matrix: mc([ct - xt + M - R, it - Dt + I - N], l)\n      });\n    } else\n      n.push({\n        type: \"offset\",\n        target: r,\n        origin: H\n      });\n    if (lt !== 1 && n.push({\n      type: \"zoom\",\n      target: r,\n      matrix: Zh(Sv([lt, lt], l), l, [0, 0])\n    }), f || (f = T), h || (h = H), d || (d = z), o || w)\n      break;\n    r = x, a = S, (!e || r === s) && (o = a);\n  }\n  return f || (f = Oe(l)), h || (h = [0, 0]), d || (d = [0, 0]), {\n    zoom: g,\n    offsetContainer: v,\n    matrixes: n,\n    targetMatrix: f,\n    transformOrigin: h,\n    targetOrigin: d,\n    is3d: u,\n    hasFixed: p\n  };\n}\nvar ka = null, Na = null, Du = null;\nfunction eh(i) {\n  i ? (window.Map && (ka = /* @__PURE__ */ new Map(), Na = /* @__PURE__ */ new Map()), Du = []) : (ka = null, Du = null, Na = null);\n}\nfunction LB(i) {\n  var t = Na == null ? void 0 : Na.get(i);\n  if (t)\n    return t;\n  var e = Kh(i, !0);\n  return Na && Na.set(i, e), e;\n}\nfunction BB(i, t) {\n  if (Du) {\n    var e = nn(Du, function(n) {\n      return n[0][0] == i && n[0][1] == t;\n    });\n    if (e)\n      return e[1];\n  }\n  var r = iC(i, t, !0);\n  return Du && Du.push([[i, t], r]), r;\n}\nfunction ui(i) {\n  var t = ka == null ? void 0 : ka.get(i);\n  if (!t) {\n    var e = window.getComputedStyle(i);\n    if (!ka)\n      return function(s) {\n        return e[s];\n      };\n    t = {\n      style: e,\n      cached: {}\n    }, ka.set(i, t);\n  }\n  var r = t.cached, n = t.style;\n  return function(s) {\n    return s in r || (r[s] = n[s]), r[s];\n  };\n}\nfunction FB(i, t) {\n  return [i[0] * t[0], i[1] * t[1]];\n}\nfunction Pt() {\n  for (var i = [], t = 0; t < arguments.length; t++)\n    i[t] = arguments[t];\n  return MA.apply(void 0, Tt([_x], i, !1));\n}\nfunction nC(i) {\n  i();\n}\nfunction GB(i) {\n  return !i || i === \"none\" ? [1, 0, 0, 1, 0, 0] : ca(i) ? i : gx(i);\n}\nfunction Zh(i, t, e) {\n  return d_(t, mc(e, t), i, mc(e.map(function(r) {\n    return -r;\n  }), t));\n}\nfunction UB(i, t, e) {\n  if (t === \"%\") {\n    var r = Ex(i.ownerSVGElement);\n    return r[e ? \"width\" : \"height\"] / 100;\n  }\n  return 1;\n}\nfunction jB(i) {\n  var t = zB(Cx(i, \":before\"));\n  return t.map(function(e, r) {\n    var n = Ed(e), s = n.value, a = n.unit;\n    return s * UB(i, a, r === 0);\n  });\n}\nfunction Cv(i) {\n  return i ? i.split(\" \") : [\"0\", \"0\"];\n}\nfunction zB(i) {\n  return Cv(i.transformOrigin);\n}\nfunction sC(i) {\n  var t = ui(i), e = t(\"transform\");\n  if (e && e !== \"none\")\n    return e;\n  if (\"transform\" in i) {\n    var r = i.transform, n = r.baseVal;\n    if (!n)\n      return \"\";\n    var s = n.length;\n    if (!s)\n      return \"\";\n    for (var a = [], o = function(l) {\n      var h = n[l].matrix;\n      a.push(\"matrix(\".concat([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"].map(function(d) {\n        return h[d];\n      }).join(\", \"), \")\"));\n    }, u = 0; u < s; ++u)\n      o(u);\n    return a.join(\" \");\n  }\n  return \"\";\n}\nfunction yc(i, t, e, r, n) {\n  var s, a, o = i && i.ownerDocument ? i.ownerDocument : document, u = o.documentElement || o.body, l = !1, h, d;\n  if (!i || e)\n    h = i;\n  else {\n    var f = (s = i == null ? void 0 : i.assignedSlot) === null || s === void 0 ? void 0 : s.parentElement, p = i.parentElement;\n    f ? (l = !0, d = p, h = f) : h = p;\n  }\n  for (var v = !1, g = i === t || h === t, m = \"relative\", y = 1, _ = parseFloat(n == null ? void 0 : n(\"zoom\")) || 1, b = n == null ? void 0 : n(\"position\"); h && h !== u; ) {\n    t === h && (g = !0);\n    var w = ui(h), T = h.tagName.toLowerCase(), x = sC(h), S = w(\"willChange\"), C = parseFloat(w(\"zoom\")) || 1;\n    if (m = w(\"position\"), r && C !== 1) {\n      y = C;\n      break;\n    }\n    if (\n      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n      !e && r && _ !== 1 && b && b !== \"absolute\" || T === \"svg\" || m !== \"static\" || x && x !== \"none\" || S === \"transform\"\n    )\n      break;\n    var M = (a = i == null ? void 0 : i.assignedSlot) === null || a === void 0 ? void 0 : a.parentNode, I = h.parentNode;\n    M && (l = !0, d = I);\n    var R = I;\n    if (R && R.nodeType === 11) {\n      h = R.host, v = !0, m = ui(h)(\"position\");\n      break;\n    }\n    h = R, m = \"relative\";\n  }\n  return {\n    offsetZoom: y,\n    hasSlot: l,\n    parentSlotElement: d,\n    isCustomElement: v,\n    isStatic: m === \"static\",\n    isEnd: g || !h || h === u,\n    offsetParent: h || u\n  };\n}\nfunction HB(i, t) {\n  var e, r = i.tagName.toLowerCase(), n = i.offsetLeft, s = i.offsetTop, a = ui(i), o = o0(n), u = !o, l, h;\n  return !u && r !== \"svg\" ? (l = HT ? jB(i) : Cv(a(\"transformOrigin\")).map(function(d) {\n    return parseFloat(d);\n  }), h = l.slice(), u = !0, e = XB(i, l, i === t && t.tagName.toLowerCase() === \"g\"), n = e[0], s = e[1], l[0] = e[2], l[1] = e[3]) : (l = Cv(a(\"transformOrigin\")).map(function(d) {\n    return parseFloat(d);\n  }), h = l.slice()), {\n    tagName: r,\n    isSVG: o,\n    hasOffset: u,\n    offset: [n || 0, s || 0],\n    origin: l,\n    targetOrigin: h\n  };\n}\nfunction aC(i, t) {\n  var e = ui(i), r = ui(document.body), n = r(\"position\");\n  if (!t && (!n || n === \"static\"))\n    return [0, 0];\n  var s = parseInt(r(\"marginLeft\"), 10), a = parseInt(r(\"marginTop\"), 10);\n  return e(\"position\") === \"absolute\" && ((e(\"top\") !== \"auto\" || e(\"bottom\") !== \"auto\") && (a = 0), (e(\"left\") !== \"auto\" || e(\"right\") !== \"auto\") && (s = 0)), [s, a];\n}\nfunction T_(i) {\n  i.forEach(function(t) {\n    var e = t.matrix;\n    e && (t.matrix = An(e, 3, 4));\n  });\n}\nfunction $B(i) {\n  for (var t = i.parentElement, e = !1; t; ) {\n    var r = Cx(t).transform;\n    if (r && r !== \"none\") {\n      e = !0;\n      break;\n    }\n    if (t === document.body)\n      break;\n    t = t.parentElement;\n  }\n  return {\n    fixedContainer: t || document.body,\n    hasTransform: e\n  };\n}\nfunction p0(i, t) {\n  return t === void 0 && (t = i.length > 9), \"\".concat(t ? \"matrix3d\" : \"matrix\", \"(\").concat(AT(i, !t).join(\",\"), \")\");\n}\nfunction Ex(i) {\n  var t = i.clientWidth, e = i.clientHeight;\n  if (!i)\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      clientWidth: t,\n      clientHeight: e\n    };\n  var r = i.viewBox, n = r && r.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: n.x,\n    y: n.y,\n    width: n.width || t,\n    height: n.height || e,\n    clientWidth: t,\n    clientHeight: e\n  };\n}\nfunction VB(i, t) {\n  var e = Ex(i), r = e.width, n = e.height, s = e.clientWidth, a = e.clientHeight, o = s / r, u = a / n, l = i.preserveAspectRatio.baseVal, h = l.align, d = l.meetOrSlice, f = [0, 0], p = [o, u], v = [0, 0];\n  if (h !== 1) {\n    var g = (h - 2) % 3, m = Math.floor((h - 2) / 3);\n    f[0] = r * g / 2, f[1] = n * m / 2;\n    var y = d === 2 ? Math.max(u, o) : Math.min(o, u);\n    p[0] = y, p[1] = y, v[0] = (s - r) / 2 * g, v[1] = (a - n) / 2 * m;\n  }\n  var _ = Sv(p, t);\n  return _[t * (t - 1)] = v[0], _[t * (t - 1) + 1] = v[1], Zh(_, t, f);\n}\nfunction XB(i, t, e) {\n  if (!i.getBBox || !e && i.tagName.toLowerCase() === \"g\")\n    return [0, 0, 0, 0];\n  var r = i.getBBox(), n = Ex(i.ownerSVGElement), s = r.x - n.x, a = r.y - n.y;\n  return [s, a, t[0] - s, t[1] - a];\n}\nfunction nr(i, t, e) {\n  return br(i, eu(t, e), e);\n}\nfunction da(i, t, e, r) {\n  return [[0, 0], [t, 0], [0, e], [t, e]].map(function(n) {\n    return nr(i, n, r);\n  });\n}\nfunction Ti(i) {\n  var t = i.map(function(l) {\n    return l[0];\n  }), e = i.map(function(l) {\n    return l[1];\n  }), r = Math.min.apply(Math, t), n = Math.min.apply(Math, e), s = Math.max.apply(Math, t), a = Math.max.apply(Math, e), o = s - r, u = a - n;\n  return {\n    left: r,\n    top: n,\n    right: s,\n    bottom: a,\n    width: o,\n    height: u\n  };\n}\nfunction ww(i, t, e, r) {\n  var n = da(i, t, e, r);\n  return Ti(n);\n}\nfunction WB(i, t, e, r, n) {\n  var s, a = i.target, o = i.origin, u = t.matrix, l = uC(a), h = l.offsetWidth, d = l.offsetHeight, f = e.getBoundingClientRect(), p = [0, 0];\n  e === document.body && (p = aC(a, !0));\n  for (var v = a.getBoundingClientRect(), g = v.left - f.left + e.scrollLeft - (e.clientLeft || 0) + p[0], m = v.top - f.top + e.scrollTop - (e.clientTop || 0) + p[1], y = v.width, _ = v.height, b = d_(r, n, u), w = ww(b, h, d, r), T = w.left, x = w.top, S = w.width, C = w.height, M = nr(b, o, r), I = Mt(M, [T, x]), R = [g + I[0] * y / S, m + I[1] * _ / C], N = [0, 0], A = 0; ++A < 10; ) {\n    var U = Nn(n, r);\n    s = Mt(nr(U, R, r), nr(U, M, r)), N[0] = s[0], N[1] = s[1];\n    var B = d_(r, n, mc(N, r), u), G = ww(B, h, d, r), $ = G.left, Z = G.top, H = $ - g, z = Z - m;\n    if (Math.abs(H) < 2 && Math.abs(z) < 2)\n      break;\n    R[0] -= H, R[1] -= z;\n  }\n  return N.map(function(X) {\n    return Math.round(X);\n  });\n}\nfunction YB(i, t, e) {\n  var r = i.length === 16, n = r ? 4 : 3, s = t.map(function(u) {\n    return nr(i, u, n);\n  }), a = e.left, o = e.top;\n  return s.map(function(u) {\n    return [u[0] + a, u[1] + o];\n  });\n}\nfunction Gu(i, t, e, r) {\n  var n = i.length === 16, s = n ? 4 : 3, a = da(i, e, r, s), o = a[0], u = o[0], l = o[1], h = a[1], d = h[0], f = h[1], p = a[2], v = p[0], g = p[1], m = a[3], y = m[0], _ = m[1], b = nr(i, t, s), w = b[0], T = b[1], x = Math.min(u, d, v, y), S = Math.min(l, f, g, _), C = Math.max(u, d, v, y), M = Math.max(l, f, g, _);\n  u = u - x || 0, d = d - x || 0, v = v - x || 0, y = y - x || 0, l = l - S || 0, f = f - S || 0, g = g - S || 0, _ = _ - S || 0, w = w - x || 0, T = T - S || 0;\n  var I = u_(da(i, 100, 100, s));\n  return {\n    left: x,\n    top: S,\n    right: C,\n    bottom: M,\n    origin: [w, T],\n    pos1: [u, l],\n    pos2: [d, f],\n    pos3: [v, g],\n    pos4: [y, _],\n    direction: I\n  };\n}\nfunction Ln(i) {\n  return Math.sqrt(i[0] * i[0] + i[1] * i[1]);\n}\nfunction oC(i, t) {\n  return Ln([t[0] - i[0], t[1] - i[1]]);\n}\nfunction kh(i, t, e, r) {\n  e === void 0 && (e = 1), r === void 0 && (r = $e(i, t));\n  var n = oC(i, t);\n  return {\n    transform: \"translateY(-50%) translate(\".concat(i[0], \"px, \").concat(i[1], \"px) rotate(\").concat(r, \"rad) scaleY(\").concat(e, \")\"),\n    width: \"\".concat(n, \"px\")\n  };\n}\nfunction Sx(i, t) {\n  for (var e = [], r = 2; r < arguments.length; r++)\n    e[r - 2] = arguments[r];\n  var n = e.length, s = e.reduce(function(o, u) {\n    return o + u[0];\n  }, 0) / n, a = e.reduce(function(o, u) {\n    return o + u[1];\n  }, 0) / n;\n  return {\n    transform: \"translateZ(0px) translate(\".concat(s, \"px, \").concat(a, \"px) rotate(\").concat(i, \"rad) scale(\").concat(t, \")\")\n  };\n}\nfunction iu(i, t) {\n  var e = i[t];\n  return ca(e) ? F(F({}, i), e) : i;\n}\nfunction uC(i) {\n  var t = i && !o0(i.offsetWidth), e = 0, r = 0, n = 0, s = 0, a = 0, o = 0, u = 0, l = 0, h = 0, d = 0, f = 0, p = 0, v = 1 / 0, g = 1 / 0, m = 1 / 0, y = 1 / 0, _ = 0, b = 0, w = !1;\n  if (i)\n    if (!t && i.tagName.toLowerCase() !== \"svg\") {\n      var T = i.getBBox();\n      w = !0, e = T.width, r = T.height, a = e, o = r, u = e, l = r, n = e, s = r;\n    } else {\n      var x = ui(i), S = i.style, C = x(\"boxSizing\") === \"border-box\", M = parseFloat(x(\"borderLeftWidth\")) || 0, I = parseFloat(x(\"borderRightWidth\")) || 0, R = parseFloat(x(\"borderTopWidth\")) || 0, N = parseFloat(x(\"borderBottomWidth\")) || 0, A = parseFloat(x(\"paddingLeft\")) || 0, U = parseFloat(x(\"paddingRight\")) || 0, B = parseFloat(x(\"paddingTop\")) || 0, G = parseFloat(x(\"paddingBottom\")) || 0, $ = A + U, Z = B + G, H = M + I, z = R + N, X = $ + H, ct = Z + z, it = x(\"position\"), lt = 0, et = 0;\n      if (\"clientLeft\" in i) {\n        var k = null;\n        if (it === \"absolute\") {\n          var ft = yc(i, document.body);\n          k = ft.offsetParent;\n        } else\n          k = i.parentElement;\n        if (k) {\n          var Q = ui(k);\n          lt = parseFloat(Q(\"width\")), et = parseFloat(Q(\"height\"));\n        }\n      }\n      h = Math.max($, Te(x(\"minWidth\"), lt) || 0), d = Math.max(Z, Te(x(\"minHeight\"), et) || 0), v = Te(x(\"maxWidth\"), lt), g = Te(x(\"maxHeight\"), et), isNaN(v) && (v = 1 / 0), isNaN(g) && (g = 1 / 0), _ = Te(S.width, 0) || 0, b = Te(S.height, 0) || 0, a = parseFloat(x(\"width\")) || 0, o = parseFloat(x(\"height\")) || 0, u = Math.abs(a - _) < 1 ? a_(h, _ || a, v) : a, l = Math.abs(o - b) < 1 ? a_(d, b || o, g) : o, e = u, r = l, n = u, s = l, C ? (m = v, y = g, f = h, p = d, u = e - X, l = r - ct) : (m = v + X, y = g + ct, f = h + X, p = d + ct, e = u + X, r = l + ct), n = u + $, s = l + Z;\n    }\n  return {\n    svg: w,\n    offsetWidth: e,\n    offsetHeight: r,\n    clientWidth: n,\n    clientHeight: s,\n    contentWidth: u,\n    contentHeight: l,\n    inlineCSSWidth: _,\n    inlineCSSHeight: b,\n    cssWidth: a,\n    cssHeight: o,\n    minWidth: h,\n    minHeight: d,\n    maxWidth: v,\n    maxHeight: g,\n    minOffsetWidth: f,\n    minOffsetHeight: p,\n    maxOffsetWidth: m,\n    maxOffsetHeight: y\n  };\n}\nfunction lC(i, t) {\n  return $e(t > 0 ? i[0] : i[1], t > 0 ? i[1] : i[0]);\n}\nfunction gp() {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\nfunction hC(i, t) {\n  var e = i === document.body || i === document.documentElement, r = {\n    clientLeft: i.clientLeft,\n    clientTop: i.clientTop,\n    clientWidth: i.clientWidth,\n    clientHeight: i.clientHeight,\n    scrollWidth: i.scrollWidth,\n    scrollHeight: i.scrollHeight,\n    overflow: !1\n  };\n  return e && (r.clientHeight = Math.max(t.height, r.clientHeight), r.scrollHeight = Math.max(t.height, r.scrollHeight)), r.overflow = ui(i)(\"overflow\") !== \"visible\", F(F({}, t), r);\n}\nfunction oy(i, t, e, r) {\n  var n = i.left, s = i.right, a = i.top, o = i.bottom, u = t.top, l = t.left, h = {\n    left: l + n,\n    top: u + a,\n    right: l + s,\n    bottom: u + o,\n    width: s - n,\n    height: o - a\n  };\n  return e && r ? hC(e, h) : h;\n}\nfunction Kh(i, t) {\n  var e = 0, r = 0, n = 0, s = 0;\n  if (i) {\n    var a = i.getBoundingClientRect();\n    e = a.left, r = a.top, n = a.width, s = a.height;\n  }\n  var o = {\n    left: e,\n    top: r,\n    width: n,\n    height: s,\n    right: e + n,\n    bottom: r + s\n  };\n  return i && t ? hC(i, o) : o;\n}\nfunction cC(i, t, e, r) {\n  var n;\n  if (i)\n    n = i;\n  else if (t)\n    n = [0, 0];\n  else {\n    var s = e.target;\n    n = fC(s, r);\n  }\n  return n;\n}\nfunction fC(i, t) {\n  if (i) {\n    var e = i.getAttribute(\"data-rotation\") || \"\", r = i.getAttribute(\"data-direction\");\n    if (t.deg = e, !!r) {\n      var n = [0, 0];\n      return r.indexOf(\"w\") > -1 && (n[0] = -1), r.indexOf(\"e\") > -1 && (n[0] = 1), r.indexOf(\"n\") > -1 && (n[1] = -1), r.indexOf(\"s\") > -1 && (n[1] = 1), n;\n    }\n  }\n}\nfunction Tx(i, t) {\n  return [Jt(t, i[0]), Jt(t, i[1]), Jt(t, i[2]), Jt(t, i[3])];\n}\nfunction Ci(i) {\n  var t = i.left, e = i.top, r = i.pos1, n = i.pos2, s = i.pos3, a = i.pos4;\n  return Tx([r, n, s, a], [t, e]);\n}\nfunction ku(i, t) {\n  var e;\n  (e = i[t]) === null || e === void 0 || e.unset(), i[t] = null;\n}\nfunction Ir(i, t) {\n  if (t) {\n    var e = dh(t);\n    e.nextStyle = F(F({}, e.nextStyle), i);\n  }\n  return {\n    style: i,\n    cssText: Ps(i).map(function(r) {\n      return \"\".concat($p(r, \"-\"), \": \").concat(i[r], \";\");\n    }).join(\"\")\n  };\n}\nfunction dC(i, t, e) {\n  var r = t.afterTransform || t.transform;\n  return F(F({}, Ir(F(F(F({}, i.style), t.style), {\n    transform: r\n  }), e)), {\n    afterTransform: r,\n    transform: i.transform\n  });\n}\nfunction Ut(i, t, e, r) {\n  var n = t.datas;\n  n.datas || (n.datas = {});\n  var s = F(F({}, e), {\n    target: i.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: i,\n    moveable: i,\n    datas: n.datas,\n    isFirstDrag: !!t.isFirstDrag,\n    isTrusted: t.isTrusted !== !1,\n    stopAble: function() {\n      n.isEventStart = !1;\n    },\n    stopDrag: function() {\n      var a;\n      (a = t.stop) === null || a === void 0 || a.call(t);\n    }\n  });\n  return n.isStartEvent ? r || (n.lastEvent = s) : n.isStartEvent = !0, s;\n}\nfunction li(i, t, e) {\n  var r = t.datas, n = \"isDrag\" in e ? e.isDrag : t.isDrag;\n  return r.datas || (r.datas = {}), F(F({\n    isDrag: n\n  }, e), {\n    moveable: i,\n    target: i.state.target,\n    clientX: t.clientX,\n    clientY: t.clientY,\n    inputEvent: t.inputEvent,\n    currentTarget: i,\n    lastEvent: r.lastEvent,\n    isDouble: t.isDouble,\n    datas: r.datas,\n    isFirstDrag: !!t.isFirstDrag\n  });\n}\nfunction v0(i, t, e) {\n  i._emitter.on(t, e);\n}\nfunction mt(i, t, e, r) {\n  return i.triggerEvent(t, e, r);\n}\nfunction Cx(i, t) {\n  return window.getComputedStyle(i, t);\n}\nfunction mp(i, t, e) {\n  var r = {}, n = {};\n  return i.filter(function(s) {\n    var a = s.name;\n    if (r[a] || !t.some(function(o) {\n      return s[o];\n    }))\n      return !1;\n    if (!e && s.ableGroup) {\n      if (n[s.ableGroup])\n        return !1;\n      n[s.ableGroup] = !0;\n    }\n    return r[a] = !0, !0;\n  });\n}\nfunction C_(i, t) {\n  return i === t || i == null && t == null;\n}\nfunction qB() {\n  for (var i = [], t = 0; t < arguments.length; t++)\n    i[t] = arguments[t];\n  for (var e = i.length - 1, r = 0; r < e; ++r) {\n    var n = i[r];\n    if (!o0(n))\n      return n;\n  }\n  return i[e];\n}\nfunction pC(i, t) {\n  var e = [], r = [];\n  return i.forEach(function(n, s) {\n    var a = t(n, s, i), o = r.indexOf(a), u = e[o] || [];\n    o === -1 && (r.push(a), e.push(u)), u.push(n);\n  }), e;\n}\nfunction ZB(i, t) {\n  var e = [], r = {};\n  return i.forEach(function(n, s) {\n    var a = t(n, s, i), o = r[a];\n    o || (o = [], r[a] = o, e.push(o)), o.push(n);\n  }), e;\n}\nfunction vC(i) {\n  return i.reduce(function(t, e) {\n    return t.concat(e);\n  }, []);\n}\nfunction rh() {\n  for (var i = [], t = 0; t < arguments.length; t++)\n    i[t] = arguments[t];\n  return i.sort(function(e, r) {\n    return Math.abs(r) - Math.abs(e);\n  }), i[0];\n}\nfunction ih(i, t, e) {\n  return br(Nn(i, e), eu(t, e), e);\n}\nfunction gC(i, t) {\n  var e, r = i.is3d, n = i.rootMatrix, s = r ? 4 : 3;\n  return e = ih(n, [t.distX, t.distY], s), t.distX = e[0], t.distY = e[1], t;\n}\nfunction yp(i, t, e, r, n) {\n  return Mt(nr(i, Jt(e, t), n), r);\n}\nfunction Vi(i, t, e) {\n  return e ? \"\".concat(i / t * 100, \"%\") : \"\".concat(i, \"px\");\n}\nfunction Mv(i) {\n  return Math.abs(i) <= Rr ? 0 : i;\n}\nfunction Mx(i) {\n  return function(t) {\n    if (!t.isDragging(i))\n      return \"\";\n    var e = NB(t, i), r = e.deg;\n    return r ? Pt(\"view-control-rotation\".concat(r)) : \"\";\n  };\n}\nfunction Px(i, t) {\n  return t === void 0 && (t = [i]), function(e, r) {\n    if (r.isRequest)\n      return t.some(function(s) {\n        return r.requestAble === s;\n      }) ? r.parentDirection : !1;\n    var n = r.inputEvent.target;\n    return sr(n, Pt(\"direction\")) && (!i || sr(n, Pt(i)));\n  };\n}\nfunction KB(i, t) {\n  var e = i.slice(0, t < 0 ? void 0 : t), r = i.slice(0, t < 0 ? void 0 : t + 1), n = i[t] || \"\", s = t < 0 ? [] : i.slice(t), a = t < 0 ? [] : i.slice(t + 1), o = Da(e), u = Da(r), l = Da([n]), h = Da(s), d = Da(a), f = bu(o), p = bu(u), v = bu(h), g = bu(d), m = _e(f, v, 4);\n  return {\n    transforms: i,\n    beforeFunctionMatrix: f,\n    beforeFunctionMatrix2: p,\n    targetFunctionMatrix: bu(l),\n    afterFunctionMatrix: v,\n    afterFunctionMatrix2: g,\n    allFunctionMatrix: m,\n    beforeFunctions: o,\n    beforeFunctions2: u,\n    targetFunction: l[0],\n    afterFunctions: h,\n    afterFunctions2: d,\n    beforeFunctionTexts: e,\n    beforeFunctionTexts2: r,\n    targetFunctionText: n,\n    afterFunctionTexts: s,\n    afterFunctionTexts2: a\n  };\n}\nfunction JB(i) {\n  return !i || !ca(i) || i instanceof Element ? !1 : tr(i) || \"length\" in i;\n}\nfunction nu(i, t) {\n  return i ? i instanceof Element ? i : Vr(i) ? t ? document.querySelector(i) : i : sx(i) ? i() : \"current\" in i ? i.current : i : null;\n}\nfunction Ox(i, t) {\n  if (!i)\n    return [];\n  var e = JB(i) ? [].slice.call(i) : [i];\n  return e.reduce(function(r, n) {\n    return Vr(n) && t ? Tt(Tt([], r, !0), [].slice.call(document.querySelectorAll(n)), !0) : (tr(n) ? r.push(Ox(n, t)) : r.push(nu(n, t)), r);\n  }, []);\n}\nfunction QB(i, t, e) {\n  var r = $e(i, t) / Math.PI * 180;\n  return r = e >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;\n}\nfunction Ew(i, t) {\n  var e = i.rootMatrix, r = i.is3d, n = r ? 4 : 3, s = Nn(e, n);\n  return r || (s = An(s, 3, 4)), s[12] = 0, s[13] = 0, s[14] = 0, RL(s, t);\n}\nfunction mC(i, t, e, r, n) {\n  var s = i[0], a = i[1], o = 0, u = 0;\n  if (n && s && a) {\n    var l = $e([0, 0], t), h = $e([0, 0], r), d = Ln(t), f = Math.cos(l - h) * d;\n    if (!r[0])\n      u = f, o = u * e;\n    else if (!r[1])\n      o = f, u = o / e;\n    else {\n      var p = r[0] * s, v = r[1] * a, g = Math.atan2(p + t[0], v + t[1]), m = Math.atan2(p, v);\n      g < 0 && (g += Math.PI * 2), m < 0 && (m += Math.PI * 2);\n      var y = 0;\n      Math.abs(g - m) < Math.PI / 2 || Math.abs(g - m) > Math.PI / 2 * 3 || (m += Math.PI), y = g - m, y > Math.PI * 2 ? y -= Math.PI * 2 : y > Math.PI ? y = 2 * Math.PI - y : y < -Math.PI && (y = -2 * Math.PI - y);\n      var _ = Ln([p + t[0], v + t[1]]) * Math.cos(y);\n      o = _ * Math.sin(m) - p, u = _ * Math.cos(m) - v, r[0] < 0 && (o *= -1), r[1] < 0 && (u *= -1);\n    }\n  } else\n    o = r[0] * t[0], u = r[1] * t[1];\n  return [o, u];\n}\nfunction yC(i, t, e, r) {\n  var n, s = e.ratio, a = e.startOffsetWidth, o = e.startOffsetHeight, u = 0, l = 0, h = r.distX, d = r.distY, f = r.pinchScale, p = r.parentDistance, v = r.parentDist, g = r.parentScale, m = e.fixedDirection, y = [0, 1].map(function(S) {\n    return Math.abs(i[S] - m[S]);\n  }), _ = [0, 1].map(function(S) {\n    var C = y[S];\n    return C !== 0 && (C = 2 / C), C;\n  });\n  if (v)\n    u = v[0], l = v[1], t && (u ? l || (l = u / s) : u = l * s);\n  else if (pc(f))\n    u = (f - 1) * a, l = (f - 1) * o;\n  else if (g)\n    u = (g[0] - 1) * a, l = (g[1] - 1) * o;\n  else if (p) {\n    var b = a * y[0], w = o * y[1], T = Ln([b, w]);\n    u = p / T * b * _[0], l = p / T * w * _[1];\n  } else {\n    var x = Un({\n      datas: e,\n      distX: h,\n      distY: d\n    });\n    x = _.map(function(S, C) {\n      return x[C] * S;\n    }), n = mC([a, o], x, s, i, t), u = n[0], l = n[1];\n  }\n  return {\n    // direction,\n    // sizeDirection,\n    distWidth: u,\n    distHeight: l\n  };\n}\nfunction M_(i, t) {\n  if (t) {\n    if (i === \"left\")\n      return {\n        x: \"0%\",\n        y: \"50%\"\n      };\n    if (i === \"top\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (i === \"center\")\n      return {\n        x: \"50%\",\n        y: \"50%\"\n      };\n    if (i === \"right\")\n      return {\n        x: \"100%\",\n        y: \"50%\"\n      };\n    if (i === \"bottom\")\n      return {\n        x: \"50%\",\n        y: \"100%\"\n      };\n    var e = i.split(\" \"), r = e[0], n = e[1], s = M_(r || \"\"), a = M_(n || \"\"), o = F(F({}, s), a), u = {\n      x: \"50%\",\n      y: \"50%\"\n    };\n    return o.x && (u.x = o.x), o.y && (u.y = o.y), o.value && (o.x && !o.y && (u.y = o.value), !o.x && o.y && (u.x = o.value)), u;\n  }\n  return i === \"left\" ? {\n    x: \"0%\"\n  } : i === \"right\" ? {\n    x: \"100%\"\n  } : i === \"top\" ? {\n    y: \"0%\"\n  } : i === \"bottom\" ? {\n    y: \"100%\"\n  } : i ? i === \"center\" ? {\n    value: \"50%\"\n  } : {\n    value: i\n  } : {};\n}\nfunction tF(i, t, e) {\n  var r = M_(i, !0), n = r.x, s = r.y;\n  return [Te(n, t) || 0, Te(s, e) || 0];\n}\nfunction eF(i, t, e) {\n  var r = i.map(function(s) {\n    return Mt(s, t);\n  }), n = r.map(function(s) {\n    return Md(s, e);\n  });\n  return {\n    prev: r,\n    next: n,\n    result: n.map(function(s) {\n      return Jt(s, t);\n    })\n  };\n}\nfunction _C(i, t) {\n  return i.length === t.length && i.every(function(e, r) {\n    var n = t[r], s = tr(e), a = tr(n);\n    return s && a ? _C(e, n) : !s && !a ? e === n : !1;\n  });\n}\nfunction Sw(i, t, e, r) {\n  var n = i[t];\n  return t in i && (n === e || r(n) === r(e)) ? n : (i[t] = e, e);\n}\nvar rF = Id(\"pinchable\", {\n  props: [\"pinchable\"],\n  events: [\"pinchStart\", \"pinch\", \"pinchEnd\", \"pinchGroupStart\", \"pinchGroup\", \"pinchGroupEnd\"],\n  dragStart: function() {\n    return !0;\n  },\n  pinchStart: function(i, t) {\n    var e = t.datas, r = t.targets, n = t.angle, s = t.originalDatas, a = i.props, o = a.pinchable, u = a.ables;\n    if (!o)\n      return !1;\n    var l = \"onPinch\".concat(r ? \"Group\" : \"\", \"Start\"), h = \"drag\".concat(r ? \"Group\" : \"\", \"ControlStart\"), d = (o === !0 ? i.controlAbles : u.filter(function(g) {\n      return o.indexOf(g.name) > -1;\n    })).filter(function(g) {\n      return g.canPinch && g[h];\n    }), f = Ut(i, t, {});\n    r && (f.targets = r);\n    var p = mt(i, l, f);\n    e.isPinch = p !== !1, e.ables = d;\n    var v = e.isPinch;\n    return v ? (d.forEach(function(g) {\n      if (s[g.name] = s[g.name] || {}, !!g[h]) {\n        var m = F(F({}, t), {\n          datas: s[g.name],\n          parentRotate: n,\n          isPinch: !0\n        });\n        g[h](i, m);\n      }\n    }), i.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: [0, 0]\n    }, v) : !1;\n  },\n  pinch: function(i, t) {\n    var e = t.datas, r = t.scale, n = t.distance, s = t.originalDatas, a = t.inputEvent, o = t.targets, u = t.angle;\n    if (e.isPinch) {\n      var l = n * (1 - 1 / r), h = Ut(i, t, {});\n      o && (h.targets = o);\n      var d = \"onPinch\".concat(o ? \"Group\" : \"\");\n      mt(i, d, h);\n      var f = e.ables, p = \"drag\".concat(o ? \"Group\" : \"\", \"Control\");\n      return f.forEach(function(v) {\n        v[p] && v[p](i, F(F({}, t), {\n          datas: s[v.name],\n          inputEvent: a,\n          resolveMatrix: !0,\n          pinchScale: r,\n          parentDistance: l,\n          parentRotate: u,\n          isPinch: !0\n        }));\n      }), h;\n    }\n  },\n  pinchEnd: function(i, t) {\n    var e = t.datas, r = t.isPinch, n = t.inputEvent, s = t.targets, a = t.originalDatas;\n    if (e.isPinch) {\n      var o = \"onPinch\".concat(s ? \"Group\" : \"\", \"End\"), u = li(i, t, {\n        isDrag: r\n      });\n      s && (u.targets = s), mt(i, o, u);\n      var l = e.ables, h = \"drag\".concat(s ? \"Group\" : \"\", \"ControlEnd\");\n      return l.forEach(function(d) {\n        d[h] && d[h](i, F(F({}, t), {\n          isDrag: r,\n          datas: a[d.name],\n          inputEvent: n,\n          isPinch: !0\n        }));\n      }), r;\n    }\n  },\n  pinchGroupStart: function(i, t) {\n    return this.pinchStart(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  pinchGroup: function(i, t) {\n    return this.pinch(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  pinchGroupEnd: function(i, t) {\n    return this.pinchEnd(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  }\n});\nfunction Ji(i, t, e) {\n  var r = e.originalDatas;\n  r.groupable = r.groupable || {};\n  var n = r.groupable;\n  n.childDatas = n.childDatas || [];\n  var s = n.childDatas;\n  return i.moveables.map(function(a, o) {\n    return s[o] = s[o] || {}, s[o][t] = s[o][t] || {}, F(F({}, e), {\n      datas: s[o][t],\n      originalDatas: s[o]\n    });\n  });\n}\nfunction uy(i, t, e, r, n, s, a) {\n  var o = !!e.match(/Start$/g), u = !!e.match(/End$/g), l = n.isPinch, h = n.datas, d = Ji(i, t.name, n), f = i.moveables, p = d.map(function(v, g) {\n    var m = f[g], y = m.state, _ = y.gestos, b = v;\n    if (o)\n      b = new th(a).dragStart(r, v);\n    else {\n      if (_[a] || (_[a] = h.childGestos[g]), !_[a])\n        return;\n      b = Rd(v, y, r, l, s, a);\n    }\n    var w = t[e](m, F(F({}, b), {\n      parentFlag: !0\n    }));\n    return u && (_[a] = null), w;\n  });\n  return o && (h.childGestos = f.map(function(v) {\n    return v.state.gestos[a];\n  })), p;\n}\nfunction Ss(i, t, e, r, n, s) {\n  n === void 0 && (n = function(h, d) {\n    return d;\n  });\n  var a = !!e.match(/End$/g), o = Ji(i, t.name, r), u = i.moveables, l = o.map(function(h, d) {\n    var f = u[d], p = h;\n    p = n(f, h);\n    var v = t[e](f, F(F({}, p), {\n      parentFlag: !0\n    }));\n    return v && s && s(f, h, v, d), a && (f.state.gestos = {}), v;\n  });\n  return l;\n}\nfunction Pv(i, t, e, r) {\n  var n = e.fixedDirection, s = e.fixedPosition, a = r.datas.startPositions || Ci(t.state), o = ze(a, n), u = br(Pd(-i.rotation / 180 * Math.PI, 3), [o[0] - s[0], o[1] - s[1], 1], 3), l = u[0], h = u[1];\n  return r.datas.originalX = l, r.datas.originalY = h, r;\n}\nvar iF = [\"left\", \"right\", \"center\"], nF = [\"top\", \"bottom\", \"middle\"], pa = {\n  start: \"left\",\n  end: \"right\",\n  center: \"center\"\n}, va = {\n  start: \"top\",\n  end: \"bottom\",\n  center: \"middle\"\n};\nfunction ph(i, t) {\n  var e = i.props, r = e.snappable, n = e.bounds, s = e.innerBounds, a = e.verticalGuidelines, o = e.horizontalGuidelines, u = e.snapGridWidth, l = e.snapGridHeight, h = i.state, d = h.guidelines, f = h.enableSnap;\n  return !r || !f || t && r !== !0 && r.indexOf(t) < 0 ? !1 : !!(u || l || n || s || d && d.length || a && a.length || o && o.length);\n}\nfunction Ix(i) {\n  return i === !1 ? {} : i === !0 || !i ? {\n    left: !0,\n    right: !0,\n    top: !0,\n    bottom: !0\n  } : i;\n}\nfunction sF(i, t) {\n  var e = Ix(i), r = {};\n  for (var n in e)\n    n in t && e[n] && (r[n] = t[n]);\n  return r;\n}\nfunction Rx(i, t) {\n  var e = sF(i, t), r = nF.filter(function(s) {\n    return s in e;\n  }), n = iF.filter(function(s) {\n    return s in e;\n  });\n  return {\n    horizontal: r.map(function(s) {\n      return e[s];\n    }),\n    vertical: n.map(function(s) {\n      return e[s];\n    })\n  };\n}\nfunction aF(i, t, e) {\n  var r = nr(i, [t.clientLeft, t.clientTop], e);\n  return [t.left + r[0], t.top + r[1]];\n}\nfunction oF(i) {\n  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];\n  Math.abs(r) < Je && (r = 0), Math.abs(n) < Je && (n = 0);\n  var s = 0, a = 0, o = 0;\n  return r ? n ? (s = -n / r, a = 1, o = s * t[0] - t[1]) : (a = 1, o = -t[1]) : (s = -1, o = t[0]), [s, a, o].map(function(u) {\n    return Gt(u, Je);\n  });\n}\nfunction g0(i, t, e, r) {\n  var n = i.props, s = qB(r, n.snapThreshold, 5);\n  return bC(i.state.guidelines, t, e, s);\n}\nfunction bC(i, t, e, r) {\n  return {\n    vertical: Cw(i, \"vertical\", t, r),\n    horizontal: Cw(i, \"horizontal\", e, r)\n  };\n}\nfunction uF(i, t, e) {\n  var r = e[0], n = e[1], s = t[0], a = t[1], o = Mt(e, t), u = o[0], l = o[1], h = l > 0, d = u > 0;\n  u = Mv(u), l = Mv(l);\n  var f = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  }, p = {\n    isSnap: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (u === 0 && l === 0)\n    return {\n      vertical: f,\n      horizontal: p\n    };\n  var v = g0(i, u ? [r] : [], l ? [n] : []), g = v.vertical, m = v.horizontal;\n  g.posInfos.filter(function(U) {\n    var B = U.pos;\n    return d ? B >= s : B <= s;\n  }), m.posInfos.filter(function(U) {\n    var B = U.pos;\n    return h ? B >= a : B <= a;\n  }), g.isSnap = g.posInfos.length > 0, m.isSnap = m.posInfos.length > 0;\n  var y = P_(g), _ = y.isSnap, b = y.guideline, w = P_(m), T = w.isSnap, x = w.guideline, S = T ? x.pos[1] : 0, C = _ ? b.pos[0] : 0;\n  if (u === 0)\n    T && (p.isSnap = !0, p.pos = x.pos[1], p.offset = n - p.pos);\n  else if (l === 0)\n    _ && (f.isSnap = !0, f.pos = C, f.offset = r - C);\n  else {\n    var M = l / u, I = e[1] - M * r, R = 0, N = 0, A = !1;\n    _ ? (N = C, R = M * N + I, A = !0) : T && (R = S, N = (R - I) / M, A = !0), A && (f.isSnap = !0, f.pos = N, f.offset = r - N, p.isSnap = !0, p.pos = R, p.offset = n - R);\n  }\n  return {\n    vertical: f,\n    horizontal: p\n  };\n}\nfunction Tw(i, t, e) {\n  var r = Rx(i.props.snapDirections, t);\n  return g0(i, r.vertical, r.horizontal, e);\n}\nfunction P_(i) {\n  var t = i.isSnap;\n  if (!t)\n    return {\n      isSnap: !1,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  var e = i.posInfos[0], r = e.guidelineInfos[0], n = r.offset, s = r.dist, a = r.guideline;\n  return {\n    isSnap: t,\n    offset: n,\n    dist: s,\n    pos: e.pos,\n    guideline: a\n  };\n}\nfunction Cw(i, t, e, r) {\n  if (!i || !i.length)\n    return {\n      isSnap: !1,\n      index: -1,\n      posInfos: []\n    };\n  var n = t === \"vertical\", s = n ? 0 : 1, a = e.map(function(u, l) {\n    var h = i.map(function(d) {\n      var f = d.pos, p = u - f[s];\n      return {\n        offset: p,\n        dist: Math.abs(p),\n        guideline: d\n      };\n    }).filter(function(d) {\n      var f = d.guideline, p = d.dist, v = f.type;\n      return !(v !== t || p > r);\n    }).sort(function(d, f) {\n      return d.dist - f.dist;\n    });\n    return {\n      pos: u,\n      index: l,\n      guidelineInfos: h\n    };\n  }).filter(function(u) {\n    return u.guidelineInfos.length > 0;\n  }).sort(function(u, l) {\n    return u.guidelineInfos[0].dist - l.guidelineInfos[0].dist;\n  }), o = a.length > 0;\n  return {\n    isSnap: o,\n    index: o ? a[0].index : -1,\n    posInfos: a\n  };\n}\nfunction lF(i, t, e, r) {\n  r === void 0 && (r = 1);\n  var n = [];\n  if (e[0] && e[1])\n    n = [e, [-e[0], e[1]], [e[0], -e[1]]].map(function(o) {\n      return ze(t, o);\n    });\n  else if (!e[0] && !e[1])\n    for (var s = [t[0], t[1], t[3], t[2], t[0]], a = 0; a < 4; ++a)\n      n.push(s[a]), n.push([(s[a][0] + s[a + 1][0]) / 2, (s[a][1] + s[a + 1][1]) / 2]);\n  else\n    i.props.keepRatio ? n = [[-1, -1], [-1, 1], [1, -1], [1, 1], e].map(function(o) {\n      return ze(t, o);\n    }) : (n = CB(t, e), n.length > 1 && n.push([(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2]));\n  return g0(i, n.map(function(o) {\n    return o[0];\n  }), n.map(function(o) {\n    return o[1];\n  }), r);\n}\nfunction xC(i, t) {\n  var e = Math.abs(i.offset), r = Math.abs(t.offset);\n  return i.isBound && t.isBound ? r - e : i.isBound ? -1 : t.isBound ? 1 : i.isSnap && t.isSnap ? r - e : i.isSnap ? -1 : t.isSnap || e < Rr ? 1 : r < Rr ? -1 : e - r;\n}\nfunction Ov(i, t) {\n  return i.slice().sort(function(e, r) {\n    var n = e.sign[t], s = r.sign[t], a = e.offset[t], o = r.offset[t];\n    if (n) {\n      if (!s)\n        return -1;\n    } else\n      return 1;\n    return xC({\n      isBound: e.isBound,\n      isSnap: e.isSnap,\n      offset: a\n    }, {\n      isBound: r.isBound,\n      isSnap: r.isSnap,\n      offset: o\n    });\n  })[0];\n}\nfunction hF(i, t, e) {\n  var r = [];\n  if (e)\n    Math.abs(t[0]) !== 1 || Math.abs(t[1]) !== 1 ? r.push([t, [-1, -1]], [t, [-1, 1]], [t, [1, -1]], [t, [1, 1]]) : r.push([t, [i[0], -i[1]]], [t, [-i[0], i[1]]]), r.push([t, i]);\n  else if (i[0] && i[1] || !i[0] && !i[1]) {\n    var n = i[0] ? i : [1, 1];\n    [1, -1].forEach(function(a) {\n      [1, -1].forEach(function(o) {\n        var u = [a * n[0], o * n[1]];\n        t[0] === u[0] && t[1] === u[1] || r.push([t, u]);\n      });\n    });\n  } else if (i[0]) {\n    var s = Math.abs(t[0]) === 1 ? [1] : [1, -1];\n    s.forEach(function(a) {\n      r.push([[t[0], -1], [a * i[0], -1]], [[t[0], 0], [a * i[0], 0]], [[t[0], 1], [a * i[0], 1]]);\n    });\n  } else if (i[1]) {\n    var s = Math.abs(t[1]) === 1 ? [1] : [1, -1];\n    s.forEach(function(o) {\n      r.push([[-1, t[1]], [-1, o * i[1]]], [[0, t[1]], [0, o * i[1]]], [[1, t[1]], [1, o * i[1]]]);\n    });\n  }\n  return r;\n}\nfunction wC(i, t) {\n  var e = o_([t[0][0], t[1][0]]), r = o_([t[0][1], t[1][1]]);\n  return {\n    vertical: e <= i[0],\n    horizontal: r <= i[1]\n  };\n}\nfunction Dx(i, t) {\n  var e = t[0], r = t[1], n = r[0] - e[0], s = r[1] - e[1];\n  Math.abs(n) < Rr && (n = 0), Math.abs(s) < Rr && (s = 0);\n  var a, o;\n  if (!n)\n    a = e[0], o = i[0];\n  else if (!s)\n    a = e[1], o = i[1];\n  else {\n    var u = s / n;\n    a = u * (i[0] - e[0]) + e[1], o = i[1];\n  }\n  return a - o;\n}\nfunction EC(i, t, e, r) {\n  return r === void 0 && (r = Rr), i.every(function(n) {\n    var s = Dx(n, t), a = s <= 0;\n    return a === e || Math.abs(s) <= r;\n  });\n}\nfunction Mw(i, t, e, r, n) {\n  return n === void 0 && (n = 0), r && t - n <= i || !r && i <= e + n ? {\n    isBound: !0,\n    offset: r ? t - i : e - i\n  } : {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction cF(i, t) {\n  var e = t.line, r = t.centerSign, n = t.verticalSign, s = t.horizontalSign, a = t.lineConstants, o = i.props.innerBounds;\n  if (!o)\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var u = o.left, l = o.top, h = o.width, d = o.height, f = [[u, l], [u, l + d]], p = [[u, l], [u + h, l]], v = [[u + h, l], [u + h, l + d]], g = [[u, l + d], [u + h, l + d]];\n  if (EC([[u, l], [u + h, l], [u, l + d], [u + h, l + d]], e, r))\n    return {\n      isAllBound: !1,\n      isBound: !1,\n      isVerticalBound: !1,\n      isHorizontalBound: !1,\n      offset: [0, 0]\n    };\n  var m = ua(e, a, p, n), y = ua(e, a, g, n), _ = ua(e, a, f, s), b = ua(e, a, v, s), w = m.isBound && y.isBound, T = m.isBound || y.isBound, x = _.isBound && b.isBound, S = _.isBound || b.isBound, C = rh(m.offset, y.offset), M = rh(_.offset, b.offset), I = [0, 0], R = !1, N = !1;\n  return Math.abs(M) < Math.abs(C) ? (I = [C, 0], R = T, N = w) : (I = [0, M], R = S, N = x), {\n    isAllBound: N,\n    isVerticalBound: T,\n    isHorizontalBound: S,\n    isBound: R,\n    offset: I\n  };\n}\nfunction ua(i, t, e, r, n, s) {\n  var a = t[0], o = t[1], u = i[0], l = e[0], h = e[1], d = Mv(h[1] - l[1]), f = Mv(h[0] - l[0]), p = o, v = a, g = -a / o;\n  if (f) {\n    if (!d) {\n      if (s && !p)\n        return {\n          isBound: !1,\n          offset: 0\n        };\n      if (v) {\n        var b = (l[1] - u[1]) / g + u[0];\n        return Mw(b, l[0], h[0], r, n);\n      } else {\n        var y = l[1] - u[1], _ = Math.abs(y) <= (n || 0);\n        return {\n          isBound: _,\n          offset: _ ? y : 0\n        };\n      }\n    }\n  } else {\n    if (s && !v)\n      return {\n        isBound: !1,\n        offset: 0\n      };\n    if (p) {\n      var m = g * (l[0] - u[0]) + u[1];\n      return Mw(m, l[1], h[1], r, n);\n    } else {\n      var y = l[0] - u[0], _ = Math.abs(y) <= (n || 0);\n      return {\n        isBound: _,\n        offset: _ ? y : 0\n      };\n    }\n  }\n  return {\n    isBound: !1,\n    offset: 0\n  };\n}\nfunction SC(i, t, e) {\n  return t.map(function(r) {\n    var n = cF(i, r), s = n.isBound, a = n.offset, o = n.isVerticalBound, u = n.isHorizontalBound, l = r.multiple, h = Un({\n      datas: e,\n      distX: a[0],\n      distY: a[1]\n    }).map(function(d, f) {\n      return d * (l[f] ? 2 / l[f] : 0);\n    });\n    return {\n      sign: l,\n      isBound: s,\n      isVerticalBound: o,\n      isHorizontalBound: u,\n      isSnap: !1,\n      offset: h\n    };\n  });\n}\nfunction fF(i, t, e) {\n  var r, n = kx(i, t, [0, 0], !1).map(function(f) {\n    return F(F({}, f), {\n      multiple: f.multiple.map(function(p) {\n        return Math.abs(p) * 2;\n      })\n    });\n  }), s = SC(i, n, e), a = Ov(s, 0), o = Ov(s, 1), u = 0, l = 0, h = a.isVerticalBound || o.isVerticalBound, d = a.isHorizontalBound || o.isHorizontalBound;\n  return (h || d) && (r = SB({\n    datas: e,\n    distX: -a.offset[0],\n    distY: -o.offset[1]\n  }), u = r[0], l = r[1]), {\n    vertical: {\n      isBound: h,\n      offset: u\n    },\n    horizontal: {\n      isBound: d,\n      offset: l\n    }\n  };\n}\nfunction dF(i, t) {\n  var e = [], r = i[0], n = i[1];\n  return r && n ? e.push([[0, n * 2], i, [-r, n]], [[r * 2, 0], i, [r, -n]]) : r ? (e.push([[r * 2, 0], [r, 1], [r, -1]]), t && e.push([[0, -1], [r, -1], [-r, -1]], [[0, 1], [r, 1], [-r, 1]])) : n ? (e.push([[0, n * 2], [1, n], [-1, n]]), t && e.push([[-1, 0], [-1, n], [-1, -n]], [[1, 0], [1, n], [1, -n]])) : e.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]), e;\n}\nfunction kx(i, t, e, r) {\n  var n = i.state, s = n.allMatrix, a = n.is3d, o = da(s, 100, 100, a ? 4 : 3), u = ze(o, [0, 0]);\n  return dF(e, r).map(function(l) {\n    var h = l[0], d = l[1], f = l[2], p = [ze(o, d), ze(o, f)], v = oF(p), g = wC(u, p), m = g.vertical, y = g.horizontal, _ = Dx(u, p) <= 0;\n    return {\n      multiple: h,\n      centerSign: _,\n      verticalSign: m,\n      horizontalSign: y,\n      lineConstants: v,\n      line: [ze(t, d), ze(t, f)]\n    };\n  });\n}\nfunction Pw(i, t, e, r) {\n  var n = r ? i.map(function(s) {\n    return Md(s, r);\n  }) : i;\n  return [[n[0], n[1]], [n[1], n[3]], [n[3], n[2]], [n[2], n[0]]].some(function(s) {\n    var a = Dx(e, s) <= 0;\n    return !EC(t, s, a);\n  });\n}\nfunction pF(i) {\n  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];\n  if (!r)\n    return Math.abs(t[0]);\n  if (!n)\n    return Math.abs(t[1]);\n  var s = n / r;\n  return Math.abs((-s * t[0] + t[1]) / Math.sqrt(Math.pow(s, 2) + 1));\n}\nfunction vF(i) {\n  var t = i[0], e = i[1], r = e[0] - t[0], n = e[1] - t[1];\n  if (!r)\n    return [t[0], 0];\n  if (!n)\n    return [0, t[1]];\n  var s = n / r, a = -s * t[0] + t[1];\n  return [-a / (s + 1 / s), a / (s * s + 1)];\n}\nfunction gF(i, t, e, r, n) {\n  var s = i.props.innerBounds, a = n * Math.PI / 180;\n  if (!s)\n    return [];\n  var o = s.left, u = s.top, l = s.width, h = s.height, d = o - r[0], f = o + l - r[0], p = u - r[1], v = u + h - r[1], g = [[d, p], [f, p], [d, v], [f, v]], m = ze(e, [0, 0]);\n  if (!Pw(e, g, m, 0))\n    return [];\n  var y = [], _ = g.map(function(b) {\n    return [Ln(b), $e([0, 0], b)];\n  });\n  return [[e[0], e[1]], [e[1], e[3]], [e[3], e[2]], [e[2], e[0]]].forEach(function(b) {\n    var w = $e([0, 0], vF(b)), T = pF(b);\n    y.push.apply(y, _.filter(function(x) {\n      var S = x[0];\n      return S && T <= S;\n    }).map(function(x) {\n      var S = x[0], C = x[1], M = Math.acos(S ? T / S : 0), I = C + M, R = C - M;\n      return [a + I - w, a + R - w];\n    }).reduce(function(x, S) {\n      return x.push.apply(x, S), x;\n    }, []).filter(function(x) {\n      return !Pw(t, g, m, x);\n    }).map(function(x) {\n      return Gt(x * 180 / Math.PI, Rr);\n    }));\n  }), y;\n}\nfunction mF(i) {\n  var t = i.props.innerBounds;\n  if (!t)\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  var e = i.getRect(), r = e.pos1, n = e.pos2, s = e.pos3, a = e.pos4, o = [r, n, s, a], u = ze(o, [0, 0]), l = t.left, h = t.top, d = t.width, f = t.height, p = [[l, h], [l, h + f]], v = [[l, h], [l + d, h]], g = [[l + d, h], [l + d, h + f]], m = [[l, h + f], [l + d, h + f]], y = kx(i, o, [0, 0], !1), _ = [], b = [], w = {\n    top: !1,\n    bottom: !1,\n    left: !1,\n    right: !1\n  };\n  return y.forEach(function(T) {\n    var x = T.line, S = T.lineConstants, C = wC(u, x), M = C.horizontal, I = C.vertical, R = ua(x, S, v, I, 1, !0), N = ua(x, S, m, I, 1, !0), A = ua(x, S, p, M, 1, !0), U = ua(x, S, g, M, 1, !0);\n    R.isBound && !w.top && (_.push(h), w.top = !0), N.isBound && !w.bottom && (_.push(h + f), w.bottom = !0), A.isBound && !w.left && (b.push(l), w.left = !0), U.isBound && !w.right && (b.push(l + d), w.right = !0);\n  }), {\n    horizontal: _,\n    vertical: b\n  };\n}\nfunction Nx(i, t, e) {\n  var r = i || {}, n = r.position, s = n === void 0 ? \"client\" : n, a = r.left, o = a === void 0 ? -1 / 0 : a, u = r.top, l = u === void 0 ? -1 / 0 : u, h = r.right, d = h === void 0 ? 1 / 0 : h, f = r.bottom, p = f === void 0 ? 1 / 0 : f, v = {\n    position: s,\n    left: o,\n    top: l,\n    right: d,\n    bottom: p\n  };\n  return {\n    vertical: Ow(v, t, !0),\n    horizontal: Ow(v, e, !1)\n  };\n}\nfunction m0(i, t) {\n  var e = i.state, r = e.containerClientRect, n = r.clientHeight, s = r.clientWidth, a = r.clientLeft, o = r.clientTop, u = e.snapOffset, l = u.left, h = u.top, d = u.right, f = u.bottom, p = t || i.props.bounds || {}, v = p.position || \"client\", g = v === \"css\", m = p.left, y = m === void 0 ? -1 / 0 : m, _ = p.top, b = _ === void 0 ? -1 / 0 : _, w = p.right, T = w === void 0 ? g ? -1 / 0 : 1 / 0 : w, x = p.bottom, S = x === void 0 ? g ? -1 / 0 : 1 / 0 : x;\n  return g && (T = s + d - l - T, S = n + f - h - S), {\n    left: y + l - a,\n    right: T + l - a,\n    top: b + h - o,\n    bottom: S + h - o\n  };\n}\nfunction yF(i, t, e) {\n  var r = m0(i), n = r.left, s = r.top, a = r.right, o = r.bottom, u = e[0], l = e[1], h = Mt(e, t), d = h[0], f = h[1];\n  Math.abs(d) < Rr && (d = 0), Math.abs(f) < Rr && (f = 0);\n  var p = f > 0, v = d > 0, g = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }, m = {\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  };\n  if (d === 0 && f === 0)\n    return {\n      vertical: g,\n      horizontal: m\n    };\n  if (d === 0)\n    p ? o < l && (m.pos = o, m.offset = l - o) : s > l && (m.pos = s, m.offset = l - s);\n  else if (f === 0)\n    v ? a < u && (g.pos = a, g.offset = u - a) : n > u && (g.pos = n, g.offset = u - n);\n  else {\n    var y = f / d, _ = e[1] - y * u, b = 0, w = 0, T = !1;\n    v && a <= u ? (b = y * a + _, w = a, T = !0) : !v && u <= n && (b = y * n + _, w = n, T = !0), T && (b < s || b > o) && (T = !1), T || (p && o <= l ? (b = o, w = (b - _) / y, T = !0) : !p && l <= s && (b = s, w = (b - _) / y, T = !0)), T && (g.isBound = !0, g.pos = w, g.offset = u - w, m.isBound = !0, m.pos = b, m.offset = l - b);\n  }\n  return {\n    vertical: g,\n    horizontal: m\n  };\n}\nfunction Ow(i, t, e) {\n  var r = i[e ? \"left\" : \"top\"], n = i[e ? \"right\" : \"bottom\"], s = Math.min.apply(Math, t), a = Math.max.apply(Math, t), o = [];\n  return r + 1 > s && o.push({\n    isBound: !0,\n    offset: s - r,\n    pos: r\n  }), n - 1 < a && o.push({\n    isBound: !0,\n    offset: a - n,\n    pos: n\n  }), o.length || o.push({\n    isBound: !1,\n    offset: 0,\n    pos: 0\n  }), o.sort(function(u, l) {\n    return Math.abs(l.offset) - Math.abs(u.offset);\n  });\n}\nfunction Iw(i, t, e) {\n  var r = e ? i.map(function(n) {\n    return Md(n, e);\n  }) : i;\n  return r.some(function(n) {\n    return n[0] < t.left && Math.abs(n[0] - t.left) > 0.1 || n[0] > t.right && Math.abs(n[0] - t.right) > 0.1 || n[1] < t.top && Math.abs(n[1] - t.top) > 0.1 || n[1] > t.bottom && Math.abs(n[1] - t.bottom) > 0.1;\n  });\n}\nfunction _F(i, t, e) {\n  var r = Ln(i), n = Math.sqrt(r * r - t * t) || 0;\n  return [n, -n].sort(function(s, a) {\n    return Math.abs(s - i[e ? 0 : 1]) - Math.abs(a - i[e ? 0 : 1]);\n  }).map(function(s) {\n    return $e([0, 0], e ? [s, t] : [t, s]);\n  });\n}\nfunction bF(i, t, e, r, n) {\n  if (!i.props.bounds)\n    return [];\n  var s = n * Math.PI / 180, a = m0(i), o = a.left, u = a.top, l = a.right, h = a.bottom, d = o - r[0], f = l - r[0], p = u - r[1], v = h - r[1], g = {\n    left: d,\n    top: p,\n    right: f,\n    bottom: v\n  };\n  if (!Iw(e, g, 0))\n    return [];\n  var m = [];\n  return [[d, 0], [f, 0], [p, 1], [v, 1]].forEach(function(y) {\n    var _ = y[0], b = y[1];\n    e.forEach(function(w) {\n      var T = $e([0, 0], w);\n      m.push.apply(m, _F(w, _, b).map(function(x) {\n        return s + x - T;\n      }).filter(function(x) {\n        return !Iw(t, g, x);\n      }).map(function(x) {\n        return Gt(x * 180 / Math.PI, Rr);\n      }));\n    });\n  }), m;\n}\nfunction xF(i, t) {\n  var e, r = i.direction, n = i.classNames, s = i.size, a = i.pos, o = i.zoom, u = i.key, l = r === \"horizontal\", h = l ? \"Y\" : \"X\";\n  return t.createElement(\"div\", {\n    key: u,\n    className: n.join(\" \"),\n    style: (e = {}, e[l ? \"width\" : \"height\"] = \"\".concat(s), e.transform = \"translate(\".concat(a[0], \", \").concat(a[1], \") translate\").concat(h, \"(-50%) scale\").concat(h, \"(\").concat(o, \")\"), e)\n  });\n}\nfunction Ax(i, t) {\n  return xF(F(F({}, i), {\n    classNames: Tt([Pt(\"line\", \"guideline\", i.direction)], i.classNames, !0).filter(function(e) {\n      return e;\n    }),\n    size: i.size || \"\".concat(i.sizeValue, \"px\"),\n    pos: i.pos || i.posValue.map(function(e) {\n      return \"\".concat(Gt(e, 0.1), \"px\");\n    })\n  }), t);\n}\nfunction Rw(i, t, e, r, n, s, a, o) {\n  var u = i.props.zoom;\n  return e.map(function(l, h) {\n    var d = l.type, f = l.pos, p = [0, 0];\n    return p[a] = r, p[a ? 0 : 1] = -n + f, Ax({\n      key: \"\".concat(t, \"TargetGuideline\").concat(h),\n      classNames: [Pt(\"target\", \"bold\", d)],\n      posValue: p,\n      sizeValue: s,\n      zoom: u,\n      direction: t\n    }, o);\n  });\n}\nfunction Dw(i, t, e, r, n, s) {\n  var a = i.props, o = a.zoom, u = a.isDisplayInnerSnapDigit, l = t === \"horizontal\" ? pa : va, h = n[l.start], d = n[l.end];\n  return e.filter(function(f) {\n    var p = f.hide, v = f.elementRect;\n    if (p)\n      return !1;\n    if (u && v) {\n      var g = v.rect;\n      if (g[l.start] <= h && d <= g[l.end])\n        return !1;\n    }\n    return !0;\n  }).map(function(f, p) {\n    var v = f.pos, g = f.size, m = f.element, y = f.className, _ = [-r[0] + v[0], -r[1] + v[1]];\n    return Ax({\n      key: \"\".concat(t, \"-default-guideline-\").concat(p),\n      classNames: m ? [Pt(\"bold\"), y] : [Pt(\"normal\"), y],\n      direction: t,\n      posValue: _,\n      sizeValue: g,\n      zoom: o\n    }, s);\n  });\n}\nfunction Nh(i, t, e, r, n, s, a, o) {\n  var u, l = i.props, h = l.snapDigit, d = h === void 0 ? 0 : h, f = l.isDisplaySnapDigit, p = f === void 0 ? !0 : f, v = l.snapDistFormat, g = v === void 0 ? function(T, x) {\n    return T;\n  } : v, m = l.zoom, y = t === \"horizontal\" ? \"X\" : \"Y\", _ = t === \"vertical\" ? \"height\" : \"width\", b = Math.abs(n), w = p ? parseFloat(b.toFixed(d)) : 0;\n  return o.createElement(\"div\", {\n    key: \"\".concat(t, \"-\").concat(e, \"-guideline-\").concat(r),\n    className: Pt(\"guideline-group\", t),\n    style: (u = {\n      left: \"\".concat(s[0], \"px\"),\n      top: \"\".concat(s[1], \"px\")\n    }, u[_] = \"\".concat(b, \"px\"), u)\n  }, Ax({\n    direction: t,\n    classNames: [Pt(e), a],\n    size: \"100%\",\n    posValue: [0, 0],\n    sizeValue: b,\n    zoom: m\n  }, o), o.createElement(\"div\", {\n    className: Pt(\"size-value\", \"gap\"),\n    style: {\n      transform: \"translate\".concat(y, \"(-50%) scale(\").concat(m, \")\")\n    }\n  }, w > 0 ? g(w, t) : \"\"));\n}\nfunction wF(i, t, e, r) {\n  var n = i === \"vertical\" ? 0 : 1, s = i === \"vertical\" ? 1 : 0, a = n ? pa : va, o = e[a.start], u = e[a.end];\n  return pC(t, function(l) {\n    return l.pos[n];\n  }).map(function(l) {\n    var h = [], d = [], f = [];\n    return l.forEach(function(p) {\n      var v, g, m = p.element, y = p.elementRect.rect;\n      if (y[a.end] < o)\n        h.push(p);\n      else if (u < y[a.start])\n        d.push(p);\n      else if (y[a.start] <= o && u <= y[a.end] && r) {\n        var _ = p.pos, b = {\n          element: m,\n          rect: F(F({}, y), (v = {}, v[a.end] = y[a.start], v))\n        }, w = {\n          element: m,\n          rect: F(F({}, y), (g = {}, g[a.start] = y[a.end], g))\n        }, T = [0, 0], x = [0, 0];\n        T[n] = _[n], T[s] = _[s], x[n] = _[n], x[s] = _[s] + p.size, h.push({\n          type: i,\n          pos: T,\n          size: 0,\n          elementRect: b\n        }), d.push({\n          type: i,\n          pos: x,\n          size: 0,\n          elementRect: w\n        });\n      }\n    }), h.sort(function(p, v) {\n      return v.pos[s] - p.pos[s];\n    }), d.sort(function(p, v) {\n      return p.pos[s] - v.pos[s];\n    }), {\n      total: l,\n      start: h,\n      end: d,\n      inner: f\n    };\n  });\n}\nfunction EF(i, t, e, r, n) {\n  var s = i.props.isDisplayInnerSnapDigit, a = [];\n  return [\"vertical\", \"horizontal\"].forEach(function(o) {\n    var u = t.filter(function(m) {\n      return m.type === o;\n    }), l = o === \"vertical\" ? 1 : 0, h = l ? 0 : 1, d = wF(o, u, r, s), f = l ? va : pa, p = l ? pa : va, v = r[f.start], g = r[f.end];\n    d.forEach(function(m) {\n      var y = m.total, _ = m.start, b = m.end, w = m.inner, T = e[h] + y[0].pos[h] - r[p.start], x = r;\n      _.forEach(function(S) {\n        var C = S.elementRect.rect, M = x[f.start] - C[f.end];\n        if (M > 0) {\n          var I = [0, 0];\n          I[l] = e[l] + x[f.start] - v - M, I[h] = T, a.push(Nh(i, o, \"dashed\", a.length, M, I, S.className, n));\n        }\n        x = C;\n      }), x = r, b.forEach(function(S) {\n        var C = S.elementRect.rect, M = C[f.start] - x[f.end];\n        if (M > 0) {\n          var I = [0, 0];\n          I[l] = e[l] + x[f.end] - v, I[h] = T, a.push(Nh(i, o, \"dashed\", a.length, M, I, S.className, n));\n        }\n        x = C;\n      }), w.forEach(function(S) {\n        var C = S.elementRect.rect, M = v - C[f.start], I = C[f.end] - g, R = [0, 0], N = [0, 0];\n        R[l] = e[l] - M, R[h] = T, N[l] = e[l] + g - v, N[h] = T, a.push(Nh(i, o, \"dashed\", a.length, M, R, S.className, n)), a.push(Nh(i, o, \"dashed\", a.length, I, N, S.className, n));\n      });\n    });\n  }), a;\n}\nfunction SF(i, t, e, r, n) {\n  var s = [];\n  return [\"horizontal\", \"vertical\"].forEach(function(a) {\n    var o = t.filter(function(m) {\n      return m.type === a;\n    }).slice(0, 1), u = a === \"vertical\" ? 0 : 1, l = u ? 0 : 1, h = u ? va : pa, d = u ? pa : va, f = r[h.start], p = r[h.end], v = r[d.start], g = r[d.end];\n    o.forEach(function(m) {\n      var y = m.gap, _ = m.gapRects, b = Math.max.apply(Math, Tt([v], _.map(function(x) {\n        var S = x.rect;\n        return S[d.start];\n      }), !1)), w = Math.min.apply(Math, Tt([g], _.map(function(x) {\n        var S = x.rect;\n        return S[d.end];\n      }), !1)), T = (b + w) / 2;\n      b === w || T === (v + g) / 2 || _.forEach(function(x) {\n        var S = x.rect, C = x.className, M = [e[0], e[1]];\n        if (S[h.end] < f)\n          M[u] += S[h.end] - f;\n        else if (p < S[h.start])\n          M[u] += S[h.start] - f - y;\n        else\n          return;\n        M[l] += T - v, s.push(Nh(i, u ? \"vertical\" : \"horizontal\", \"gap\", s.length, y, M, C, n));\n      });\n    });\n  }), s;\n}\nfunction TF(i, t, e, r) {\n  var n = t[0] - i[0], s = t[1] - i[1];\n  if (Math.abs(n) < Je && (n = 0), Math.abs(s) < Je && (s = 0), !n)\n    return r ? [0, 0] : [0, e];\n  if (!s)\n    return r ? [e, 0] : [0, 0];\n  var a = s / n, o = i[1] - a * i[0];\n  if (r) {\n    var u = a * (t[0] + e) + o;\n    return [e, u - t[1]];\n  } else {\n    var l = (t[1] + e - o) / a;\n    return [l - t[0], e];\n  }\n}\nfunction O_(i, t, e, r, n) {\n  var s = TF(i, t, e, r);\n  if (!s)\n    return {\n      isOutside: !1,\n      offset: [0, 0]\n    };\n  var a = Zi(i, t), o = Zi(s, i), u = Zi(s, t), l = o > a || u > a, h = Un({\n    datas: n,\n    distX: s[0],\n    distY: s[1]\n  }), d = h[0], f = h[1];\n  return {\n    offset: [d, f],\n    isOutside: l\n  };\n}\nfunction Iv(i, t) {\n  return i.isBound ? i.offset : t.isSnap ? P_(t).offset : 0;\n}\nfunction CF(i, t, e, r, n) {\n  var s = t[0], a = t[1], o = e[0], u = e[1], l = r[0], h = r[1], d = n[0], f = n[1], p = -d, v = -f;\n  if (i && s && a) {\n    p = 0, v = 0;\n    var g = [];\n    if (o && u ? g.push([0, f], [d, 0]) : o ? g.push([d, 0]) : u ? g.push([0, f]) : l && h ? g.push([0, f], [d, 0]) : l ? g.push([d, 0]) : h && g.push([0, f]), g.length) {\n      g.sort(function(b, w) {\n        return Ln(Mt([s, a], b)) - Ln(Mt([s, a], w));\n      });\n      var m = g[0];\n      if (m[0] && Math.abs(s) > Je)\n        p = -m[0], v = a * Math.abs(s + p) / Math.abs(s) - a;\n      else if (m[1] && Math.abs(a) > Je) {\n        var y = a;\n        v = -m[1], p = s * Math.abs(a + v) / Math.abs(y) - s;\n      }\n      if (i && u && o)\n        if (Math.abs(p) > Je && Math.abs(p) < Math.abs(d)) {\n          var _ = Math.abs(d) / Math.abs(p);\n          p *= _, v *= _;\n        } else if (Math.abs(v) > Je && Math.abs(v) < Math.abs(f)) {\n          var _ = Math.abs(f) / Math.abs(v);\n          p *= _, v *= _;\n        } else\n          p = rh(-d, p), v = rh(-f, v);\n    }\n  } else\n    p = s || o ? -d : 0, v = a || u ? -f : 0;\n  return [p, v];\n}\nfunction MF(i, t, e, r, n, s) {\n  if (!ph(i, \"draggable\"))\n    return [{\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }, {\n      isSnap: !1,\n      isBound: !1,\n      offset: 0\n    }];\n  var a = Tx(s.absolutePoses, [t, e]), o = Ti(a), u = o.left, l = o.right, h = o.top, d = o.bottom, f = {\n    horizontal: a.map(function(U) {\n      return U[1];\n    }),\n    vertical: a.map(function(U) {\n      return U[0];\n    })\n  }, p = Ix(i.props.snapDirections), v = Rx(p, {\n    left: u,\n    right: l,\n    top: h,\n    bottom: d,\n    center: (u + l) / 2,\n    middle: (h + d) / 2\n  }), g = y0(i, n, v, f), m = g.vertical, y = g.horizontal, _ = fF(i, a, s), b = _.vertical, w = _.horizontal, T = m.isSnap, x = y.isSnap, S = m.isBound || b.isBound, C = y.isBound || w.isBound, M = rh(m.offset, b.offset), I = rh(y.offset, w.offset), R = CF(r, [t, e], [S, C], [T, x], [M, I]), N = R[0], A = R[1];\n  return [{\n    isBound: S,\n    isSnap: T,\n    offset: N\n  }, {\n    isBound: C,\n    isSnap: x,\n    offset: A\n  }];\n}\nfunction y0(i, t, e, r) {\n  r === void 0 && (r = e);\n  var n = Nx(m0(i), r.vertical, r.horizontal), s = n.horizontal, a = n.vertical, o = t ? {\n    horizontal: {\n      isSnap: !1,\n      index: -1\n    },\n    vertical: {\n      isSnap: !1,\n      index: -1\n    }\n  } : g0(i, e.vertical, e.horizontal), u = o.horizontal, l = o.vertical, h = Iv(s[0], u), d = Iv(a[0], l), f = Math.abs(h), p = Math.abs(d);\n  return {\n    horizontal: {\n      isBound: s[0].isBound,\n      isSnap: u.isSnap,\n      snapIndex: u.index,\n      offset: h,\n      dist: f,\n      bounds: s,\n      snap: u\n    },\n    vertical: {\n      isBound: a[0].isBound,\n      isSnap: l.isSnap,\n      snapIndex: l.index,\n      offset: d,\n      dist: p,\n      bounds: a,\n      snap: l\n    }\n  };\n}\nfunction kw(i, t, e, r, n) {\n  var s = Nx(t, e, r), a = s.horizontal, o = s.vertical, u = bC(i, e, r, n), l = u.horizontal, h = u.vertical, d = Iv(a[0], l), f = Iv(o[0], h), p = Math.abs(d), v = Math.abs(f);\n  return {\n    horizontal: {\n      isBound: a[0].isBound,\n      isSnap: l.isSnap,\n      snapIndex: l.index,\n      offset: d,\n      dist: p,\n      bounds: a,\n      snap: l\n    },\n    vertical: {\n      isBound: o[0].isBound,\n      isSnap: h.isSnap,\n      snapIndex: h.index,\n      offset: f,\n      dist: v,\n      bounds: o,\n      snap: h\n    }\n  };\n}\nfunction PF(i, t, e, r) {\n  var n = $e(i, t) / Math.PI * 180, s = e.vertical, a = s.isBound, o = s.isSnap, u = s.dist, l = e.horizontal, h = l.isBound, d = l.isSnap, f = l.dist, p = n % 180, v = p < 3 || p > 177, g = p > 87 && p < 93;\n  return f < u && (a || o && !g && (!r || !v)) ? \"vertical\" : h || d && !v && (!r || !g) ? \"horizontal\" : \"\";\n}\nfunction OF(i, t, e, r, n, s) {\n  return e.map(function(a) {\n    var o = a[0], u = a[1], l = ze(t, o), h = ze(t, u), d = r ? IF(i, l, h, n) : y0(i, n, {\n      vertical: [h[0]],\n      horizontal: [h[1]]\n    }), f = d.horizontal, p = f.offset, v = f.isBound, g = f.isSnap, m = d.vertical, y = m.offset, _ = m.isBound, b = m.isSnap, w = Mt(u, o);\n    if (!y && !p)\n      return {\n        isBound: _ || v,\n        isSnap: b || g,\n        sign: w,\n        offset: [0, 0]\n      };\n    var T = PF(l, h, d, r);\n    if (!T)\n      return {\n        sign: w,\n        isBound: !1,\n        isSnap: !1,\n        offset: [0, 0]\n      };\n    var x = T === \"vertical\", S = [0, 0];\n    return !r && Math.abs(u[0]) === 1 && Math.abs(u[1]) === 1 && o[0] !== u[0] && o[1] !== u[1] ? S = Un({\n      datas: s,\n      distX: -y,\n      distY: -p\n    }) : S = O_(l, h, -(x ? y : p), x, s).offset, S = S.map(function(C, M) {\n      return C * (w[M] ? 2 / w[M] : 0);\n    }), {\n      sign: w,\n      isBound: x ? _ : v,\n      isSnap: x ? b : g,\n      offset: S\n    };\n  });\n}\nfunction Nw(i, t) {\n  return i.isBound ? i.offset : t.isSnap ? t.offset : 0;\n}\nfunction IF(i, t, e, r) {\n  var n = yF(i, t, e), s = n.horizontal, a = n.vertical, o = r ? {\n    horizontal: {\n      isSnap: !1\n    },\n    vertical: {\n      isSnap: !1\n    }\n  } : uF(i, t, e), u = o.horizontal, l = o.vertical, h = Nw(s, u), d = Nw(a, l), f = Math.abs(h), p = Math.abs(d);\n  return {\n    horizontal: {\n      isBound: s.isBound,\n      isSnap: u.isSnap,\n      offset: h,\n      dist: f\n    },\n    vertical: {\n      isBound: a.isBound,\n      isSnap: l.isSnap,\n      offset: d,\n      dist: p\n    }\n  };\n}\nfunction RF(i, t, e, r, n) {\n  var s = [-e[0], -e[1]], a = i.state, o = a.width, u = a.height, l = i.props.bounds, h = 1 / 0, d = 1 / 0;\n  if (l) {\n    var f = [[e[0], -e[1]], [-e[0], e[1]]], p = l.left, v = p === void 0 ? -1 / 0 : p, g = l.top, m = g === void 0 ? -1 / 0 : g, y = l.right, _ = y === void 0 ? 1 / 0 : y, b = l.bottom, w = b === void 0 ? 1 / 0 : b;\n    f.forEach(function(T) {\n      var x = T[0] !== s[0], S = T[1] !== s[1], C = ze(t, T), M = $e(r, C) * 360 / Math.PI;\n      if (S) {\n        var I = C.slice();\n        (Math.abs(M - 360) < 2 || Math.abs(M - 180) < 2) && (I[1] = r[1]);\n        var R = O_(r, I, (r[1] < C[1] ? w : m) - C[1], !1, n), N = R.offset, A = N[1], U = R.isOutside;\n        isNaN(A) || (d = u + (U ? 1 : -1) * Math.abs(A));\n      }\n      if (x) {\n        var I = C.slice();\n        (Math.abs(M - 90) < 2 || Math.abs(M - 270) < 2) && (I[0] = r[0]);\n        var B = O_(r, I, (r[0] < C[0] ? _ : v) - C[0], !0, n), G = B.offset[0], $ = B.isOutside;\n        isNaN(G) || (h = o + ($ ? 1 : -1) * Math.abs(G));\n      }\n    });\n  }\n  return {\n    maxWidth: h,\n    maxHeight: d\n  };\n}\nfunction I_(i) {\n  var t = i.state, e = t.containerClientRect, r = t.hasFixed, n = e.overflow, s = e.scrollHeight, a = e.scrollWidth, o = e.clientHeight, u = e.clientWidth, l = e.clientLeft, h = e.clientTop, d = i.props, f = d.snapGap, p = f === void 0 ? !0 : f, v = d.verticalGuidelines, g = d.horizontalGuidelines, m = d.snapThreshold, y = m === void 0 ? 5 : m, _ = d.snapGridWidth, b = _ === void 0 ? 0 : _, w = d.snapGridHeight, T = w === void 0 ? 0 : w, x = d.maxSnapElementGuidelineDistance, S = x === void 0 ? 1 / 0 : x, C = Ti(Ci(i.state)), M = C.top, I = C.left, R = C.bottom, N = C.right, A = {\n    top: M,\n    left: I,\n    bottom: R,\n    right: N,\n    center: (I + N) / 2,\n    middle: (M + R) / 2\n  }, U = NF(i), B = Tt([], U, !0);\n  p && B.push.apply(B, DF(i, A, y)), B.push.apply(B, kF(b, T, n ? a : u, n ? s : o, l, h));\n  var G = F({}, t.snapOffset || {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  });\n  if (r) {\n    var $ = e.left, Z = e.top;\n    G.left += $, G.top += Z, G.right += $, G.bottom += Z;\n  }\n  return B.push.apply(B, CC(g || !1, v || !1, n ? a : u, n ? s : o, l, h, G)), B = B.filter(function(H) {\n    var z = H.element, X = H.elementRect, ct = H.type;\n    if (!z || !X)\n      return !0;\n    var it = X.rect;\n    return TC(A, it, ct, S);\n  }), B;\n}\nfunction DF(i, t, e) {\n  var r = i.props, n = r.maxSnapElementGuidelineDistance, s = n === void 0 ? 1 / 0 : n, a = r.maxSnapElementGapDistance, o = a === void 0 ? 1 / 0 : a, u = i.state.elementRects, l = [];\n  return [[\"vertical\", pa, va], [\"horizontal\", va, pa]].forEach(function(h) {\n    var d = h[0], f = h[1], p = h[2], v = t[f.start], g = t[f.end], m = t[f.center], y = t[p.start], _ = t[p.end];\n    function b(x) {\n      var S = x.rect;\n      return S[f.end] < v + e ? v - S[f.end] : g - e < S[f.start] ? S[f.start] - g : -1;\n    }\n    var w = u.filter(function(x) {\n      var S = x.rect;\n      return S[p.start] > _ || S[p.end] < y ? !1 : b(x) > 0;\n    }).sort(function(x, S) {\n      return b(x) - b(S);\n    }), T = [];\n    w.forEach(function(x) {\n      w.forEach(function(S) {\n        if (x !== S) {\n          var C = x.rect, M = S.rect, I = C[p.start], R = C[p.end], N = M[p.start], A = M[p.end];\n          I > A || N > R || T.push([x, S]);\n        }\n      });\n    }), T.forEach(function(x) {\n      var S = x[0], C = x[1], M = S.rect, I = C.rect, R = M[f.start], N = M[f.end], A = I[f.start], U = I[f.end], B = 0, G = 0, $ = !1, Z = !1, H = !1;\n      if (N <= v && g <= A) {\n        if (Z = !0, B = (A - N - (g - v)) / 2, G = N + B + (g - v) / 2, Math.abs(G - m) > e)\n          return;\n      } else if (N < A && U < v + e) {\n        if ($ = !0, B = A - N, G = U + B, Math.abs(G - v) > e)\n          return;\n      } else if (N < A && g - e < R) {\n        if (H = !0, B = A - N, G = R - B, Math.abs(G - g) > e)\n          return;\n      } else\n        return;\n      B && TC(t, I, d, s) && (B > o || l.push({\n        type: d,\n        pos: d === \"vertical\" ? [G, 0] : [0, G],\n        element: C.element,\n        size: 0,\n        className: C.className,\n        isStart: $,\n        isCenter: Z,\n        isEnd: H,\n        gap: B,\n        hide: !0,\n        gapRects: [S, C]\n      }));\n    });\n  }), l;\n}\nfunction kF(i, t, e, r, n, s) {\n  n === void 0 && (n = 0), s === void 0 && (s = 0);\n  var a = [];\n  if (t)\n    for (var o = 0; o <= r; o += t)\n      a.push({\n        type: \"horizontal\",\n        pos: [0, Gt(o - s, 0.1)],\n        size: e,\n        hide: !0\n      });\n  if (i)\n    for (var o = 0; o <= e; o += i)\n      a.push({\n        type: \"vertical\",\n        pos: [Gt(o - n, 0.1), 0],\n        size: r,\n        hide: !0\n      });\n  return a;\n}\nfunction TC(i, t, e, r) {\n  return e === \"horizontal\" ? Math.abs(i.right - t.left) <= r || Math.abs(i.left - t.right) <= r || i.left <= t.right && t.left <= i.right : e === \"vertical\" ? Math.abs(i.bottom - t.top) <= r || Math.abs(i.top - t.bottom) <= r || i.top <= t.bottom && t.top <= i.bottom : !0;\n}\nfunction NF(i) {\n  var t = i.state, e = i.props.elementGuidelines, r = e === void 0 ? [] : e;\n  if (!r.length)\n    return t.elementRects = [], [];\n  var n = (t.elementRects || []).filter(function(f) {\n    return !f.refresh;\n  }), s = r.map(function(f) {\n    return ca(f) && \"element\" in f ? F(F({}, f), {\n      element: nu(f.element, !0)\n    }) : {\n      element: nu(f, !0)\n    };\n  }).filter(function(f) {\n    return f.element;\n  }), a = NL(n.map(function(f) {\n    return f.element;\n  }), s.map(function(f) {\n    return f.element;\n  })), o = a.maintained, u = a.added, l = [];\n  o.forEach(function(f) {\n    var p = f[0], v = f[1];\n    l[v] = n[p];\n  }), AF(i, u.map(function(f) {\n    return s[f];\n  })).map(function(f, p) {\n    l[u[p]] = f;\n  }), t.elementRects = l;\n  var h = Ix(i.props.elementSnapDirections), d = [];\n  return l.forEach(function(f) {\n    var p = f.element, v = f.top, g = v === void 0 ? h.top : v, m = f.left, y = m === void 0 ? h.left : m, _ = f.right, b = _ === void 0 ? h.right : _, w = f.bottom, T = w === void 0 ? h.bottom : w, x = f.center, S = x === void 0 ? h.center : x, C = f.middle, M = C === void 0 ? h.middle : C, I = f.className, R = f.rect, N = Rx({\n      top: g,\n      right: b,\n      left: y,\n      bottom: T,\n      center: S,\n      middle: M\n    }, R), A = N.horizontal, U = N.vertical, B = R.top, G = R.left, $ = R.right - G, Z = R.bottom - B, H = [$, Z];\n    U.forEach(function(z) {\n      d.push({\n        type: \"vertical\",\n        element: p,\n        pos: [Gt(z, 0.1), B],\n        size: Z,\n        sizes: H,\n        className: I,\n        elementRect: f\n      });\n    }), A.forEach(function(z) {\n      d.push({\n        type: \"horizontal\",\n        element: p,\n        pos: [G, Gt(z, 0.1)],\n        size: $,\n        sizes: H,\n        className: I,\n        elementRect: f\n      });\n    });\n  }), d;\n}\nfunction Aw(i, t) {\n  return i ? i.map(function(e) {\n    var r = ca(e) ? e : {\n      pos: e\n    }, n = r.pos;\n    return pc(n) ? r : F(F({}, r), {\n      pos: Te(n, t)\n    });\n  }) : [];\n}\nfunction CC(i, t, e, r, n, s, a) {\n  n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0\n  });\n  var o = [], u = a.left, l = a.top, h = a.bottom, d = a.right, f = e + d - u, p = r + h - l;\n  return Aw(i, p).forEach(function(v) {\n    o.push({\n      type: \"horizontal\",\n      pos: [u, Gt(v.pos - s + l, 0.1)],\n      size: f,\n      className: v.className\n    });\n  }), Aw(t, f).forEach(function(v) {\n    o.push({\n      type: \"vertical\",\n      pos: [Gt(v.pos - n + u, 0.1), l],\n      size: p,\n      className: v.className\n    });\n  }), o;\n}\nfunction AF(i, t) {\n  if (!t.length)\n    return [];\n  var e = i.state, r = e.containerClientRect, n = e.rootMatrix, s = e.is3d, a = e.offsetDelta, o = s ? 4 : 3, u = aF(n, r, o), l = u[0], h = u[1];\n  return t.map(function(d) {\n    var f = d.element.getBoundingClientRect(), p = f.left - l - a[0], v = f.top - h - a[1], g = v + f.height, m = p + f.width, y = ih(n, [p, v], o), _ = y[0], b = y[1], w = ih(n, [m, g], o), T = w[0], x = w[1];\n    return F(F({}, d), {\n      rect: {\n        left: _,\n        right: T,\n        top: b,\n        bottom: x,\n        center: (_ + T) / 2,\n        middle: (b + x) / 2\n      }\n    });\n  });\n}\nfunction _p(i) {\n  var t = i.state, e = t.container, r = i.props.snapContainer || e;\n  if (t.snapContainer === r && t.guidelines && t.guidelines.length)\n    return !1;\n  var n = t.containerClientRect, s = {\n    left: 0,\n    top: 0,\n    bottom: 0,\n    right: 0\n  };\n  if (e !== r) {\n    var a = nu(r, !0);\n    if (a) {\n      var o = Kh(a), u = Ew(t, [o.left - n.left, o.top - n.top]), l = Ew(t, [o.right - n.right, o.bottom - n.bottom]);\n      s.left = Gt(u[0], 1e-5), s.top = Gt(u[1], 1e-5), s.right = Gt(l[0], 1e-5), s.bottom = Gt(l[1], 1e-5);\n    }\n  }\n  return t.snapContainer = r, t.snapOffset = s, t.guidelines = I_(i), t.enableSnap = !0, !0;\n}\nfunction MC(i, t, e, r, n, s) {\n  var a = da(i, t, e, s ? 4 : 3), o = ze(a, r);\n  return Tx(a, Mt(n, o));\n}\nfunction LF(i, t, e, r, n, s) {\n  var a = s.fixedDirection, o = hF(e, a, r), u = kx(i, t, e, r), l = Tt(Tt([], OF(i, t, o, r, n, s), !0), SC(i, u, s), !0), h = Ov(l, 0), d = Ov(l, 1);\n  return {\n    width: {\n      isBound: h.isBound,\n      offset: h.offset[0]\n    },\n    height: {\n      isBound: d.isBound,\n      offset: d.offset[1]\n    }\n  };\n}\nfunction BF(i, t, e, r, n, s, a, o, u) {\n  var l = ze(t, a), h = y0(i, o, {\n    vertical: [l[0]],\n    horizontal: [l[1]]\n  }), d = h.horizontal.offset, f = h.vertical.offset;\n  if (Gt(f, w_) || Gt(d, w_)) {\n    var p = Un({\n      datas: u,\n      distX: -f,\n      distY: -d\n    }), v = p[0], g = p[1], m = Math.min(n || 1 / 0, e + a[0] * v), y = Math.min(s || 1 / 0, r + a[1] * g);\n    return [m - e, y - r];\n  }\n  return [0, 0];\n}\nfunction PC(i, t, e, r, n, s, a, o) {\n  for (var u = Ci(i.state), l = i.props.keepRatio, h = 0, d = 0, f = 0; f < 2; ++f) {\n    var p = t(h, d), v = LF(i, p, n, l, a, o), g = v.width, m = v.height, y = g.isBound, _ = m.isBound, b = g.offset, w = m.offset;\n    if (f === 1 && (y || (b = 0), _ || (w = 0)), f === 0 && a && !y && !_)\n      return [0, 0];\n    if (l) {\n      var T = Math.abs(b) * (e ? 1 / e : 1), x = Math.abs(w) * (r ? 1 / r : 1), S = y && _ ? T < x : _ || !y && T < x;\n      S ? b = e * w / r : w = r * b / e;\n    }\n    h += b, d += w;\n  }\n  if (n[0] && n[1]) {\n    var C = RF(i, u, n, s, o), M = C.maxWidth, I = C.maxHeight, R = BF(i, t(h, d).map(function(U) {\n      return U.map(function(B) {\n        return Gt(B, w_);\n      });\n    }), e + h, r + d, M, I, n, a, o), b = R[0], w = R[1];\n    h += b, d += w;\n  }\n  return [h, d];\n}\nfunction FF(i, t, e) {\n  if (!ph(i, \"rotatable\"))\n    return {\n      isSnap: !1,\n      rotation: e\n    };\n  var r = t.pos1, n = t.pos2, s = t.pos3, a = t.pos4, o = t.origin, u = e * Math.PI / 180, l = [r, n, s, a].map(function(p) {\n    return Mt(p, o);\n  }), h = l.map(function(p) {\n    return Md(p, u);\n  }), d = Tt(Tt([], bF(i, l, h, o, e), !0), gF(i, l, h, o, e), !0);\n  d.sort(function(p, v) {\n    return Math.abs(p - e) - Math.abs(v - e);\n  });\n  var f = d.length > 0;\n  return {\n    isSnap: f,\n    rotation: f ? d[0] : e\n  };\n}\nfunction GF(i, t, e, r, n, s, a) {\n  if (!ph(i, \"resizable\"))\n    return [0, 0];\n  var o = a.fixedDirection, u = a.nextAllMatrix, l = i.state, h = l.allMatrix, d = l.is3d;\n  return PC(i, function(f, p) {\n    return MC(u || h, t + f, e + p, o, n, d);\n  }, t, e, r, n, s, a);\n}\nfunction UF(i, t, e, r, n) {\n  if (!ph(i, \"scalable\"))\n    return [0, 0];\n  var s = n.startOffsetWidth, a = n.startOffsetHeight, o = n.fixedPosition, u = n.fixedDirection, l = n.is3d, h = PC(i, function(d, f) {\n    return MC(OB(n, Jt(t, [d / s, f / a])), s, a, u, o, l);\n  }, s, a, e, o, r, n);\n  return [h[0] / s, h[1] / a];\n}\nfunction jF(i, t) {\n  t.absolutePoses = Ci(i.state);\n}\nfunction Lw(i) {\n  var t = [];\n  return i.forEach(function(e) {\n    e.guidelineInfos.forEach(function(r) {\n      var n = r.guideline;\n      t.indexOf(n) > -1 || t.push(n);\n    });\n  }), t;\n}\nfunction Bw(i, t, e, r, n, s) {\n  var a = Nx(m0(i, s), t, e), o = a.vertical, u = a.horizontal;\n  o.forEach(function(f) {\n    f.isBound && r.push({\n      type: \"bounds\",\n      pos: f.pos\n    });\n  }), u.forEach(function(f) {\n    f.isBound && n.push({\n      type: \"bounds\",\n      pos: f.pos\n    });\n  });\n  var l = mF(i), h = l.vertical, d = l.horizontal;\n  h.forEach(function(f) {\n    Ms(r, function(p) {\n      var v = p.type, g = p.pos;\n      return v === \"bounds\" && g === f;\n    }) >= 0 || r.push({\n      type: \"bounds\",\n      pos: f\n    });\n  }), d.forEach(function(f) {\n    Ms(n, function(p) {\n      var v = p.type, g = p.pos;\n      return v === \"bounds\" && g === f;\n    }) >= 0 || n.push({\n      type: \"bounds\",\n      pos: f\n    });\n  });\n}\nvar zF = Px(\"\", [\"resizable\", \"scalable\"]), HF = {\n  name: \"snappable\",\n  dragRelation: \"strong\",\n  props: [\"snappable\", \"snapContainer\", \"snapDirections\", \"elementSnapDirections\", \"snapGap\", \"snapGridWidth\", \"snapGridHeight\", \"isDisplaySnapDigit\", \"isDisplayInnerSnapDigit\", \"snapDigit\", \"snapThreshold\", \"snapRenderThreshold\", \"horizontalGuidelines\", \"verticalGuidelines\", \"elementGuidelines\", \"bounds\", \"innerBounds\", \"snapDistFormat\", \"maxSnapElementGuidelineDistance\", \"maxSnapElementGapDistance\"],\n  events: [\"snap\"],\n  css: [`:host {\n--bounds-color: #d66;\n}\n.guideline {\npointer-events: none;\nz-index: 2;\n}\n.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}\n.guideline-group {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.guideline-group .size-value {\nposition: absolute;\ncolor: #f55;\nfont-size: 12px;\nfont-size: calc(12px * var(--zoom));\nfont-weight: bold;\n}\n.guideline-group.horizontal .size-value {\ntransform-origin: 50% 100%;\ntransform: translateX(-50%);\nleft: 50%;\nbottom: 5px;\nbottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\ntransform-origin: 0% 50%;\ntop: 50%;\ntransform: translateY(-50%);\nleft: 5px;\nleft: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\nbackground: #f55;\n}\n.size-value.gap {\ncolor: #f55;\n}\n`],\n  render: function(i, t) {\n    var e = i.state, r = e.top, n = e.left, s = e.pos1, a = e.pos2, o = e.pos3, u = e.pos4, l = e.snapRenderInfo, h = i.props.snapRenderThreshold, d = h === void 0 ? 1 : h;\n    if (!l || !l.render || !ph(i, \"\"))\n      return [];\n    e.guidelines = I_(i);\n    var f = Math.min(s[0], a[0], o[0], u[0]), p = Math.min(s[1], a[1], o[1], u[1]), v = l.externalPoses || [], g = Ci(i.state), m = [], y = [], _ = [], b = [], w = [], T = Ti(g), x = T.width, S = T.height, C = T.top, M = T.left, I = T.bottom, R = T.right, N = {\n      left: M,\n      right: R,\n      top: C,\n      bottom: I,\n      center: (M + R) / 2,\n      middle: (C + I) / 2\n    }, A = v.length > 0, U = A ? Ti(v) : {};\n    if (!l.request) {\n      if (l.direction && w.push(lF(i, g, l.direction, d)), l.snap) {\n        var B = Ti(g);\n        l.center && (B.middle = (B.top + B.bottom) / 2, B.center = (B.left + B.right) / 2), w.push(Tw(i, B, d));\n      }\n      A && (l.center && (U.middle = (U.top + U.bottom) / 2, U.center = (U.left + U.right) / 2), w.push(Tw(i, U, d))), w.forEach(function(H) {\n        var z = H.vertical.posInfos, X = H.horizontal.posInfos;\n        m.push.apply(m, z.filter(function(ct) {\n          var it = ct.guidelineInfos;\n          return it.some(function(lt) {\n            var et = lt.guideline;\n            return !et.hide;\n          });\n        }).map(function(ct) {\n          return {\n            type: \"snap\",\n            pos: ct.pos\n          };\n        })), y.push.apply(y, X.filter(function(ct) {\n          var it = ct.guidelineInfos;\n          return it.some(function(lt) {\n            var et = lt.guideline;\n            return !et.hide;\n          });\n        }).map(function(ct) {\n          return {\n            type: \"snap\",\n            pos: ct.pos\n          };\n        })), _.push.apply(_, Lw(z)), b.push.apply(b, Lw(X));\n      });\n    }\n    Bw(i, [M, R], [C, I], m, y), A && Bw(i, [U.left, U.right], [U.top, U.bottom], m, y, l.externalBounds);\n    var G = Tt(Tt([], _, !0), b, !0), $ = G.filter(function(H) {\n      return H.element && !H.gapRects;\n    }), Z = G.filter(function(H) {\n      return H.gapRects;\n    }).sort(function(H, z) {\n      return H.gap - z.gap;\n    });\n    return mt(i, \"onSnap\", {\n      guidelines: G.filter(function(H) {\n        var z = H.element;\n        return !z;\n      }),\n      elements: $,\n      gaps: Z\n    }, !0), Tt(Tt(Tt(Tt(Tt(Tt([], EF(i, $, [f, p], N, t), !0), SF(i, Z, [f, p], N, t), !0), Dw(i, \"horizontal\", b, [n, r], N, t), !0), Dw(i, \"vertical\", _, [n, r], N, t), !0), Rw(i, \"horizontal\", y, f, r, x, 0, t), !0), Rw(i, \"vertical\", m, p, n, S, 1, t), !0);\n  },\n  dragStart: function(i, t) {\n    i.state.snapRenderInfo = {\n      request: t.isRequest,\n      snap: !0,\n      center: !0\n    }, _p(i);\n  },\n  drag: function(i) {\n    var t = i.state;\n    _p(i) || (t.guidelines = I_(i)), t.snapRenderInfo && (t.snapRenderInfo.render = !0);\n  },\n  pinchStart: function(i) {\n    this.unset(i);\n  },\n  dragEnd: function(i) {\n    this.unset(i);\n  },\n  dragControlCondition: function(i, t) {\n    if (zF(i, t) || D_(i, t))\n      return !0;\n    if (!t.isRequest && t.inputEvent)\n      return sr(t.inputEvent.target, Pt(\"snap-control\"));\n  },\n  dragControlStart: function(i) {\n    i.state.snapRenderInfo = null, _p(i);\n  },\n  dragControl: function(i) {\n    this.drag(i);\n  },\n  dragControlEnd: function(i) {\n    this.unset(i);\n  },\n  dragGroupStart: function(i, t) {\n    this.dragStart(i, t);\n  },\n  dragGroup: function(i) {\n    this.drag(i);\n  },\n  dragGroupEnd: function(i) {\n    this.unset(i);\n  },\n  dragGroupControlStart: function(i) {\n    i.state.snapRenderInfo = null, _p(i);\n  },\n  dragGroupControl: function(i) {\n    this.drag(i);\n  },\n  dragGroupControlEnd: function(i) {\n    this.unset(i);\n  },\n  unset: function(i) {\n    var t = i.state;\n    t.enableSnap = !1, t.guidelines = [], t.snapRenderInfo = null, t.elementRects = [];\n  }\n};\nfunction OC(i, t, e, r) {\n  var n = i.getState(), s = n.renderPoses, a = n.rotation, o = n.direction, u = iu(i.props, t).zoom, l = o > 0 ? 1 : -1, h = a / Math.PI * 180, d = {}, f = i.renderState;\n  f.renderDirectionMap || (f.renderDirectionMap = {});\n  var p = f.renderDirectionMap;\n  return e.forEach(function(v) {\n    var g = v.dir;\n    d[g] = !0;\n  }), e.map(function(v) {\n    var g = v.data, m = v.classNames, y = v.dir, _ = bx[y];\n    if (!_ || !d[y])\n      return null;\n    p[y] = !0;\n    var b = (Gt(h, 15) + l * XT[y] + 720) % 180, w = {};\n    return Ps(g).forEach(function(T) {\n      w[\"data-\".concat(T)] = g[T];\n    }), r.createElement(\"div\", F({\n      className: Pt.apply(void 0, Tt([\"control\", \"direction\", y, t], m, !1)),\n      \"data-rotation\": b,\n      \"data-direction\": y\n    }, w, {\n      key: \"direction-\".concat(y),\n      style: Sx.apply(void 0, Tt([a, u], _.map(function(T) {\n        return s[T];\n      }), !1))\n    }));\n  });\n}\nfunction IC(i, t, e, r) {\n  var n = iu(i.props, e), s = n.renderDirections, a = s === void 0 ? t : s, o = n.displayAroundControls;\n  if (!a)\n    return [];\n  var u = a === !0 ? yx : a;\n  return Tt(Tt([], o ? NC(i, r, e, u) : [], !0), OC(i, e, u.map(function(l) {\n    return {\n      data: {},\n      classNames: [],\n      dir: l\n    };\n  }), r), !0);\n}\nfunction _c(i, t, e, r, n, s) {\n  for (var a = [], o = 6; o < arguments.length; o++)\n    a[o - 6] = arguments[o];\n  var u = $e(e, r), l = t ? Gt(u / Math.PI * 180, 15) % 180 : -1;\n  return i.createElement(\"div\", {\n    key: \"line-\".concat(s),\n    className: Pt.apply(void 0, Tt([\"line\", \"direction\", t ? \"edge\" : \"\", t], a, !1)),\n    \"data-rotation\": l,\n    \"data-line-key\": s,\n    \"data-direction\": t,\n    style: kh(e, r, n, u)\n  });\n}\nfunction RC(i, t, e, r, n) {\n  var s = e === !0 ? lB : e;\n  return s.map(function(a, o) {\n    var u = bx[a], l = u[0], h = u[1];\n    if (h != null)\n      return _c(i, a, r[l], r[h], n, \"\".concat(t, \"Edge\").concat(o), t);\n  }).filter(Boolean);\n}\nfunction DC(i) {\n  return function(t, e) {\n    var r = iu(t.props, i).edge;\n    return r && (r === !0 || r.length) ? Tt(Tt([], RC(e, i, r, t.getState().renderPoses, t.props.zoom), !0), $F(t, i, e), !0) : kC(t, i, e);\n  };\n}\nfunction kC(i, t, e) {\n  return IC(i, yx, t, e);\n}\nfunction $F(i, t, e) {\n  return IC(i, [\"nw\", \"ne\", \"sw\", \"se\"], t, e);\n}\nfunction NC(i, t, e, r) {\n  var n = i.renderState;\n  n.renderDirectionMap || (n.renderDirectionMap = {});\n  var s = i.getState(), a = s.renderPoses, o = s.rotation, u = s.direction, l = n.renderDirectionMap, h = i.props.zoom, d = u > 0 ? 1 : -1, f = o / Math.PI * 180;\n  return (r || Ps(l)).map(function(p) {\n    var v = bx[p];\n    if (!v)\n      return null;\n    var g = (Gt(f, 15) + d * XT[p] + 720) % 180, m = [\"around-control\"];\n    return e && m.push(\"direction\", e), t.createElement(\"div\", {\n      className: Pt.apply(void 0, m),\n      \"data-rotation\": g,\n      \"data-direction\": p,\n      key: \"direction-around-\".concat(p),\n      style: Sx.apply(void 0, Tt([o, h], v.map(function(y) {\n        return a[y];\n      }), !1))\n    });\n  });\n}\nvar Or = {\n  name: \"draggable\",\n  props: [\"draggable\", \"throttleDrag\", \"throttleDragRotate\", \"startDragRotate\", \"edgeDraggable\"],\n  events: [\"dragStart\", \"drag\", \"dragEnd\", \"dragGroupStart\", \"dragGroup\", \"dragGroupEnd\"],\n  requestStyle: function() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  requestChildStyle: function() {\n    return [\"left\", \"top\", \"right\", \"bottom\"];\n  },\n  render: function(i, t) {\n    var e = i.props, r = e.throttleDragRotate, n = e.zoom, s = i.getState(), a = s.dragInfo, o = s.beforeOrigin;\n    if (!r || !a)\n      return [];\n    var u = a.dist;\n    if (!u[0] && !u[1])\n      return [];\n    var l = Ln(u), h = $e(u, [0, 0]);\n    return [t.createElement(\"div\", {\n      className: Pt(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: \"\".concat(l, \"px\"),\n        transform: \"translate(\".concat(o[0], \"px, \").concat(o[1], \"px) rotate(\").concat(h, \"rad) scaleY(\").concat(n, \")\")\n      }\n    })];\n  },\n  dragStart: function(i, t) {\n    var e = t.datas, r = t.parentEvent, n = t.parentGesto, s = i.state, a = s.gestos, o = s.style;\n    if (a.draggable)\n      return !1;\n    a.draggable = n || i.targetGesto, e.datas = {}, e.left = parseFloat(o.left || \"\") || 0, e.top = parseFloat(o.top || \"\") || 0, e.bottom = parseFloat(o.bottom || \"\") || 0, e.right = parseFloat(o.right || \"\") || 0, e.startValue = [0, 0], ou(i, t), d0(t, \"translate\"), jF(i, e), e.prevDist = [0, 0], e.prevBeforeDist = [0, 0], e.isDrag = !1, e.deltaOffset = [0, 0];\n    var u = Ut(i, t, F({\n      set: function(h) {\n        e.startValue = h;\n      }\n    }, f0(t))), l = r || mt(i, \"onDragStart\", u);\n    return l !== !1 ? (e.isDrag = !0, i.state.dragInfo = {\n      startRect: i.getRect(),\n      dist: [0, 0]\n    }) : (a.draggable = null, e.isPinch = !1), e.isDrag ? u : !1;\n  },\n  drag: function(i, t) {\n    if (t) {\n      h0(t, \"translate\");\n      var e = t.datas, r = t.parentEvent, n = t.parentFlag, s = t.isPinch, a = t.isRequest, o = t.deltaOffset, u = t.distX, l = t.distY, h = e.isDrag, d = e.prevDist, f = e.prevBeforeDist, p = e.startValue;\n      if (h) {\n        o && (u += o[0], l += o[1]);\n        var v = i.props, g = v.parentMoveable, m = r ? 0 : v.throttleDrag || 0, y = r ? 0 : v.throttleDragRotate || 0, _ = 0, b = !1, w = !1, T = !1, x = !1;\n        if (!r && y > 0 && (u || l)) {\n          var S = v.startDragRotate || 0, C = Gt(S + $e([0, 0], [u, l]) * 180 / Math.PI, y) - S, M = l * Math.abs(Math.cos((C - 90) / 180 * Math.PI)), I = u * Math.abs(Math.cos(C / 180 * Math.PI)), R = Ln([I, M]);\n          _ = C * Math.PI / 180, u = R * Math.cos(_), l = R * Math.sin(_);\n        }\n        if (!s && !r && !n) {\n          var N = MF(i, u, l, y, a || o, e), A = N[0], U = N[1];\n          b = A.isSnap, w = A.isBound, T = U.isSnap, x = U.isBound;\n          var B = A.offset, G = U.offset;\n          u += B, l += G;\n        }\n        var $ = Jt(ZT({\n          datas: e,\n          distX: u,\n          distY: l\n        }), p), Z = Jt(EB({\n          datas: e,\n          distX: u,\n          distY: l\n        }), p);\n        lw(Z, Rr), lw($, Rr), y || (!b && !w && (Z[0] = Gt(Z[0], m), $[0] = Gt($[0], m)), !T && !x && (Z[1] = Gt(Z[1], m), $[1] = Gt($[1], m)));\n        var H = Mt($, p), z = Mt(Z, p), X = Mt(z, d), ct = Mt(H, f);\n        e.prevDist = z, e.prevBeforeDist = H, e.passDelta = X, e.passDist = z;\n        var it = e.left + H[0], lt = e.top + H[1], et = e.right - H[0], k = e.bottom - H[1], ft = c0(e, \"translate(\".concat(Z[0], \"px, \").concat(Z[1], \"px)\"), \"translate(\".concat(z[0], \"px, \").concat(z[1], \"px)\"));\n        if (xx(t, ft), i.state.dragInfo.dist = r ? [0, 0] : z, !(!r && !g && X.every(function(bt) {\n          return !bt;\n        }) && ct.some(function(bt) {\n          return !bt;\n        }))) {\n          var Q = i.state, St = Q.width, at = Q.height, q = Ut(i, t, F({\n            transform: ft,\n            dist: z,\n            delta: X,\n            translate: Z,\n            beforeDist: H,\n            beforeDelta: ct,\n            beforeTranslate: $,\n            left: it,\n            top: lt,\n            right: et,\n            bottom: k,\n            width: St,\n            height: at,\n            isPinch: s\n          }, Ir({\n            transform: ft\n          }, t)));\n          return !r && mt(i, \"onDrag\", q), q;\n        }\n      }\n    }\n  },\n  dragAfter: function(i, t) {\n    var e = t.datas, r = e.deltaOffset;\n    return r[0] || r[1] ? (e.deltaOffset = [0, 0], this.drag(i, F(F({}, t), {\n      deltaOffset: r\n    }))) : !1;\n  },\n  dragEnd: function(i, t) {\n    var e = t.parentEvent, r = t.datas;\n    if (i.state.dragInfo = null, !!r.isDrag) {\n      r.isDrag = !1;\n      var n = li(i, t, {});\n      return !e && mt(i, \"onDragEnd\", n), n;\n    }\n  },\n  dragGroupStart: function(i, t) {\n    var e = t.datas, r = t.clientX, n = t.clientY, s = this.dragStart(i, t);\n    if (!s)\n      return !1;\n    var a = uy(i, this, \"dragStart\", [r || 0, n || 0], t, !1, \"draggable\"), o = F(F({}, s), {\n      targets: i.props.targets,\n      events: a\n    }), u = mt(i, \"onDragGroupStart\", o);\n    return e.isDrag = u !== !1, e.isDrag ? s : !1;\n  },\n  dragGroup: function(i, t) {\n    var e = t.datas;\n    if (e.isDrag) {\n      var r = this.drag(i, t), n = t.datas.passDelta, s = uy(i, this, \"drag\", n, t, !1, \"draggable\");\n      if (r) {\n        var a = F({\n          targets: i.props.targets,\n          events: s\n        }, r);\n        return mt(i, \"onDragGroup\", a), a;\n      }\n    }\n  },\n  dragGroupEnd: function(i, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isDrag) {\n      this.dragEnd(i, t);\n      var n = uy(i, this, \"dragEnd\", [0, 0], t, !1, \"draggable\");\n      return mt(i, \"onDragGroupEnd\", li(i, t, {\n        targets: i.props.targets,\n        events: n\n      })), e;\n    }\n  },\n  /**\n   * @method Moveable.Draggable#request\n   * @param {object} [e] - the draggable's request parameter\n   * @param {number} [e.x] - x position\n   * @param {number} [e.y] - y position\n   * @param {number} [e.deltaX] - X number to move\n   * @param {number} [e.deltaY] - Y number to move\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"draggable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 });\n   * moveable.request(\"draggable\", { x: 220, y: 100 });\n   * moveable.request(\"draggable\", { x: 240, y: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(i) {\n    var t = {}, e = i.getRect(), r = 0, n = 0;\n    return {\n      isControl: !1,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(s) {\n        return \"x\" in s ? r = s.x - e.left : \"deltaX\" in s && (r += s.deltaX), \"y\" in s ? n = s.y - e.top : \"deltaY\" in s && (n += s.deltaY), {\n          datas: t,\n          distX: r,\n          distY: n\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(i) {\n    i.state.gestos.draggable = null, i.state.dragInfo = null;\n  }\n}, Fw = Px(\"resizable\"), R_ = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: [\"resizable\", \"throttleResize\", \"renderDirections\", \"displayAroundControls\", \"keepRatio\", \"resizeFormat\", \"keepRatioFinally\", \"edge\", \"checkResizableError\"],\n  events: [\"resizeStart\", \"beforeResize\", \"resize\", \"resizeEnd\", \"resizeGroupStart\", \"beforeResizeGroup\", \"resizeGroup\", \"resizeGroupEnd\"],\n  render: DC(\"resizable\"),\n  dragControlCondition: Fw,\n  viewClassName: Mx(\"resizable\"),\n  dragControlStart: function(i, t) {\n    var e, r = t.inputEvent, n = t.isPinch, s = t.isGroup, a = t.parentDirection, o = t.parentGesto, u = t.datas, l = t.parentFixedDirection, h = t.parentEvent, d = cC(a, n, r, u), f = i.state, p = f.target, v = f.width, g = f.height, m = f.gestos;\n    if (!d || !p || m.resizable)\n      return !1;\n    m.resizable = o || i.controlGesto, !n && ou(i, t), u.datas = {}, u.direction = d, u.startOffsetWidth = v, u.startOffsetHeight = g, u.prevWidth = 0, u.prevHeight = 0, u.minSize = [0, 0], u.startWidth = f.inlineCSSWidth || f.cssWidth, u.startHeight = f.inlineCSSHeight || f.cssHeight, u.maxSize = [1 / 0, 1 / 0], s || (u.minSize = [f.minOffsetWidth, f.minOffsetHeight], u.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);\n    var y = i.props.transformOrigin || \"% %\";\n    u.transformOrigin = y && Vr(y) ? y.split(\" \") : y, u.startOffsetMatrix = f.offsetMatrix, u.startTransformOrigin = f.transformOrigin, u.isWidth = (e = t == null ? void 0 : t.parentIsWidth) !== null && e !== void 0 ? e : !d[0] && !d[1] || d[0] || !d[1];\n    function _(M) {\n      u.ratio = M && isFinite(M) ? M : 0;\n    }\n    u.startPositions = Ci(i.state);\n    function b(M) {\n      u.fixedDirection = M, u.fixedPosition = ze(u.startPositions, M);\n    }\n    function w(M) {\n      var I = i.state, R = I.width, N = I.height;\n      u.fixedPosition = M, u.fixedDirection = eC(M, R, N);\n    }\n    function T(M) {\n      u.minSize = [Te(\"\".concat(M[0]), 0) || 0, Te(\"\".concat(M[1]), 0) || 0];\n    }\n    function x(M) {\n      var I = [M[0] || 1 / 0, M[1] || 1 / 0];\n      (!pc(I[0]) || isFinite(I[0])) && (I[0] = Te(\"\".concat(I[0]), 0) || 1 / 0), (!pc(I[1]) || isFinite(I[1])) && (I[1] = Te(\"\".concat(I[1]), 0) || 1 / 0), u.maxSize = I;\n    }\n    _(v / g), b(l || [-d[0], -d[1]]), u.setFixedDirection = b, u.setFixedPosition = w, u.setMin = T, u.setMax = x;\n    var S = Ut(i, t, {\n      direction: d,\n      startRatio: u.ratio,\n      set: function(M) {\n        var I = M[0], R = M[1];\n        u.startWidth = I, u.startHeight = R;\n      },\n      setMin: T,\n      setMax: x,\n      setRatio: _,\n      setFixedDirection: b,\n      setFixedPosition: w,\n      setOrigin: function(M) {\n        u.transformOrigin = M;\n      },\n      dragStart: Or.dragStart(i, new th().dragStart([0, 0], t))\n    }), C = h || mt(i, \"onResizeStart\", S);\n    return u.startFixedDirection = u.fixedDirection, u.startFixedPosition = u.fixedPosition, C !== !1 && (u.isResize = !0, i.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: d\n    }), u.isResize ? S : !1;\n  },\n  dragControl: function(i, t) {\n    var e, r = t.datas, n = t.parentFlag, s = t.isPinch, a = t.parentKeepRatio, o = t.dragClient, u = t.parentDist, l = t.isRequest, h = t.isGroup, d = t.parentEvent, f = t.resolveMatrix, p = r.isResize, v = r.transformOrigin, g = r.startWidth, m = r.startHeight, y = r.prevWidth, _ = r.prevHeight, b = r.minSize, w = r.maxSize, T = r.ratio, x = r.startOffsetWidth, S = r.startOffsetHeight, C = r.isWidth;\n    if (!p)\n      return;\n    if (f) {\n      var M = i.state.is3d, I = r.startOffsetMatrix, R = r.startTransformOrigin, N = M ? 4 : 3, A = gx(JT(t)), U = Math.sqrt(A.length);\n      N !== U && (A = An(A, U, N));\n      var B = Dd(I, A, R, N), G = da(B, x, S, N);\n      r.startPositions = G, r.nextTargetMatrix = A, r.nextAllMatrix = B;\n    }\n    var $ = iu(i.props, \"resizable\"), Z = $.resizeFormat, H = $.throttleResize, z = H === void 0 ? n ? 0 : 1 : H, X = $.parentMoveable, ct = $.keepRatioFinally, it = r.direction, lt = it, et = 0, k = 0;\n    !it[0] && !it[1] && (lt = [1, 1]);\n    var ft = T && (a ?? $.keepRatio) || !1;\n    function Q() {\n      var ee = r.fixedDirection, de = yC(lt, ft, r, t);\n      et = de.distWidth, k = de.distHeight;\n      var ue = lt[0] - ee[0] || ft ? Math.max(x + et, Rr) : x, se = lt[1] - ee[1] || ft ? Math.max(S + k, Rr) : S;\n      return ft && x && S && (C ? se = ue / T : ue = se * T), [ue, se];\n    }\n    var St = Q(), at = St[0], q = St[1];\n    d || (r.setFixedDirection(r.fixedDirection), mt(i, \"onBeforeResize\", Ut(i, t, {\n      startFixedDirection: r.startFixedDirection,\n      startFixedPosition: r.startFixedPosition,\n      setFixedDirection: function(ee) {\n        var de;\n        return r.setFixedDirection(ee), de = Q(), at = de[0], q = de[1], [at, q];\n      },\n      setFixedPosition: function(ee) {\n        var de;\n        return r.setFixedPosition(ee), de = Q(), at = de[0], q = de[1], [at, q];\n      },\n      boundingWidth: at,\n      boundingHeight: q,\n      setSize: function(ee) {\n        at = ee[0], q = ee[1];\n      }\n    }, !0)));\n    var bt = o;\n    o || (!n && s ? bt = kB(i, [0, 0]) : bt = r.fixedPosition);\n    var st = [0, 0];\n    s || (st = GF(i, at, q, it, bt, l, r)), u && (!u[0] && (st[0] = 0), !u[1] && (st[1] = 0));\n    function W() {\n      var ee;\n      Z && (ee = Z([at, q]), at = ee[0], q = ee[1]), at = Gt(at, z), q = Gt(q, z);\n    }\n    if (ft) {\n      lt[0] && lt[1] && st[0] && st[1] && (Math.abs(st[0]) > Math.abs(st[1]) ? st[1] = 0 : st[0] = 0);\n      var nt = !st[0] && !st[1];\n      nt && W(), lt[0] && !lt[1] || st[0] && !st[1] || nt && C ? (at += st[0], q = at / T) : (!lt[0] && lt[1] || !st[0] && st[1] || nt && !C) && (q += st[1], at = q * T);\n    } else\n      at += st[0], q += st[1], at = Math.max(0, at), q = Math.max(0, q);\n    e = jA([at, q], b, w, ft ? T : !1), at = e[0], q = e[1], W(), ft && (h || ct) && (C ? q = at / T : at = q * T), et = at - x, k = q - S;\n    var dt = [et - y, k - _];\n    r.prevWidth = et, r.prevHeight = k;\n    var V = DB(i, at, q, bt, v, r);\n    if (!(!X && dt.every(function(ee) {\n      return !ee;\n    }) && V.every(function(ee) {\n      return !ee;\n    }))) {\n      var xt = Or.drag(i, Rd(t, i.state, V, !!s, !1, \"draggable\")), Dt = xt.transform, Ct = g + et, be = m + k, je = Ut(i, t, F({\n        width: Ct,\n        height: be,\n        offsetWidth: Math.round(at),\n        offsetHeight: Math.round(q),\n        startRatio: T,\n        boundingWidth: at,\n        boundingHeight: q,\n        direction: it,\n        dist: [et, k],\n        delta: dt,\n        isPinch: !!s,\n        drag: xt\n      }, dC({\n        style: {\n          width: \"\".concat(Ct, \"px\"),\n          height: \"\".concat(be, \"px\")\n        },\n        transform: Dt\n      }, xt, t)));\n      return !d && mt(i, \"onResize\", je), je;\n    }\n  },\n  dragControlAfter: function(i, t) {\n    var e = t.datas, r = e.isResize, n = e.startOffsetWidth, s = e.startOffsetHeight, a = e.prevWidth, o = e.prevHeight;\n    if (!(!r || i.props.checkResizableError === !1)) {\n      var u = i.state, l = u.width, h = u.height, d = l - (n + a), f = h - (s + o), p = Math.abs(d) > 3, v = Math.abs(f) > 3;\n      if (p && (e.startWidth += d, e.startOffsetWidth += d, e.prevWidth += d), v && (e.startHeight += f, e.startOffsetHeight += f, e.prevHeight += f), p || v)\n        return this.dragControl(i, t);\n    }\n  },\n  dragControlEnd: function(i, t) {\n    var e = t.datas, r = t.parentEvent;\n    if (e.isResize) {\n      e.isResize = !1;\n      var n = li(i, t, {});\n      return !r && mt(i, \"onResizeEnd\", n), n;\n    }\n  },\n  dragGroupControlCondition: Fw,\n  dragGroupControlStart: function(i, t) {\n    var e = t.datas, r = this.dragControlStart(i, F(F({}, t), {\n      isGroup: !0\n    }));\n    if (!r)\n      return !1;\n    var n = Ji(i, \"resizable\", t), s = e.startOffsetWidth, a = e.startOffsetHeight;\n    function o() {\n      var p = e.minSize;\n      n.forEach(function(v) {\n        var g = v.datas, m = g.minSize, y = g.startOffsetWidth, _ = g.startOffsetHeight, b = s * (y ? m[0] / y : 0), w = a * (_ ? m[1] / _ : 0);\n        p[0] = Math.max(p[0], b), p[1] = Math.max(p[1], w);\n      });\n    }\n    function u() {\n      var p = e.maxSize;\n      n.forEach(function(v) {\n        var g = v.datas, m = g.maxSize, y = g.startOffsetWidth, _ = g.startOffsetHeight, b = s * (y ? m[0] / y : 0), w = a * (_ ? m[1] / _ : 0);\n        p[0] = Math.min(p[0], b), p[1] = Math.min(p[1], w);\n      });\n    }\n    var l = Ss(i, this, \"dragControlStart\", t, function(p, v) {\n      return Pv(i, p, e, v);\n    });\n    o(), u();\n    var h = function(p) {\n      r.setFixedDirection(p), l.forEach(function(v, g) {\n        v.setFixedDirection(p), Pv(i, v.moveable, e, n[g]);\n      });\n    };\n    e.setFixedDirection = h;\n    var d = F(F({}, r), {\n      targets: i.props.targets,\n      events: l.map(function(p) {\n        return F(F({}, p), {\n          setMin: function(v) {\n            p.setMin(v), o();\n          },\n          setMax: function(v) {\n            p.setMax(v), u();\n          }\n        });\n      }),\n      setFixedDirection: h,\n      setMin: function(p) {\n        r.setMin(p), o();\n      },\n      setMax: function(p) {\n        r.setMax(p), u();\n      }\n    }), f = mt(i, \"onResizeGroupStart\", d);\n    return e.isResize = f !== !1, e.isResize ? r : !1;\n  },\n  dragGroupControl: function(i, t) {\n    var e = t.datas;\n    if (e.isResize) {\n      var r = iu(i.props, \"resizable\");\n      v0(i, \"onBeforeResize\", function(p) {\n        mt(i, \"onBeforeResizeGroup\", Ut(i, t, F(F({}, p), {\n          targets: r.targets\n        }), !0));\n      });\n      var n = this.dragControl(i, F(F({}, t), {\n        isGroup: !0\n      }));\n      if (n) {\n        var s = n.boundingWidth, a = n.boundingHeight, o = n.dist, u = r.keepRatio, l = [s / (s - o[0]), a / (a - o[1])], h = e.fixedPosition, d = Ss(i, this, \"dragControl\", t, function(p, v) {\n          var g = br(Pd(i.rotation / 180 * Math.PI, 3), [v.datas.originalX * l[0], v.datas.originalY * l[1], 1], 3), m = g[0], y = g[1];\n          return F(F({}, v), {\n            parentDist: null,\n            parentScale: l,\n            dragClient: Jt(h, [m, y]),\n            parentKeepRatio: u\n          });\n        }), f = F({\n          targets: r.targets,\n          events: d\n        }, n);\n        return mt(i, \"onResizeGroup\", f), f;\n      }\n    }\n  },\n  dragGroupControlEnd: function(i, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isResize) {\n      this.dragControlEnd(i, t);\n      var n = Ss(i, this, \"dragControlEnd\", t), s = li(i, t, {\n        targets: i.props.targets,\n        events: n\n      });\n      return mt(i, \"onResizeGroupEnd\", s), e;\n    }\n  },\n  /**\n   * @method Moveable.Resizable#request\n   * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"resizable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(i) {\n    var t = {}, e = 0, r = 0, n = i.getRect();\n    return {\n      isControl: !0,\n      requestStart: function(s) {\n        var a;\n        return {\n          datas: t,\n          parentDirection: s.direction || [1, 1],\n          parentIsWidth: (a = s == null ? void 0 : s.horizontal) !== null && a !== void 0 ? a : !0\n        };\n      },\n      request: function(s) {\n        return \"offsetWidth\" in s ? e = s.offsetWidth - n.offsetWidth : \"deltaWidth\" in s && (e += s.deltaWidth), \"offsetHeight\" in s ? r = s.offsetHeight - n.offsetHeight : \"deltaHeight\" in s && (r += s.deltaHeight), {\n          datas: t,\n          parentDist: [e, r],\n          parentKeepRatio: s.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  },\n  unset: function(i) {\n    i.state.gestos.resizable = null;\n  }\n};\nfunction ly(i, t, e, r, n) {\n  var s = i.props.groupable, a = i.state, o = a.is3d ? 4 : 3, u = t.origin, l = nr(\n    i.state.rootMatrix,\n    // TO-DO #710\n    Mt([u[0], u[1]], s ? [0, 0] : [a.left, a.top]),\n    o\n  ), h = Jt([n.left, n.top], l);\n  t.startAbsoluteOrigin = h, t.prevDeg = $e(h, [e, r]) / Math.PI * 180, t.defaultDeg = t.prevDeg, t.prevSnapDeg = 0, t.loop = 0, t.startDist = Zi(h, [e, r]);\n}\nfunction Vp(i, t, e) {\n  var r = e.defaultDeg, n = e.prevDeg, s = n % 360, a = Math.floor(n / 360);\n  s < 0 && (s += 360), s > i && s > 270 && i < 90 ? ++a : s < i && s < 90 && i > 270 && --a;\n  var o = t * (a * 360 + i - r);\n  return e.prevDeg = r + o, o;\n}\nfunction hy(i, t, e, r) {\n  return Vp($e(r.startAbsoluteOrigin, [i, t]) / Math.PI * 180, e, r);\n}\nfunction cy(i, t, e, r, n, s) {\n  var a = i.props.throttleRotate, o = a === void 0 ? 0 : a, u = e.prevSnapDeg, l = 0, h = !1;\n  if (s) {\n    var d = FF(i, t, r);\n    h = d.isSnap, l = n + d.rotation;\n  }\n  h || (l = Gt(n + r, o));\n  var f = l - n;\n  return e.prevSnapDeg = f, [f - u, f, l];\n}\nfunction AC(i, t, e) {\n  var r = t[0], n = t[1], s = t[2], a = t[3];\n  if (i === \"none\")\n    return [];\n  if (tr(i))\n    return i.map(function(g) {\n      return AC(g, [r, n, s, a], e)[0];\n    });\n  var o = (i || \"top\").split(\"-\"), u = o[0], l = o[1], h = [r, n];\n  u === \"left\" ? h = [s, r] : u === \"right\" ? h = [n, a] : u === \"bottom\" && (h = [a, s]);\n  var d = [(h[0][0] + h[1][0]) / 2, (h[0][1] + h[1][1]) / 2], f = lC(h, e);\n  if (l) {\n    var p = l === \"top\" || l === \"left\", v = u === \"bottom\" || u === \"left\";\n    d = h[p && !v || !p && v ? 0 : 1];\n  }\n  return [[d, f]];\n}\nfunction D_(i, t) {\n  if (t.isRequest)\n    return t.requestAble === \"rotatable\";\n  var e = t.inputEvent.target;\n  if (sr(e, Pt(\"rotation-control\")) || i.props.rotateAroundControls && sr(e, Pt(\"around-control\")) || sr(e, Pt(\"control\")) && sr(e, Pt(\"rotatable\")))\n    return !0;\n  var r = i.props.rotationTarget;\n  return r ? Ox(r, !0).some(function(n) {\n    return n ? e === n || e.contains(n) : !1;\n  }) : !1;\n}\nvar VF = `.rotation {\nposition: absolute;\nheight: 40px;\nwidth: 1px;\ntransform-origin: 50% 100%;\nheight: calc(40px * var(--zoom));\ntop: auto;\nleft: 0;\nbottom: 100%;\nwill-change: transform;\n}\n.rotation .rotation-line {\ndisplay: block;\nwidth: 100%;\nheight: 100%;\ntransform-origin: 50% 50%;\n}\n.rotation .rotation-control {\nborder-color: #4af;\nborder-color: var(--moveable-color);\nbackground:#fff;\ncursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\ncursor: alias;\n}\n.rotatable.direction.control.move {\ncursor: move;\n}\n`, XF = {\n  name: \"rotatable\",\n  canPinch: !0,\n  props: [\"rotatable\", \"rotationPosition\", \"throttleRotate\", \"renderDirections\", \"rotationTarget\", \"rotateAroundControls\", \"edge\", \"resolveAblesWithRotatable\", \"displayAroundControls\"],\n  events: [\"rotateStart\", \"beforeRotate\", \"rotate\", \"rotateEnd\", \"rotateGroupStart\", \"beforeRotateGroup\", \"rotateGroup\", \"rotateGroupEnd\"],\n  css: [VF],\n  viewClassName: function(i) {\n    return i.isDragging(\"rotatable\") ? Pt(\"view-rotation-dragging\") : \"\";\n  },\n  render: function(i, t) {\n    var e = iu(i.props, \"rotatable\"), r = e.rotatable, n = e.rotationPosition, s = e.zoom, a = e.renderDirections, o = e.rotateAroundControls, u = e.resolveAblesWithRotatable, l = i.getState(), h = l.renderPoses, d = l.direction;\n    if (!r)\n      return null;\n    var f = AC(n, h, d), p = [];\n    if (f.forEach(function(y, _) {\n      var b = y[0], w = y[1];\n      p.push(t.createElement(\"div\", {\n        key: \"rotation\".concat(_),\n        className: Pt(\"rotation\"),\n        style: {\n          // tslint:disable-next-line: max-line-length\n          transform: \"translate(-50%) translate(\".concat(b[0], \"px, \").concat(b[1], \"px) rotate(\").concat(w, \"rad)\")\n        }\n      }, t.createElement(\"div\", {\n        className: Pt(\"line rotation-line\"),\n        style: {\n          transform: \"scaleX(\".concat(s, \")\")\n        }\n      }), t.createElement(\"div\", {\n        className: Pt(\"control rotation-control\"),\n        style: {\n          transform: \"translate(0.5px) scale(\".concat(s, \")\")\n        }\n      })));\n    }), a) {\n      var v = Ps(u || {}), g = {};\n      v.forEach(function(y) {\n        u[y].forEach(function(_) {\n          g[_] = y;\n        });\n      });\n      var m = [];\n      tr(a) && (m = a.map(function(y) {\n        var _ = g[y];\n        return {\n          data: _ ? {\n            resolve: _\n          } : {},\n          classNames: _ ? [\"move\"] : [],\n          dir: y\n        };\n      })), p.push.apply(p, OC(i, \"rotatable\", m, t));\n    }\n    return o && p.push.apply(p, NC(i, t)), p;\n  },\n  dragControlCondition: D_,\n  dragControlStart: function(i, t) {\n    var e, r, n = t.datas, s = t.clientX, a = t.clientY, o = t.parentRotate, u = t.parentFlag, l = t.isPinch, h = t.isRequest, d = i.state, f = d.target, p = d.left, v = d.top, g = d.direction, m = d.beforeDirection, y = d.targetTransform, _ = d.moveableClientRect, b = d.offsetMatrix, w = d.targetMatrix, T = d.allMatrix, x = d.width, S = d.height;\n    if (!h && !f)\n      return !1;\n    var C = i.getRect();\n    n.rect = C, n.transform = y, n.left = p, n.top = v;\n    var M = function(et) {\n      var k = i.state, ft = k.allMatrix, Q = k.is3d, St = k.width, at = k.height, q = eC(et, St, at);\n      n.fixedDirection = q, n.fixedPosition = nr(ft, et, Q ? 4 : 3), X && X.setFixedPosition(et);\n    }, I = function(et) {\n      n.fixedDirection = et, n.fixedPosition = rC(i, et), X && X.setFixedDirection(et);\n    }, R = s, N = a;\n    if (h || l || u) {\n      var A = o || 0;\n      n.beforeInfo = {\n        origin: C.beforeOrigin,\n        prevDeg: A,\n        defaultDeg: A,\n        prevSnapDeg: 0,\n        startDist: 0\n      }, n.afterInfo = F(F({}, n.beforeInfo), {\n        origin: C.origin\n      }), n.absoluteInfo = F(F({}, n.beforeInfo), {\n        origin: C.origin,\n        startValue: A\n      });\n    } else {\n      var U = (r = t.inputEvent) === null || r === void 0 ? void 0 : r.target;\n      if (U) {\n        var B = U.getAttribute(\"data-direction\") || \"\", G = xB[B];\n        if (G) {\n          n.isControl = !0, n.isAroundControl = sr(U, Pt(\"around-control\")), n.controlDirection = G;\n          var $ = U.getAttribute(\"data-resolve\");\n          $ && (n.resolveAble = $);\n          var Z = YB(d.rootMatrix, d.renderPoses, _);\n          e = ze(Z, G), R = e[0], N = e[1];\n        }\n      }\n      n.beforeInfo = {\n        origin: C.beforeOrigin\n      }, n.afterInfo = {\n        origin: C.origin\n      }, n.absoluteInfo = {\n        origin: C.origin,\n        startValue: C.rotation\n      };\n      var H = M;\n      M = function(et) {\n        var k = d.is3d ? 4 : 3, ft = Jt(NT(w, k), et), Q = ft[0], St = ft[1], at = br(b, eu([Q, St], k)), q = br(T, eu([et[0], et[1]], k));\n        H(et);\n        var bt = d.posDelta;\n        n.beforeInfo.origin = Mt(at, bt), n.afterInfo.origin = Mt(q, bt), n.absoluteInfo.origin = Mt(q, bt), ly(i, n.beforeInfo, R, N, _), ly(i, n.afterInfo, R, N, _), ly(i, n.absoluteInfo, R, N, _);\n      }, I = function(et) {\n        var k = ze([[0, 0], [x, 0], [0, S], [x, S]], et);\n        M(k);\n      };\n    }\n    n.startClientX = R, n.startClientY = N, n.direction = g, n.beforeDirection = m, n.startValue = 0, n.datas = {}, d0(t, \"rotate\");\n    var z = !1, X = !1;\n    if (n.isControl && n.resolveAble) {\n      var ct = n.resolveAble;\n      ct === \"resizable\" && (X = R_.dragControlStart(i, F(F({}, new th(\"resizable\").dragStart([0, 0], t)), {\n        parentPosition: n.controlPosition,\n        parentFixedPosition: n.fixedPosition\n      })));\n    }\n    X || (z = Or.dragStart(i, new th().dragStart([0, 0], t))), M(d.transformOrigin);\n    var it = Ut(i, t, F(F({\n      set: function(et) {\n        n.startValue = et * Math.PI / 180;\n      },\n      setFixedDirection: I,\n      setFixedPosition: M\n    }, f0(t)), {\n      dragStart: z,\n      resizeStart: X\n    })), lt = mt(i, \"onRotateStart\", it);\n    return n.isRotate = lt !== !1, d.snapRenderInfo = {\n      request: t.isRequest\n    }, n.isRotate ? it : !1;\n  },\n  dragControl: function(i, t) {\n    var e, r, n, s = t.datas, a = t.clientDistX, o = t.clientDistY, u = t.parentRotate, l = t.parentFlag, h = t.isPinch, d = t.groupDelta, f = t.resolveMatrix, p = s.beforeDirection, v = s.beforeInfo, g = s.afterInfo, m = s.absoluteInfo, y = s.isRotate, _ = s.startValue, b = s.rect, w = s.startClientX, T = s.startClientY;\n    if (y) {\n      h0(t, \"rotate\");\n      var x = wB(t), S = p * x, C = i.props.parentMoveable, M = 0, I, R, N = 0, A, U, B = 0, G, $, Z = 180 / Math.PI * _, H = m.startValue, z = !1, X = w + a, ct = T + o;\n      if (!l && \"parentDist\" in t) {\n        var it = t.parentDist;\n        I = it, A = it, G = it;\n      } else\n        h || l ? (I = Vp(u, p, v), A = Vp(u, S, g), G = Vp(u, S, m)) : (I = hy(X, ct, p, v), A = hy(X, ct, S, g), G = hy(X, ct, S, m), z = !0);\n      if (R = Z + I, U = Z + A, $ = H + G, mt(i, \"onBeforeRotate\", Ut(i, t, {\n        beforeRotation: R,\n        rotation: U,\n        absoluteRotation: $,\n        setRotation: function(st) {\n          A = st - Z, I = A, G = A;\n        }\n      }, !0)), e = cy(i, b, v, I, Z, z), M = e[0], I = e[1], R = e[2], r = cy(i, b, g, A, Z, z), N = r[0], A = r[1], U = r[2], n = cy(i, b, m, G, H, z), B = n[0], G = n[1], $ = n[2], !(!B && !N && !M && !C && !f)) {\n        var lt = c0(s, \"rotate(\".concat(U, \"deg)\"), \"rotate(\".concat(A, \"deg)\"));\n        f && (s.fixedPosition = wx(i, s.targetAllTransform, [0, 0], s));\n        var et = RB(i, A, s), k = Mt(Jt(d || [0, 0], et), s.prevInverseDist || [0, 0]);\n        s.prevInverseDist = et, s.requestValue = null;\n        var ft = QT(i, lt, k, h, t), Q = ft, St = Zi([X, ct], m.startAbsoluteOrigin) - m.startDist, at = void 0;\n        if (s.resolveAble === \"resizable\") {\n          var q = R_.dragControl(i, F(F({}, Rd(t, i.state, [t.deltaX, t.deltaY], !!h, !1, \"resizable\")), {\n            resolveMatrix: !0,\n            parentDistance: St\n          }));\n          q && (at = q, Q = dC(Q, q, t));\n        }\n        var bt = Ut(i, t, F(F({\n          delta: N,\n          dist: A,\n          rotate: U,\n          rotation: U,\n          beforeDist: I,\n          beforeDelta: M,\n          beforeRotate: R,\n          beforeRotation: R,\n          absoluteDist: G,\n          absoluteDelta: B,\n          absoluteRotate: $,\n          absoluteRotation: $,\n          isPinch: !!h,\n          resize: at\n        }, ft), Q));\n        return mt(i, \"onRotate\", bt), bt;\n      }\n    }\n  },\n  dragControlEnd: function(i, t) {\n    var e = t.datas;\n    if (e.isRotate) {\n      e.isRotate = !1;\n      var r = li(i, t, {});\n      return mt(i, \"onRotateEnd\", r), r;\n    }\n  },\n  dragGroupControlCondition: D_,\n  dragGroupControlStart: function(i, t) {\n    var e = t.datas, r = i.state, n = r.left, s = r.top, a = r.beforeOrigin, o = this.dragControlStart(i, t);\n    if (!o)\n      return !1;\n    o.set(e.beforeDirection * i.rotation);\n    var u = Ss(i, this, \"dragControlStart\", t, function(d, f) {\n      var p = d.state, v = p.left, g = p.top, m = p.beforeOrigin, y = Jt(Mt([v, g], [n, s]), Mt(m, a));\n      return f.datas.startGroupClient = y, f.datas.groupClient = y, F(F({}, f), {\n        parentRotate: 0\n      });\n    }), l = F(F({}, o), {\n      targets: i.props.targets,\n      events: u\n    }), h = mt(i, \"onRotateGroupStart\", l);\n    return e.isRotate = h !== !1, e.isRotate ? o : !1;\n  },\n  dragGroupControl: function(i, t) {\n    var e = t.datas;\n    if (e.isRotate) {\n      v0(i, \"onBeforeRotate\", function(l) {\n        mt(i, \"onBeforeRotateGroup\", Ut(i, t, F(F({}, l), {\n          targets: i.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(i, t);\n      if (r) {\n        var n = e.beforeDirection, s = r.beforeDist, a = s / 180 * Math.PI, o = Ss(i, this, \"dragControl\", t, function(l, h) {\n          var d = h.datas.startGroupClient, f = h.datas.groupClient, p = f[0], v = f[1], g = Md(d, a * n), m = g[0], y = g[1], _ = [m - p, y - v];\n          return h.datas.groupClient = [m, y], F(F({}, h), {\n            parentRotate: s,\n            groupDelta: _\n          });\n        });\n        i.rotation = n * r.beforeRotation;\n        var u = F({\n          targets: i.props.targets,\n          events: o,\n          set: function(l) {\n            i.rotation = l;\n          },\n          setGroupRotation: function(l) {\n            i.rotation = l;\n          }\n        }, r);\n        return mt(i, \"onRotateGroup\", u), u;\n      }\n    }\n  },\n  dragGroupControlEnd: function(i, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isRotate) {\n      this.dragControlEnd(i, t);\n      var n = Ss(i, this, \"dragControlEnd\", t), s = li(i, t, {\n        targets: i.props.targets,\n        events: n\n      });\n      return mt(i, \"onRotateGroupEnd\", s), e;\n    }\n  },\n  /**\n   * @method Moveable.Rotatable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.deltaRotate=0] -  delta number of rotation\n   * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n   *\n   * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"rotatable\");\n   *\n   * // request\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   *\n   * requester.request({ rotate: 10 });\n   * requester.request({ rotate: 20 });\n   * requester.request({ rotate: 30 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function(i) {\n    var t = {}, e = 0, r = i.getRotation();\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(n) {\n        return \"deltaRotate\" in n ? e += n.deltaRotate : \"rotate\" in n && (e = n.rotate - r), {\n          datas: t,\n          parentDist: e\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n}, Gw = Px(\"scalable\"), WF = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: !0,\n  props: [\"scalable\", \"throttleScale\", \"renderDirections\", \"keepRatio\", \"edge\", \"displayAroundControls\"],\n  events: [\"scaleStart\", \"beforeScale\", \"scale\", \"scaleEnd\", \"scaleGroupStart\", \"beforeScaleGroup\", \"scaleGroup\", \"scaleGroupEnd\"],\n  render: DC(\"scalable\"),\n  dragControlCondition: Gw,\n  viewClassName: Mx(\"scalable\"),\n  dragControlStart: function(i, t) {\n    var e = t.datas, r = t.isPinch, n = t.inputEvent, s = t.parentDirection, a = cC(s, r, n, e), o = i.state, u = o.width, l = o.height, h = o.targetTransform, d = o.target, f = o.pos1, p = o.pos2, v = o.pos4;\n    if (!a || !d)\n      return !1;\n    r || ou(i, t), e.datas = {}, e.transform = h, e.prevDist = [1, 1], e.direction = a, e.startOffsetWidth = u, e.startOffsetHeight = l, e.startValue = [1, 1];\n    var g = Zi(f, p), m = Zi(p, v), y = !a[0] && !a[1] || a[0] || !a[1];\n    e.scaleWidth = g, e.scaleHeight = m, e.scaleXRatio = g / u, e.scaleYRatio = m / l, d0(t, \"scale\"), e.isWidth = y;\n    function _(x) {\n      e.ratio = x && isFinite(x) ? x : 0;\n    }\n    e.startPositions = Ci(i.state);\n    function b(x) {\n      e.fixedDirection = x, e.fixedPosition = ze(e.startPositions, x);\n    }\n    e.setFixedDirection = b, _(Zi(f, p) / Zi(p, v)), b([-a[0], -a[1]]);\n    var w = Ut(i, t, F(F({\n      direction: a,\n      set: function(x) {\n        e.startValue = x;\n      },\n      setRatio: _,\n      setFixedDirection: b\n    }, f0(t)), {\n      dragStart: Or.dragStart(i, new th().dragStart([0, 0], t))\n    })), T = mt(i, \"onScaleStart\", w);\n    return e.startFixedDirection = e.fixedDirection, T !== !1 && (e.isScale = !0, i.state.snapRenderInfo = {\n      request: t.isRequest,\n      direction: a\n    }), e.isScale ? w : !1;\n  },\n  dragControl: function(i, t) {\n    h0(t, \"scale\");\n    var e = t.datas, r = t.parentKeepRatio, n = t.parentFlag, s = t.isPinch, a = t.dragClient, o = t.isRequest, u = t.resolveMatrix, l = e.prevDist, h = e.direction, d = e.startOffsetWidth, f = e.startOffsetHeight, p = e.isScale, v = e.startValue, g = e.isWidth, m = e.ratio;\n    if (!p)\n      return !1;\n    var y = i.props, _ = y.throttleScale, b = y.parentMoveable, w = h;\n    !h[0] && !h[1] && (w = [1, 1]);\n    var T = m && (r ?? y.keepRatio) || !1, x = i.state;\n    function S() {\n      var it = yC(w, T, e, t), lt = it.distWidth, et = it.distHeight, k = d ? (d + lt) / d : 1, ft = f ? (f + et) / f : 1;\n      return k = w[0] || T ? k * v[0] : v[0], ft = w[1] || T ? ft * v[1] : v[1], k === 0 && (k = (l[0] > 0 ? 1 : -1) * dp), ft === 0 && (ft = (l[1] > 0 ? 1 : -1) * dp), [k, ft];\n    }\n    var C = S();\n    if (!s && i.props.groupable) {\n      var M = x.snapRenderInfo || {}, I = M.direction;\n      tr(I) && (I[0] || I[1]) && (x.snapRenderInfo = {\n        direction: h,\n        request: t.isRequest\n      });\n    }\n    mt(i, \"onBeforeScale\", Ut(i, t, {\n      scale: C,\n      setFixedDirection: function(it) {\n        return e.setFixedDirection(it), C = S(), C;\n      },\n      startFixedDirection: e.startFixedDirection,\n      setScale: function(it) {\n        C = it;\n      }\n    }, !0));\n    var R = [C[0] / v[0], C[1] / v[1]], N = a, A = [0, 0], U = !a && !n && s;\n    if (U || u ? N = wx(i, e.targetAllTransform, [0, 0], e) : a || (N = e.fixedPosition), s || (A = UF(i, R, h, o, e)), T) {\n      w[0] && w[1] && A[0] && A[1] && (Math.abs(A[0] * d) > Math.abs(A[1] * f) ? A[1] = 0 : A[0] = 0);\n      var B = !A[0] && !A[1];\n      if (B && (g ? R[0] = Gt(R[0] * v[0], _) / v[0] : R[1] = Gt(R[1] * v[1], _) / v[1]), w[0] && !w[1] || A[0] && !A[1] || B && g) {\n        R[0] += A[0];\n        var G = d * R[0] * v[0] / m;\n        R[1] = G / f / v[1];\n      } else if (!w[0] && w[1] || !A[0] && A[1] || B && !g) {\n        R[1] += A[1];\n        var $ = f * R[1] * v[1] * m;\n        R[0] = $ / d / v[0];\n      }\n    } else\n      R[0] += A[0], R[1] += A[1], A[0] || (R[0] = Gt(R[0] * v[0], _) / v[0]), A[1] || (R[1] = Gt(R[1] * v[1], _) / v[1]);\n    R[0] === 0 && (R[0] = (l[0] > 0 ? 1 : -1) * dp), R[1] === 0 && (R[1] = (l[1] > 0 ? 1 : -1) * dp);\n    var Z = [R[0] / l[0], R[1] / l[1]];\n    C = FB(R, v);\n    var H = IB(i, R, e.fixedDirection, N, e), z = U ? H : Mt(H, e.prevInverseDist || [0, 0]);\n    if (e.prevDist = R, e.prevInverseDist = H, C[0] === l[0] && C[1] === l[1] && z.every(function(it) {\n      return !it;\n    }) && !b && !U)\n      return !1;\n    var X = c0(e, \"scale(\".concat(C.join(\", \"), \")\"), \"scale(\".concat(R.join(\", \"), \")\")), ct = Ut(i, t, F({\n      offsetWidth: d,\n      offsetHeight: f,\n      direction: h,\n      scale: C,\n      dist: R,\n      delta: Z,\n      isPinch: !!s\n    }, QT(i, X, z, s, t)));\n    return mt(i, \"onScale\", ct), ct;\n  },\n  dragControlEnd: function(i, t) {\n    var e = t.datas;\n    if (!e.isScale)\n      return !1;\n    e.isScale = !1;\n    var r = li(i, t, {});\n    return mt(i, \"onScaleEnd\", r), r;\n  },\n  dragGroupControlCondition: Gw,\n  dragGroupControlStart: function(i, t) {\n    var e = t.datas, r = this.dragControlStart(i, t);\n    if (!r)\n      return !1;\n    var n = Ji(i, \"resizable\", t);\n    e.moveableScale = i.scale;\n    var s = Ss(i, this, \"dragControlStart\", t, function(l, h) {\n      return Pv(i, l, e, h);\n    }), a = function(l) {\n      r.setFixedDirection(l), s.forEach(function(h, d) {\n        h.setFixedDirection(l), Pv(i, h.moveable, e, n[d]);\n      });\n    };\n    e.setFixedDirection = a;\n    var o = F(F({}, r), {\n      targets: i.props.targets,\n      events: s,\n      setFixedDirection: a\n    }), u = mt(i, \"onScaleGroupStart\", o);\n    return e.isScale = u !== !1, e.isScale ? o : !1;\n  },\n  dragGroupControl: function(i, t) {\n    var e = t.datas;\n    if (e.isScale) {\n      v0(i, \"onBeforeScale\", function(d) {\n        mt(i, \"onBeforeScaleGroup\", Ut(i, t, F(F({}, d), {\n          targets: i.props.targets\n        }), !0));\n      });\n      var r = this.dragControl(i, t);\n      if (r) {\n        var n = e.moveableScale;\n        i.scale = [r.scale[0] * n[0], r.scale[1] * n[1]];\n        var s = i.props.keepRatio, a = r.dist, o = r.scale, u = e.fixedPosition, l = Ss(i, this, \"dragControl\", t, function(d, f) {\n          var p = br(Pd(i.rotation / 180 * Math.PI, 3), [f.datas.originalX * a[0], f.datas.originalY * a[1], 1], 3), v = p[0], g = p[1];\n          return F(F({}, f), {\n            parentDist: null,\n            parentScale: o,\n            parentKeepRatio: s,\n            dragClient: Jt(u, [v, g])\n          });\n        }), h = F({\n          targets: i.props.targets,\n          events: l\n        }, r);\n        return mt(i, \"onScaleGroup\", h), h;\n      }\n    }\n  },\n  dragGroupControlEnd: function(i, t) {\n    var e = t.isDrag, r = t.datas;\n    if (r.isScale) {\n      this.dragControlEnd(i, t);\n      var n = Ss(i, this, \"dragControlEnd\", t), s = li(i, t, {\n        targets: i.props.targets,\n        events: n\n      });\n      return mt(i, \"onScaleGroupEnd\", s), e;\n    }\n  },\n  /**\n   * @method Moveable.Scalable#request\n   * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"scalable\");\n   *\n   * // request\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function() {\n    var i = {}, t = 0, e = 0;\n    return {\n      isControl: !0,\n      requestStart: function(r) {\n        return {\n          datas: i,\n          parentDirection: r.direction || [1, 1]\n        };\n      },\n      request: function(r) {\n        return t += r.deltaWidth, e += r.deltaHeight, {\n          datas: i,\n          parentDist: [t, e],\n          parentKeepRatio: r.keepRatio\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: i,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction Rs(i, t) {\n  return i.map(function(e, r) {\n    return Pa(e, t[r], 1, 2);\n  });\n}\nfunction Uw(i, t, e) {\n  var r = $e(i, t), n = $e(i, e), s = n - r;\n  return s >= 0 ? s : s + 2 * Math.PI;\n}\nfunction YF(i, t) {\n  var e = Uw(i[0], i[1], i[2]), r = Uw(t[0], t[1], t[2]), n = Math.PI;\n  return !(e >= n && r <= n || e <= n && r >= n);\n}\nvar qF = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: [\"warpable\", \"renderDirections\", \"edge\", \"displayAroundControls\"],\n  events: [\"warpStart\", \"warp\", \"warpEnd\"],\n  viewClassName: Mx(\"warpable\"),\n  render: function(i, t) {\n    var e = i.props, r = e.resizable, n = e.scalable, s = e.warpable, a = e.zoom;\n    if (r || n || !s)\n      return [];\n    var o = i.state, u = o.pos1, l = o.pos2, h = o.pos3, d = o.pos4, f = Rs(u, l), p = Rs(l, u), v = Rs(u, h), g = Rs(h, u), m = Rs(h, d), y = Rs(d, h), _ = Rs(l, d), b = Rs(d, l);\n    return Tt([t.createElement(\"div\", {\n      className: Pt(\"line\"),\n      key: \"middeLine1\",\n      style: kh(f, m, a)\n    }), t.createElement(\"div\", {\n      className: Pt(\"line\"),\n      key: \"middeLine2\",\n      style: kh(p, y, a)\n    }), t.createElement(\"div\", {\n      className: Pt(\"line\"),\n      key: \"middeLine3\",\n      style: kh(v, _, a)\n    }), t.createElement(\"div\", {\n      className: Pt(\"line\"),\n      key: \"middeLine4\",\n      style: kh(g, b, a)\n    })], kC(i, \"warpable\", t), !0);\n  },\n  dragControlCondition: function(i, t) {\n    if (t.isRequest)\n      return !1;\n    var e = t.inputEvent.target;\n    return sr(e, Pt(\"direction\")) && sr(e, Pt(\"warpable\"));\n  },\n  dragControlStart: function(i, t) {\n    var e = t.datas, r = t.inputEvent, n = i.props.target, s = r.target, a = fC(s, e);\n    if (!a || !n)\n      return !1;\n    var o = i.state, u = o.transformOrigin, l = o.is3d, h = o.targetTransform, d = o.targetMatrix, f = o.width, p = o.height, v = o.left, g = o.top;\n    e.datas = {}, e.targetTransform = h, e.warpTargetMatrix = l ? d : An(d, 3, 4), e.targetInverseMatrix = kT(Nn(e.warpTargetMatrix, 4), 3, 4), e.direction = a, e.left = v, e.top = g, e.poses = [[0, 0], [f, 0], [0, p], [f, p]].map(function(_) {\n      return Mt(_, u);\n    }), e.nextPoses = e.poses.map(function(_) {\n      var b = _[0], w = _[1];\n      return br(e.warpTargetMatrix, [b, w, 0, 1], 4);\n    }), e.startValue = Oe(4), e.prevMatrix = Oe(4), e.absolutePoses = Ci(o), e.posIndexes = KT(a), ou(i, t), d0(t, \"matrix3d\"), o.snapRenderInfo = {\n      request: t.isRequest,\n      direction: a\n    };\n    var m = Ut(i, t, F({\n      set: function(_) {\n        e.startValue = _;\n      }\n    }, f0(t))), y = mt(i, \"onWarpStart\", m);\n    return y !== !1 && (e.isWarp = !0), e.isWarp;\n  },\n  dragControl: function(i, t) {\n    var e = t.datas, r = t.isRequest, n = t.distX, s = t.distY, a = e.targetInverseMatrix, o = e.prevMatrix, u = e.isWarp, l = e.startValue, h = e.poses, d = e.posIndexes, f = e.absolutePoses;\n    if (!u)\n      return !1;\n    if (h0(t, \"matrix3d\"), ph(i, \"warpable\")) {\n      var p = d.map(function(M) {\n        return f[M];\n      });\n      p.length > 1 && p.push([(p[0][0] + p[1][0]) / 2, (p[0][1] + p[1][1]) / 2]);\n      var v = y0(i, r, {\n        horizontal: p.map(function(M) {\n          return M[1] + s;\n        }),\n        vertical: p.map(function(M) {\n          return M[0] + n;\n        })\n      }), g = v.horizontal, m = v.vertical;\n      s -= g.offset, n -= m.offset;\n    }\n    var y = Un({\n      datas: e,\n      distX: n,\n      distY: s\n    }, !0), _ = e.nextPoses.slice();\n    if (d.forEach(function(M) {\n      _[M] = Jt(_[M], y);\n    }), !bB.every(function(M) {\n      return YF(M.map(function(I) {\n        return h[I];\n      }), M.map(function(I) {\n        return _[I];\n      }));\n    }))\n      return !1;\n    var b = vx(h[0], h[2], h[1], h[3], _[0], _[2], _[1], _[3]);\n    if (!b.length)\n      return !1;\n    var w = _e(a, b, 4), T = qT(e, w, !0), x = _e(Nn(o, 4), T, 4);\n    e.prevMatrix = T;\n    var S = _e(l, T, 4), C = c0(e, \"matrix3d(\".concat(S.join(\", \"), \")\"), \"matrix3d(\".concat(T.join(\", \"), \")\"));\n    return xx(t, C), mt(i, \"onWarp\", Ut(i, t, F({\n      delta: x,\n      matrix: S,\n      dist: T,\n      multiply: _e,\n      transform: C\n    }, Ir({\n      transform: C\n    }, t)))), !0;\n  },\n  dragControlEnd: function(i, t) {\n    var e = t.datas, r = t.isDrag;\n    return e.isWarp ? (e.isWarp = !1, mt(i, \"onWarpEnd\", li(i, t, {})), r) : !1;\n  }\n}, ZF = /* @__PURE__ */ Pt(\"area-pieces\"), bp = /* @__PURE__ */ Pt(\"area-piece\"), LC = /* @__PURE__ */ Pt(\"avoid\"), KF = Pt(\"view-dragging\");\nfunction fy(i) {\n  var t = i.areaElement;\n  if (t) {\n    var e = i.state, r = e.width, n = e.height;\n    dT(t, LC), t.style.cssText += \"left: 0px; top: 0px; width: \".concat(r, \"px; height: \").concat(n, \"px\");\n  }\n}\nfunction jw(i) {\n  return i.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: ZF\n  }, i.createElement(\"div\", {\n    className: bp\n  }), i.createElement(\"div\", {\n    className: bp\n  }), i.createElement(\"div\", {\n    className: bp\n  }), i.createElement(\"div\", {\n    className: bp\n  }));\n}\nvar BC = {\n  name: \"dragArea\",\n  props: [\"dragArea\", \"passDragArea\"],\n  events: [\"click\", \"clickGroup\"],\n  render: function(i, t) {\n    var e = i.props, r = e.target, n = e.dragArea, s = e.groupable, a = e.passDragArea, o = i.getState(), u = o.width, l = o.height, h = o.renderPoses, d = a ? Pt(\"area\", \"pass\") : Pt(\"area\");\n    if (s)\n      return [t.createElement(\"div\", {\n        key: \"area\",\n        ref: Es(i, \"areaElement\"),\n        className: d\n      }), jw(t)];\n    if (!r || !n)\n      return [];\n    var f = vx([0, 0], [u, 0], [0, l], [u, l], h[0], h[1], h[2], h[3]), p = f.length ? p0(f, !0) : \"none\";\n    return [t.createElement(\"div\", {\n      key: \"area\",\n      ref: Es(i, \"areaElement\"),\n      className: d,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: \"\".concat(u, \"px\"),\n        height: \"\".concat(l, \"px\"),\n        transformOrigin: \"0 0\",\n        transform: p\n      }\n    }), jw(t)];\n  },\n  dragStart: function(i, t) {\n    var e = t.datas, r = t.clientX, n = t.clientY, s = t.inputEvent;\n    if (!s)\n      return !1;\n    e.isDragArea = !1;\n    var a = i.areaElement, o = i.state, u = o.moveableClientRect, l = o.renderPoses, h = o.rootMatrix, d = o.is3d, f = u.left, p = u.top, v = Ti(l), g = v.left, m = v.top, y = v.width, _ = v.height, b = d ? 4 : 3, w = ih(h, [r - f, n - p], b), T = w[0], x = w[1];\n    T -= g, x -= m;\n    var S = [{\n      left: g,\n      top: m,\n      width: y,\n      height: x - 10\n    }, {\n      left: g,\n      top: m,\n      width: T - 10,\n      height: _\n    }, {\n      left: g,\n      top: m + x + 10,\n      width: y,\n      height: _ - x - 10\n    }, {\n      left: g + T + 10,\n      top: m,\n      width: y - T - 10,\n      height: _\n    }], C = [].slice.call(a.nextElementSibling.children);\n    S.forEach(function(M, I) {\n      C[I].style.cssText = \"left: \".concat(M.left, \"px;top: \").concat(M.top, \"px; width: \").concat(M.width, \"px; height: \").concat(M.height, \"px;\");\n    }), fT(a, LC), o.disableNativeEvent = !0;\n  },\n  drag: function(i, t) {\n    var e = t.datas, r = t.inputEvent;\n    if (this.enableNativeEvent(i), !r)\n      return !1;\n    e.isDragArea || (e.isDragArea = !0, fy(i));\n  },\n  dragEnd: function(i, t) {\n    this.enableNativeEvent(i);\n    var e = t.inputEvent, r = t.datas;\n    if (!e)\n      return !1;\n    r.isDragArea || fy(i);\n  },\n  dragGroupStart: function(i, t) {\n    return this.dragStart(i, t);\n  },\n  dragGroup: function(i, t) {\n    return this.drag(i, t);\n  },\n  dragGroupEnd: function(i, t) {\n    return this.dragEnd(i, t);\n  },\n  unset: function(i) {\n    fy(i), i.state.disableNativeEvent = !1;\n  },\n  enableNativeEvent: function(i) {\n    var t = i.state;\n    t.disableNativeEvent && hT(function() {\n      t.disableNativeEvent = !1;\n    });\n  }\n}, JF = Id(\"origin\", {\n  render: function(i, t) {\n    var e = i.props.zoom, r = i.getState(), n = r.beforeOrigin, s = r.rotation;\n    return [t.createElement(\"div\", {\n      className: Pt(\"control\", \"origin\"),\n      style: Sx(s, e, n),\n      key: \"beforeOrigin\"\n    })];\n  }\n});\nfunction QF(i) {\n  var t = i.scrollContainer;\n  return [t.scrollLeft, t.scrollTop];\n}\nvar t3 = {\n  name: \"scrollable\",\n  canPinch: !0,\n  props: [\"scrollable\", \"scrollContainer\", \"scrollThreshold\", \"scrollThrottleTime\", \"getScrollPosition\", \"scrollOptions\"],\n  events: [\"scroll\", \"scrollGroup\"],\n  dragRelation: \"strong\",\n  dragStart: function(i, t) {\n    var e = i.props, r = e.scrollContainer, n = r === void 0 ? i.getContainer() : r, s = e.scrollOptions, a = new UL(), o = nu(n, !0);\n    t.datas.dragScroll = a, i.state.dragScroll = a;\n    var u = t.isControl ? \"controlGesto\" : \"targetGesto\", l = t.targets;\n    a.on(\"scroll\", function(h) {\n      var d = h.container, f = h.direction, p = Ut(i, t, {\n        scrollContainer: d,\n        direction: f\n      }), v = l ? \"onScrollGroup\" : \"onScroll\";\n      l && (p.targets = l), mt(i, v, p);\n    }).on(\"move\", function(h) {\n      var d = h.offsetX, f = h.offsetY, p = h.inputEvent;\n      i[u].scrollBy(d, f, p.inputEvent, !0);\n    }).on(\"scrollDrag\", function(h) {\n      var d = h.next;\n      d(i[u].getCurrentEvent());\n    }), a.dragStart(t, F({\n      container: o\n    }, s));\n  },\n  checkScroll: function(i, t) {\n    var e = t.datas.dragScroll;\n    if (e) {\n      var r = i.props, n = r.scrollContainer, s = n === void 0 ? i.getContainer() : n, a = r.scrollThreshold, o = a === void 0 ? 0 : a, u = r.scrollThrottleTime, l = u === void 0 ? 0 : u, h = r.getScrollPosition, d = h === void 0 ? QF : h, f = r.scrollOptions;\n      return e.drag(t, F({\n        container: s,\n        threshold: o,\n        throttleTime: l,\n        getScrollPosition: function(p) {\n          return d({\n            scrollContainer: p.container,\n            direction: p.direction\n          });\n        }\n      }, f)), !0;\n    }\n  },\n  drag: function(i, t) {\n    return this.checkScroll(i, t);\n  },\n  dragEnd: function(i, t) {\n    t.datas.dragScroll.dragEnd(), t.datas.dragScroll = null;\n  },\n  dragControlStart: function(i, t) {\n    return this.dragStart(i, F(F({}, t), {\n      isControl: !0\n    }));\n  },\n  dragControl: function(i, t) {\n    return this.drag(i, t);\n  },\n  dragControlEnd: function(i, t) {\n    return this.dragEnd(i, t);\n  },\n  dragGroupStart: function(i, t) {\n    return this.dragStart(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  dragGroup: function(i, t) {\n    return this.drag(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  dragGroupEnd: function(i, t) {\n    return this.dragEnd(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  dragGroupControlStart: function(i, t) {\n    return this.dragStart(i, F(F({}, t), {\n      targets: i.props.targets,\n      isControl: !0\n    }));\n  },\n  dragGroupControl: function(i, t) {\n    return this.drag(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  dragGroupControEnd: function(i, t) {\n    return this.dragEnd(i, F(F({}, t), {\n      targets: i.props.targets\n    }));\n  },\n  unset: function(i) {\n    var t, e = i.state;\n    (t = e.dragScroll) === null || t === void 0 || t.dragEnd(), e.dragScroll = null;\n  }\n}, FC = {\n  name: \"\",\n  props: [\"target\", \"dragTarget\", \"container\", \"warpSelf\", \"rootContainer\", \"useResizeObserver\", \"useMutationObserver\", \"zoom\", \"transformOrigin\", \"edge\", \"ables\", \"className\", \"pinchThreshold\", \"pinchOutside\", \"triggerAblesSimultaneously\", \"checkInput\", \"cspNonce\", \"translateZ\", \"hideDefaultLines\", \"props\", \"flushSync\", \"stopPropagation\", \"preventClickEventOnDrag\", \"preventClickDefault\", \"viewContainer\", \"persistData\", \"useAccuratePosition\", \"firstRenderState\", \"linePadding\", \"displayAroundControls\", \"controlPadding\", \"preventDefault\", \"requestStyles\"],\n  events: [\"changeTargets\"]\n}, e3 = Id(\"padding\", {\n  render: function(i, t) {\n    var e = i.props;\n    if (e.dragArea)\n      return [];\n    var r = e.padding || {}, n = r.left, s = n === void 0 ? 0 : n, a = r.top, o = a === void 0 ? 0 : a, u = r.right, l = u === void 0 ? 0 : u, h = r.bottom, d = h === void 0 ? 0 : h, f = i.getState(), p = f.renderPoses, v = f.pos1, g = f.pos2, m = f.pos3, y = f.pos4, _ = [v, g, m, y], b = [];\n    return s > 0 && b.push([0, 2]), o > 0 && b.push([0, 1]), l > 0 && b.push([1, 3]), d > 0 && b.push([2, 3]), b.map(function(w, T) {\n      var x = w[0], S = w[1], C = _[x], M = _[S], I = p[x], R = p[S], N = vx([0, 0], [100, 0], [0, 100], [100, 100], C, M, I, R);\n      if (N.length)\n        return t.createElement(\"div\", {\n          key: \"padding\".concat(T),\n          className: Pt(\"padding\"),\n          style: {\n            transform: p0(N, !0)\n          }\n        });\n    });\n  }\n}), zw = [\"nw\", \"ne\", \"se\", \"sw\"];\nfunction xp(i, t) {\n  var e = i[0] + i[1], r = e > t ? t / e : 1;\n  return i[0] *= r, i[1] = t - i[1] * r, i;\n}\nvar r3 = [1, 2, 5, 6], i3 = [0, 3, 4, 7], Aa = [1, -1, -1, 1], La = [1, 1, -1, -1];\nfunction Lx(i, t, e, r, n, s, a, o) {\n  n === void 0 && (n = 0), s === void 0 && (s = 0), a === void 0 && (a = e), o === void 0 && (o = r);\n  var u = [], l = !1, h = i.filter(function(f) {\n    return !f.virtual;\n  }), d = h.map(function(f) {\n    var p = f.horizontal, v = f.vertical, g = f.pos;\n    if (v && !l && (l = !0, u.push(\"/\")), l) {\n      var m = Math.max(0, v === 1 ? g[1] - s : o - g[1]);\n      return u.push(Vi(m, r, t)), m;\n    } else {\n      var m = Math.max(0, p === 1 ? g[0] - n : a - g[0]);\n      return u.push(Vi(m, e, t)), m;\n    }\n  });\n  return {\n    radiusPoses: h,\n    styles: u,\n    raws: d\n  };\n}\nfunction GC(i) {\n  for (var t = [0, 0], e = [0, 0], r = i.length, n = 0; n < r; ++n) {\n    var s = i[n];\n    s.sub && (s.horizontal && (t[1] === 0 && (t[0] = n), t[1] = n - t[0] + 1, e[0] = n + 1), s.vertical && (e[1] === 0 && (e[0] = n), e[1] = n - e[0] + 1));\n  }\n  return {\n    horizontalRange: t,\n    verticalRange: e\n  };\n}\nfunction UC(i, t, e, r, n, s, a) {\n  var o, u, l, h;\n  s === void 0 && (s = [0, 0]), a === void 0 && (a = !1);\n  var d = i.indexOf(\"/\"), f = (d > -1 ? i.slice(0, d) : i).length, p = i.slice(0, f), v = i.slice(f + 1), g = p.length, m = v.length, y = m > 0, _ = p[0], b = _ === void 0 ? \"0px\" : _, w = p[1], T = w === void 0 ? b : w, x = p[2], S = x === void 0 ? b : x, C = p[3], M = C === void 0 ? T : C, I = v[0], R = I === void 0 ? b : I, N = v[1], A = N === void 0 ? y ? R : T : N, U = v[2], B = U === void 0 ? y ? R : S : U, G = v[3], $ = G === void 0 ? y ? A : M : G, Z = [b, T, S, M].map(function(lt) {\n    return Te(lt, t);\n  }), H = [R, A, B, $].map(function(lt) {\n    return Te(lt, e);\n  }), z = Z.slice(), X = H.slice();\n  o = xp([z[0], z[1]], t), z[0] = o[0], z[1] = o[1], u = xp([z[3], z[2]], t), z[3] = u[0], z[2] = u[1], l = xp([X[0], X[3]], e), X[0] = l[0], X[3] = l[1], h = xp([X[1], X[2]], e), X[1] = h[0], X[2] = h[1];\n  var ct = a ? z : z.slice(0, Math.max(s[0], g)), it = a ? X : X.slice(0, Math.max(s[1], m));\n  return Tt(Tt([], ct.map(function(lt, et) {\n    var k = zw[et];\n    return {\n      virtual: et >= g,\n      horizontal: Aa[et],\n      vertical: 0,\n      pos: [r + lt, n + (La[et] === -1 ? e : 0)],\n      sub: !0,\n      raw: Z[et],\n      direction: k\n    };\n  }), !0), it.map(function(lt, et) {\n    var k = zw[et];\n    return {\n      virtual: et >= m,\n      horizontal: 0,\n      vertical: La[et],\n      pos: [r + (Aa[et] === -1 ? t : 0), n + lt],\n      sub: !0,\n      raw: H[et],\n      direction: k\n    };\n  }), !0);\n}\nfunction n3(i, t, e, r, n) {\n  n === void 0 && (n = t.length);\n  var s = GC(i.slice(r)), a = s.horizontalRange, o = s.verticalRange, u = e - r, l = 0;\n  if (u === 0)\n    l = n;\n  else if (u > 0 && u < a[1])\n    l = a[1] - u;\n  else if (u >= o[0])\n    l = o[0] + o[1] - u;\n  else\n    return;\n  i.splice(e, l), t.splice(e, l);\n}\nfunction s3(i, t, e, r, n, s, a, o, u, l, h) {\n  l === void 0 && (l = 0), h === void 0 && (h = 0);\n  var d = GC(i.slice(e)), f = d.horizontalRange, p = d.verticalRange;\n  if (r > -1)\n    for (var v = Aa[r] === 1 ? s - l : o - s, g = f[1]; g <= r; ++g) {\n      var m = La[g] === 1 ? h : u, y = 0;\n      if (r === g ? y = s : g === 0 ? y = l + v : Aa[g] === -1 && (y = o - (t[e][0] - l)), i.splice(e + g, 0, {\n        horizontal: Aa[g],\n        vertical: 0,\n        pos: [y, m]\n      }), t.splice(e + g, 0, [y, m]), g === 0)\n        break;\n    }\n  else if (n > -1) {\n    var _ = La[n] === 1 ? a - h : u - a;\n    if (f[1] === 0 && p[1] === 0) {\n      var b = [l + _, h];\n      i.push({\n        horizontal: Aa[0],\n        vertical: 0,\n        pos: b\n      }), t.push(b);\n    }\n    for (var w = p[0], g = p[1]; g <= n; ++g) {\n      var y = Aa[g] === 1 ? l : o, m = 0;\n      if (n === g ? m = a : g === 0 ? m = h + _ : La[g] === 1 ? m = t[e + w][1] : La[g] === -1 && (m = u - (t[e + w][1] - h)), i.push({\n        horizontal: 0,\n        vertical: La[g],\n        pos: [y, m]\n      }), t.push([y, m]), g === 0)\n        break;\n    }\n  }\n}\nfunction a3(i, t) {\n  t === void 0 && (t = i.map(function(n) {\n    return n.raw;\n  }));\n  var e = i.map(function(n, s) {\n    return n.horizontal ? t[s] : null;\n  }).filter(function(n) {\n    return n != null;\n  }), r = i.map(function(n, s) {\n    return n.vertical ? t[s] : null;\n  }).filter(function(n) {\n    return n != null;\n  });\n  return {\n    horizontals: e,\n    verticals: r\n  };\n}\nvar o3 = [[0, -1, \"n\"], [1, 0, \"e\"]], u3 = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]];\nfunction Bx(i, t, e) {\n  var r = i.props.clipRelative, n = i.state, s = n.width, a = n.height, o = t, u = o.type, l = o.poses, h = u === \"rect\", d = u === \"circle\";\n  if (u === \"polygon\")\n    return e.map(function(x) {\n      return \"\".concat(Vi(x[0], s, r), \" \").concat(Vi(x[1], a, r));\n    });\n  if (h || u === \"inset\") {\n    var f = e[1][1], p = e[3][0], v = e[7][0], g = e[5][1];\n    if (h)\n      return [f, p, g, v].map(function(x) {\n        return \"\".concat(x, \"px\");\n      });\n    var m = [f, s - p, a - g, v].map(function(x, S) {\n      return Vi(x, S % 2 ? s : a, r);\n    });\n    if (e.length > 8) {\n      var y = Mt(e[4], e[0]), _ = y[0], b = y[1];\n      m.push.apply(m, Tt([\"round\"], Lx(l.slice(8).map(function(x, S) {\n        return F(F({}, x), {\n          pos: e[S]\n        });\n      }), r, _, b, v, f, p, g).styles, !1));\n    }\n    return m;\n  } else if (d || u === \"ellipse\") {\n    var w = e[0], T = Vi(Math.abs(e[1][1] - w[1]), d ? Math.sqrt((s * s + a * a) / 2) : a, r), m = d ? [T] : [Vi(Math.abs(e[2][0] - w[0]), s, r), T];\n    return m.push(\"at\", Vi(w[0], s, r), Vi(w[1], a, r)), m;\n  }\n}\nfunction Rv(i, t, e, r) {\n  var n = [r, (r + t) / 2, t], s = [i, (i + e) / 2, e];\n  return u3.map(function(a) {\n    var o = a[0], u = a[1], l = a[2], h = n[o + 1], d = s[u + 1];\n    return {\n      vertical: Math.abs(u),\n      horizontal: Math.abs(o),\n      direction: l,\n      pos: [h, d]\n    };\n  });\n}\nfunction jC(i) {\n  var t = [1 / 0, -1 / 0], e = [1 / 0, -1 / 0];\n  return i.forEach(function(r) {\n    var n = r.pos;\n    t[0] = Math.min(t[0], n[0]), t[1] = Math.max(t[1], n[0]), e[0] = Math.min(e[0], n[1]), e[1] = Math.max(e[1], n[1]);\n  }), [Math.abs(t[1] - t[0]), Math.abs(e[1] - e[0])];\n}\nfunction Hw(i, t, e, r, n) {\n  var s, a, o, u, l, h, d;\n  if (i) {\n    var f = n;\n    if (!f) {\n      var p = ui(i), v = p(\"clipPath\");\n      f = v !== \"none\" ? v : p(\"clip\");\n    }\n    if (!((!f || f === \"none\" || f === \"auto\") && (f = r, !f))) {\n      var g = lT(f), m = g.prefix, y = m === void 0 ? f : m, _ = g.value, b = _ === void 0 ? \"\" : _, w = y === \"circle\", T = \" \";\n      if (y === \"polygon\") {\n        var x = Ga(b || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n        T = \",\";\n        var S = x.map(function(xt) {\n          var Dt = xt.split(\" \"), Ct = Dt[0], be = Dt[1];\n          return {\n            vertical: 1,\n            horizontal: 1,\n            pos: [Te(Ct, t), Te(be, e)]\n          };\n        }), C = ru(S.map(function(xt) {\n          return xt.pos;\n        }));\n        return {\n          type: y,\n          clipText: f,\n          poses: S,\n          splitter: T,\n          left: C.minX,\n          right: C.maxX,\n          top: C.minY,\n          bottom: C.maxY\n        };\n      } else if (w || y === \"ellipse\") {\n        var M = \"\", I = \"\", R = 0, N = 0, x = fa(b);\n        if (w) {\n          var A = \"\";\n          s = x[0], A = s === void 0 ? \"50%\" : s, a = x[2], M = a === void 0 ? \"50%\" : a, o = x[3], I = o === void 0 ? \"50%\" : o, R = Te(A, Math.sqrt((t * t + e * e) / 2)), N = R;\n        } else {\n          var U = \"\", B = \"\";\n          u = x[0], U = u === void 0 ? \"50%\" : u, l = x[1], B = l === void 0 ? \"50%\" : l, h = x[3], M = h === void 0 ? \"50%\" : h, d = x[4], I = d === void 0 ? \"50%\" : d, R = Te(U, t), N = Te(B, e);\n        }\n        var G = [Te(M, t), Te(I, e)], S = Tt([{\n          vertical: 1,\n          horizontal: 1,\n          pos: G,\n          direction: \"nesw\"\n        }], o3.slice(0, w ? 1 : 2).map(function(Ct) {\n          return {\n            vertical: Math.abs(Ct[1]),\n            horizontal: Ct[0],\n            direction: Ct[2],\n            sub: !0,\n            pos: [G[0] + Ct[0] * R, G[1] + Ct[1] * N]\n          };\n        }), !0);\n        return {\n          type: y,\n          clipText: f,\n          radiusX: R,\n          radiusY: N,\n          left: G[0] - R,\n          top: G[1] - N,\n          right: G[0] + R,\n          bottom: G[1] + N,\n          poses: S,\n          splitter: T\n        };\n      } else if (y === \"inset\") {\n        var x = fa(b || \"0 0 0 0\"), $ = x.indexOf(\"round\"), Z = ($ > -1 ? x.slice(0, $) : x).length, H = x.slice(Z + 1), z = x.slice(0, Z), X = z[0], ct = z[1], it = ct === void 0 ? X : ct, lt = z[2], et = lt === void 0 ? X : lt, k = z[3], ft = k === void 0 ? it : k, Q = [X, et].map(function(Ct) {\n          return Te(Ct, e);\n        }), St = Q[0], at = Q[1], q = [ft, it].map(function(Ct) {\n          return Te(Ct, t);\n        }), bt = q[0], st = q[1], W = t - st, nt = e - at, dt = UC(H, W - bt, nt - St, bt, St), S = Tt(Tt([], Rv(St, W, nt, bt), !0), dt, !0);\n        return {\n          type: \"inset\",\n          clipText: f,\n          poses: S,\n          top: St,\n          left: bt,\n          right: W,\n          bottom: nt,\n          radius: H,\n          splitter: T\n        };\n      } else if (y === \"rect\") {\n        var x = Ga(b || \"0px, \".concat(t, \"px, \").concat(e, \"px, 0px\"));\n        T = \",\";\n        var V = x.map(function(de) {\n          var ue = Ed(de).value;\n          return ue;\n        }), St = V[0], st = V[1], at = V[2], bt = V[3], S = Rv(St, st, at, bt);\n        return {\n          type: \"rect\",\n          clipText: f,\n          poses: S,\n          top: St,\n          right: st,\n          bottom: at,\n          left: bt,\n          values: x,\n          splitter: T\n        };\n      }\n    }\n  }\n}\nfunction l3(i, t, e, r, n) {\n  var s = i[t], a = s.direction, o = s.sub, u = i.map(function() {\n    return [0, 0];\n  }), l = a ? a.split(\"\") : [];\n  if (r && t < 8) {\n    var h = l.filter(function(A) {\n      return A === \"w\" || A === \"e\";\n    }), d = l.filter(function(A) {\n      return A === \"n\" || A === \"s\";\n    }), f = h[0], p = d[0];\n    u[t] = e;\n    var v = jC(i), g = v[0], m = v[1], y = g && m ? g / m : 0;\n    if (y && n) {\n      var _ = (t + 4) % 8, b = i[_].pos, w = [0, 0];\n      a.indexOf(\"w\") > -1 ? w[0] = -1 : a.indexOf(\"e\") > -1 && (w[0] = 1), a.indexOf(\"n\") > -1 ? w[1] = -1 : a.indexOf(\"s\") > -1 && (w[1] = 1);\n      var T = mC([g, m], e, y, w, !0), x = g + T[0], S = m + T[1], C = b[1], M = b[1], I = b[0], R = b[0];\n      w[0] === -1 ? I = R - x : w[0] === 1 ? R = I + x : (I = I - x / 2, R = R + x / 2), w[1] === -1 ? C = M - S : (w[1] === 1 || (C = M - S / 2), M = C + S);\n      var N = Rv(C, R, M, I);\n      i.forEach(function(A, U) {\n        u[U][0] = N[U].pos[0] - A.pos[0], u[U][1] = N[U].pos[1] - A.pos[1];\n      });\n    } else\n      i.forEach(function(A, U) {\n        var B = A.direction;\n        B && (B.indexOf(f) > -1 && (u[U][0] = e[0]), B.indexOf(p) > -1 && (u[U][1] = e[1]));\n      }), f && (u[1][0] = e[0] / 2, u[5][0] = e[0] / 2), p && (u[3][1] = e[1] / 2, u[7][1] = e[1] / 2);\n  } else\n    a && !o ? l.forEach(function(A) {\n      var U = A === \"n\" || A === \"s\";\n      i.forEach(function(B, G) {\n        var $ = B.direction, Z = B.horizontal, H = B.vertical;\n        !$ || $.indexOf(A) === -1 || (u[G] = [U || !Z ? 0 : e[0], !U || !H ? 0 : e[1]]);\n      });\n    }) : u[t] = e;\n  return u;\n}\nfunction h3(i, t) {\n  var e = YT(i, t), r = e[0], n = e[1], s = t.datas, a = s.clipPath, o = s.clipIndex, u = a, l = u.type, h = u.poses, d = u.splitter, f = h.map(function(_) {\n    return _.pos;\n  });\n  if (l === \"polygon\")\n    f.splice(o, 0, [r, n]);\n  else if (l === \"inset\") {\n    var p = r3.indexOf(o), v = i3.indexOf(o), g = h.length;\n    if (s3(h, f, 8, p, v, r, n, f[4][0], f[4][1], f[0][0], f[0][1]), g === h.length)\n      return;\n  } else\n    return;\n  var m = Bx(i, a, f), y = \"\".concat(l, \"(\").concat(m.join(d), \")\");\n  mt(i, \"onClip\", Ut(i, t, F({\n    clipEventType: \"added\",\n    clipType: l,\n    poses: f,\n    clipStyles: m,\n    clipStyle: y,\n    distX: 0,\n    distY: 0\n  }, Ir({\n    clipPath: y\n  }, t))));\n}\nfunction c3(i, t) {\n  var e = t.datas, r = e.clipPath, n = e.clipIndex, s = r, a = s.type, o = s.poses, u = s.splitter, l = o.map(function(p) {\n    return p.pos;\n  }), h = l.length;\n  if (a === \"polygon\")\n    o.splice(n, 1), l.splice(n, 1);\n  else if (a === \"inset\") {\n    if (n < 8 || (n3(o, l, n, 8, h), h === o.length))\n      return;\n  } else\n    return;\n  var d = Bx(i, r, l), f = \"\".concat(a, \"(\").concat(d.join(u), \")\");\n  mt(i, \"onClip\", Ut(i, t, F({\n    clipEventType: \"removed\",\n    clipType: a,\n    poses: l,\n    clipStyles: d,\n    clipStyle: f,\n    distX: 0,\n    distY: 0\n  }, Ir({\n    clipPath: f\n  }, t))));\n}\nvar f3 = {\n  name: \"clippable\",\n  props: [\"clippable\", \"defaultClipPath\", \"customClipPath\", \"keepRatio\", \"clipRelative\", \"clipArea\", \"dragWithClip\", \"clipTargetBounds\", \"clipVerticalGuidelines\", \"clipHorizontalGuidelines\", \"clipSnapThreshold\"],\n  events: [\"clipStart\", \"clip\", \"clipEnd\"],\n  css: [`.control.clip-control {\nbackground: #6d6;\ncursor: pointer;\n}\n.control.clip-control.clip-radius {\nbackground: #d66;\n}\n.line.clip-line {\nbackground: #6e6;\ncursor: move;\nz-index: 1;\n}\n.clip-area {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.clip-ellipse {\nposition: absolute;\ncursor: move;\nborder: 1px solid #6d6;\nborder: var(--zoompx) solid #6d6;\nborder-radius: 50%;\ntransform-origin: 0px 0px;\n}`, `:host {\n--bounds-color: #d66;\n}`, `.guideline {\npointer-events: none;\nz-index: 2;\n}`, `.line.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}`],\n  render: function(i, t) {\n    var e = i.props, r = e.customClipPath, n = e.defaultClipPath, s = e.clipArea, a = e.zoom, o = e.groupable, u = i.getState(), l = u.target, h = u.width, d = u.height, f = u.allMatrix, p = u.is3d, v = u.left, g = u.top, m = u.pos1, y = u.pos2, _ = u.pos3, b = u.pos4, w = u.clipPathState, T = u.snapBoundInfos, x = u.rotation;\n    if (!l || o)\n      return [];\n    var S = Hw(l, h, d, n || \"inset\", w || r);\n    if (!S)\n      return [];\n    var C = p ? 4 : 3, M = S.type, I = S.poses, R = I.map(function(nt) {\n      var dt = nr(f, nt.pos, C);\n      return [dt[0] - v, dt[1] - g];\n    }), N = [], A = [], U = M === \"rect\", B = M === \"inset\", G = M === \"polygon\";\n    if (U || B || G) {\n      var $ = B ? R.slice(0, 8) : R;\n      A = $.map(function(nt, dt) {\n        var V = dt === 0 ? $[$.length - 1] : $[dt - 1], xt = $e(V, nt), Dt = oC(V, nt);\n        return t.createElement(\"div\", {\n          key: \"clipLine\".concat(dt),\n          className: Pt(\"line\", \"clip-line\", \"snap-control\"),\n          \"data-clip-index\": dt,\n          style: {\n            width: \"\".concat(Dt, \"px\"),\n            transform: \"translate(\".concat(V[0], \"px, \").concat(V[1], \"px) rotate(\").concat(xt, \"rad) scaleY(\").concat(a, \")\")\n          }\n        });\n      });\n    }\n    if (N = R.map(function(nt, dt) {\n      return t.createElement(\"div\", {\n        key: \"clipControl\".concat(dt),\n        className: Pt(\"control\", \"clip-control\", \"snap-control\"),\n        \"data-clip-index\": dt,\n        style: {\n          transform: \"translate(\".concat(nt[0], \"px, \").concat(nt[1], \"px) rotate(\").concat(x, \"rad) scale(\").concat(a, \")\")\n        }\n      });\n    }), B && N.push.apply(N, R.slice(8).map(function(nt, dt) {\n      return t.createElement(\"div\", {\n        key: \"clipRadiusControl\".concat(dt),\n        className: Pt(\"control\", \"clip-control\", \"clip-radius\", \"snap-control\"),\n        \"data-clip-index\": 8 + dt,\n        style: {\n          transform: \"translate(\".concat(nt[0], \"px, \").concat(nt[1], \"px) rotate(\").concat(x, \"rad) scale(\").concat(a, \")\")\n        }\n      });\n    })), M === \"circle\" || M === \"ellipse\") {\n      var Z = S.left, H = S.top, z = S.radiusX, X = S.radiusY, ct = Mt(nr(f, [Z, H], C), nr(f, [0, 0], C)), it = ct[0], lt = ct[1], et = \"none\";\n      if (!s) {\n        for (var k = Math.max(10, z / 5, X / 5), ft = [], Q = 0; Q <= k; ++Q) {\n          var St = Math.PI * 2 / k * Q;\n          ft.push([z + (z - a) * Math.cos(St), X + (X - a) * Math.sin(St)]);\n        }\n        ft.push([z, -2]), ft.push([-2, -2]), ft.push([-2, X * 2 + 2]), ft.push([z * 2 + 2, X * 2 + 2]), ft.push([z * 2 + 2, -2]), ft.push([z, -2]), et = \"polygon(\".concat(ft.map(function(nt) {\n          return \"\".concat(nt[0], \"px \").concat(nt[1], \"px\");\n        }).join(\", \"), \")\");\n      }\n      N.push(t.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: Pt(\"clip-ellipse\", \"snap-control\"),\n        style: {\n          width: \"\".concat(z * 2, \"px\"),\n          height: \"\".concat(X * 2, \"px\"),\n          clipPath: et,\n          transform: \"translate(\".concat(-v + it, \"px, \").concat(-g + lt, \"px) \").concat(p0(f))\n        }\n      }));\n    }\n    if (s) {\n      var at = Ti(Tt([m, y, _, b], R, !0)), q = at.width, bt = at.height, st = at.left, W = at.top;\n      if (G || U || B) {\n        var ft = B ? R.slice(0, 8) : R;\n        N.push(t.createElement(\"div\", {\n          key: \"clipArea\",\n          className: Pt(\"clip-area\", \"snap-control\"),\n          style: {\n            width: \"\".concat(q, \"px\"),\n            height: \"\".concat(bt, \"px\"),\n            transform: \"translate(\".concat(st, \"px, \").concat(W, \"px)\"),\n            clipPath: \"polygon(\".concat(ft.map(function(dt) {\n              return \"\".concat(dt[0] - st, \"px \").concat(dt[1] - W, \"px\");\n            }).join(\", \"), \")\")\n          }\n        }));\n      }\n    }\n    return T && [\"vertical\", \"horizontal\"].forEach(function(nt) {\n      var dt = T[nt], V = nt === \"horizontal\";\n      dt.isSnap && A.push.apply(A, dt.snap.posInfos.map(function(xt, Dt) {\n        var Ct = xt.pos, be = Mt(nr(f, V ? [0, Ct] : [Ct, 0], C), [v, g]), je = Mt(nr(f, V ? [h, Ct] : [Ct, d], C), [v, g]);\n        return _c(t, \"\", be, je, a, \"clip\".concat(nt, \"snap\").concat(Dt), \"guideline\");\n      })), dt.isBound && A.push.apply(A, dt.bounds.map(function(xt, Dt) {\n        var Ct = xt.pos, be = Mt(nr(f, V ? [0, Ct] : [Ct, 0], C), [v, g]), je = Mt(nr(f, V ? [h, Ct] : [Ct, d], C), [v, g]);\n        return _c(t, \"\", be, je, a, \"clip\".concat(nt, \"bounds\").concat(Dt), \"guideline\", \"bounds\", \"bold\");\n      }));\n    }), Tt(Tt([], N, !0), A, !0);\n  },\n  dragControlCondition: function(i, t) {\n    return t.inputEvent && (t.inputEvent.target.getAttribute(\"class\") || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function(i, t) {\n    var e = i.props, r = e.dragWithClip, n = r === void 0 ? !0 : r;\n    return n ? !1 : this.dragControlStart(i, t);\n  },\n  drag: function(i, t) {\n    return this.dragControl(i, F(F({}, t), {\n      isDragTarget: !0\n    }));\n  },\n  dragEnd: function(i, t) {\n    return this.dragControlEnd(i, t);\n  },\n  dragControlStart: function(i, t) {\n    var e = i.state, r = i.props, n = r.defaultClipPath, s = r.customClipPath, a = e.target, o = e.width, u = e.height, l = t.inputEvent ? t.inputEvent.target : null, h = l && l.getAttribute(\"class\") || \"\", d = t.datas, f = Hw(a, o, u, n || \"inset\", s);\n    if (!f)\n      return !1;\n    var p = f.clipText, v = f.type, g = f.poses, m = mt(i, \"onClipStart\", Ut(i, t, {\n      clipType: v,\n      clipStyle: p,\n      poses: g.map(function(y) {\n        return y.pos;\n      })\n    }));\n    return m === !1 ? (d.isClipStart = !1, !1) : (d.isControl = h && h.indexOf(\"clip-control\") > -1, d.isLine = h.indexOf(\"clip-line\") > -1, d.isArea = h.indexOf(\"clip-area\") > -1 || h.indexOf(\"clip-ellipse\") > -1, d.clipIndex = l ? parseInt(l.getAttribute(\"data-clip-index\"), 10) : -1, d.clipPath = f, d.isClipStart = !0, e.clipPathState = p, ou(i, t), !0);\n  },\n  dragControl: function(i, t) {\n    var e, r, n = t.datas, s = t.originalDatas, a = t.isDragTarget;\n    if (!n.isClipStart)\n      return !1;\n    var o = n, u = o.isControl, l = o.isLine, h = o.isArea, d = o.clipIndex, f = o.clipPath;\n    if (!f)\n      return !1;\n    var p = iu(i.props, \"clippable\"), v = p.keepRatio, g = 0, m = 0, y = s.draggable, _ = Un(t);\n    a && y ? (e = y.prevBeforeDist, g = e[0], m = e[1]) : (g = _[0], m = _[1]);\n    var b = [g, m], w = i.state, T = w.width, x = w.height, S = !h && !u && !l, C = f.type, M = f.poses, I = f.splitter, R = M.map(function(L) {\n      return L.pos;\n    });\n    S && (g = -g, m = -m);\n    var N = !u || M[d].direction === \"nesw\", A = C === \"inset\" || C === \"rect\", U = M.map(function() {\n      return [0, 0];\n    });\n    if (u && !N) {\n      var B = M[d], G = B.horizontal, $ = B.vertical, Z = [g * Math.abs(G), m * Math.abs($)];\n      U = l3(M, d, Z, A, v);\n    } else\n      N && (U = R.map(function() {\n        return [g, m];\n      }));\n    var H = R.map(function(L, j) {\n      return Jt(L, U[j]);\n    }), z = Tt([], H, !0);\n    w.snapBoundInfos = null;\n    var X = f.type === \"circle\", ct = f.type === \"ellipse\";\n    if (X || ct) {\n      var it = Ti(H), lt = Math.abs(it.bottom - it.top), et = Math.abs(ct ? it.right - it.left : lt), k = H[0][1] + lt, ft = H[0][0] - et, Q = H[0][0] + et;\n      X && (z.push([Q, it.bottom]), U.push([1, 0])), z.push([it.left, k]), U.push([0, 1]), z.push([ft, it.bottom]), U.push([1, 0]);\n    }\n    var St = CC((p.clipHorizontalGuidelines || []).map(function(L) {\n      return Te(\"\".concat(L), x);\n    }), (p.clipVerticalGuidelines || []).map(function(L) {\n      return Te(\"\".concat(L), T);\n    }), T, x), at = [], q = [];\n    if (X || ct)\n      at = [z[4][0], z[2][0]], q = [z[1][1], z[3][1]];\n    else if (A) {\n      var bt = [z[0], z[2], z[4], z[6]], st = [U[0], U[2], U[4], U[6]];\n      at = bt.filter(function(L, j) {\n        return st[j][0];\n      }).map(function(L) {\n        return L[0];\n      }), q = bt.filter(function(L, j) {\n        return st[j][1];\n      }).map(function(L) {\n        return L[1];\n      });\n    } else\n      at = z.filter(function(L, j) {\n        return U[j][0];\n      }).map(function(L) {\n        return L[0];\n      }), q = z.filter(function(L, j) {\n        return U[j][1];\n      }).map(function(L) {\n        return L[1];\n      });\n    var W = [0, 0], nt = kw(St, p.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: T,\n      bottom: x\n    }, at, q, 5), dt = nt.horizontal, V = nt.vertical, xt = dt.offset, Dt = V.offset;\n    if (dt.isBound && (W[1] += xt), V.isBound && (W[0] += Dt), (ct || X) && U[0][0] === 0 && U[0][1] === 0) {\n      var it = Ti(H), Ct = it.bottom - it.top, be = ct ? it.right - it.left : Ct, je = V.isBound ? Math.abs(Dt) : V.snapIndex === 0 ? -Dt : Dt, ee = dt.isBound ? Math.abs(xt) : dt.snapIndex === 0 ? -xt : xt;\n      be -= je, Ct -= ee, X && (Ct = xC(V, dt) > 0 ? Ct : be, be = Ct);\n      var de = z[0];\n      z[1][1] = de[1] - Ct, z[2][0] = de[0] + be, z[3][1] = de[1] + Ct, z[4][0] = de[0] - be;\n    } else if (A && v && u) {\n      var ue = jC(M), se = ue[0], ne = ue[1], Ht = se && ne ? se / ne : 0, xr = M[d], uu = xr.direction || \"\", gh = z[1][1], k = z[5][1], ft = z[7][0], Q = z[3][0];\n      xt <= Dt ? xt = Dt / Ht : Dt = xt * Ht, uu.indexOf(\"w\") > -1 ? ft -= Dt : uu.indexOf(\"e\") > -1 ? Q -= Dt : (ft += Dt / 2, Q -= Dt / 2), uu.indexOf(\"n\") > -1 ? gh -= xt : uu.indexOf(\"s\") > -1 ? k -= xt : (gh += xt / 2, k -= xt / 2);\n      var w0 = Rv(gh, Q, k, ft);\n      z.forEach(function(rt, ot) {\n        var ut;\n        ut = w0[ot].pos, rt[0] = ut[0], rt[1] = ut[1];\n      });\n    } else\n      z.forEach(function(L, j) {\n        var J = U[j];\n        J[0] && (L[0] -= Dt), J[1] && (L[1] -= xt);\n      });\n    var mh = Bx(i, f, H), lu = \"\".concat(C, \"(\").concat(mh.join(I), \")\");\n    if (w.clipPathState = lu, X || ct)\n      at = [z[4][0], z[2][0]], q = [z[1][1], z[3][1]];\n    else if (A) {\n      var bt = [z[0], z[2], z[4], z[6]];\n      at = bt.map(function(j) {\n        return j[0];\n      }), q = bt.map(function(j) {\n        return j[1];\n      });\n    } else\n      at = z.map(function(L) {\n        return L[0];\n      }), q = z.map(function(L) {\n        return L[1];\n      });\n    if (w.snapBoundInfos = kw(St, p.clipTargetBounds && {\n      left: 0,\n      top: 0,\n      right: T,\n      bottom: x\n    }, at, q, 1), y) {\n      var Ad = w.is3d, Ld = w.allMatrix, E0 = Ad ? 4 : 3, D = W;\n      a && (D = [b[0] + W[0] - _[0], b[1] + W[1] - _[1]]), y.deltaOffset = _e(Ld, [D[0], D[1], 0, 0], E0);\n    }\n    return mt(i, \"onClip\", Ut(i, t, F({\n      clipEventType: \"changed\",\n      clipType: C,\n      poses: H,\n      clipStyle: lu,\n      clipStyles: mh,\n      distX: g,\n      distY: m\n    }, Ir((r = {}, r[C === \"rect\" ? \"clip\" : \"clipPath\"] = lu, r), t)))), !0;\n  },\n  dragControlEnd: function(i, t) {\n    this.unset(i);\n    var e = t.isDrag, r = t.datas, n = t.isDouble, s = r.isLine, a = r.isClipStart, o = r.isControl;\n    return a ? (mt(i, \"onClipEnd\", li(i, t, {})), n && (o ? c3(i, t) : s && h3(i, t)), n || e) : !1;\n  },\n  unset: function(i) {\n    i.state.clipPathState = \"\", i.state.snapBoundInfos = null;\n  }\n}, d3 = {\n  name: \"originDraggable\",\n  props: [\"originDraggable\", \"originRelative\"],\n  events: [\"dragOriginStart\", \"dragOrigin\", \"dragOriginEnd\"],\n  css: [`:host[data-able-origindraggable] .control.origin {\npointer-events: auto;\n}`],\n  dragControlCondition: function(i, t) {\n    return t.isRequest ? t.requestAble === \"originDraggable\" : sr(t.inputEvent.target, Pt(\"origin\"));\n  },\n  dragControlStart: function(i, t) {\n    var e = t.datas;\n    ou(i, t);\n    var r = Ut(i, t, {\n      dragStart: Or.dragStart(i, new th().dragStart([0, 0], t))\n    }), n = mt(i, \"onDragOriginStart\", r);\n    return e.startOrigin = i.state.transformOrigin, e.startTargetOrigin = i.state.targetOrigin, e.prevOrigin = [0, 0], e.isDragOrigin = !0, n === !1 ? (e.isDragOrigin = !1, !1) : r;\n  },\n  dragControl: function(i, t) {\n    var e = t.datas, r = t.isPinch, n = t.isRequest;\n    if (!e.isDragOrigin)\n      return !1;\n    var s = Un(t), a = s[0], o = s[1], u = i.state, l = u.width, h = u.height, d = u.offsetMatrix, f = u.targetMatrix, p = u.is3d, v = i.props.originRelative, g = v === void 0 ? !0 : v, m = p ? 4 : 3, y = [a, o];\n    if (n) {\n      var _ = t.distOrigin;\n      (_[0] || _[1]) && (y = _);\n    }\n    var b = Jt(e.startOrigin, y), w = Jt(e.startTargetOrigin, y), T = Mt(y, e.prevOrigin), x = Dd(d, f, b, m), S = i.getRect(), C = Ti(da(x, l, h, m)), M = [S.left - C.left, S.top - C.top];\n    e.prevOrigin = y;\n    var I = [Vi(w[0], l, g), Vi(w[1], h, g)].join(\" \"), R = Or.drag(i, Rd(t, i.state, M, !!r, !1)), N = Ut(i, t, F(F({\n      width: l,\n      height: h,\n      origin: b,\n      dist: y,\n      delta: T,\n      transformOrigin: I,\n      drag: R\n    }, Ir({\n      transformOrigin: I,\n      transform: R.transform\n    }, t)), {\n      afterTransform: R.transform\n    }));\n    return mt(i, \"onDragOrigin\", N), N;\n  },\n  dragControlEnd: function(i, t) {\n    var e = t.datas;\n    return e.isDragOrigin ? (mt(i, \"onDragOriginEnd\", li(i, t, {})), !0) : !1;\n  },\n  dragGroupControlCondition: function(i, t) {\n    return this.dragControlCondition(i, t);\n  },\n  dragGroupControlStart: function(i, t) {\n    var e = this.dragControlStart(i, t);\n    return !!e;\n  },\n  dragGroupControl: function(i, t) {\n    var e = this.dragControl(i, t);\n    return e ? (i.transformOrigin = e.transformOrigin, !0) : !1;\n  },\n  /**\n  * @method Moveable.OriginDraggable#request\n  * @param {object} e - the OriginDraggable's request parameter\n  * @param {number} [e.x] - x position\n  * @param {number} [e.y] - y position\n  * @param {number} [e.deltaX] - x number to move\n  * @param {number} [e.deltaY] - y number to move\n  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n  * @param {array} [e.origin] - transform-origin position\n  * @param {number} [e.isInstant] - Whether to execute the request instantly\n  * @return {Moveable.Requester} Moveable Requester\n  * @example\n   * // Instantly Request (requestStart - request - requestEnd)\n  * // Use Relative Value\n  * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n  * // Use Transform Value\n  * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n  * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n  * // requestStart\n  * const requester = moveable.request(\"originDraggable\");\n  *\n  * // request\n  * // Use Relative Value\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n  *\n  * // requestEnd\n  * requester.requestEnd();\n  */\n  request: function(i) {\n    var t = {}, e = i.getRect(), r = 0, n = 0, s = e.transformOrigin, a = [0, 0];\n    return {\n      isControl: !0,\n      requestStart: function() {\n        return {\n          datas: t\n        };\n      },\n      request: function(o) {\n        return \"deltaOrigin\" in o ? (a[0] += o.deltaOrigin[0], a[1] += o.deltaOrigin[1]) : \"origin\" in o ? (a[0] = o.origin[0] - s[0], a[1] = o.origin[1] - s[1]) : (\"x\" in o ? r = o.x - e.left : \"deltaX\" in o && (r += o.deltaX), \"y\" in o ? n = o.y - e.top : \"deltaY\" in o && (n += o.deltaY)), {\n          datas: t,\n          distX: r,\n          distY: n,\n          distOrigin: a\n        };\n      },\n      requestEnd: function() {\n        return {\n          datas: t,\n          isDrag: !0\n        };\n      }\n    };\n  }\n};\nfunction p3(i, t, e, r) {\n  var n = i.filter(function(u) {\n    var l = u.virtual, h = u.horizontal;\n    return h && !l;\n  }).length, s = i.filter(function(u) {\n    var l = u.virtual, h = u.vertical;\n    return h && !l;\n  }).length, a = -1;\n  if (t === 0 && (n === 0 ? a = 0 : n === 1 && (a = 1)), t === 2 && (n <= 2 ? a = 2 : n <= 3 && (a = 3)), t === 3 && (s === 0 ? a = 4 : s < 4 && (a = 7)), t === 1 && (s <= 1 ? a = 5 : s <= 2 && (a = 6)), !(a === -1 || !i[a].virtual)) {\n    var o = i[a];\n    v3(i, a), a < 4 ? o.pos[0] = e : o.pos[1] = r;\n  }\n}\nfunction v3(i, t) {\n  t < 4 ? i.slice(0, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }) : (i[0].virtual && (i[0].virtual = !1), i.slice(4, t + 1).forEach(function(e) {\n    e.virtual = !1;\n  }));\n}\nfunction g3(i, t) {\n  t < 4 ? i.slice(t, 4).forEach(function(e) {\n    e.virtual = !0;\n  }) : i.slice(t).forEach(function(e) {\n    e.virtual = !0;\n  });\n}\nfunction $w(i, t, e, r, n) {\n  r === void 0 && (r = [0, 0]);\n  var s = [];\n  return !i || i === \"0px\" ? s = [] : s = fa(i), UC(s, t, e, 0, 0, r, n);\n}\nfunction Vw(i, t, e, r, n) {\n  var s = i.state, a = s.width, o = s.height, u = Lx(n, i.props.roundRelative, a, o), l = u.raws, h = u.styles, d = u.radiusPoses, f = a3(d, l), p = f.horizontals, v = f.verticals, g = h.join(\" \");\n  s.borderRadiusState = g;\n  var m = Ut(i, t, F({\n    horizontals: p,\n    verticals: v,\n    borderRadius: g,\n    width: a,\n    height: o,\n    delta: r,\n    dist: e\n  }, Ir({\n    borderRadius: g\n  }, t)));\n  return mt(i, \"onRound\", m), m;\n}\nfunction Xw(i) {\n  var t, e, r = i.getState().style, n = r.borderRadius || \"\";\n  if (!n && i.props.groupable) {\n    var s = i.moveables[0], a = i.getTargets()[0];\n    a && ((s == null ? void 0 : s.props.target) === a ? (n = (e = (t = i.moveables[0]) === null || t === void 0 ? void 0 : t.state.style.borderRadius) !== null && e !== void 0 ? e : \"\", r.borderRadius = n) : (n = Cx(a).borderRadius, r.borderRadius = n));\n  }\n  return n;\n}\nvar m3 = {\n  name: \"roundable\",\n  props: [\"roundable\", \"roundRelative\", \"minRoundControls\", \"maxRoundControls\", \"roundClickable\", \"roundPadding\", \"isDisplayShadowRoundControls\"],\n  events: [\"roundStart\", \"round\", \"roundEnd\", \"roundGroupStart\", \"roundGroup\", \"roundGroupEnd\"],\n  css: [`.control.border-radius {\nbackground: #d66;\ncursor: pointer;\nz-index: 3;\n}`, `.control.border-radius.vertical {\nbackground: #d6d;\nz-index: 2;\n}`, `.control.border-radius.virtual {\nopacity: 0.5;\nz-index: 1;\n}`, `:host.round-line-clickable .line.direction {\ncursor: pointer;\n}`],\n  className: function(i) {\n    var t = i.props.roundClickable;\n    return t === !0 || t === \"line\" ? Pt(\"round-line-clickable\") : \"\";\n  },\n  requestStyle: function() {\n    return [\"borderRadius\"];\n  },\n  requestChildStyle: function() {\n    return [\"borderRadius\"];\n  },\n  render: function(i, t) {\n    var e = i.getState(), r = e.target, n = e.width, s = e.height, a = e.allMatrix, o = e.is3d, u = e.left, l = e.top, h = e.borderRadiusState, d = i.props, f = d.minRoundControls, p = f === void 0 ? [0, 0] : f, v = d.maxRoundControls, g = v === void 0 ? [4, 4] : v, m = d.zoom, y = d.roundPadding, _ = y === void 0 ? 0 : y, b = d.isDisplayShadowRoundControls, w = d.groupable;\n    if (!r)\n      return null;\n    var T = h || Xw(i), x = o ? 4 : 3, S = $w(T, n, s, p, !0);\n    if (!S)\n      return null;\n    var C = 0, M = 0, I = w ? [0, 0] : [u, l];\n    return S.map(function(R, N) {\n      var A = R.horizontal, U = R.vertical, B = R.direction || \"\", G = Tt([], R.pos, !0);\n      M += Math.abs(A), C += Math.abs(U), A && B.indexOf(\"n\") > -1 && (G[1] -= _), U && B.indexOf(\"w\") > -1 && (G[0] -= _), A && B.indexOf(\"s\") > -1 && (G[1] += _), U && B.indexOf(\"e\") > -1 && (G[0] += _);\n      var $ = Mt(nr(a, G, x), I), Z = R.vertical ? C <= g[1] && (b || !R.virtual) : M <= g[0] && (b || !R.virtual);\n      return t.createElement(\"div\", {\n        key: \"borderRadiusControl\".concat(N),\n        className: Pt(\"control\", \"border-radius\", R.vertical ? \"vertical\" : \"\", R.virtual ? \"virtual\" : \"\"),\n        \"data-radius-index\": N,\n        style: {\n          display: Z ? \"block\" : \"none\",\n          transform: \"translate(\".concat($[0], \"px, \").concat($[1], \"px) scale(\").concat(m, \")\")\n        }\n      });\n    });\n  },\n  dragControlCondition: function(i, t) {\n    if (!t.inputEvent || t.isRequest)\n      return !1;\n    var e = t.inputEvent.target.getAttribute(\"class\") || \"\";\n    return e.indexOf(\"border-radius\") > -1 || e.indexOf(\"moveable-line\") > -1 && e.indexOf(\"moveable-direction\") > -1;\n  },\n  dragGroupControlCondition: function(i, t) {\n    return this.dragControlCondition(i, t);\n  },\n  dragControlStart: function(i, t) {\n    var e = t.inputEvent, r = t.datas, n = e.target, s = n.getAttribute(\"class\") || \"\", a = s.indexOf(\"border-radius\") > -1, o = s.indexOf(\"moveable-line\") > -1 && s.indexOf(\"moveable-direction\") > -1, u = a ? parseInt(n.getAttribute(\"data-radius-index\"), 10) : -1, l = -1;\n    if (o) {\n      var h = n.getAttribute(\"data-line-key\") || \"\";\n      h && (l = parseInt(h.replace(/render-line-/g, \"\"), 10), isNaN(l) && (l = -1));\n    }\n    if (!a && !o)\n      return !1;\n    var d = Ut(i, t, {}), f = mt(i, \"onRoundStart\", d);\n    if (f === !1)\n      return !1;\n    r.lineIndex = l, r.controlIndex = u, r.isControl = a, r.isLine = o, ou(i, t);\n    var p = i.props, v = p.roundRelative, g = p.minRoundControls, m = g === void 0 ? [0, 0] : g, y = i.state, _ = y.width, b = y.height;\n    r.isRound = !0, r.prevDist = [0, 0];\n    var w = Xw(i), T = $w(w || \"\", _, b, m, !0) || [];\n    return r.controlPoses = T, y.borderRadiusState = Lx(T, v, _, b).styles.join(\" \"), d;\n  },\n  dragControl: function(i, t) {\n    var e = t.datas, r = e.controlPoses;\n    if (!e.isRound || !e.isControl || !r.length)\n      return !1;\n    var n = e.controlIndex, s = Un(t), a = s[0], o = s[1], u = [a, o], l = Mt(u, e.prevDist), h = i.props.maxRoundControls, d = h === void 0 ? [4, 4] : h, f = i.state, p = f.width, v = f.height, g = r[n], m = g.vertical, y = g.horizontal, _ = r.map(function(w) {\n      var T = w.horizontal, x = w.vertical, S = [T * y * u[0], x * m * u[1]];\n      if (T) {\n        if (d[0] === 1)\n          return S;\n        if (d[0] < 4 && T !== y)\n          return S;\n      } else {\n        if (d[1] === 0)\n          return S[1] = x * y * u[0] / p * v, S;\n        if (m) {\n          if (d[1] === 1)\n            return S;\n          if (d[1] < 4 && x !== m)\n            return S;\n        }\n      }\n      return [0, 0];\n    });\n    _[n] = u;\n    var b = r.map(function(w, T) {\n      return F(F({}, w), {\n        pos: Jt(w.pos, _[T])\n      });\n    });\n    return n < 4 ? b.slice(0, n + 1).forEach(function(w) {\n      w.virtual = !1;\n    }) : b.slice(4, n + 1).forEach(function(w) {\n      w.virtual = !1;\n    }), e.prevDist = [a, o], Vw(i, t, u, l, b);\n  },\n  dragControlEnd: function(i, t) {\n    var e = i.state;\n    e.borderRadiusState = \"\";\n    var r = t.datas, n = t.isDouble;\n    if (!r.isRound)\n      return !1;\n    var s = r.isControl, a = r.controlIndex, o = r.isLine, u = r.lineIndex, l = r.controlPoses, h = l.filter(function(y) {\n      var _ = y.virtual;\n      return _;\n    }).length, d = i.props.roundClickable, f = d === void 0 ? !0 : d;\n    if (n && f) {\n      if (s && (f === !0 || f === \"control\"))\n        g3(l, a);\n      else if (o && (f === !0 || f === \"line\")) {\n        var p = YT(i, t), v = p[0], g = p[1];\n        p3(l, u, v, g);\n      }\n      h !== l.filter(function(y) {\n        var _ = y.virtual;\n        return _;\n      }).length && Vw(i, t, [0, 0], [0, 0], l);\n    }\n    var m = li(i, t, {});\n    return mt(i, \"onRoundEnd\", m), e.borderRadiusState = \"\", m;\n  },\n  dragGroupControlStart: function(i, t) {\n    var e = this.dragControlStart(i, t);\n    if (!e)\n      return !1;\n    var r = i.moveables, n = i.props.targets, s = Ji(i, \"roundable\", t), a = F({\n      targets: i.props.targets,\n      events: s.map(function(o, u) {\n        return F(F({}, o), {\n          target: n[u],\n          moveable: r[u],\n          currentTarget: r[u]\n        });\n      })\n    }, e);\n    return mt(i, \"onRoundGroupStart\", a), e;\n  },\n  dragGroupControl: function(i, t) {\n    var e = this.dragControl(i, t);\n    if (!e)\n      return !1;\n    var r = i.moveables, n = i.props.targets, s = Ji(i, \"roundable\", t), a = F({\n      targets: i.props.targets,\n      events: s.map(function(o, u) {\n        return F(F(F({}, o), {\n          target: n[u],\n          moveable: r[u],\n          currentTarget: r[u]\n        }), Ir({\n          borderRadius: e.borderRadius\n        }, o));\n      })\n    }, e);\n    return mt(i, \"onRoundGroup\", a), a;\n  },\n  dragGroupControlEnd: function(i, t) {\n    var e = i.moveables, r = i.props.targets, n = Ji(i, \"roundable\", t);\n    v0(i, \"onRound\", function(o) {\n      var u = F({\n        targets: i.props.targets,\n        events: n.map(function(l, h) {\n          return F(F(F({}, l), {\n            target: r[h],\n            moveable: e[h],\n            currentTarget: e[h]\n          }), Ir({\n            borderRadius: o.borderRadius\n          }, l));\n        })\n      }, o);\n      mt(i, \"onRoundGroup\", u);\n    });\n    var s = this.dragControlEnd(i, t);\n    if (!s)\n      return !1;\n    var a = F({\n      targets: i.props.targets,\n      events: n.map(function(o, u) {\n        var l;\n        return F(F({}, o), {\n          target: r[u],\n          moveable: e[u],\n          currentTarget: e[u],\n          lastEvent: (l = o.datas) === null || l === void 0 ? void 0 : l.lastEvent\n        });\n      })\n    }, s);\n    return mt(i, \"onRoundGroupEnd\", a), a;\n  },\n  unset: function(i) {\n    i.state.borderRadiusState = \"\";\n  }\n};\nfunction y3(i, t) {\n  var e = t ? 4 : 3, r = Oe(e), n = \"matrix\".concat(t ? \"3d\" : \"\", \"(\").concat(r.join(\",\"), \")\");\n  return i === n || i === \"matrix(1,0,0,1,0,0)\";\n}\nvar zC = {\n  isPinch: !0,\n  name: \"beforeRenderable\",\n  props: [],\n  events: [\"beforeRenderStart\", \"beforeRender\", \"beforeRenderEnd\", \"beforeRenderGroupStart\", \"beforeRenderGroup\", \"beforeRenderGroupEnd\"],\n  dragRelation: \"weak\",\n  setTransform: function(i, t) {\n    var e = i.state, r = e.is3d, n = e.target, s = e.targetMatrix, a = n == null ? void 0 : n.style.transform, o = r ? \"matrix3d(\".concat(s.join(\",\"), \")\") : \"matrix(\".concat(AT(s, !0), \")\"), u = !a || a === \"none\" ? o : a;\n    t.datas.startTransforms = y3(u, r) ? [] : fa(u);\n  },\n  resetStyle: function(i) {\n    var t = i.datas;\n    t.nextStyle = {}, t.nextTransforms = i.datas.startTransforms, t.nextTransformAppendedIndexes = [];\n  },\n  fillDragStartParams: function(i, t) {\n    return Ut(i, t, {\n      setTransform: function(e) {\n        t.datas.startTransforms = tr(e) ? e : fa(e);\n      },\n      isPinch: !!t.isPinch\n    });\n  },\n  fillDragParams: function(i, t) {\n    return Ut(i, t, {\n      isPinch: !!t.isPinch\n    });\n  },\n  dragStart: function(i, t) {\n    this.setTransform(i, t), this.resetStyle(t), mt(i, \"onBeforeRenderStart\", this.fillDragStartParams(i, t));\n  },\n  drag: function(i, t) {\n    this.resetStyle(t), mt(i, \"onBeforeRender\", Ut(i, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  dragEnd: function(i, t) {\n    mt(i, \"onBeforeRenderEnd\", Ut(i, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag\n    }));\n  },\n  dragGroupStart: function(i, t) {\n    var e = this;\n    this.dragStart(i, t);\n    var r = Ji(i, \"beforeRenderable\", t), n = i.moveables, s = r.map(function(a, o) {\n      var u = n[o];\n      return e.setTransform(u, a), e.resetStyle(a), e.fillDragStartParams(u, a);\n    });\n    mt(i, \"onBeforeRenderGroupStart\", Ut(i, t, {\n      isPinch: !!t.isPinch,\n      targets: i.props.targets,\n      setTransform: function() {\n      },\n      events: s\n    }));\n  },\n  dragGroup: function(i, t) {\n    var e = this;\n    this.drag(i, t);\n    var r = Ji(i, \"beforeRenderable\", t), n = i.moveables, s = r.map(function(a, o) {\n      var u = n[o];\n      return e.resetStyle(a), e.fillDragParams(u, a);\n    });\n    mt(i, \"onBeforeRenderGroup\", Ut(i, t, {\n      isPinch: !!t.isPinch,\n      targets: i.props.targets,\n      events: s\n    }));\n  },\n  dragGroupEnd: function(i, t) {\n    this.dragEnd(i, t), mt(i, \"onBeforeRenderGroupEnd\", Ut(i, t, {\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: i.props.targets\n    }));\n  },\n  dragControlStart: function(i, t) {\n    return this.dragStart(i, t);\n  },\n  dragControl: function(i, t) {\n    return this.drag(i, t);\n  },\n  dragControlEnd: function(i, t) {\n    return this.dragEnd(i, t);\n  },\n  dragGroupControlStart: function(i, t) {\n    return this.dragGroupStart(i, t);\n  },\n  dragGroupControl: function(i, t) {\n    return this.dragGroup(i, t);\n  },\n  dragGroupControlEnd: function(i, t) {\n    return this.dragGroupEnd(i, t);\n  }\n}, HC = {\n  name: \"renderable\",\n  props: [],\n  events: [\"renderStart\", \"render\", \"renderEnd\", \"renderGroupStart\", \"renderGroup\", \"renderGroupEnd\"],\n  dragRelation: \"weak\",\n  dragStart: function(i, t) {\n    mt(i, \"onRenderStart\", Ut(i, t, {\n      isPinch: !!t.isPinch\n    }));\n  },\n  drag: function(i, t) {\n    mt(i, \"onRender\", this.fillDragParams(i, t));\n  },\n  dragAfter: function(i, t) {\n    return this.drag(i, t);\n  },\n  dragEnd: function(i, t) {\n    mt(i, \"onRenderEnd\", this.fillDragEndParams(i, t));\n  },\n  dragGroupStart: function(i, t) {\n    mt(i, \"onRenderGroupStart\", Ut(i, t, {\n      isPinch: !!t.isPinch,\n      targets: i.props.targets\n    }));\n  },\n  dragGroup: function(i, t) {\n    var e = this, r = Ji(i, \"beforeRenderable\", t), n = i.moveables, s = r.map(function(a, o) {\n      var u = n[o];\n      return e.fillDragParams(u, a);\n    });\n    mt(i, \"onRenderGroup\", Ut(i, t, F(F({\n      isPinch: !!t.isPinch,\n      targets: i.props.targets,\n      transform: pp(t)\n    }, Ir(vp(t))), {\n      events: s\n    })));\n  },\n  dragGroupEnd: function(i, t) {\n    var e = this, r = Ji(i, \"beforeRenderable\", t), n = i.moveables, s = r.map(function(a, o) {\n      var u = n[o];\n      return e.fillDragEndParams(u, a);\n    });\n    mt(i, \"onRenderGroupEnd\", Ut(i, t, F({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      targets: i.props.targets,\n      events: s,\n      transform: pp(t)\n    }, Ir(vp(t)))));\n  },\n  dragControlStart: function(i, t) {\n    return this.dragStart(i, t);\n  },\n  dragControl: function(i, t) {\n    return this.drag(i, t);\n  },\n  dragControlAfter: function(i, t) {\n    return this.dragAfter(i, t);\n  },\n  dragControlEnd: function(i, t) {\n    return this.dragEnd(i, t);\n  },\n  dragGroupControlStart: function(i, t) {\n    return this.dragGroupStart(i, t);\n  },\n  dragGroupControl: function(i, t) {\n    return this.dragGroup(i, t);\n  },\n  dragGroupControlEnd: function(i, t) {\n    return this.dragGroupEnd(i, t);\n  },\n  fillDragParams: function(i, t) {\n    return Ut(i, t, F({\n      isPinch: !!t.isPinch,\n      transform: pp(t)\n    }, Ir(vp(t))));\n  },\n  fillDragEndParams: function(i, t) {\n    return Ut(i, t, F({\n      isPinch: !!t.isPinch,\n      isDrag: t.isDrag,\n      transform: pp(t)\n    }, Ir(vp(t))));\n  }\n};\nfunction Jh(i, t, e, r, n, s, a) {\n  s.clientDistX = s.distX, s.clientDistY = s.distY;\n  var o = n === \"Start\", u = n === \"End\", l = n === \"After\", h = i.state.target, d = s.isRequest;\n  if (!h || o && r.indexOf(\"Control\") > -1 && !d && i.areaElement === s.inputEvent.target)\n    return !1;\n  var f = Tt([], i[t], !0);\n  if (d) {\n    var p = s.requestAble;\n    f.some(function(M) {\n      return M.name === p;\n    }) || f.push.apply(f, i.props.ables.filter(function(M) {\n      return M.name === p;\n    }));\n  }\n  if (!f.length || f.every(function(M) {\n    return M.dragRelation;\n  }))\n    return !1;\n  var v = s.inputEvent, g;\n  u && v && (g = document.elementFromPoint(s.clientX, s.clientY) || v.target);\n  var m = !1, y = function() {\n    var M;\n    m = !0, (M = s.stop) === null || M === void 0 || M.call(s);\n  }, _ = o && (!i.targetGesto || !i.controlGesto || !i.targetGesto.isFlag() || !i.controlGesto.isFlag());\n  _ && i.updateRect(n, !0, !1);\n  var b = s.datas, w = function(M, I, R) {\n    if (!(I in M))\n      return !1;\n    var N = M.name, A = b[N] || (b[N] = {});\n    if (o && (A.isEventStart = !R || !M[R] || M[R](i, s)), !A.isEventStart)\n      return !1;\n    var U = M[I](i, F(F({}, s), {\n      stop: y,\n      datas: A,\n      originalDatas: b,\n      inputTarget: g\n    }));\n    return i._emitter.off(), o && U === !1 && (A.isEventStart = !1), U;\n  };\n  _ && f.forEach(function(M) {\n    M.unset && M.unset(i);\n  }), w(zC, \"drag\".concat(r).concat(n));\n  var T = 0, x = 0;\n  e.forEach(function(M) {\n    if (m)\n      return !1;\n    var I = \"\".concat(M).concat(r).concat(n), R = \"\".concat(M).concat(r, \"Condition\");\n    n === \"\" && !d && gC(i.state, s);\n    var N = f.filter(function(B) {\n      return B[I];\n    });\n    N = N.filter(function(B, G) {\n      return B.name && N.indexOf(B) === G;\n    });\n    var A = N.filter(function(B) {\n      return w(B, I, R);\n    }), U = A.length;\n    m && ++T, U && ++x, !m && o && N.length && !U && (T += N.filter(function(B) {\n      var G = B.name, $ = b[G];\n      return $.isEventStart ? B.dragRelation !== \"strong\" : !1;\n    }).length ? 1 : 0);\n  }), (!l || x) && w(HC, \"drag\".concat(r).concat(n));\n  var S = T === e.length;\n  if ((u || m || S) && (i.state.gestos = {}, i.moveables && i.moveables.forEach(function(M) {\n    M.state.gestos = {};\n  }), f.forEach(function(M) {\n    M.unset && M.unset(i);\n  })), o && !S && !d && x && i.props.preventDefault && (s == null || s.preventDefault()), i.isUnmounted || S)\n    return !1;\n  if (!o && x && !a || u) {\n    var C = i.props.flushSync || nC;\n    C(function() {\n      i.updateRect(u ? n : \"\", !0, !1), i.forceUpdate();\n    });\n  }\n  return !o && !u && !l && x && !a && Jh(i, t, e, r, n + \"After\", s), !0;\n}\nfunction k_(i) {\n  return function(t) {\n    var e = i.props.dragTarget, r = t.inputEvent.target, n = i.areaElement;\n    return e && (r === e || e.contains(r)) || r === n || !i.isMoveableElement(r) && !i.controlBox.contains(r) || sr(r, \"moveable-area\") || sr(r, \"moveable-padding\") || sr(r, \"moveable-edgeDraggable\");\n  };\n}\nfunction $C(i, t, e) {\n  var r = i.controlBox, n = [], s = i.props.dragTarget;\n  return n.push(r), (!i.props.dragArea || s) && n.push(t), Fx(i, n, \"targetAbles\", e, {\n    dragStart: k_(i),\n    pinchStart: k_(i)\n  });\n}\nfunction Fx(i, t, e, r, n) {\n  n === void 0 && (n = {});\n  var s = e === \"targetAbles\", a = i.props, o = a.pinchOutside, u = a.pinchThreshold, l = a.preventClickEventOnDrag, h = a.preventClickDefault, d = a.checkInput, f = a.preventDefault, p = f === void 0 ? !0 : f, v = {\n    preventDefault: p,\n    preventRightClick: !0,\n    preventWheelClick: !0,\n    container: window,\n    pinchThreshold: u,\n    pinchOutside: o,\n    preventClickEventOnDrag: s ? l : !1,\n    preventClickEventOnDragStart: s ? h : !1,\n    preventClickEventByCondition: s ? null : function(y) {\n      return i.controlBox.contains(y.target);\n    },\n    checkInput: s ? d : !1\n  }, g = new JL(t, v), m = r === \"Control\";\n  return [\"drag\", \"pinch\"].forEach(function(y) {\n    [\"Start\", \"\", \"End\"].forEach(function(_) {\n      g.on(\"\".concat(y).concat(_), function(b) {\n        var w, T = b.eventType, x = y === \"drag\" && b.isPinch;\n        if (n[T] && !n[T](b)) {\n          b.stop();\n          return;\n        }\n        if (!x) {\n          var S = y === \"drag\" ? [y] : [\"drag\", y], C = Jh(i, e, S, r, _, b);\n          C ? (i.props.stopPropagation || _ === \"Start\" && m) && ((w = b == null ? void 0 : b.inputEvent) === null || w === void 0 || w.stopPropagation()) : b.stop();\n        }\n      });\n    });\n  }), g;\n}\nvar _3 = /* @__PURE__ */ function() {\n  function i(e, r, n) {\n    var s = this;\n    this.target = e, this.moveable = r, this.eventName = n, this.ables = [], this._onEvent = function(a) {\n      var o = s.eventName, u = s.moveable;\n      u.state.disableNativeEvent || s.ables.forEach(function(l) {\n        l[o](u, {\n          inputEvent: a\n        });\n      });\n    }, e.addEventListener(n.toLowerCase(), this._onEvent);\n  }\n  var t = i.prototype;\n  return t.setAbles = function(e) {\n    this.ables = e;\n  }, t.destroy = function() {\n    this.target.removeEventListener(this.eventName.toLowerCase(), this._onEvent), this.target = null, this.moveable = null;\n  }, i;\n}();\nfunction b3(i, t, e, r) {\n  var n;\n  e === void 0 && (e = t);\n  var s = iC(i, t), a = s.matrixes, o = s.is3d, u = s.targetMatrix, l = s.transformOrigin, h = s.targetOrigin, d = s.offsetContainer, f = s.hasFixed, p = s.zoom, v = BB(d, e), g = v.matrixes, m = v.is3d, y = v.offsetContainer, _ = v.zoom, b = r || m || o, w = b ? 4 : 3, T = i.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in i, x = u, S = Oe(w), C = Oe(w), M = Oe(w), I = Oe(w), R = a.length, N = Tt([], g, !0).reverse();\n  a.reverse(), !o && b && (x = An(x, 3, 4), T_(a)), !m && b && T_(N), N.forEach(function(H) {\n    C = _e(C, H.matrix, w);\n  });\n  var A = e || document.body, U = ((n = N[0]) === null || n === void 0 ? void 0 : n.target) || yc(A, A, !0).offsetParent, B = N.slice(1).reduce(function(H, z) {\n    return _e(H, z.matrix, w);\n  }, Oe(w));\n  a.forEach(function(H, z) {\n    if (R - 2 === z && (M = S.slice()), R - 1 === z && (I = S.slice()), !H.matrix) {\n      var X = a[z + 1], ct = WB(H, X, U, w, _e(B, S, w));\n      H.matrix = mc(ct, w);\n    }\n    S = _e(S, H.matrix, w);\n  });\n  var G = !T && o;\n  x || (x = Oe(G ? 4 : 3));\n  var $ = p0(T && x.length === 16 ? An(x, 4, 3) : x, G), Z = C;\n  return C = kT(C, w, w), {\n    hasZoom: p !== 1 || _ !== 1,\n    hasFixed: f,\n    rootMatrix: C,\n    originalRootMatrix: Z,\n    beforeMatrix: M,\n    offsetMatrix: I,\n    allMatrix: S,\n    targetMatrix: x,\n    targetTransform: $,\n    transformOrigin: l,\n    targetOrigin: h,\n    is3d: b,\n    offsetContainer: d,\n    offsetRootContainer: y\n  };\n}\nfunction x3(i, t, e, r) {\n  e === void 0 && (e = t);\n  var n = 0, s = 0, a = 0, o = {}, u = uC(i);\n  if (i && (n = u.offsetWidth, s = u.offsetHeight), i) {\n    var l = b3(i, t, e, r), h = Gu(l.allMatrix, l.transformOrigin, n, s);\n    o = F(F({}, l), h);\n    var d = Gu(l.allMatrix, [50, 50], 100, 100);\n    a = lC([d.pos1, d.pos2], d.direction);\n  }\n  var f = r ? 4 : 3;\n  return F(F(F({\n    hasZoom: !1,\n    width: n,\n    height: s,\n    rotation: a\n  }, u), {\n    originalRootMatrix: Oe(f),\n    rootMatrix: Oe(f),\n    beforeMatrix: Oe(f),\n    offsetMatrix: Oe(f),\n    allMatrix: Oe(f),\n    targetMatrix: Oe(f),\n    targetTransform: \"\",\n    transformOrigin: [0, 0],\n    targetOrigin: [0, 0],\n    is3d: !!r,\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n    origin: [0, 0],\n    pos1: [0, 0],\n    pos2: [0, 0],\n    pos3: [0, 0],\n    pos4: [0, 0],\n    direction: 1,\n    hasFixed: !1,\n    offsetContainer: null,\n    offsetRootContainer: null\n  }), o);\n}\nfunction N_(i, t, e, r, n, s) {\n  s === void 0 && (s = []);\n  var a = 1, o = [0, 0], u = gp(), l = gp(), h = gp(), d = gp(), f = [0, 0], p = {}, v = x3(t, e, n, !0);\n  if (t) {\n    var g = ui(t);\n    s.forEach(function(N) {\n      p[N] = g(N);\n    });\n    var m = v.is3d ? 4 : 3, y = Gu(v.offsetMatrix, Jt(v.transformOrigin, NT(v.targetMatrix, m)), v.width, v.height);\n    a = y.direction, o = Jt(y.origin, [y.left - v.left, y.top - v.top]), d = Kh(v.offsetRootContainer);\n    var _ = yc(r, r, !0).offsetParent || v.offsetRootContainer;\n    if (v.hasZoom) {\n      var b = Gu(_e(v.originalRootMatrix, v.allMatrix), v.transformOrigin, v.width, v.height), w = Gu(v.originalRootMatrix, Cv(ui(_)(\"transformOrigin\")).map(function(N) {\n        return parseFloat(N);\n      }), _.offsetWidth, _.offsetHeight);\n      if (u = oy(b, d), h = oy(w, d, _, !0), i) {\n        var T = b.left, x = b.top;\n        l = oy({\n          left: T,\n          top: x,\n          bottom: x,\n          right: x\n        }, d);\n      }\n    } else {\n      u = Kh(t), h = LB(_), i && (l = Kh(i));\n      var S = h.left, C = h.top, M = h.clientLeft, I = h.clientTop, R = [u.left - S, u.top - C];\n      f = Mt(ih(v.rootMatrix, R, 4), [M + v.left, I + v.top]);\n    }\n  }\n  return F({\n    targetClientRect: u,\n    containerClientRect: h,\n    moveableClientRect: l,\n    rootContainerClientRect: d,\n    beforeDirection: a,\n    beforeOrigin: o,\n    originalBeforeOrigin: o,\n    target: t,\n    style: p,\n    offsetDelta: f\n  }, v);\n}\nfunction Ww(i) {\n  var t = i.pos1, e = i.pos2, r = i.pos3, n = i.pos4;\n  if (!t || !e || !r || !n)\n    return null;\n  var s = ru([t, e, r, n]), a = [s.minX, s.minY], o = Mt(i.origin, a);\n  return t = Mt(t, a), e = Mt(e, a), r = Mt(r, a), n = Mt(n, a), F(F({}, i), {\n    left: i.left,\n    top: i.top,\n    posDelta: a,\n    pos1: t,\n    pos2: e,\n    pos3: r,\n    pos4: n,\n    origin: o,\n    beforeOrigin: o,\n    // originalBeforeOrigin: origin,\n    isPersisted: !0\n  });\n}\nvar nh = /* @__PURE__ */ function(i) {\n  Od(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.state = F({\n      container: null,\n      gestos: {},\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      disableNativeEvent: !1,\n      posDelta: [0, 0]\n    }, N_(null)), r.renderState = {}, r.enabledAbles = [], r.targetAbles = [], r.controlAbles = [], r.rotation = 0, r.scale = [1, 1], r.isMoveableMounted = !1, r.isUnmounted = !1, r.events = {\n      mouseEnter: null,\n      mouseLeave: null\n    }, r._emitter = new l0(), r._prevTarget = null, r._prevDragArea = !1, r._isPropTargetChanged = !1, r._hasFirstTarget = !1, r._reiszeObserver = null, r._observerId = 0, r._mutationObserver = null, r._rootContainer = null, r._viewContainer = null, r._viewClassNames = [], r._store = {}, r.checkUpdateRect = function() {\n      if (!r.isDragging()) {\n        var n = r.props.parentMoveable;\n        if (n) {\n          n.checkUpdateRect();\n          return;\n        }\n        GA(r._observerId), r._observerId = hT(function() {\n          r.isDragging() || r.updateRect();\n        });\n      }\n    }, r._onPreventClick = function(n) {\n      n.stopPropagation(), n.preventDefault();\n    }, r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this.props, n = this.getState(), s = r.parentPosition, a = r.className, o = r.target, u = r.zoom, l = r.cspNonce, h = r.translateZ, d = r.cssStyled, f = r.groupable, p = r.linePadding, v = r.controlPadding;\n    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();\n    var g = s || [0, 0], m = g[0], y = g[1], _ = n.left, b = n.top, w = n.target, T = n.direction, x = n.hasFixed, S = n.offsetDelta, C = r.targets, M = this.isDragging(), I = {};\n    this.getEnabledAbles().forEach(function(G) {\n      I[\"data-able-\".concat(G.name.toLowerCase())] = !0;\n    });\n    var R = this._getAbleClassName(), N = C && C.length && (w || f) || o || !this._hasFirstTarget && this.state.isPersisted, A = this.controlBox || this.props.firstRenderState || this.props.persistData, U = [_ - m, b - y];\n    !f && r.useAccuratePosition && (U[0] += S[0], U[1] += S[1]);\n    var B = {\n      position: x ? \"fixed\" : \"absolute\",\n      display: N ? \"block\" : \"none\",\n      visibility: A ? \"visible\" : \"hidden\",\n      transform: \"translate3d(\".concat(U[0], \"px, \").concat(U[1], \"px, \").concat(h, \")\"),\n      \"--zoom\": u,\n      \"--zoompx\": \"\".concat(u, \"px\")\n    };\n    return p && (B[\"--moveable-line-padding\"] = p), v && (B[\"--moveable-control-padding\"] = v), Ki(d, F({\n      cspNonce: l,\n      ref: Es(this, \"controlBox\"),\n      className: \"\".concat(Pt(\"control-box\", T === -1 ? \"reverse\" : \"\", M ? \"dragging\" : \"\"), \" \").concat(R, \" \").concat(a)\n    }, I, {\n      onClick: this._onPreventClick,\n      style: B\n    }), this.renderAbles(), this._renderLines());\n  }, e.componentDidMount = function() {\n    this.isMoveableMounted = !0, this.isUnmounted = !1;\n    var r = this.props, n = r.parentMoveable, s = r.container, a = r.wrapperMoveable;\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !s && !n && !a && !this.state.isPersisted && (this.updateRect(\"\", !1, !1), this.forceUpdate());\n  }, e.componentDidUpdate = function(r) {\n    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateEvents(), this._updateTargets(), this.updateCheckInput(), this._updateObserver(r);\n  }, e.componentWillUnmount = function() {\n    var r, n;\n    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (r = this._reiszeObserver) === null || r === void 0 || r.disconnect(), (n = this._mutationObserver) === null || n === void 0 || n.disconnect();\n    var s = this._viewContainer;\n    s && this._changeAbleViewClassNames([]), ku(this, \"targetGesto\"), ku(this, \"controlGesto\");\n    var a = this.events;\n    for (var o in a) {\n      var u = a[o];\n      u && u.destroy();\n    }\n  }, e.getTargets = function() {\n    var r = this.props.target;\n    return r ? [r] : [];\n  }, e.getAble = function(r) {\n    var n = this.props.ables || [];\n    return nn(n, function(s) {\n      return s.name === r;\n    });\n  }, e.getContainer = function() {\n    var r = this.props, n = r.parentMoveable, s = r.wrapperMoveable, a = r.container;\n    return a || s && s.getContainer() || n && n.getContainer() || this.controlBox.parentElement;\n  }, e.isMoveableElement = function(r) {\n    var n;\n    return r && (((n = r.getAttribute) === null || n === void 0 ? void 0 : n.call(r, \"class\")) || \"\").indexOf(_x) > -1;\n  }, e.dragStart = function(r) {\n    var n = this.targetGesto, s = this.controlGesto;\n    return n && k_(this)({\n      inputEvent: r\n    }) ? n.isFlag() || n.triggerDragStart(r) : s && this.isMoveableElement(r.target) && (s.isFlag() || s.triggerDragStart(r)), this;\n  }, e.hitTest = function(r) {\n    var n = this.state, s = n.target, a = n.pos1, o = n.pos2, u = n.pos3, l = n.pos4, h = n.targetClientRect;\n    if (!s)\n      return 0;\n    var d;\n    if (r instanceof Element) {\n      var f = r.getBoundingClientRect();\n      d = {\n        left: f.left,\n        top: f.top,\n        width: f.width,\n        height: f.height\n      };\n    } else\n      d = F({\n        width: 0,\n        height: 0\n      }, r);\n    var p = d.left, v = d.top, g = d.width, m = d.height, y = yw([a, o, l, u], h), _ = XL(y, [[p, v], [p + g, v], [p + g, v + m], [p, v + m]]), b = FT(y);\n    return !_ || !b ? 0 : Math.min(100, _ / b * 100);\n  }, e.isInside = function(r, n) {\n    var s = this.state, a = s.target, o = s.pos1, u = s.pos2, l = s.pos3, h = s.pos4, d = s.targetClientRect;\n    return a ? m_([r, n], yw([o, u, h, l], d)) : !1;\n  }, e.updateRect = function(r, n, s) {\n    s === void 0 && (s = !0);\n    var a = this.props, o = !a.parentPosition && !a.wrapperMoveable;\n    o && eh(!0);\n    var u = a.parentMoveable, l = this.state, h = l.target || a.target, d = this.getContainer(), f = u ? u._rootContainer : this._rootContainer, p = N_(this.controlBox, h, d, d, f || d, this._getRequestStyles());\n    if (!h && this._hasFirstTarget && a.persistData) {\n      var v = Ww(a.persistData);\n      for (var g in v)\n        p[g] = v[g];\n    }\n    o && eh(), this.updateState(p, u ? !1 : s);\n  }, e.isDragging = function(r) {\n    var n, s, a = this.targetGesto, o = this.controlGesto;\n    if (a != null && a.isFlag()) {\n      if (!r)\n        return !0;\n      var u = a.getEventData();\n      return !!(!((n = u[r]) === null || n === void 0) && n.isEventStart);\n    }\n    if (o != null && o.isFlag()) {\n      if (!r)\n        return !0;\n      var u = o.getEventData();\n      return !!(!((s = u[r]) === null || s === void 0) && s.isEventStart);\n    }\n    return !1;\n  }, e.updateTarget = function(r) {\n    this.updateRect(r, !0);\n  }, e.getRect = function() {\n    var r = this.state, n = Ci(this.state), s = n[0], a = n[1], o = n[2], u = n[3], l = Ti(n), h = r.width, d = r.height, f = l.width, p = l.height, v = l.left, g = l.top, m = [r.left, r.top], y = Jt(m, r.origin), _ = Jt(m, r.beforeOrigin), b = r.transformOrigin;\n    return {\n      width: f,\n      height: p,\n      left: v,\n      top: g,\n      pos1: s,\n      pos2: a,\n      pos3: o,\n      pos4: u,\n      offsetWidth: h,\n      offsetHeight: d,\n      beforeOrigin: _,\n      origin: y,\n      transformOrigin: b,\n      rotation: this.getRotation()\n    };\n  }, e.getManager = function() {\n    return this;\n  }, e.stopDrag = function(r) {\n    var n, s;\n    (!r || r === \"target\") && ((n = this.targetGesto) === null || n === void 0 || n.stop()), (!r || r === \"control\") && ((s = this.controlGesto) === null || s === void 0 || s.stop());\n  }, e.getRotation = function() {\n    var r = this.state, n = r.pos1, s = r.pos2, a = r.direction;\n    return QB(n, s, a);\n  }, e.request = function(r, n, s) {\n    n === void 0 && (n = {});\n    var a = this.props, o = a.ables, u = a.groupable, l = o.filter(function(m) {\n      return m.name === r;\n    })[0];\n    if (this.isDragging() || !l || !l.request)\n      return {\n        request: function() {\n          return this;\n        },\n        requestEnd: function() {\n          return this;\n        }\n      };\n    var h = this, d = l.request(this), f = s || n.isInstant, p = d.isControl ? \"controlAbles\" : \"targetAbles\", v = \"\".concat(u ? \"Group\" : \"\").concat(d.isControl ? \"Control\" : \"\"), g = {\n      request: function(m) {\n        return Jh(h, p, [\"drag\"], v, \"\", F(F({}, d.request(m)), {\n          requestAble: r,\n          isRequest: !0\n        }), f), this;\n      },\n      requestEnd: function() {\n        return Jh(h, p, [\"drag\"], v, \"End\", F(F({}, d.requestEnd()), {\n          requestAble: r,\n          isRequest: !0\n        }), f), this;\n      }\n    };\n    return Jh(h, p, [\"drag\"], v, \"Start\", F(F({}, d.requestStart(n)), {\n      requestAble: r,\n      isRequest: !0\n    }), f), f ? g.request(n).requestEnd() : g;\n  }, e.destroy = function() {\n    this.componentWillUnmount();\n  }, e.updateRenderPoses = function() {\n    var r = this.getState(), n = this.props, s = r.originalBeforeOrigin, a = r.transformOrigin, o = r.allMatrix, u = r.is3d, l = r.pos1, h = r.pos2, d = r.pos3, f = r.pos4, p = r.left, v = r.top, g = r.isPersisted, m = n.padding || {}, y = m.left, _ = y === void 0 ? 0 : y, b = m.top, w = b === void 0 ? 0 : b, T = m.bottom, x = T === void 0 ? 0 : T, S = m.right, C = S === void 0 ? 0 : S, M = u ? 4 : 3, I = [];\n    g ? I = a : this.controlBox && n.groupable ? I = s : I = Jt(s, [p, v]), r.renderPoses = [Jt(l, yp(o, [-_, -w], a, I, M)), Jt(h, yp(o, [C, -w], a, I, M)), Jt(d, yp(o, [-_, x], a, I, M)), Jt(f, yp(o, [C, x], a, I, M))];\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1;\n    var r = this.props, n = r.target, s = r.container, a = r.parentMoveable, o = this.state, u = o.target, l = o.container;\n    if (!(!u && !n)) {\n      this.updateAbles();\n      var h = !C_(u, n), d = h || !C_(l, s);\n      if (d) {\n        var f = s || this.controlBox;\n        f && this.unsetAbles(), this.updateState({\n          target: n,\n          container: s\n        }), !a && f && this.updateRect(\"End\", !1, !1), this._isPropTargetChanged = h;\n      }\n    }\n  }, e.waitToChangeTarget = function() {\n    return new Promise(function() {\n    });\n  }, e.triggerEvent = function(r, n) {\n    this._emitter.trigger(r, n);\n    var s = this.props[r];\n    return s && s(n);\n  }, e.useCSS = function(r, n) {\n    var s = this.props.customStyledMap, a = r + n;\n    return s[a] || (s[a] = jT(r, n)), s[a];\n  }, e.getState = function() {\n    var r, n = this.props;\n    (n.target || !((r = n.targets) === null || r === void 0) && r.length) && (this._hasFirstTarget = !0);\n    var s = this.controlBox, a = n.persistData, o = n.firstRenderState;\n    if (o && !s)\n      return o;\n    if (!this._hasFirstTarget && a) {\n      var u = Ww(a);\n      if (u)\n        return this.updateState(u, !1), this.state;\n    }\n    return this.state.isPersisted = !1, this.state;\n  }, e.updateSelectors = function() {\n  }, e.unsetAbles = function() {\n    var r = this;\n    this.targetAbles.forEach(function(n) {\n      n.unset && n.unset(r);\n    });\n  }, e.updateAbles = function(r, n) {\n    r === void 0 && (r = this.props.ables), n === void 0 && (n = \"\");\n    var s = this.props, a = s.triggerAblesSimultaneously, o = this.getEnabledAbles(r), u = \"drag\".concat(n, \"Start\"), l = \"pinch\".concat(n, \"Start\"), h = \"drag\".concat(n, \"ControlStart\"), d = mp(o, [u, l], a), f = mp(o, [h], a);\n    this.enabledAbles = o, this.targetAbles = d, this.controlAbles = f;\n  }, e.updateState = function(r, n) {\n    if (n) {\n      if (this.isUnmounted)\n        return;\n      this.setState(r);\n    } else {\n      var s = this.state;\n      for (var a in r)\n        s[a] = r[a];\n    }\n  }, e.getEnabledAbles = function(r) {\n    r === void 0 && (r = this.props.ables);\n    var n = this.props;\n    return r.filter(function(s) {\n      return s && (s.always && n[s.name] !== !1 || n[s.name]);\n    });\n  }, e.renderAbles = function() {\n    var r = this, n = this.props, s = n.triggerAblesSimultaneously, a = {\n      createElement: Ki\n    };\n    return this.renderState = {}, ZB(vC(mp(this.getEnabledAbles(), [\"render\"], s).map(function(o) {\n      var u = o.render;\n      return u(r, a) || [];\n    })).filter(function(o) {\n      return o;\n    }), function(o) {\n      var u = o.key;\n      return u;\n    }).map(function(o) {\n      return o[0];\n    });\n  }, e.updateCheckInput = function() {\n    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);\n  }, e._getRequestStyles = function() {\n    var r = this.getEnabledAbles().reduce(function(n, s) {\n      var a, o, u = (o = (a = s.requestStyle) === null || a === void 0 ? void 0 : a.call(s)) !== null && o !== void 0 ? o : [];\n      return Tt(Tt([], n, !0), u, !0);\n    }, Tt([], this.props.requestStyles || [], !0));\n    return r;\n  }, e._updateObserver = function(r) {\n    this._updateResizeObserver(r), this._updateMutationObserver(r);\n  }, e._updateEvents = function() {\n    var r = this.controlBox, n = this.targetAbles.length, s = this.controlAbles.length, a = this.props, o = a.dragTarget || a.target, u = !n && this.targetGesto || this._isTargetChanged(!0);\n    u && (ku(this, \"targetGesto\"), this.updateState({\n      gesto: null\n    })), s || ku(this, \"controlGesto\"), o && n && !this.targetGesto && (this.targetGesto = $C(this, o, \"\")), !this.controlGesto && s && (this.controlGesto = Fx(this, r, \"controlAbles\", \"Control\"));\n  }, e._updateTargets = function() {\n    var r = this.props;\n    this._prevTarget = r.dragTarget || r.target, this._prevDragArea = r.dragArea;\n  }, e._renderLines = function() {\n    var r = this.props, n = r, s = n.zoom, a = n.hideDefaultLines, o = n.hideChildMoveableDefaultLines, u = n.parentMoveable;\n    if (a || u && o)\n      return [];\n    var l = this.getState().renderPoses, h = {\n      createElement: Ki\n    };\n    return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(d, f) {\n      var p = d[0], v = d[1];\n      return _c(h, \"\", l[p], l[v], s, \"render-line-\".concat(f));\n    });\n  }, e._isTargetChanged = function(r) {\n    var n = this.props, s = n.dragTarget || n.target, a = this._prevTarget, o = this._prevDragArea, u = n.dragArea, l = !u && a !== s, h = (r || u) && o !== u;\n    return l || h;\n  }, e._updateNativeEvents = function() {\n    var r = this, n = this.props, s = n.dragArea ? this.areaElement : this.state.target, a = this.events, o = Ps(a);\n    if (this._isTargetChanged())\n      for (var u in a) {\n        var l = a[u];\n        l && l.destroy(), a[u] = null;\n      }\n    if (s) {\n      var h = this.enabledAbles;\n      o.forEach(function(d) {\n        var f = mp(h, [d]), p = f.length > 0, v = a[d];\n        if (!p) {\n          v && (v.destroy(), a[d] = null);\n          return;\n        }\n        v || (v = new _3(s, r, d), a[d] = v), v.setAbles(f);\n      });\n    }\n  }, e._checkUpdateRootContainer = function() {\n    var r = this.props.rootContainer;\n    !this._rootContainer && r && (this._rootContainer = nu(r, !0));\n  }, e._checkUpdateViewContainer = function() {\n    var r = this.props.viewContainer;\n    !this._viewContainer && r && (this._viewContainer = nu(r, !0));\n    var n = this._viewContainer;\n    n && this._changeAbleViewClassNames(Tt(Tt([], this._getAbleViewClassNames(), !0), [this.isDragging() ? KF : \"\"], !1));\n  }, e._changeAbleViewClassNames = function(r) {\n    var n = this._viewContainer, s = pC(r.filter(Boolean), function(h) {\n      return h;\n    }).map(function(h) {\n      var d = h[0];\n      return d;\n    }), a = this._viewClassNames, o = Sd(a, s), u = o.removed, l = o.added;\n    u.forEach(function(h) {\n      dT(n, a[h]);\n    }), l.forEach(function(h) {\n      fT(n, s[h]);\n    }), this._viewClassNames = s;\n  }, e._getAbleViewClassNames = function() {\n    var r = this;\n    return (this.getEnabledAbles().map(function(n) {\n      var s;\n      return ((s = n.viewClassName) === null || s === void 0 ? void 0 : s.call(n, r)) || \"\";\n    }).join(\" \") + \" \".concat(this._getAbleClassName(\"-view\"))).split(/\\s+/g);\n  }, e._getAbleClassName = function(r) {\n    var n = this;\n    r === void 0 && (r = \"\");\n    var s = this.getEnabledAbles(), a = this.targetGesto, o = this.controlGesto, u = a != null && a.isFlag() ? a.getEventData() : {}, l = o != null && o.isFlag() ? o.getEventData() : {};\n    return s.map(function(h) {\n      var d, f, p, v = h.name, g = ((d = h.className) === null || d === void 0 ? void 0 : d.call(h, n)) || \"\";\n      return (!((f = u[v]) === null || f === void 0) && f.isEventStart || !((p = l[v]) === null || p === void 0) && p.isEventStart) && (g += \" \".concat(Pt(\"\".concat(v).concat(r, \"-dragging\")))), g.trim();\n    }).filter(Boolean).join(\" \");\n  }, e._updateResizeObserver = function(r) {\n    var n, s = this.props, a = s.target;\n    if (!window.ResizeObserver || !a || !s.useResizeObserver) {\n      (n = this._reiszeObserver) === null || n === void 0 || n.disconnect();\n      return;\n    }\n    if (!(r.target === a && this._reiszeObserver)) {\n      var o = new ResizeObserver(this.checkUpdateRect);\n      o.observe(a, {\n        box: \"border-box\"\n      }), this._reiszeObserver = o;\n    }\n  }, e._updateMutationObserver = function(r) {\n    var n = this, s, a = this.props, o = a.target;\n    if (!window.MutationObserver || !o || !a.useMutationObserver) {\n      (s = this._mutationObserver) === null || s === void 0 || s.disconnect();\n      return;\n    }\n    if (!(r.target === o && this._mutationObserver)) {\n      var u = new MutationObserver(function(l) {\n        for (var h = 0, d = l; h < d.length; h++) {\n          var f = d[h];\n          f.type === \"attributes\" && f.attributeName === \"style\" && n.checkUpdateRect();\n        }\n      });\n      u.observe(o, {\n        attributes: !0\n      }), this._mutationObserver = u;\n    }\n  }, t.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: !0,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    isWrapperMounted: !1,\n    parentPosition: null,\n    warpSelf: !1,\n    useResizeObserver: !1,\n    useMutationObserver: !1,\n    preventDefault: !0,\n    linePadding: 0,\n    controlPadding: 0,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: !1,\n    passDragArea: !1,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: !1,\n    padding: {},\n    pinchOutside: !0,\n    checkInput: !1,\n    groupable: !1,\n    hideDefaultLines: !1,\n    cspNonce: \"\",\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: !1,\n    preventClickDefault: !1,\n    preventClickEventOnDrag: !0,\n    flushSync: nC,\n    firstRenderState: null,\n    persistData: null,\n    viewContainer: null,\n    requestStyles: [],\n    useAccuratePosition: !1\n  }, t;\n}(bT), Gx = {\n  name: \"groupable\",\n  props: [\"defaultGroupRotate\", \"defaultGroupOrigin\", \"groupable\", \"groupableProps\", \"targetGroups\", \"hideChildMoveableDefaultLines\"],\n  events: [],\n  render: function(i, t) {\n    var e, r = i.props, n = r.targets || [], s = i.getState(), a = s.left, o = s.top, u = s.isPersisted, l = r.zoom || 1, h = i.renderGroupRects, d = ((e = r.persistData) === null || e === void 0 ? void 0 : e.children) || [];\n    u ? n = d.map(function() {\n      return null;\n    }) : d = [];\n    var f = i._store, p = Sw(f, \"parentPosition\", [a, o], function(g) {\n      return g.join(\",\");\n    }), v = Sw(f, \"requestStyles\", i.getRequestChildStyles(), function(g) {\n      return g.join(\",\");\n    });\n    return i.moveables = i.moveables.slice(0, n.length), Tt(Tt([], n.map(function(g, m) {\n      return t.createElement(nh, {\n        key: \"moveable\" + m,\n        ref: sT(i, \"moveables\", m),\n        target: g,\n        origin: !1,\n        requestStyles: v,\n        cssStyled: r.cssStyled,\n        customStyledMap: r.customStyledMap,\n        useResizeObserver: r.useResizeObserver,\n        hideChildMoveableDefaultLines: r.hideChildMoveableDefaultLines,\n        parentMoveable: i,\n        parentPosition: [a, o],\n        persistData: d[m],\n        zoom: l\n      });\n    }), !0), vC(h.map(function(g, m) {\n      var y = g.pos1, _ = g.pos2, b = g.pos3, w = g.pos4, T = [y, _, b, w];\n      return [[0, 1], [1, 3], [3, 2], [2, 0]].map(function(x, S) {\n        var C = x[0], M = x[1];\n        return _c(t, \"\", Mt(T[C], p), Mt(T[M], p), l, \"group-rect-\".concat(m, \"-\").concat(S));\n      });\n    })), !0);\n  }\n}, w3 = Id(\"clickable\", {\n  props: [\"clickable\"],\n  events: [\"click\", \"clickGroup\"],\n  always: !0,\n  dragRelation: \"weak\",\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dragStart: function() {\n  },\n  dragControlStart: function() {\n  },\n  dragGroupStart: function(i, t) {\n    t.datas.inputTarget = t.inputEvent && t.inputEvent.target;\n  },\n  dragEnd: function(i, t) {\n    var e = i.props.target, r = t.inputEvent, n = t.inputTarget, s = i.isMoveableElement(n), a = !s && i.controlBox.contains(n);\n    if (!(!r || !n || t.isDrag || i.isMoveableElement(n) || a)) {\n      var o = e.contains(n);\n      mt(i, \"onClick\", Ut(i, t, {\n        isDouble: t.isDouble,\n        inputTarget: n,\n        isTarget: e === n,\n        moveableTarget: i.props.target,\n        containsTarget: o\n      }));\n    }\n  },\n  dragGroupEnd: function(i, t) {\n    var e = t.inputEvent, r = t.inputTarget;\n    if (!(!e || !r || t.isDrag || i.isMoveableElement(r) || t.datas.inputTarget === r)) {\n      var n = i.props.targets, s = n.indexOf(r), a = s > -1, o = !1;\n      s === -1 && (s = Ms(n, function(u) {\n        return u.contains(r);\n      }), o = s > -1), mt(i, \"onClickGroup\", Ut(i, t, {\n        isDouble: t.isDouble,\n        targets: n,\n        inputTarget: r,\n        targetIndex: s,\n        isTarget: a,\n        containsTarget: o,\n        moveableTarget: n[s]\n      }));\n    }\n  },\n  dragControlEnd: function(i, t) {\n    this.dragEnd(i, t);\n  },\n  dragGroupControlEnd: function(i, t) {\n    this.dragEnd(i, t);\n  }\n});\nfunction yu(i) {\n  var t = i.originalDatas.draggable;\n  return t || (i.originalDatas.draggable = {}, t = i.originalDatas.draggable), F(F({}, i), {\n    datas: t\n  });\n}\nvar E3 = Id(\"edgeDraggable\", {\n  css: [`.edge.edgeDraggable.line {\ncursor: move;\n}`],\n  render: function(i, t) {\n    var e = i.props, r = e.edgeDraggable;\n    return r ? RC(t, \"edgeDraggable\", r, i.getState().renderPoses, e.zoom) : [];\n  },\n  dragCondition: function(i, t) {\n    var e, r = i.props, n = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !n ? !1 : !r.draggable && sr(n, Pt(\"direction\")) && sr(n, Pt(\"edge\")) && sr(n, Pt(\"edgeDraggable\"));\n  },\n  dragStart: function(i, t) {\n    return Or.dragStart(i, yu(t));\n  },\n  drag: function(i, t) {\n    return Or.drag(i, yu(t));\n  },\n  dragEnd: function(i, t) {\n    return Or.dragEnd(i, yu(t));\n  },\n  dragGroupCondition: function(i, t) {\n    var e, r = i.props, n = (e = t.inputEvent) === null || e === void 0 ? void 0 : e.target;\n    return !r.edgeDraggable || !n ? !1 : !r.draggable && sr(n, Pt(\"direction\")) && sr(n, Pt(\"line\"));\n  },\n  dragGroupStart: function(i, t) {\n    return Or.dragGroupStart(i, yu(t));\n  },\n  dragGroup: function(i, t) {\n    return Or.dragGroup(i, yu(t));\n  },\n  dragGroupEnd: function(i, t) {\n    return Or.dragGroupEnd(i, yu(t));\n  },\n  unset: function(i) {\n    return Or.unset(i);\n  }\n}), VC = {\n  name: \"individualGroupable\",\n  props: [\"individualGroupable\", \"individualGroupableProps\"],\n  events: []\n}, Ux = [zC, FC, HF, rF, Or, E3, R_, WF, qF, XF, t3, e3, JF, d3, f3, m3, Gx, VC, w3, BC, HC], S3 = /* @__PURE__ */ Ux.reduce(function(i, t) {\n  return (t.events || []).forEach(function(e) {\n    cT(i, e);\n  }), i;\n}, []), T3 = /* @__PURE__ */ Ux.reduce(function(i, t) {\n  return (t.props || []).forEach(function(e) {\n    cT(i, e);\n  }), i;\n}, []);\nfunction Yw(i, t) {\n  var e = i[0], r = i[1], n = i[2];\n  return (e * t[0] + r * t[1] + n) / Math.sqrt(e * e + r * r);\n}\nfunction wp(i, t) {\n  var e = i[0], r = i[1];\n  return -e * t[0] - r * t[1];\n}\nfunction qw(i, t) {\n  return Math.max.apply(Math, i.map(function(e) {\n    var r = e[0], n = e[1], s = e[2], a = e[3];\n    return Math.max(r[t], n[t], s[t], a[t]);\n  }));\n}\nfunction Zw(i, t) {\n  return Math.min.apply(Math, i.map(function(e) {\n    var r = e[0], n = e[1], s = e[2], a = e[3];\n    return Math.min(r[t], n[t], s[t], a[t]);\n  }));\n}\nfunction C3(i, t) {\n  var e, r = [0, 0], n = [0, 0], s = [0, 0], a = [0, 0], o = 0, u = 0;\n  if (!i.length)\n    return {\n      pos1: r,\n      pos2: n,\n      pos3: s,\n      pos4: a,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width: o,\n      height: u,\n      rotation: t\n    };\n  var l = Gt(t, Rr);\n  if (l % 90) {\n    var h = l / 180 * Math.PI, d = Math.tan(h), f = -1 / d, p = [E_, xw], v = [[0, 0], [0, 0]], g = [E_, xw], m = [[0, 0], [0, 0]];\n    i.forEach(function(H) {\n      H.forEach(function(z) {\n        var X = Yw([-d, 1, 0], z), ct = Yw([-f, 1, 0], z);\n        p[0] > X && (v[0] = z, p[0] = X), p[1] < X && (v[1] = z, p[1] = X), g[0] > ct && (m[0] = z, g[0] = ct), g[1] < ct && (m[1] = z, g[1] = ct);\n      });\n    });\n    var y = v[0], _ = v[1], b = m[0], w = m[1], T = [-d, 1, wp([-d, 1], y)], x = [-d, 1, wp([-d, 1], _)], S = [-f, 1, wp([-f, 1], b)], C = [-f, 1, wp([-f, 1], w)];\n    e = [[T, S], [T, C], [x, S], [x, C]].map(function(H) {\n      var z = H[0], X = H[1];\n      return mx(z, X)[0];\n    }), r = e[0], n = e[1], s = e[2], a = e[3], o = g[1] - g[0], u = p[1] - p[0];\n  } else {\n    var M = Zw(i, 0), I = Zw(i, 1), R = qw(i, 0), N = qw(i, 1);\n    if (r = [M, I], n = [R, I], s = [M, N], a = [R, N], o = R - M, u = N - I, l % 180) {\n      var A = [s, r, a, n];\n      r = A[0], n = A[1], s = A[2], a = A[3], o = N - I, u = R - M;\n    }\n  }\n  if (l % 360 > 180) {\n    var A = [a, s, n, r];\n    r = A[0], n = A[1], s = A[2], a = A[3];\n  }\n  var U = ru([r, n, s, a]), B = U.minX, G = U.minY, $ = U.maxX, Z = U.maxY;\n  return {\n    pos1: r,\n    pos2: n,\n    pos3: s,\n    pos4: a,\n    width: o,\n    height: u,\n    minX: B,\n    minY: G,\n    maxX: $,\n    maxY: Z,\n    rotation: t\n  };\n}\nfunction XC(i, t) {\n  var e = t.map(function(r) {\n    if (tr(r)) {\n      var n = XC(i, r), s = n.length;\n      return s > 1 ? n : s === 1 ? n[0] : null;\n    } else {\n      var a = nn(i, function(o) {\n        var u = o.manager;\n        return u.props.target === r;\n      });\n      return a ? (a.finded = !0, a.manager) : null;\n    }\n  }).filter(Boolean);\n  return e.length === 1 && tr(e[0]) ? e[0] : e;\n}\nvar M3 = /* @__PURE__ */ function(i) {\n  Od(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.differ = new BT(), r.moveables = [], r.transformOrigin = \"50% 50%\", r.renderGroupRects = [], r._targetGroups = [], r._hasFirstTargets = !1, r;\n  }\n  var e = t.prototype;\n  return e.componentDidMount = function() {\n    i.prototype.componentDidMount.call(this);\n  }, e.checkUpdate = function() {\n    this._isPropTargetChanged = !1, this.updateAbles();\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, n, s) {\n    var a;\n    s === void 0 && (s = !0);\n    var o = this.state;\n    if (!this.controlBox || o.isPersisted)\n      return;\n    eh(!0), this.moveables.forEach(function(Q) {\n      Q.updateRect(r, !1, !1);\n    });\n    var u = this.props, l = this.moveables, h = o.target || u.target, d = l.map(function(Q) {\n      return {\n        finded: !1,\n        manager: Q\n      };\n    }), f = this.props.targetGroups || [], p = XC(d, f);\n    p.push.apply(p, d.filter(function(Q) {\n      var St = Q.finded;\n      return !St;\n    }).map(function(Q) {\n      var St = Q.manager;\n      return St;\n    }));\n    var v = [], g = !n || r !== \"\" && u.updateGroup, m = u.defaultGroupRotate || 0;\n    if (!this._hasFirstTargets) {\n      var y = (a = this.props.persistData) === null || a === void 0 ? void 0 : a.rotation;\n      y != null && (m = y);\n    }\n    function _(Q, St, at) {\n      var q = Q.map(function(xt) {\n        if (tr(xt)) {\n          var Dt = _(xt, St), Ct = [Dt.pos1, Dt.pos2, Dt.pos3, Dt.pos4];\n          return v.push(Dt), {\n            poses: Ct,\n            rotation: Dt.rotation\n          };\n        } else\n          return {\n            poses: Ci(xt.state),\n            rotation: xt.getRotation()\n          };\n      }), bt = q.map(function(xt) {\n        var Dt = xt.rotation;\n        return Dt;\n      }), st = 0, W = bt[0], nt = bt.every(function(xt) {\n        return Math.abs(W - xt) < 0.1;\n      });\n      g ? st = nt ? W : m : st = !at && nt ? W : St;\n      var dt = q.map(function(xt) {\n        var Dt = xt.poses;\n        return Dt;\n      }), V = C3(dt, st);\n      return V;\n    }\n    var b = _(p, this.rotation, !0);\n    g && (this.rotation = b.rotation, this.transformOrigin = u.defaultGroupOrigin || \"50% 50%\", this.scale = [1, 1]), this._targetGroups = f, this.renderGroupRects = v;\n    var w = this.transformOrigin, T = this.rotation, x = this.scale, S = b.width, C = b.height, M = b.minX, I = b.minY, R = eF([[0, 0], [S, 0], [0, C], [S, C]], tF(w, S, C), this.rotation / 180 * Math.PI), N = ru(R.result), A = N.minX, U = N.minY, B = \" rotate(\".concat(T, \"deg)\") + \" scale(\".concat(x[0] >= 0 ? 1 : -1, \", \").concat(x[1] >= 0 ? 1 : -1, \")\"), G = \"translate(\".concat(-A, \"px, \").concat(-U, \"px)\").concat(B);\n    this.controlBox.style.transform = \"translate3d(\".concat(M, \"px, \").concat(I, \"px, \").concat(this.props.translateZ || 0, \")\"), h.style.cssText += \"left:0px;top:0px;\" + \"transform-origin:\".concat(w, \";\") + \"width:\".concat(S, \"px;height:\").concat(C, \"px;\") + \"transform: \".concat(G), o.width = S, o.height = C;\n    var $ = this.getContainer(), Z = N_(this.controlBox, h, this.controlBox, this.getContainer(), this._rootContainer || $, []), H = [Z.left, Z.top], z = Ci(Z), X = z[0], ct = z[1], it = z[2], lt = z[3], et = ru([X, ct, it, lt]), k = [et.minX, et.minY], ft = x[0] * x[1] > 0 ? 1 : -1;\n    Z.pos1 = Mt(X, k), Z.pos2 = Mt(ct, k), Z.pos3 = Mt(it, k), Z.pos4 = Mt(lt, k), Z.left = M - Z.left + k[0], Z.top = I - Z.top + k[1], Z.origin = Mt(Jt(H, Z.origin), k), Z.beforeOrigin = Mt(Jt(H, Z.beforeOrigin), k), Z.originalBeforeOrigin = Jt(H, Z.originalBeforeOrigin), Z.transformOrigin = Mt(Jt(H, Z.transformOrigin), k), h.style.transform = \"translate(\".concat(-A - k[0], \"px, \").concat(-U - k[1], \"px)\") + B, eh(), this.updateState(F(F({}, Z), {\n      posDelta: k,\n      direction: ft,\n      beforeDirection: ft\n    }), s);\n  }, e.getRect = function() {\n    return F(F({}, i.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.triggerEvent = function(r, n, s) {\n    if (s || r.indexOf(\"Group\") > -1)\n      return i.prototype.triggerEvent.call(this, r, n);\n    this._emitter.trigger(r, n);\n  }, e.getRequestChildStyles = function() {\n    var r = this.getEnabledAbles().reduce(function(n, s) {\n      var a, o, u = (o = (a = s.requestChildStyle) === null || a === void 0 ? void 0 : a.call(s)) !== null && o !== void 0 ? o : [];\n      return Tt(Tt([], n, !0), u, !0);\n    }, []);\n    return r;\n  }, e.updateAbles = function() {\n    i.prototype.updateAbles.call(this, Tt(Tt([], this.props.ables, !0), [Gx], !1), \"Group\");\n  }, e._updateTargets = function() {\n    i.prototype._updateTargets.call(this), this._prevTarget = this.props.dragTarget || this.areaElement;\n  }, e._updateEvents = function() {\n    var r = this.state, n = this.props, s = this._prevTarget, a = n.dragTarget || this.areaElement;\n    s !== a && (ku(this, \"targetGesto\"), ku(this, \"controlGesto\"), r.target = null), r.target || (r.target = this.areaElement, this.controlBox.style.display = \"block\"), r.target && (this.targetGesto || (this.targetGesto = $C(this, a, \"Group\")), this.controlGesto || (this.controlGesto = Fx(this, this.controlBox, \"controlAbles\", \"GroupControl\")));\n    var o = !C_(r.container, n.container);\n    o && (r.container = n.container);\n    var u = n.targets, l = this.differ.update(u), h = l.added, d = l.changed, f = l.removed, p = h.length || f.length;\n    (o || p || this.transformOrigin !== (n.defaultGroupOrigin || \"50% 50%\") || d.length || u.length && !_C(this._targetGroups, n.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!p;\n  }, e._updateObserver = function() {\n  }, t.defaultProps = F(F({}, nh.defaultProps), {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: !0,\n    dragArea: !0,\n    keepRatio: !0,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  }), t;\n}(nh), P3 = /* @__PURE__ */ function(i) {\n  Od(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.moveables = [], r;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    var r = this, n, s = this.props, a = s.cspNonce, o = s.cssStyled, u = s.persistData, l = s.targets || [], h = l.length, d = this.isUnmounted || !h, f = (n = u == null ? void 0 : u.children) !== null && n !== void 0 ? n : [];\n    return d && !h && f.length ? l = f.map(function() {\n      return null;\n    }) : d || (f = []), Ki(o, {\n      cspNonce: a,\n      ref: Es(this, \"controlBox\"),\n      className: Pt(\"control-box\")\n    }, l.map(function(p, v) {\n      var g, m, y = (m = (g = s.individualGroupableProps) === null || g === void 0 ? void 0 : g.call(s, p, v)) !== null && m !== void 0 ? m : {};\n      return Ki(nh, F({\n        key: \"moveable\" + v,\n        ref: sT(r, \"moveables\", v)\n      }, s, y, {\n        target: p,\n        wrapperMoveable: r,\n        isWrapperMounted: r.isMoveableMounted,\n        persistData: f[v]\n      }));\n    }));\n  }, e.componentDidUpdate = function() {\n  }, e.getTargets = function() {\n    return this.props.targets;\n  }, e.updateRect = function(r, n, s) {\n    s === void 0 && (s = !0), eh(!0), this.moveables.forEach(function(a) {\n      a.updateRect(r, n, s);\n    }), eh();\n  }, e.getRect = function() {\n    return F(F({}, i.prototype.getRect.call(this)), {\n      children: this.moveables.map(function(r) {\n        return r.getRect();\n      })\n    });\n  }, e.request = function() {\n    return {\n      request: function() {\n        return this;\n      },\n      requestEnd: function() {\n        return this;\n      }\n    };\n  }, e.dragStart = function() {\n    return this;\n  }, e.hitTest = function() {\n    return 0;\n  }, e.isInside = function() {\n    return !1;\n  }, e.isDragging = function() {\n    return !1;\n  }, e.updateRenderPoses = function() {\n  }, e.checkUpdate = function() {\n  }, e.triggerEvent = function() {\n  }, e.updateAbles = function() {\n  }, e._updateEvents = function() {\n  }, e._updateObserver = function() {\n  }, t;\n}(nh);\nfunction WC(i, t) {\n  var e = [];\n  return i.forEach(function(r) {\n    if (r) {\n      if (Vr(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      tr(r) ? e.push.apply(e, WC(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction YC(i, t) {\n  var e = [];\n  return i.forEach(function(r) {\n    if (r) {\n      if (Vr(r)) {\n        t[r] && e.push.apply(e, t[r]);\n        return;\n      }\n      tr(r) ? e.push(YC(r, t)) : e.push(r);\n    }\n  }), e;\n}\nfunction qC(i, t) {\n  return i.length !== t.length || i.some(function(e, r) {\n    var n = t[r];\n    return !e && !n ? !1 : e != n ? tr(e) && tr(n) ? qC(e, n) : !0 : !1;\n  });\n}\nvar O3 = /* @__PURE__ */ function(i) {\n  Od(t, i);\n  function t() {\n    var r = i !== null && i.apply(this, arguments) || this;\n    return r.refTargets = [], r.selectorMap = {}, r._differ = new BT(), r._elementTargets = [], r._onChangeTargets = null, r;\n  }\n  var e = t.prototype;\n  return t.makeStyled = function() {\n    var r = {}, n = this.getTotalAbles();\n    n.forEach(function(a) {\n      var o = a.css;\n      o && o.forEach(function(u) {\n        r[u] = !0;\n      });\n    });\n    var s = Ps(r).join(`\n`);\n    this.defaultStyled = jT(\"div\", PA(_x, _B + s));\n  }, t.getTotalAbles = function() {\n    return Tt([FC, Gx, VC, BC], this.defaultAbles, !0);\n  }, e.render = function() {\n    var r, n = this.constructor;\n    n.defaultStyled || n.makeStyled();\n    var s = this.props, a = s.ables, o = s.props, u = oB(s, [\"ables\", \"props\"]), l = this._updateRefs(!0), h = WC(l, this.selectorMap), d = h.length > 1, f = n.getTotalAbles(), p = Tt(Tt([], f, !0), a || [], !0), v = F(F(F({}, u), o || {}), {\n      ables: p,\n      cssStyled: n.defaultStyled,\n      customStyledMap: n.customStyledMap\n    });\n    this._elementTargets = h;\n    var g = null, m = this.moveable, y = u.persistData;\n    if (y != null && y.children && (d = !0), u.individualGroupable)\n      return Ki(P3, F({\n        key: \"individual-group\",\n        ref: Es(this, \"moveable\")\n      }, v, {\n        target: null,\n        targets: h\n      }));\n    if (d) {\n      var _ = YC(l, this.selectorMap);\n      if (m && !m.props.groupable && !m.props.individualGroupable) {\n        var b = m.props.target;\n        b && h.indexOf(b) > -1 && (g = F({}, m.state));\n      }\n      return Ki(M3, F({\n        key: \"group\",\n        ref: Es(this, \"moveable\")\n      }, v, (r = u.groupableProps) !== null && r !== void 0 ? r : {}, {\n        target: null,\n        targets: h,\n        targetGroups: _,\n        firstRenderState: g\n      }));\n    } else {\n      var w = h[0];\n      if (m && (m.props.groupable || m.props.individualGroupable)) {\n        var T = m.moveables || [], x = nn(T, function(S) {\n          return S.props.target === w;\n        });\n        x && (g = F({}, x.state));\n      }\n      return Ki(nh, F({\n        key: \"single\",\n        ref: Es(this, \"moveable\")\n      }, v, {\n        target: w,\n        firstRenderState: g\n      }));\n    }\n  }, e.componentDidMount = function() {\n    this._checkChangeTargets(), this._updateRefs();\n  }, e.componentDidUpdate = function() {\n    this._checkChangeTargets();\n  }, e.componentWillUnmount = function() {\n    this.selectorMap = {}, this.refTargets = [];\n  }, e.getTargets = function() {\n    var r, n;\n    return (n = (r = this.moveable) === null || r === void 0 ? void 0 : r.getTargets()) !== null && n !== void 0 ? n : [];\n  }, e.updateSelectors = function() {\n    this.selectorMap = {}, this._updateRefs();\n  }, e.waitToChangeTarget = function() {\n    var r = this, n;\n    return this._onChangeTargets = function() {\n      r._onChangeTargets = null, n();\n    }, new Promise(function(s) {\n      n = s;\n    });\n  }, e.waitToChangeTargets = function() {\n    return this.waitToChangeTarget();\n  }, e.getManager = function() {\n    return this.moveable;\n  }, e._updateRefs = function(r) {\n    var n = this.refTargets, s = Ox(this.props.target || this.props.targets), a = typeof document < \"u\", o = qC(n, s), u = this.selectorMap, l = {};\n    return this.refTargets.forEach(function h(d) {\n      if (Vr(d)) {\n        var f = u[d];\n        f ? l[d] = u[d] : a && (o = !0, l[d] = [].slice.call(document.querySelectorAll(d)));\n      } else\n        tr(d) && d.forEach(h);\n    }), this.refTargets = s, this.selectorMap = l, !r && o && this.forceUpdate(), s;\n  }, e._checkChangeTargets = function() {\n    var r, n, s, a = this._differ.update(this._elementTargets), o = a.added, u = a.removed, l = o.length || u.length;\n    l && ((n = (r = this.props).onChangeTargets) === null || n === void 0 || n.call(r, {\n      moveable: this.moveable,\n      targets: this._elementTargets\n    }), (s = this._onChangeTargets) === null || s === void 0 || s.call(this)), this._updateRefs();\n  }, t.defaultAbles = [], t.customStyledMap = {}, t.defaultStyled = null, uB([OA(WT)], t.prototype, \"moveable\", void 0), t;\n}(bT), I3 = /* @__PURE__ */ function(i) {\n  Od(t, i);\n  function t() {\n    return i !== null && i.apply(this, arguments) || this;\n  }\n  return t.defaultAbles = Ux, t;\n}(O3), R3 = I3, A_ = function(i, t) {\n  return A_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, r) {\n    e.__proto__ = r;\n  } || function(e, r) {\n    for (var n in r)\n      Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n  }, A_(i, t);\n};\nfunction jx(i, t) {\n  if (typeof t != \"function\" && t !== null)\n    throw new TypeError(\"Class extends value \" + String(t) + \" is not a constructor or null\");\n  A_(i, t);\n  function e() {\n    this.constructor = i;\n  }\n  i.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());\n}\nvar bc = function() {\n  return bc = Object.assign || function(t) {\n    for (var e, r = 1, n = arguments.length; r < n; r++) {\n      e = arguments[r];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);\n    }\n    return t;\n  }, bc.apply(this, arguments);\n};\nfunction D3(i, t, e, r) {\n  var n = arguments.length, s = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, e) : r, a;\n  if (typeof Reflect == \"object\" && typeof Reflect.decorate == \"function\")\n    s = Reflect.decorate(i, t, e, r);\n  else\n    for (var o = i.length - 1; o >= 0; o--)\n      (a = i[o]) && (s = (n < 3 ? a(s) : n > 3 ? a(t, e, s) : a(t, e)) || s);\n  return n > 3 && s && Object.defineProperty(t, e, s), s;\n}\nvar k3 = /* @__PURE__ */ function(i) {\n  jx(t, i);\n  function t(r) {\n    var n = i.call(this, r) || this;\n    return n.state = {}, n.state = n.props, n;\n  }\n  var e = t.prototype;\n  return e.render = function() {\n    return Ki(R3, bc({\n      ref: Es(this, \"moveable\")\n    }, this.state));\n  }, t;\n}(cx), N3 = T3, A3 = WT, L3 = S3, B3 = /* @__PURE__ */ function(i) {\n  jx(t, i);\n  function t(r, n) {\n    n === void 0 && (n = {});\n    var s = i.call(this) || this;\n    s.containerProvider = null, s.selfElement = null, s._warp = !1;\n    var a = bc({}, n), o = {};\n    L3.forEach(function(h) {\n      o[FA(\"on \".concat(h))] = function(d) {\n        return s.trigger(h, d);\n      };\n    });\n    var u;\n    n.warpSelf ? (delete n.warpSelf, s._warp = !0, u = r) : (u = document.createElement(\"div\"), r.appendChild(u)), s.containerProvider = vw(Ki(k3, bc({\n      ref: Es(s, \"innerMoveable\")\n    }, a, o)), u);\n    var l = a.target;\n    return tr(l) && l.length > 1 && s.updateRect(), s;\n  }\n  var e = t.prototype;\n  return e.setState = function(r, n) {\n    this.innerMoveable.setState(r, n);\n  }, e.forceUpdate = function(r) {\n    this.innerMoveable.forceUpdate(r);\n  }, e.dragStart = function(r) {\n    var n = this.innerMoveable;\n    n.$_timer && this.forceUpdate(), this.getMoveable().dragStart(r);\n  }, e.destroy = function() {\n    var r, n = this.selfElement;\n    vw(null, n, this.containerProvider), this._warp || (r = n == null ? void 0 : n.parentElement) === null || r === void 0 || r.removeChild(n), this.containerProvider = null, this.off(), this.selfElement = null, this.innerMoveable = null;\n  }, e.getMoveable = function() {\n    return this.innerMoveable.moveable;\n  }, t = D3([ow(A3, function(r, n) {\n    r[n] || (r[n] = function() {\n      for (var s = [], a = 0; a < arguments.length; a++)\n        s[a] = arguments[a];\n      var o = this.getMoveable();\n      if (!(!o || !o[n]))\n        return o[n].apply(o, s);\n    });\n  }), ow(N3, function(r, n) {\n    Object.defineProperty(r, n, {\n      get: function() {\n        return this.getMoveable().props[n];\n      },\n      set: function(s) {\n        var a;\n        this.setState((a = {}, a[n] = s, a));\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  })], t), t;\n}(l0), F3 = /* @__PURE__ */ function(i) {\n  jx(t, i);\n  function t() {\n    return i !== null && i.apply(this, arguments) || this;\n  }\n  return t;\n}(B3), hn, Qu, tl, el, rl, qc, qa, Za, Zc, L_;\nconst pt = class {\n  constructor(t, e = !1) {\n    // divでmovを更新\n    E(this, Zc);\n    K(this, \"hArg\", {});\n    K(this, \"id_tag\", \"\");\n    K(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0\n    });\n    K(this, \"child\");\n    K(this, \"parent\");\n    K(this, \"fncLay\", () => {\n    });\n    K(this, \"mov\");\n    K(this, \"div\");\n    K(this, \"lx\", 0);\n    // これ以後の this変数スケールは SKYNovel スクリプト値\n    K(this, \"ly\", 0);\n    K(this, \"rect\", Nt.EMPTY);\n    // cvsResizeBaseやhint座標など計算用\n    K(this, \"pivot\", new xe(0, 0));\n    K(this, \"scale\", new xe(1, 1));\n    K(this, \"rotation\", 0);\n    K(this, \"oldFn\", () => \"\");\n    K(this, \"rotatable\", !0);\n    this.bg_col = t, this.isLay = e;\n  }\n  static init(t, e, r, n, s, a, o) {\n    pt.sys = e, P(pt, Qu, r), pt.prpPrs = n, P(pt, tl, s), P(pt, el, a), pt.hPages = o, Ur.cvs.insertAdjacentHTML(\"beforebegin\", `<div id=\"${c(pt, rl)}\" style=\"width: ${Y.stageW * e.cvsScale}px; height: ${Y.stageH * e.cvsScale}px; background: rgba(0,0,0,0); position: absolute; touch-action: none; user-select: none; display: none;\"></div>`), P(pt, hn, document.getElementById(c(pt, rl))), pt.divHint.classList.add(\"sn_design_hint\"), t.view.parentElement.appendChild(pt.divHint), Lu(`\n.sn_design_cast {\n\tposition: absolute; touch-action: none; user-select: none;\n\topacity: 0.6; border-radius: 8px;\n}\n\n.sn_design_cast.drag_border {\n\tline-height: 1.8;\n\tborder: dashed 5px #333;\n}\n\n.sn_design_hint {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tpadding: 5px;\n\tborder-radius: 5px;\n\tbackground: #333;\n\tz-index: 10;\n\tcolor: #fff;\n\tfont-weight: bold;\n\tfont-size: 12px;\n\tdisplay: none;\n}\n`);\n  }\n  static setHint(t, e, r, n) {\n    pt.divHint.innerHTML = t;\n    const s = window.getComputedStyle(pt.divHint), a = parseFloat(s.width), o = parseFloat(s.height);\n    pt.divHint.style.cssText = `display: block; left: ${Math.max(10, n.lx + e - a)}px;\n\t\ttop: ${Math.max(10, n.ly + r - o - 10)}px;`;\n  }\n  static cvsResizeDesign() {\n    const t = c(pt, hn).style;\n    t.width = `${Y.stageW * pt.sys.cvsScale}px`, t.height = `${Y.stageH * pt.sys.cvsScale}px`;\n  }\n  destroy() {\n    var t;\n    this.div = void 0, (t = this.mov) == null || t.destroy(), this.mov = void 0;\n  }\n  gethArg() {\n    return this.hArg;\n  }\n  sethArg(t) {\n    if (!this.includeDesignArg(t))\n      return;\n    this.id_tag || (this.id_tag = t[\":id_tag\"] ?? \"\"), this.hArg = t;\n    const e = t[\":id_dc\"] ?? this.id_tag;\n    c(pt, qa)[e] = this;\n  }\n  includeDesignArg(t) {\n    return Object.keys(t).some((e) => e in this.hDesignArg);\n  }\n  getRect() {\n    return Nt.EMPTY;\n  }\n  cnvPosArg(t, e) {\n    return {};\n  }\n  cnvSizeArg(t, e) {\n    return {};\n  }\n  setPos(t, e) {\n  }\n  setSize(t, e) {\n  }\n  setOther(t) {\n  }\n  adopt(t) {\n    this.child = t, t.parent = this;\n  }\n  static enterMode() {\n    pt.leaveMode(), c(pt, hn).style.display = \"inline\", P(pt, qc, 0), P(pt, qa, {});\n  }\n  static allHide() {\n    c(pt, Za).forEach((t) => t.visible = !1);\n  }\n  set visible(t) {\n    !this.div || !this.mov || (this.div.style.display = t ? \"inline\" : \"none\", this.mov.updateTarget());\n  }\n  static leaveMode() {\n    c(pt, hn).textContent = \"\", c(pt, hn).style.display = \"none\", c(pt, Za).forEach((t) => t.destroy()), P(pt, Za, []);\n  }\n  cvsResize() {\n    var t;\n    O(this, Zc, L_).call(this), (t = this.mov) == null || t.updateTarget();\n  }\n  onDragStart() {\n  }\n  make() {\n    const t = this.hArg[\":id_dc\"] ?? this.id_tag;\n    c(pt, qa)[t] = this;\n    const e = this.div = document.createElement(\"div\");\n    e.id = c(pt, rl) + \"_\" + ++Ve(pt, qc)._, e.classList.add(\"sn_design_cast\"), e.dataset.id_dc = t, e.style.backgroundColor = `${this.bg_col}`, e.style.display = \"none\", this.rect = this.getRect(), O(this, Zc, L_).call(this), (this.parent ? document.querySelector(\n      `[data-id_dc=\"${this.parent.id_tag}\"]`\n      // 親なので\n    ) ?? c(pt, hn) : c(pt, hn)).appendChild(e);\n    const r = {\n      // movがdivを操作する際の雑用。スケールはHTML DOM\n      aPos: [0, 0],\n      roDeg: 0,\n      trOrg: \"\",\n      origin: [0, 0]\n    }, n = () => {\n      r.aPos = [NaN, NaN], r.roDeg = this.rotation;\n      const u = this.pivot.x * pt.sys.cvsScale, l = this.pivot.y * pt.sys.cvsScale;\n      r.trOrg = `${u}px ${l}px`, r.origin = [u, l];\n    }, s = (u) => {\n      pt.sys.send2Dbg(\"_changeCast\", {\n        ...u,\n        \":id_tag\": this.id_tag\n      }), pt.divHint.style.display = \"none\";\n    }, a = () => {\n      const [u, l] = r.aPos;\n      if (isNaN(u)) {\n        pt.divHint.style.display = \"none\";\n        return;\n      }\n      const h = $t(this.rect.x += u / pt.sys.cvsScale + this.pivot.x), d = $t(this.rect.y += l / pt.sys.cvsScale + this.pivot.y);\n      this.setPos(h, d);\n      const f = ni(this.rect.width), p = ni(this.rect.height);\n      this.setSize(f, p), s({\n        ...this.cnvPosArg(h, d),\n        ...this.cnvSizeArg(f, p)\n      });\n    };\n    let o;\n    this.mov = new F3(document.body, {\n      target: e,\n      draggable: !0,\n      resizable: !0,\n      //\tscalable\t: true,\n      rotatable: this.rotatable,\n      originDraggable: this.rotatable,\n      snappable: !0\n    }).on(\"dragStart\", (u) => {\n      var h;\n      n(), this.onDragStart();\n      const l = (h = this.child) == null ? void 0 : h.mov;\n      l && (o = l.target, l.isInside(u.clientX, u.clientY) && (l.target = void 0));\n    }).on(\"drag\", (u) => {\n      r.aPos = u.beforeTranslate, this.procDragHint(u, u.left, u.top);\n    }).on(\"dragEnd\", () => {\n      var u, l;\n      a(), (u = this.child) != null && u.mov && (this.child.mov.target = o), (l = this.parent) != null && l.mov && (this.parent.mov.target = this.parent.div);\n    }).on(\"resizeStart\", n).on(\"resize\", (u) => {\n      e.style.width = `${u.width}px`, e.style.height = `${u.height}px`, r.aPos = u.drag.beforeTranslate, this.rect.width = u.width / pt.sys.cvsScale, this.rect.height = u.height / pt.sys.cvsScale, this.procResizeHint(u, u.drag.left, u.drag.top);\n    }).on(\"resizeEnd\", a).on(\"rotateStart\", (u) => {\n      n(), u.set(r.roDeg);\n    }).on(\"rotate\", (u) => {\n      r.roDeg = u.beforeRotate, pt.setHint($t(r.roDeg) + \"度\", u.drag.left, u.drag.top, this);\n    }).on(\"rotateEnd\", () => {\n      this.rotation = r.roDeg, this.setOther({}), s({ rotation: $t(r.roDeg) });\n    }).on(\"dragOriginStart\", () => n).on(\"dragOrigin\", (u) => {\n      r.trOrg = u.transformOrigin, r.origin = u.origin;\n    }).on(\"dragOriginEnd\", () => {\n      const [u, l] = r.origin;\n      r.trOrg = `${u}px ${l}px`;\n      const h = this.pivot.x = u / pt.sys.cvsScale, d = this.pivot.y = l / pt.sys.cvsScale;\n      this.setOther({});\n      const f = $t(this.rect.x + h), p = $t(this.rect.y + d);\n      this.setPos(f, p), s({\n        ...this.cnvPosArg(f, p),\n        pivot_x: $t(h),\n        pivot_y: $t(d)\n      });\n    }).on(\"render\", () => {\n      const { aPos: u, roDeg: l, trOrg: h } = r;\n      e.style.transformOrigin = h, e.style.transform = `translate(${u[0]}px, ${u[1]}px) rotate(${l}deg)`;\n    }), c(pt, Za).push(this), e.addEventListener(\"dragenter\", () => e.classList.add(\"drag_border\")), e.addEventListener(\"dragover\", (u) => {\n      u.stopPropagation(), u.preventDefault(), u.dataTransfer && (u.dataTransfer.dropEffect = \"copy\");\n    }), e.addEventListener(\"dragleave\", () => e.classList.remove(\"drag_border\")), e.addEventListener(\"drop\", (u) => {\n      u.stopPropagation(), u.preventDefault(), e.classList.remove(\"drag_border\");\n      const l = u.dataTransfer;\n      if (!l || l.files.length === 0)\n        return;\n      const h = l.files[0], d = {\n        \":id_tag\": this.id_tag,\n        fn: Xh(h.name),\n        ext: uv(h.name),\n        url: \"\",\n        buf: new ArrayBuffer(0),\n        old_fn: this.oldFn(),\n        old_url: c(pt, el).searchPath(this.oldFn(), vr.SP_GSM)\n      };\n      h.arrayBuffer().then((f) => {\n        d.buf = f;\n        try {\n          d.url = c(pt, Qu).cnvPath4Dbg(\n            c(pt, el).searchPath(h.name, vr.SP_GSM)\n          );\n        } catch {\n        }\n        pt.sys.send2Dbg(\"_dropFile\", d);\n      }).catch((f) => console.error(\"drop2dc %o\", f));\n    }), e.addEventListener(\"dblclick\", (u) => {\n      u.preventDefault(), pt.sys.send2Dbg(\"_focusScript\", this.hArg);\n    });\n  }\n  procDragHint(t, e, r) {\n    const [n, s] = t.beforeTranslate;\n    pt.setHint(\n      `(${$t(this.rect.x + n / pt.sys.cvsScale)}, ${$t(this.rect.y + s / pt.sys.cvsScale)})`,\n      e,\n      r,\n      this\n    );\n  }\n  procResizeHint(t, e, r) {\n    pt.setHint(\n      `(${$t(t.drag.left)}, ${$t(t.drag.top)})<br/>${$t(this.rect.width)} x ${$t(this.rect.height)}`,\n      e,\n      r,\n      this\n    );\n  }\n  static replaceToken(t) {\n    var h, d, f, p, v, g, m, y;\n    const r = t[\":id_tag\"], n = c(pt, qa)[r];\n    if (!document.querySelector(`div[data-id_dc='${r}']`) || !n)\n      return;\n    const a = t[\":token\"];\n    c(pt, Qu).replace(t[\":idx_tkn\"], a);\n    const [o, u] = Rp(a);\n    n.child && (n.child.hArg[\":token\"] = n.hArg[\":token\"]), c(pt, tl).parse(u);\n    const l = c(pt, tl).hPrm;\n    if (\"pivot_x\" in l || \"pivot_y\" in l) {\n      const _ = Number(pt.prpPrs.getValAmpersand(l.pivot_x.val)), b = Number(pt.prpPrs.getValAmpersand(l.pivot_y.val));\n      (isNaN(_) || isNaN(b)) && zt.myTrace(`pivot_xかpivot_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${a}`, \"F\"), n.pivot.set(_, b);\n    }\n    if (\"left\" in l || \"top\" in l || \"x\" in l || \"y\" in l) {\n      const _ = $t(pt.prpPrs.getValAmpersand(((h = l.left) == null ? void 0 : h.val) ?? ((d = l.x) == null ? void 0 : d.val) ?? \"0\")), b = $t(pt.prpPrs.getValAmpersand(((f = l.top) == null ? void 0 : f.val) ?? ((p = l.y) == null ? void 0 : p.val) ?? \"0\"));\n      (isNaN(_) || isNaN(b)) && zt.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${a}`, \"F\"), n.rect.x = _ - n.pivot.x, n.rect.y = b - n.pivot.y, n.setPos(_, b);\n    }\n    if (\"width\" in l || \"height\" in l) {\n      const _ = $t(pt.prpPrs.getValAmpersand(((v = l.width) == null ? void 0 : v.val) ?? \"0\")), b = $t(pt.prpPrs.getValAmpersand(((g = l.height) == null ? void 0 : g.val) ?? \"0\"));\n      (isNaN(_) || isNaN(b)) && zt.myTrace(`widthかheightが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${a}`, \"F\"), n.rect.width = _, n.rect.height = b, n.setSize(_, b);\n    }\n    if (\"scale_x\" in l || \"scale_y\" in l) {\n      const _ = Number(pt.prpPrs.getValAmpersand(((m = l.scale_x) == null ? void 0 : m.val) ?? \"0\")), b = Number(pt.prpPrs.getValAmpersand(((y = l.scale_y) == null ? void 0 : y.val) ?? \"0\"));\n      (isNaN(_) || isNaN(b)) && zt.myTrace(`scale_xかscale_yが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${a}`, \"F\"), n.scale.set(_, b);\n    }\n    if (\"rotation\" in l) {\n      const _ = Number(pt.prpPrs.getValAmpersand(l.rotation.val));\n      isNaN(_) && zt.myTrace(`rotationが数値ではありません\n(fn:${t[\":path\"].slice(13)} ln:${t[\":ln\"]})\n${a}`, \"F\"), n.rotation = _;\n    }\n    n.setOther(l), n.cvsResize();\n  }\n};\nlet Vt = pt;\nhn = new WeakMap(), Qu = new WeakMap(), tl = new WeakMap(), el = new WeakMap(), rl = new WeakMap(), qc = new WeakMap(), qa = new WeakMap(), Za = new WeakMap(), Zc = new WeakSet(), L_ = function() {\n  this.fncLay(), this.div && Object.assign(this.div.style, {\n    left: `${this.lx + this.rect.x * pt.sys.cvsScale}px`,\n    top: `${this.ly + this.rect.y * pt.sys.cvsScale}px`,\n    width: `${this.rect.width * pt.sys.cvsScale}px`,\n    height: `${this.rect.height * pt.sys.cvsScale}px`,\n    transformOrigin: `${this.pivot.x * pt.sys.cvsScale}px ${this.pivot.y * pt.sys.cvsScale}px`,\n    transform: `scale(${this.scale.x}, ${this.scale.y}) rotate(${this.rotation}deg)`\n  });\n}, E(Vt, hn, void 0), K(Vt, \"sys\"), E(Vt, Qu, void 0), K(Vt, \"prpPrs\"), E(Vt, tl, void 0), E(Vt, el, void 0), K(Vt, \"hPages\"), K(Vt, \"divHint\", document.createElement(\"div\")), E(Vt, rl, \"DesignMode\"), E(Vt, qc, 0), E(Vt, qa, {}), E(Vt, Za, []);\nvar js;\nclass G3 extends Vt {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    E(this, js, void 0);\n    K(this, \"oldFn\", () => this.hArg.fn ?? \"\");\n    this.spLay = e, this.gl = r;\n  }\n  setSp(e) {\n    P(this, js, e);\n  }\n  getRect() {\n    var e, r;\n    return new Nt(this.spLay.x, this.spLay.y, ((e = c(this, js)) == null ? void 0 : e.width) ?? 0, ((r = c(this, js)) == null ? void 0 : r.height) ?? 0);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.x = e, this.spLay.y = r;\n  }\n  setSize(e, r) {\n    c(this, js).width = e, c(this, js).height = r;\n  }\n  setOther(e) {\n    if (\"fn\" in e) {\n      const r = Vt.prpPrs.getValAmpersand(e.fn.val);\n      this.gl.lay({ fn: r });\n    }\n    this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\njs = new WeakMap();\nclass U3 extends Vt {\n  constructor(e, r) {\n    super(\"#29e\", !0);\n    K(this, \"hDesignArg\", {\n      rotation: 0,\n      pivot_x: 0,\n      pivot_y: 0,\n      left: 0,\n      center: 0,\n      right: 0,\n      s_right: 0,\n      top: 0,\n      middle: 0,\n      bottom: 0,\n      s_bottom: 0,\n      width: 0,\n      height: 0,\n      pl: 0,\n      pr: 0,\n      pt: 0,\n      pb: 0\n    });\n    this.spLay = e, this.ts = r;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Nt(this.spLay.x, this.spLay.y, e.$width, e.$height);\n  }\n  cnvPosArg(e, r) {\n    return { left: e, top: r };\n  }\n  cnvSizeArg(e, r) {\n    return { width: e, height: r };\n  }\n  setPos(e, r) {\n    this.spLay.position.set(e, r), this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay(this.cnvSizeArg(e, r));\n  }\n  setOther(e) {\n    var r;\n    (r = this.child) == null || r.setOther(e), this.spLay.pivot.copyFrom(this.pivot), this.spLay.scale.copyFrom(this.scale), this.spLay.angle = this.rotation;\n  }\n}\nvar Kc, B_;\nclass j3 extends Vt {\n  constructor(e) {\n    super(\"#9e2\");\n    E(this, Kc);\n    K(this, \"rotatable\", !1);\n    this.ts = e;\n  }\n  getRect() {\n    const e = this.ts.infTL;\n    return new Nt(\n      e.pad_left,\n      e.pad_top,\n      e.$width - e.pad_left - e.pad_right,\n      e.$height - e.pad_top - e.pad_bottom\n    );\n  }\n  cnvPosArg(e, r) {\n    return { pl: e, pt: r };\n  }\n  cnvSizeArg(e, r) {\n    const n = this.ts.infTL;\n    return {\n      pr: n.$width - n.pad_left - e,\n      pb: n.$height - n.pad_top - r\n    };\n  }\n  setPos(e, r) {\n    this.ts.lay(this.cnvPosArg(e, r));\n  }\n  setSize(e, r) {\n    this.ts.lay({ ...this.cnvSizeArg(e, r), \":redraw\": !0 });\n  }\n  setOther(e) {\n    var n, s, a, o;\n    const r = this.ts.infTL;\n    if ((\"pl\" in e || \"pt\" in e) && (this.setPos(\n      this.rect.x = parseFloat(Vt.prpPrs.getValAmpersand(\n        ((n = e.pl) == null ? void 0 : n.val) ?? `${r.pad_left}`\n      )),\n      this.rect.y = parseFloat(Vt.prpPrs.getValAmpersand(\n        ((s = e.pt) == null ? void 0 : s.val) ?? `${r.pad_top}`\n      ))\n    ), this.cvsResize()), \"pr\" in e || \"pb\" in e) {\n      this.ts.lay({\n        pr: parseFloat(Vt.prpPrs.getValAmpersand(\n          ((a = e.pr) == null ? void 0 : a.val) ?? `${r.pad_right}`\n        )),\n        pb: parseFloat(Vt.prpPrs.getValAmpersand(\n          ((o = e.pb) == null ? void 0 : o.val) ?? `${r.pad_bottom}`\n        ))\n      });\n      const u = this.getRect();\n      this.setSize(\n        this.rect.width = u.width,\n        this.rect.height = u.height\n      ), this.cvsResize();\n    }\n  }\n  procDragHint(e, r, n) {\n    const [s, a] = e.beforeTranslate;\n    O(this, Kc, B_).call(this, r, n, s, a);\n  }\n  procResizeHint(e, r, n) {\n    const [s, a] = e.drag.beforeTranslate;\n    O(this, Kc, B_).call(this, r, n, s, a);\n  }\n}\nKc = new WeakSet(), B_ = function(e, r, n, s) {\n  const a = this.rect.x, o = this.rect.y, u = this.rect.width, l = this.rect.height, h = this.ts.infTL, d = $t(a + n / Vt.sys.cvsScale), f = $t(o + s / Vt.sys.cvsScale), p = $t(h.$width - d - u), v = $t(h.$height - f - l), g = (m) => \"&nbsp;\".repeat(m);\n  Vt.setHint(\n    g(5 + 5 + 1) + `上幅=${f}<br/>\n\t\t\t左幅=${d + g(1 + 3 + 5 + 1)}右幅=${p}<br/>` + g(5) + `内側 ${$t(u)} x ${$t(l)}<br/>` + g(5 + 5) + `下幅=${v}`,\n    e,\n    r,\n    this\n  );\n};\nclass ZC extends Vt {\n  constructor(t, e) {\n    super(\"#e92\"), this.btn = t, this.hArg = e, this.pivot.x = tt(e, \"pivot_x\", this.pivot.x), this.pivot.y = tt(e, \"pivot_y\", this.pivot.y), this.scale.x = tt(e, \"scale_x\", this.scale.x), this.scale.y = tt(e, \"scale_y\", this.scale.y), this.rotation = tt(e, \"rotation\", this.rotation), this.sethArg(e);\n  }\n  sethArg(t) {\n    super.sethArg(t);\n    const e = this.hArg.layer ?? \"\";\n    this.fncLay = !this.parent && !this.child && e ? () => {\n      const r = Vt.hPages[e].fore;\n      this.lx = r.x * Vt.sys.cvsScale, this.ly = r.y * Vt.sys.cvsScale;\n    } : () => {\n    };\n  }\n  cnvPosArg(t, e) {\n    return { left: t, top: e };\n  }\n  cnvSizeArg(t, e) {\n    return { width: t, height: e };\n  }\n  setPos(t, e) {\n    this.btn.x = t, this.btn.y = e;\n  }\n  setOther(t) {\n    this.btn.pivot.copyFrom(this.pivot), this.btn.scale.copyFrom(this.scale), this.btn.angle = this.rotation;\n  }\n  onDragStart() {\n  }\n}\nclass z3 extends ZC {\n  constructor(e, r, n) {\n    super(e, r);\n    K(this, \"oldFn\", () => this.hArg.b_pic ?? \"\");\n    this.txt = n, vt(r, \"design\", !0) || (this.setPos = () => {\n    }, this.setSize = () => {\n    });\n  }\n  getRect() {\n    return new Nt(this.btn.x, this.btn.y, this.txt.width, this.txt.height);\n  }\n  setSize(e, r) {\n    this.txt.width = e, this.txt.height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"b_pic\" in e) {\n      const r = Vt.prpPrs.getValAmpersand(e.b_pic.val ?? \"\");\n      this.btn.update_b_pic(r, this.txt);\n    }\n  }\n}\nvar qn;\nclass H3 extends ZC {\n  constructor(e, r) {\n    super(e, r);\n    E(this, qn, void 0);\n    K(this, \"oldFn\", () => this.hArg.pic ?? \"\");\n  }\n  setSp(e) {\n    P(this, qn, e);\n  }\n  getRect() {\n    return new Nt(this.btn.x, this.btn.y, c(this, qn).width, c(this, qn).height);\n  }\n  setSize(e, r) {\n    c(this, qn).width = e, c(this, qn).height = r;\n  }\n  setOther(e) {\n    if (super.setOther(e), \"pic\" in e) {\n      const r = Vt.prpPrs.getValAmpersand(e.pic.val);\n      this.btn.update_pic(r, c(this, qn));\n    }\n  }\n}\nqn = new WeakMap();\nvar vg, zs, Zn, Ka, Ja, cn, il, Qa, Jc, nl, fn, Kn, Jn, Hs, Qc, tf, ef, gg, KC, mg, JC, rf, F_, yg, QC, sl, Xp, al, Ni, ol, _g, to, nf;\nconst _t = class extends _r {\n  constructor() {\n    super();\n    E(this, fn, new G3(this.spLay, this));\n    E(this, Kn, \"\");\n    E(this, Jn, \"\");\n    E(this, Hs, \"\");\n    K(this, \"lay\", (e) => this.laySub(e, (r) => {\n      r && c(_t, Zn).resume();\n    }));\n    E(this, Qc, 0);\n    E(this, tf, 0);\n    E(this, al, void 0);\n    E(this, Ni, void 0);\n    E(this, ol, () => {\n    });\n    K(this, \"record\", () => ({\n      ...super.record(),\n      sBkFn: c(this, Jn),\n      sBkFace: c(this, Hs),\n      idc_hArg: c(this, fn).gethArg()\n    }));\n    //showDesignCastChildren() {}\n    K(this, \"dump\", () => super.dump() + `, \"pic\":\"${c(this, Kn)}\"`);\n    Y.isDbg && (this.setSp = (e) => c(this, fn).setSp(e), this.cvsResize = () => {\n      super.cvsResize(), c(this, fn).cvsResize();\n    });\n  }\n  static init(e, r, n, s, a, o) {\n    P(_t, Zn, e), P(_t, Ka, r), P(_t, Ja, n), P(_t, cn, s), P(_t, il, o);\n    const u = () => {\n      const l = c(_t, Qa) * c(_t, Jc);\n      for (const h of Object.values(_t.hFn2VElm))\n        h.volume = l;\n    };\n    a.setNoticeChgVolume(\n      (l) => {\n        P(_t, Qa, l), u();\n      },\n      (l) => {\n        P(_t, Jc, l), u();\n      }\n    ), c(_t, cn).crypto && P(_t, ef, O(_t, mg, JC));\n  }\n  static setEvtMng(e) {\n    P(_t, nl, e);\n  }\n  static destroy() {\n    c(_t, vg).clear(), P(_t, zs, {}), _t.hFn2ResAniSpr = {}, _t.hFn2VElm = {};\n  }\n  setSp(e) {\n  }\n  laySub(e, r) {\n    var u;\n    O(u = _t, sl, Xp).call(u, c(this, Jn));\n    const { fn: n, face: s = \"\" } = e;\n    if (c(this, fn).sethArg(e), !n)\n      return super.lay(e), this.spLay.children.length > 0 && this.setPos(e), P(this, Jn, \"\"), P(this, Kn, P(this, Hs, s)), r(!1), !1;\n    const a = \"fn\" in e, o = \"face\" in e;\n    return this.clearLay({ filter: \"true\" }), a && P(this, Jn, n), o && P(this, Hs, s), super.lay(e), e.dx = 0, e.dy = 0, _t.csv2Sprites(\n      P(this, Kn, n + (s ? \",\" + s : \"\")),\n      this.spLay,\n      (l) => {\n        (\"width\" in e || \"height\" in e) && (l.width = tt(e, \"width\", 0), l.height = tt(e, \"height\", 0)), P(this, Qc, l.width), P(this, tf, l.height), _r.setXY(l, e, this.spLay, !0), this.setSp(l);\n      },\n      (l) => {\n        _r.setBlendmodeParentOnly(this.spLay, e), r(l);\n      }\n    );\n  }\n  get width() {\n    return c(this, Qc);\n  }\n  get height() {\n    return c(this, tf);\n  }\n  //\tstatic #ldrHFn: {[name: string]: 1} = {};\n  static csv2Sprites(e, r, n, s = () => {\n  }) {\n    let a = !1;\n    if (e.slice(0, 5) === \"data:\") {\n      const h = () => {\n        const d = Ue.from(e);\n        r == null || r.addChild(d), n(d), s(a);\n      };\n      return e in Gr ? h() : (a = !0, new ii().add(e, e).load(h)), a;\n    }\n    const o = [], u = new ii();\n    e.split(\",\").forEach((h, d) => {\n      if (!h)\n        throw \"face属性に空要素が含まれます\";\n      const { dx: f, dy: p, blendmode: v, fn: g } = c(_t, zs)[h] || {\n        fn: h,\n        dx: 0,\n        dy: 0,\n        blendmode: Et.NORMAL\n      }, m = d === 0 ? n : (b) => {\n        b.x = f, b.y = p, b.blendMode = v;\n      };\n      if (o.push({ fn: g, fnc: m }), g in _t.hFn2ResAniSpr || g in Gr || g in ii.shared.resources)\n        return;\n      a = !0;\n      const y = c(_t, Ka).searchPath(g, vr.SP_GSM), _ = c(this, cn).crypto ? { xhrType: y.slice(-5) === \".json\" ? Ft.XHR_RESPONSE_TYPE.TEXT : Ft.XHR_RESPONSE_TYPE.BUFFER } : {};\n      u.add({ ..._, name: g, url: y });\n    });\n    const l = (h) => {\n      var d;\n      for (const { fn: f, fnc: p } of o) {\n        const v = O(d = _t, yg, QC).call(d, f, h);\n        v.name = f, r == null || r.addChild(v), p(v);\n      }\n      s(a);\n    };\n    return a ? u.use((h, d) => {\n      c(this, cn).dec(h.extension, h.data).then((f) => {\n        var p;\n        return c(p = _t, ef).call(p, f, h, () => d == null ? void 0 : d());\n      }).catch((f) => c(this, Zn).errScript(`Graphic ロード失敗です fn:${h.name} ${f}`, !1));\n    }).load((h, d) => l(d)) : l({}), a;\n  }\n  static wv(e) {\n    var a;\n    const { fn: r } = e;\n    if (!r)\n      throw \"fnは必須です\";\n    const n = _t.hFn2VElm[r];\n    if (!n || n.loop)\n      return !1;\n    if (c(this, il).getVal(\"tmp:sn.skip.enabled\") || c(this, nl).isSkippingByKeyDown() || n.ended)\n      return O(a = _t, sl, Xp).call(a, r), !1;\n    const s = () => {\n      var o;\n      O(o = _t, sl, Xp).call(o, r), c(this, Zn).resume();\n    };\n    return n.addEventListener(\"ended\", s, { once: !0, passive: !0 }), c(_t, nl).waitEvent(\n      () => {\n        n.removeEventListener(\"ended\", s), s();\n      },\n      vt(e, \"canskip\", !0),\n      vt(e, \"global\", !1)\n    );\n  }\n  renderStart() {\n    P(this, al, Si.create({\n      width: Y.stageW,\n      height: Y.stageH\n    })), P(this, Ni, new Ue(c(this, al))), c(this, Ni).visible = !1, this.spLay.addChildAt(c(this, Ni), 0), c(this, Ni).position.set(-this.spLay.x, -this.spLay.y);\n    let e = () => {\n      const r = this.spLay.alpha;\n      this.spLay.alpha = 1;\n      for (const n of this.spLay.children)\n        n.visible = !0;\n      c(this, Ni).visible = !1, c(_t, Ja).renderer.render(this.spLay, { renderTexture: c(this, al) }), this.spLay.alpha = r;\n      for (const n of this.spLay.children)\n        n.visible = !1;\n    };\n    if (!this.containMovement) {\n      let r = e;\n      e = () => {\n        e = () => {\n        }, r();\n      };\n    }\n    P(this, ol, () => {\n      e(), c(this, Ni).visible = !0;\n    }), c(_t, Ja).ticker.add(c(this, ol));\n  }\n  renderEnd() {\n    c(_t, Ja).ticker.remove(c(this, ol)), this.spLay.removeChild(c(this, Ni));\n    for (const e of this.spLay.children)\n      e.visible = !0;\n    c(this, Ni).destroy(!0);\n  }\n  // https://regex101.com/r/ZUnoFq/1\n  static loadPic2Img(e, r, n) {\n    const s = e.replace(c(_t, _g), \"\"), a = e === s ? \"\" : e.slice(s.length), o = c(this, nf)[e];\n    if (o) {\n      r.src = o;\n      return;\n    }\n    const u = c(this, to)[e];\n    if (u) {\n      u.push(r);\n      return;\n    }\n    c(this, to)[e] = [r];\n    const l = c(_t, Ka).searchPath(s, vr.SP_GSM), h = new ii().add({ name: e, url: l, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER });\n    c(_t, cn).crypto && uv(l) === \"bin\" && h.use((d, f) => {\n      c(_t, cn).dec(d.extension, d.data).then((p) => {\n        if (d.extension !== \"bin\") {\n          f == null || f();\n          return;\n        }\n        d.data = p, p instanceof HTMLImageElement && (d.type = Ft.TYPE.IMAGE), f == null || f();\n      }).catch((p) => c(_t, Zn).errScript(`GrpLayer loadPic ロード失敗です fn:${d.name} ${p}`, !1));\n    }), h.load((d, f) => {\n      for (const [p, { data: { src: v } }] of Object.entries(f)) {\n        const g = c(this, nf)[p] = v + (v.slice(0, 5) === \"blob:\" ? \"\" : a);\n        for (const m of c(this, to)[p])\n          m.src = g, n && (m.onload = () => n(m));\n        delete c(this, to)[p];\n      }\n    });\n  }\n  setPos(e) {\n    _r.setXY(\n      this.spLay.children.length === 0 ? this.spLay : this.spLay.children[0],\n      e,\n      this.spLay,\n      !0\n    );\n  }\n  static add_face(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (r in c(_t, zs))\n      throw \"一つのname（\" + r + \"）に対して同じ画像を複数割り当てられません\";\n    const { fn: n = r } = e;\n    return c(_t, zs)[r] = {\n      fn: n,\n      dx: tt(e, \"dx\", 0),\n      dy: tt(e, \"dy\", 0),\n      blendmode: _r.getBlendmodeNum(e.blendmode || \"\")\n    }, !1;\n  }\n  static clearFace2Name() {\n    P(_t, zs, {});\n  }\n  // アニメ・動画を含むか\n  get containMovement() {\n    if (c(this, Kn) === \"\")\n      return !1;\n    const e = this.spLay.children;\n    return c(this, Kn).split(\",\").some(\n      (r, n) => e[n] instanceof iw || _t.hFn2VElm[r]\n    );\n  }\n  clearLay(e) {\n    super.clearLay(e);\n    for (const r of this.spLay.removeChildren())\n      r.destroy();\n    P(this, Jn, \"\"), P(this, Hs, \"\"), P(this, Kn, \"\");\n  }\n  playback(e, r) {\n    if (super.playback(e, r), e.sBkFn === \"\" && e.sBkFace === \"\") {\n      P(this, Jn, e.sBkFn), P(this, Hs, e.sBkFace), c(this, fn).sethArg(e.idc_hArg);\n      return;\n    }\n    r.push(new Promise((n) => this.laySub(\n      { fn: e.sBkFn, face: e.sBkFace, left: e.x, top: e.y, alpha: e.alpha, blendmode: _r.getNum2Blendmode(e.blendMode), rotation: e.rotation, scale_x: e.scale_x, scale_y: e.scale_y },\n      (s) => {\n        this.spLay.position.set(e.x, e.y), n();\n      }\n      // Layer.setXY()の後に再度移動\n    )));\n  }\n  makeDesignCast(e) {\n    this.spLay.visible && e(c(this, fn));\n  }\n  //makeDesignCastChildren(_gdc: IMakeDesignCast) {}\n  cvsResize() {\n    super.cvsResize();\n  }\n  showDesignCast() {\n    c(this, fn).visible = !0;\n  }\n};\nlet Wt = _t;\nvg = new WeakMap(), zs = new WeakMap(), Zn = new WeakMap(), Ka = new WeakMap(), Ja = new WeakMap(), cn = new WeakMap(), il = new WeakMap(), Qa = new WeakMap(), Jc = new WeakMap(), nl = new WeakMap(), fn = new WeakMap(), Kn = new WeakMap(), Jn = new WeakMap(), Hs = new WeakMap(), Qc = new WeakMap(), tf = new WeakMap(), ef = new WeakMap(), gg = new WeakSet(), KC = function(e) {\n  const r = /([^\\d]+)\\d+\\.(\\w+)/.exec(e[0]);\n  if (!r)\n    return [];\n  const n = r[1].length, s = -r[2].length - 1;\n  return e.sort(\n    (a, o) => $t(a.slice(n, s)) > $t(o.slice(n, s)) ? 1 : -1\n  );\n}, mg = new WeakSet(), JC = function(e, r, n) {\n  var l;\n  if (r.data = e, r.extension === \"bin\" && (e instanceof HTMLImageElement ? (r.texture = Ot.fromLoader(e, r.url, r.name), r.type = Ft.TYPE.IMAGE) : e instanceof HTMLVideoElement && (e.volume = c(_t, Qa), _t.hFn2VElm[r.name] = O(l = _t, rf, F_).call(l, e), r.type = Ft.TYPE.VIDEO)), r.extension !== \"json\") {\n    n();\n    return;\n  }\n  if (typeof e != \"string\") {\n    n();\n    return;\n  }\n  const { meta: s, frames: a } = r.data = JSON.parse(e);\n  if (r.type = Ft.TYPE.JSON, !(s != null && s.image)) {\n    n();\n    return;\n  }\n  const o = Xh(s.image), u = c(_t, Ka).searchPath(o, vr.SP_GSM);\n  new ii().use((h, d) => {\n    c(this, cn).dec(h.extension, h.data).then((f) => {\n      h.data = f, f instanceof HTMLImageElement && (h.type = Ft.TYPE.IMAGE, URL.revokeObjectURL(f.src)), d == null || d();\n    }).catch((f) => c(this, Zn).errScript(`Graphic ロード失敗です dec2res4Cripto fn:${h.name} ${f}`, !1));\n  }).add({ name: o, url: u, xhrType: Ft.XHR_RESPONSE_TYPE.BUFFER }).load((h, d) => {\n    for (const { data: f } of Object.values(h.resources)) {\n      const { baseTexture: p } = Ot.from(f), v = Object.values(a);\n      _t.hFn2ResAniSpr[r.name] = {\n        aTex: v.map(({ frame: { x: g, y: m, w: y, h: _ } }) => new Ot(\n          p,\n          new Nt(g, m, y, _)\n        )),\n        meta: s\n      };\n    }\n    n();\n  });\n}, rf = new WeakSet(), F_ = function(e) {\n  return c(_t, il).getVal(\"const.sn.needClick2Play\") && (zt.trace_beforeNew(`[lay系] ${zt.strPos()}未クリック状態で動画を自動再生します。音声はミュートされます`, \"W\"), e.muted = !0), e.setAttribute(\"playsinline\", \"\"), e;\n}, yg = new WeakSet(), QC = function(e, r) {\n  const n = _t.hFn2ResAniSpr[e];\n  if (n) {\n    const s = new iw(n.aTex);\n    return s.animationSpeed = n.meta.animationSpeed ?? 1, s.play(), s;\n  }\n  return e in Gr ? Ue.from(e) : e in _t.hFn2VElm ? Ue.from(_t.hFn2VElm[e]) : e in r ? new Ue(r[e].texture) : new Ue();\n}, sl = new WeakSet(), Xp = function(e) {\n  const r = _t.hFn2VElm[e];\n  r && (delete _t.hFn2VElm[e], r.pause(), r.currentTime = r.duration);\n}, al = new WeakMap(), Ni = new WeakMap(), ol = new WeakMap(), _g = new WeakMap(), to = new WeakMap(), nf = new WeakMap(), E(Wt, gg), E(Wt, mg), E(Wt, rf), E(Wt, yg), E(Wt, sl), E(Wt, vg, new Ql()), E(Wt, zs, {}), E(Wt, Zn, void 0), E(Wt, Ka, void 0), E(Wt, Ja, void 0), E(Wt, cn, void 0), E(Wt, il, void 0), E(Wt, Qa, 1), E(Wt, Jc, 1), E(Wt, nl, void 0), K(Wt, \"hFn2ResAniSpr\", {}), E(Wt, ef, (e, r, n) => {\n  var s, a;\n  switch (r.type) {\n    case Ft.TYPE.JSON:\n      const o = r.spritesheet._frameKeys;\n      O(s = _t, gg, KC).call(s, o), _t.hFn2ResAniSpr[r.name] = {\n        aTex: o.map((l) => Ot.from(l)),\n        meta: r.data.meta\n      };\n      break;\n    case Ft.TYPE.VIDEO:\n      const u = r.data;\n      u.volume = c(_t, Qa), _t.hFn2VElm[r.name] = O(a = _t, rf, F_).call(a, u);\n  }\n  n();\n}), K(Wt, \"hFn2VElm\", {}), E(Wt, _g, /\\?([^?]+)$/), E(Wt, to, {}), E(Wt, nf, {});\nvar ul, sf, eo, Xt, dn, Qn, bg, Zr, $s, wt, pi, Sr, Tr, ll, Wp, Ai, ts, af, hl, xg, tM, ro, cl, Vs, io, no, so, fl, of, Xs, uf, G_, es, lf, rs, pn, dl, hf, U_, Ws, ao, cf, j_, kr;\nconst At = class extends ye {\n  constructor(e, r, n) {\n    super();\n    E(this, ll);\n    E(this, xg);\n    E(this, uf);\n    // 「g」などで下が欠ける問題対策\n    E(this, hf);\n    E(this, cf);\n    E(this, Xt, document.createElement(\"span\"));\n    // サンプリング元\n    E(this, dn, new ye());\n    // サンプリング先\n    E(this, Qn, new ai());\n    E(this, Zr, new U3(this.spLay, this));\n    E(this, $s, new j3(this));\n    E(this, wt, {\n      fontsize: 24,\n      $width: 0,\n      // レイヤサイズであり、背景色（画像）サイズ\n      $height: 0,\n      pad_left: 0,\n      // paddingLeft（レイヤサイズの内側のスペーサー）\n      pad_right: 0,\n      // paddingRight\n      pad_top: 0,\n      // paddingTop\n      pad_bottom: 0\n      // paddingBottom\n    });\n    E(this, pi, !1);\n    E(this, Sr, 0);\n    E(this, Tr, 0);\n    E(this, Ai, 0);\n    E(this, ts, !1);\n    E(this, af, 0);\n    E(this, hl, 0);\n    E(this, ro, void 0);\n    // 文字にかけるフィルター\n    E(this, cl, []);\n    E(this, Vs, []);\n    E(this, io, 0);\n    E(this, Xs, () => !1);\n    E(this, dl, 0);\n    E(this, Ws, \"Quadratic.Out\");\n    E(this, ao, \"Quadratic.Out\");\n    E(this, kr, void 0);\n    this.spLay = e, this.canFocus = r, this.sys = n, c(this, Xt).classList.add(\"sn_tx\"), c(this, Xt).style.position = \"absolute\", c(At, sf).view.parentElement.appendChild(c(this, Xt)), this.addChild(c(this, dn)), this.addChild(c(this, Qn)), c(this, Qn).name = \"grpDbgMasume\", c(this, Zr).adopt(c(this, $s));\n  }\n  static init(e, r) {\n    P(At, ul, e), P(At, sf, r), P(At, no, /[、。，．）］｝〉」』】〕”〟ぁぃぅぇぉっゃゅょゎァィゥェォッャュョヮヵヶ！？!?‼⁉・ーゝゞヽヾ々]/), P(At, so, /[［（｛〈「『【〔“〝]/), P(At, fl, /[─‥…]/);\n  }\n  static setEvtMng(e) {\n    P(At, eo, e);\n  }\n  static destroy() {\n    P(At, es, /* @__PURE__ */ Object.create(null)), P(At, rs, /* @__PURE__ */ Object.create(null)), P(At, pn, new ye());\n  }\n  lay(e) {\n    const r = c(this, Xt).style;\n    if (\"style\" in e)\n      if (e.style) {\n        const n = document.createElement(\"span\");\n        n.style.cssText = e.style;\n        const s = n.style.length;\n        for (let a = 0; a < s; ++a) {\n          const o = n.style[a];\n          if (o in c(At, bg)) {\n            zt.myTrace(`${o}は指定できません`, \"W\");\n            continue;\n          }\n          r[o] = n.style[o];\n        }\n        !n.style.opacity && \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n      } else\n        c(this, Xt).style.cssText = \"\";\n    else\n      \"alpha\" in e && (r.opacity = String(this.spLay.alpha));\n    if (\"width\" in e && (r.width = (e.width ?? \"0\") + \"px\"), \"height\" in e && (r.height = (e.height ?? \"0\") + \"px\"), \"pl\" in e && (r.paddingLeft = (e.pl ?? \"0\") + \"px\"), \"pr\" in e && (r.paddingRight = (e.pr ?? \"0\") + \"px\"), \"pt\" in e && (r.paddingTop = (e.pt ?? \"0\") + \"px\"), \"pb\" in e && (r.paddingBottom = (e.pb ?? \"0\") + \"px\"), \"kinsoku_sol\" in e && P(At, no, new RegExp(`[${e.kinsoku_sol}]`)), \"kinsoku_eol\" in e && P(At, so, new RegExp(`[${e.kinsoku_eol}]`)), \"kinsoku_dns\" in e && P(At, fl, new RegExp(`[${e.kinsoku_dns}]`)), O(this, ll, Wp).call(this), c(this, Zr).sethArg(e), P(this, Ai, this.spLay.position.x), r.transformOrigin = `${this.spLay.pivot.x}px ${this.spLay.pivot.y}px`, this.cvsResize(), r.display = this.spLay.visible ? \"inline\" : \"none\", r.textShadow = e.filter ?? r.textShadow ?? \"\", P(this, pi, vt(e, \"break_fixed\", c(this, pi))), P(this, Sr, tt(e, \"break_fixed_left\", c(this, Sr))), P(this, Tr, tt(e, \"break_fixed_top\", c(this, Tr))), \":redraw\" in e && c(this, io) > 0) {\n      const n = [\n        c(this, Xt).innerHTML.replaceAll(/(animation-delay: )\\d+ms/g, \"$10ms\"),\n        `<span class='sn_ch' data-add='{\"ch_in_style\":\"default\"}'>　</span>`\n      ];\n      O(this, cf, j_).call(this), this.goTxt(n, !0);\n    }\n  }\n  cvsResize() {\n    const e = c(this, Xt).style, r = this.sys.cvsScale;\n    e.left = `${this.sys.ofsLeft4elm + c(this, Ai) * r}px`, e.top = `${this.sys.ofsTop4elm + this.spLay.position.y * r}px`, e.transform = `rotate(${this.spLay.angle}deg) scale(${this.spLay.scale.x * r}, ${this.spLay.scale.y * r})`, c(this, Zr).cvsResize(), c(this, $s).cvsResize();\n  }\n  get tategaki() {\n    return c(this, ts);\n  }\n  get infTL() {\n    return c(this, wt);\n  }\n  get getWidth() {\n    return c(this, wt).$width;\n  }\n  get getHeight() {\n    return c(this, wt).$height;\n  }\n  setSize(e, r) {\n    c(this, wt).$width = e, c(this, wt).$height = r, c(this, Xt).style.width = c(this, wt).$width + \"px\", c(this, Xt).style.height = c(this, wt).$height + \"px\";\n  }\n  goTxt(e, r) {\n    var b, w, T;\n    c(At, pn).visible = !1;\n    let n = c(this, Vs).length, s = \"\";\n    if (n === 0) {\n      if (c(At, ul).oCfg.debug.masume && (Y.debugLog && console.log(`🍌 masume ${this.name} v:${this.visible} l:${this.x} t:${this.y} a:${this.alpha} pl:${c(this, wt).pad_left} pr:${c(this, wt).pad_right} pt:${c(this, wt).pad_top} pb:${c(this, wt).pad_bottom} w:${c(this, wt).$width} h:${c(this, wt).$height}`), c(this, Qn).clear().beginFill(3407616, 0.2).lineStyle(1, 3407616, 1).drawRect(-c(this, wt).pad_left, -c(this, wt).pad_top, c(this, wt).$width, c(this, wt).$height).endFill().beginFill(13311, 0.2).lineStyle(2, 13311, 1).drawRect(\n        0,\n        0,\n        c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right,\n        c(this, wt).$height - c(this, wt).pad_top - c(this, wt).pad_bottom\n      ).endFill()), c(this, Xt).innerHTML = [...e].join(\"\").replaceAll(/[\\n\\t]/g, \"\") + c(At, of), !c(this, pi)) {\n        const x = globalThis.getComputedStyle(c(this, Xt)), S = parseFloat(x.fontSize);\n        c(this, ts) ? (P(this, Sr, (c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right - S * 1.5) * this.sys.cvsScale), P(this, Tr, 0)) : (P(this, Sr, 0), P(this, Tr, S / 2 * this.sys.cvsScale));\n      }\n    } else\n      s = c(this, Xt).innerHTML, c(this, Xt).querySelectorAll(\":scope > br\").forEach((x) => c(this, Xt).removeChild(x)), c(this, Xt).insertAdjacentHTML(\n        \"beforeend\",\n        e.slice(c(this, io)).join(\"\").replaceAll(/[\\n\\t]/g, \"\") + c(At, of)\n        // 末尾改行削除挙動対策\n      ), --n, (b = c(this, Xt).querySelector(\".sn_ch_last\")) == null || b.remove();\n    P(this, io, e.length);\n    const a = this.sys.cvsScale, o = c(this, Xt).getBoundingClientRect(), u = o.left + c(this, wt).pad_left, l = o.top + c(this, wt).pad_top;\n    let h;\n    if (a === 1)\n      h = (x, S) => new Nt(\n        x.left - u,\n        x.top - l,\n        x.width,\n        x.height + (\"gjqy\".includes(S) ? c(this, dl) : 0)\n      );\n    else {\n      const x = this.sys.ofsPadLeft_Dom2PIXI + o.left * (1 - a), S = this.sys.ofsPadTop_Dom2PIXI + o.top * (1 - a);\n      h = (C, M) => new Nt(\n        (C.left - x) / a - u,\n        (C.top - S) / a - l,\n        C.width / a,\n        (C.height + (\"gjqy\".includes(M) ? c(this, dl) : 0)) / a\n      );\n    }\n    let d = 0, f = 2, p = !1;\n    do {\n      const x = P(this, Vs, O(this, hf, U_).call(this, c(this, Xt), h));\n      if (d = x.length, !p && (d < 2 || n === d)) {\n        n > 0 && n === d && (c(this, Xt).innerHTML = s.replaceAll('class=\"sn_ch\"', 'class=\"sn_ch sn_ch_in_default\"'));\n        break;\n      }\n      p = !0;\n      let S = -1 / 0;\n      for (; f < d; ++f) {\n        const C = x[f];\n        if (C.elm.tagName === \"RT\")\n          continue;\n        const M = this.tategaki ? C.rect.y : C.rect.x;\n        if (S <= M || ((T = (w = C.elm.previousElementSibling) == null ? void 0 : w.children[0]) == null ? void 0 : T.tagName) === \"BR\") {\n          S = M, c(this, pi) || (P(this, Sr, C.rect.x), P(this, Tr, C.rect.y));\n          continue;\n        }\n        let I = f - 1;\n        for (; x[I].elm.tagName === \"RT\"; )\n          --I;\n        const R = x[I], N = R.ch;\n        if (!c(this, pi)) {\n          P(this, Sr, R.rect.x), P(this, Tr, R.rect.y);\n          const G = globalThis.getComputedStyle(R.elm), $ = parseFloat(G.fontSize);\n          c(this, ts) ? P(this, Tr, c(this, Tr) + $) : P(this, Sr, c(this, Sr) + $);\n        }\n        S = -1 / 0;\n        const A = f;\n        if (c(At, fl).test(N) && N === C.ch)\n          f = I;\n        else {\n          if (c(At, so).test(N))\n            f = I;\n          else if (c(At, no).test(C.ch))\n            for (f = I + 1; f > 0 && c(At, no).test(x[--f].ch); )\n              ;\n          else {\n            ++f;\n            continue;\n          }\n          for (f = I + 1; f > 0 && c(At, so).test(x[--f].ch); )\n            ;\n        }\n        const U = x[f].elm.parentElement, B = document.createElement(\"br\");\n        if (U.classList.contains(\"sn_tx\"))\n          U.insertBefore(B, x[f].elm);\n        else {\n          const G = U.parentElement;\n          G.classList.contains(\"sn_ch\") ? G.parentElement.insertBefore(B, G) : G.insertBefore(B, U);\n        }\n        f += 2, f < A && (f = A), d = -1;\n        break;\n      }\n    } while (d < 0);\n    const v = Y.debugLog ? (x, S) => console.log(`🍌 masume ch:${x.ch} x:${S.x} y:${S.y} w:${S.width} h:${S.height}`) : () => {\n    }, g = c(At, ul).oCfg.debug.masume ? (x, S) => {\n      v(x, S), c(this, Qn).beginFill(6737151, 0.5).lineStyle(2, 16724736, 1).drawRect(S.x, S.y, S.width, S.height).endFill();\n    } : () => {\n    }, m = ws.ease(c(this, Ws));\n    for (let x = n; x < d; ++x) {\n      const S = c(this, Vs)[x], C = S.rect, M = JSON.parse(S.elm.dataset.arg ?? '{\"delay\": 0}'), I = JSON.parse(S.elm.dataset.add ?? \"{}\"), R = c(At, es)[I.ch_in_style];\n      if (g(S, C), S.elm.dataset.cmd === \"grp\") {\n        const N = new ye();\n        c(this, dn).addChild(N), Wt.csv2Sprites(M.pic, N, (A) => {\n          O(this, uf, G_).call(this, N, M, I, C, m, R ?? {}), N.parent || N.removeChild(A);\n        });\n      }\n      if (S.elm.dataset.lnk) {\n        const N = S.elm.parentElement.closest(\"[data-arg]\"), A = JSON.parse(N.dataset.arg ?? \"{}\");\n        A.key = `lnk=[${x}] ` + this.name;\n        const U = new Ue();\n        O(this, uf, G_).call(this, U, A, I, C, m, R ?? {});\n        const B = A.style ?? \"\", G = B + (A.style_hover ?? \"\"), $ = B + (A.style_clicked ?? \"\"), Z = A.r_style ?? \"\", H = Z + (A.r_style_hover ?? \"\"), z = Z + (A.r_style_clicked ?? \"\"), X = N.querySelectorAll(\"rt\");\n        X.forEach((et) => et.dataset.st_r_bk = et.style.cssText);\n        const ct = N.style.cssText, it = (et, k) => {\n          N.style.cssText = ct + et, X.forEach((ft) => ft.style.cssText = ft.dataset.st_r_bk + k);\n        };\n        vt(A, \"enabled\", !0) ? c(At, eo).button(\n          A,\n          U,\n          () => it(B, Z),\n          () => this.canFocus() ? (it(G, H), !0) : !1,\n          () => it($, z)\n        ) : it(\n          B + (A.style_disable ?? \"color: gray;\"),\n          Z + (A.r_style_disable ?? \"color: gray;\")\n        ), c(this, dn).addChild(U);\n      }\n    }\n    const y = c(this, Xt).querySelectorAll(\"span.sn_ch\");\n    P(this, Xs, () => (P(this, Xs, () => !1), y.forEach((x) => x.className = x.className.replaceAll(/ go_ch_in_[^\\s\"]+/g, \"\")), c(At, pn).position.set(\n      c(this, Sr),\n      c(this, Tr)\n    ), c(At, pn).visible = !0, c(At, eo).noticeCompTxt(), !0)), y.forEach((x) => x.className = x.className.replaceAll(/sn_ch_in_([^\\s\"]+)/g, \"go_ch_in_$1\")), n > 0 && ++n;\n    let _;\n    for (let x = d - 2; x >= 0; --x) {\n      const S = c(this, Vs)[x];\n      if (S.elm.tagName === \"SPAN\") {\n        _ = S.elm;\n        break;\n      }\n    }\n    if (!_ || r || n === d) {\n      c(this, Xs).call(this);\n      return;\n    }\n    _.addEventListener(\"animationend\", c(this, Xs), { once: !0, passive: !0 });\n  }\n  skipChIn() {\n    let e = c(this, Xs).call(this);\n    for (const r of c(this, cl))\n      r.tw && (r.tw.stop().end(), e = !0);\n    return P(this, cl, []), e;\n  }\n  static initChStyle() {\n    P(At, es, /* @__PURE__ */ Object.create(null)), P(At, rs, /* @__PURE__ */ Object.create(null));\n  }\n  static getChInStyle(e) {\n    return c(At, es)[e];\n  }\n  static ch_in_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (c(At, lf).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in c(At, es))\n      throw `name【${r}】はすでにあります`;\n    const n = String(e.x ?? \"=0\"), s = String(e.y ?? \"=0\");\n    return c(At, es)[r] = {\n      wait: tt(e, \"wait\", 500),\n      // アニメ・FI時間\n      alpha: tt(e, \"alpha\", 0),\n      x: n,\n      // 初期x値\n      y: s,\n      // [tsy]と同様に絶対・相対指定可能\n      // {x:500}\t\t\tX位置を500に\n      // {x:'=500'}\t\t現在のX位置に+500加算した位置\n      // {x:'=-500'}\t\t現在のX位置に-500加算した位置\n      // {x:'250,500'}\t+250から＋500までの間でランダムな値をX位置に\n      // {x:'=250,500'}\t+250から＋500までの間でランダムな値を現在のX位置に加算\n      nx: parseFloat(n.at(0) === \"=\" ? n.slice(1) : n),\n      ny: parseFloat(s.at(0) === \"=\" ? s.slice(1) : s),\n      scale_x: tt(e, \"scale_x\", 1),\n      scale_y: tt(e, \"scale_y\", 1),\n      rotate: tt(e, \"rotate\", 0),\n      join: vt(e, \"join\", !0),\n      // 文字を順番に出すか（true）同時か（false）\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  static getChOutStyle(e) {\n    return c(At, rs)[e];\n  }\n  static ch_out_style(e) {\n    const { name: r } = e;\n    if (!r)\n      throw \"nameは必須です\";\n    if (c(At, lf).test(r))\n      throw `name【${r}】に使えない文字が含まれます`;\n    if (r in c(At, rs))\n      throw `name【${r}】はすでにあります`;\n    const n = String(e.x ?? \"=0\"), s = String(e.y ?? \"=0\");\n    return c(At, rs)[r] = {\n      wait: tt(e, \"wait\", 500),\n      // アニメ・FI時間\n      alpha: tt(e, \"alpha\", 0),\n      x: n,\n      // 初期x値\n      y: s,\n      // [tsy]と同様に絶対・相対指定可能\n      // {x:500}\t\t\tX位置を500に\n      // {x:'=500'}\t\t現在のX位置に+500加算した位置\n      // {x:'=-500'}\t\t現在のX位置に-500加算した位置\n      // {x:'250,500'}\t+250から＋500までの間でランダムな値をX位置に\n      // {x:'=250,500'}\t+250から＋500までの間でランダムな値を現在のX位置に加算\n      nx: parseFloat(n.at(0) === \"=\" ? n.slice(1) : n),\n      ny: parseFloat(s.at(0) === \"=\" ? s.slice(1) : s),\n      scale_x: tt(e, \"scale_x\", 1),\n      scale_y: tt(e, \"scale_y\", 1),\n      rotate: tt(e, \"rotate\", 0),\n      join: vt(e, \"join\", !1),\n      // 文字を順番に出すか（true）同時か（false）\n      ease: e.ease ?? \"ease-out\"\n    };\n  }\n  dispBreak(e) {\n    const r = c(At, pn);\n    r.visible = !1, this.addChild(r), Wt.csv2Sprites(e, r, (n) => {\n      r.parent || r.removeChild(n);\n    });\n  }\n  static delBreak() {\n    const e = c(At, pn);\n    e.parent && (e.parent.removeChild(e), e.removeChildren()), P(At, pn, new ye());\n  }\n  reNew() {\n    var r;\n    O(this, cf, j_).call(this);\n    const e = new At(this.spLay, () => this.canFocus(), this.sys);\n    return P(e, wt, c(this, wt)), c(e, Xt).style.cssText = c(this, Xt).style.cssText, P(e, Ai, c(this, Ai)), e.name = this.name, O(r = e, ll, Wp).call(r), c(e, Zr).sethArg(c(this, Zr).gethArg()), P(e, ro, c(this, ro)), P(e, Ws, c(this, Ws)), P(e, ao, c(this, ao)), P(e, pi, c(this, pi)), P(e, Sr, c(this, Sr)), P(e, Tr, c(this, Tr)), this.destroy(), e;\n  }\n  record() {\n    return {\n      infTL: c(this, wt),\n      cssText: c(this, Xt).style.cssText,\n      left: c(this, Ai),\n      idc_hArg: c(this, Zr).gethArg(),\n      ch_filter: c(this, ro),\n      fi_easing: c(this, Ws),\n      fo_easing: c(this, ao),\n      break_fixed: c(this, pi),\n      break_fixed_left: c(this, Sr),\n      break_fixed_top: c(this, Tr)\n    };\n  }\n  playback(e) {\n    P(this, wt, e.infTL), this.position.set(c(this, wt).pad_left, c(this, wt).pad_top), c(this, Xt).style.cssText = e.cssText, P(this, Ai, e.left), O(this, ll, Wp).call(this), c(this, Zr).sethArg(e.idc_hArg), P(this, ro, e.ch_filter), P(this, Ws, e.fi_easing), P(this, ao, e.fo_easing), P(this, pi, e.break_fixed ?? !1), P(this, Sr, e.break_fixed_left ?? 0), P(this, Tr, e.break_fixed_top ?? 0);\n  }\n  snapshot(e, r) {\n    O(this, xg, tM).call(this, (n) => {\n      P(this, kr, new Ue(n)), c(this, ts) && (c(this, kr).x += Y.stageW - (c(this, Ai) + c(this, wt).$width)), c(this, kr).y -= c(this, hl), c(this, kr).texture.frame = new Nt(\n        0,\n        0,\n        Math.min(c(this, kr).width, c(this, wt).$width - c(this, Ai)),\n        Math.min(c(this, kr).height, c(this, wt).$height)\n      ), c(this, dn).addChild(c(this, kr)), e.render(c(this, kr), { clear: !1 }), r();\n    }, !1);\n  }\n  snapshot_end() {\n    c(this, kr) && (c(this, dn).removeChild(c(this, kr)), P(this, kr, void 0));\n  }\n  makeDesignCast(e) {\n    e(c(this, Zr));\n    const r = c(this, Zr).gethArg();\n    c(this, $s).sethArg({ ...r, \":id_dc\": r[\":id_tag\"] + \"_pad\" }), e(c(this, $s));\n  }\n  showDesignCast() {\n    c(this, Zr).visible = !0, c(this, $s).visible = !0;\n  }\n  dump() {\n    const e = [], r = c(this, Xt).style, n = r.length;\n    for (let s = 0; s < n; ++s) {\n      const a = r[s];\n      e.push(`\"${a}\":\"${r[a].replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\"`);\n    }\n    return `\"txt\":\"${c(this, Xt).textContent.replaceAll(/([\"\\\\])/g, \"\\\\$1\")}\", \"style\":{${e.join(\",\")}}`;\n  }\n  destroy() {\n    At.delBreak(), c(this, Xt).parentElement.removeChild(c(this, Xt)), this.removeChild(c(this, dn)), this.removeChild(c(this, Qn)), super.destroy();\n  }\n};\nlet De = At;\nul = new WeakMap(), sf = new WeakMap(), eo = new WeakMap(), Xt = new WeakMap(), dn = new WeakMap(), Qn = new WeakMap(), bg = new WeakMap(), Zr = new WeakMap(), $s = new WeakMap(), wt = new WeakMap(), pi = new WeakMap(), Sr = new WeakMap(), Tr = new WeakMap(), ll = new WeakSet(), Wp = function() {\n  const e = c(this, Xt).style, r = parseFloat(e.fontSize || \"0\");\n  c(this, wt).fontsize = r, c(this, wt).pad_left = parseFloat(e.paddingLeft || \"0\"), c(this, wt).pad_right = parseFloat(e.paddingRight || \"0\"), c(this, wt).pad_top = parseFloat(e.paddingTop || \"0\"), c(this, wt).pad_bottom = parseFloat(e.paddingBottom || \"0\"), c(this, wt).$width = parseFloat(e.width || \"0\"), c(this, wt).$height = parseFloat(e.height || \"0\"), this.position.set(c(this, wt).pad_left, c(this, wt).pad_top), P(this, ts, e.writingMode === \"vertical-rl\"), P(this, af, 0), P(this, hl, 0);\n  const n = e.lineHeight ?? \"0\";\n  P(this, dl, c(this, ts) ? 0 : (n.slice(-2) === \"px\" ? parseFloat(n) : r * parseFloat(n) - r) / 2);\n}, Ai = new WeakMap(), ts = new WeakMap(), af = new WeakMap(), hl = new WeakMap(), xg = new WeakSet(), tM = function(e, r = !0) {\n  const n = {\n    escape: (m) => m.replaceAll(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"),\n    mimeType: (m) => {\n      const y = l(m).toLowerCase();\n      return s()[y] || \"\";\n    },\n    dataAsUrl: p,\n    isDataUrl: h,\n    resolveUrl: d,\n    getAndEncode: f,\n    asArray: (m) => {\n      const y = [], _ = m.length;\n      for (let b = 0; b < _; ++b)\n        y.push(m[b]);\n      return y;\n    }\n  };\n  function s() {\n    const m = \"application/font-woff\", y = \"image/jpeg\";\n    return {\n      woff: m,\n      woff2: m,\n      ttf: \"application/font-truetype\",\n      eot: \"application/vnd.ms-fontobject\",\n      png: \"image/png\",\n      jpg: y,\n      jpeg: y,\n      gif: \"image/gif\",\n      tiff: \"image/tiff\",\n      svg: \"image/svg+xml\"\n    };\n  }\n  const a = v(), o = g();\n  function u(m) {\n    return o.resolveAll().then((y) => {\n      const _ = document.createElement(\"style\");\n      return m.appendChild(_), _.appendChild(document.createTextNode(y)), m;\n    });\n  }\n  function l(m) {\n    const y = /\\.([^\\.\\/]*?)$/g.exec(m);\n    return (y == null ? void 0 : y[1]) ?? \"\";\n  }\n  function h(m) {\n    return m.search(/^(data:)/) !== -1;\n  }\n  function d(m, y) {\n    const _ = document.implementation.createHTMLDocument(), b = _.createElement(\"base\");\n    _.head.appendChild(b);\n    const w = _.createElement(\"a\");\n    return _.body.appendChild(w), b.href = y, w.href = m, w.href;\n  }\n  function f(m) {\n    let y = 3e4;\n    return new Promise(function(_) {\n      const b = new XMLHttpRequest();\n      b.onreadystatechange = w, b.ontimeout = T, b.responseType = \"blob\", b.timeout = y, b.open(\"GET\", m, !0), b.send();\n      function w() {\n        if (b.readyState !== 4)\n          return;\n        if (b.status !== 200) {\n          x(\"cannot fetch resource: \" + m + \", status: \" + b.status);\n          return;\n        }\n        const S = new FileReader();\n        S.onloadend = function() {\n          const C = S.result.toString().split(/,/)[1];\n          _(C);\n        }, S.readAsDataURL(b.response);\n      }\n      function T() {\n        x(\"timeout of \" + y + \"ms occured while fetching resource: \" + m);\n      }\n      function x(S) {\n        console.error(S), _(\"\");\n      }\n    });\n  }\n  function p(m, y) {\n    return \"data:\" + y + \";base64,\" + m;\n  }\n  function v() {\n    const m = /url\\(['\"]?([^'\"]+?)['\"]?\\)/g;\n    return {\n      inlineAll: w,\n      shouldProcess: y\n    };\n    function y(T) {\n      return T.search(m) !== -1;\n    }\n    function _(T) {\n      const x = [];\n      let S;\n      for (; S = m.exec(T); )\n        x.push(S[1]);\n      return x.filter(function(C) {\n        return !n.isDataUrl(C);\n      });\n    }\n    function b(T, x, S, C) {\n      return Promise.resolve(x).then((I) => S ? n.resolveUrl(I, S) : I).then(C || n.getAndEncode).then((I) => n.dataAsUrl(I, n.mimeType(x))).then((I) => T.replace(M(x), \"$1\" + I + \"$3\"));\n      function M(I) {\n        return new RegExp(`(url\\\\(['\"]?)(` + n.escape(I) + `)(['\"]?\\\\))`, \"g\");\n      }\n    }\n    function w(T, x, S) {\n      if (C())\n        return Promise.resolve(T);\n      return Promise.resolve(T).then(_).then((M) => {\n        let I = Promise.resolve(T);\n        for (const R of M)\n          I = I.then((N) => b(N, R, x, S));\n        return I;\n      });\n      function C() {\n        return !y(T);\n      }\n    }\n  }\n  function g() {\n    return {\n      resolveAll: m,\n      impl: { readAll: y }\n    };\n    function m() {\n      return y().then((_) => Promise.allSettled(\n        _.map((b) => b.resolve())\n      )).then((_) => _.join(`\n`));\n    }\n    function y() {\n      return Promise.resolve(n.asArray(document.styleSheets)).then(b).then(_).then((T) => T.map(w));\n      function _(T) {\n        return T.filter((x) => x.type === CSSRule.FONT_FACE_RULE).filter((x) => a.shouldProcess(x.style.getPropertyValue(\"src\")));\n      }\n      function b(T) {\n        const x = [];\n        for (const S of T)\n          try {\n            if (S.href)\n              continue;\n            n.asArray(S.cssRules || []).forEach(x.push.bind(x));\n          } catch (C) {\n            console.error(\"Error while reading CSS rules from \" + S.href, C.toString());\n          }\n        return x;\n      }\n      function w(T) {\n        return {\n          resolve: function() {\n            const S = (T.parentStyleSheet || {}).href;\n            return a.inlineAll(T.cssText, S);\n          },\n          src: function() {\n            return T.style.getPropertyValue(\"src\");\n          }\n        };\n      }\n    }\n  }\n  Promise.resolve(c(this, Xt)).then((m) => {\n    const y = m.cloneNode(!0);\n    return y.style.padding = \"0px\", y.style.paddingRight = c(this, af) + \"px\", y.style.paddingTop = c(this, hl) + \"px\", y.style.left = \"0px\", y.style.top = \"0px\", y.style.width = c(this, wt).$width - c(this, wt).pad_left - c(this, wt).pad_right + \"px\", y.style.height = c(this, wt).$height - c(this, wt).pad_top - c(this, wt).pad_bottom + \"px\", c(this, Xt).hidden = r, y;\n  }).then(u).then((m) => {\n    m.setAttribute(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n    const y = new Image();\n    return y.src = `data:image/svg+xml;charset=utf-8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${c(this, wt).$width}px\" height=\"${c(this, wt).$height}px\"><foreignObject x=\"0\" y=\"0\" width=\"100%\" height=\"100%\">${new XMLSerializer().serializeToString(m).replaceAll(\"#\", \"%23\").replaceAll(`\n`, \"%0A\")}</foreignObject></svg>`, new Promise((_) => y.onload = () => _(y));\n  }).then((m) => new Promise((y) => setTimeout(() => y(m), 100))).then((m) => {\n    const y = document.createElement(\"canvas\");\n    y.width = c(this, wt).$width, y.height = c(this, wt).$height, y.getContext(\"2d\").drawImage(m, 0, 0), y.toBlob((_) => {\n      if (!_)\n        return;\n      const b = URL.createObjectURL(_);\n      Ot.from(b).once(\"update\", (w) => {\n        e(w), URL.revokeObjectURL(b);\n      });\n    });\n  }).catch((m) => zt.myTrace(`goTxt() = ${m}`));\n}, ro = new WeakMap(), cl = new WeakMap(), Vs = new WeakMap(), io = new WeakMap(), no = new WeakMap(), so = new WeakMap(), fl = new WeakMap(), of = new WeakMap(), Xs = new WeakMap(), uf = new WeakSet(), G_ = function(e, r, n, s, a, o) {\n  e.alpha = 0, r.x && (s.x = r.x.at(0) === \"=\" ? s.x + parseInt(r.x.slice(1)) : parseInt(r.x)), r.y && (s.y = r.y.at(0) === \"=\" ? s.y + parseInt(r.y.slice(1)) : parseInt(r.y)), r.width && (s.width = parseInt(r.width)), r.height && (s.height = parseInt(r.height)), r.wait && (o.wait = parseInt(r.wait)), e.width = s.width, e.height = s.height, o.x ? e.position.set(\n    o.x.at(0) === \"=\" ? s.x + e.width * o.nx : o.nx,\n    o.y.at(0) === \"=\" ? s.y + e.height * o.ny : o.ny\n  ) : e.position.set(s.x, s.y);\n  const u = {\n    sp: e,\n    tw: new Tn(e).to({ alpha: 1, x: s.x, y: s.y, width: s.width, height: s.height, angle: 0 }, o.wait ?? 0).easing(a).delay((n.wait ?? 0) + (r.delay ?? 0)).onComplete(() => {\n      u.tw = void 0;\n    }).start()\n  };\n  c(this, cl).push(u);\n}, es = new WeakMap(), lf = new WeakMap(), rs = new WeakMap(), pn = new WeakMap(), dl = new WeakMap(), hf = new WeakSet(), U_ = function(e, r) {\n  const n = [];\n  if (e.nodeType !== e.TEXT_NODE)\n    return Array.from(e.childNodes).map((u) => O(this, hf, U_).call(this, u, r)).flat();\n  const s = e.ownerDocument.createRange();\n  s.selectNodeContents(e);\n  let a = 0;\n  const o = s.endOffset;\n  for (; a < o; ) {\n    s.setStart(e, a), s.setEnd(e, ++a);\n    const u = s.toString();\n    n.push({\n      ch: u,\n      rect: r(s.getBoundingClientRect(), u),\n      elm: s.startContainer.parentElement\n    });\n  }\n  return s.detach(), n;\n}, Ws = new WeakMap(), ao = new WeakMap(), cf = new WeakSet(), j_ = function() {\n  var a;\n  c(this, Qn).clear(), P(this, Vs, []), P(this, io, 0), this.skipChIn();\n  const e = c(this, Xt).cloneNode(!0);\n  e.textContent = \"\";\n  const r = c(this, Xt);\n  r.parentElement.insertBefore(e, r);\n  let n = 0;\n  r.querySelectorAll(\"span.sn_ch\").forEach((o) => {\n    var h, d, f;\n    const u = JSON.parse(\n      (o == null ? void 0 : o.dataset.add) ?? // 通常文字\n      ((h = o == null ? void 0 : o.children[0]) == null ? void 0 : h.getAttribute(\"data-add\")) ?? // ルビ\n      ((f = (d = o == null ? void 0 : o.children[0]) == null ? void 0 : d.children[0]) == null ? void 0 : f.getAttribute(\"data-add\")) ?? \"{}\"\n      // 縦中横\n    );\n    if (!u.ch_out_style)\n      return;\n    const l = c(At, rs)[u.ch_out_style];\n    if (l) {\n      if (l.wait === 0) {\n        o.style.display = \"none\";\n        return;\n      }\n      n += l.wait, l.join || (o.style.animationDelay = \"0ms\"), o.classList.add(`go_ch_out_${u.ch_out_style}`);\n    }\n  });\n  const s = () => {\n    r.parentElement.removeChild(r);\n    for (const o of c(this, dn).removeChildren())\n      o instanceof ye && c(At, eo).unButton(o), o.destroy();\n  };\n  n === 0 ? (c(this, Xt).textContent = \"\", s()) : (a = r.lastElementChild) == null || a.addEventListener(\"animationend\", s, { once: !0, passive: !0 }), P(this, Xt, e);\n}, kr = new WeakMap(), E(De, ul, void 0), E(De, sf, void 0), E(De, eo, void 0), E(De, bg, {\n  \"background-color\": 0,\n  \"border-bottom-width\": 0,\n  \"border-left-width\": 0,\n  \"border-right-width\": 0,\n  \"border-top-width\": 0,\n  \"margin-bottom\": 0,\n  \"margin-left\": 0,\n  \"margin-right\": 0,\n  \"margin-top\": 0\n}), E(De, no, void 0), E(De, so, void 0), E(De, fl, void 0), E(De, of, \"<span class='sn_ch sn_ch_last'>　</span>\"), E(De, es, /* @__PURE__ */ Object.create(null)), E(De, lf, /[\\s\\.,]/), E(De, rs, /* @__PURE__ */ Object.create(null)), E(De, pn, new ye());\nvar oo, vn, ff;\nconst As = class {\n  constructor() {\n    E(this, vn, () => {\n    });\n  }\n  static setting(t) {\n    t.sesame && P(As, oo, t.sesame);\n  }\n  static getSesame() {\n    return c(As, oo);\n  }\n  static destroy() {\n    P(As, oo, \"ヽ\");\n  }\n  init(t) {\n    P(this, vn, t);\n  }\n  static setEscape(t) {\n    P(As, ff, new RegExp(\n      `${t ? `(?<ce>\\\\${t}\\\\S)|` : \"\"}｜(?<str>[^《\\\\n]+)《(?<ruby>[^》\\\\n]+)》|(?:(?<kan>[⺀-⿟々〇〻㐀-鿿豈-﫿]+[ぁ-ヿ]*|[^　｜《》\\\\n])《(?<kan_ruby>[^》\\\\n]+)》)|(?<txt>[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[^｜《》]+?|.)`,\n      \"gs\"\n    ));\n  }\n  putTxt(t) {\n    for (const { groups: e } of t.matchAll(c(As, ff))) {\n      const { ruby: r, kan_ruby: n, kan: s, ce: a, txt: o = \"\", str: u } = e;\n      if (r) {\n        this.putTxtRb(decodeURIComponent(u), r);\n        continue;\n      }\n      if (n) {\n        this.putTxtRb(s, n);\n        continue;\n      }\n      if (a) {\n        c(this, vn).call(this, a.slice(1), \"\");\n        continue;\n      }\n      for (const l of Array.from(o))\n        c(this, vn).call(this, l, \"\");\n    }\n  }\n  putTxtRb(t, e) {\n    if (/^\\w+｜{\"/.test(e)) {\n      c(this, vn).call(this, t, e);\n      return;\n    }\n    const r = Array.from(t), n = r.length;\n    if (/^\\*.?$/.test(e)) {\n      const u = \"center｜\" + (e === \"*\" ? c(As, oo) : e.charAt(1));\n      for (let l = 0; l < n; ++l)\n        c(this, vn).call(this, r[l], u);\n      return;\n    }\n    if (n === 1 || e.indexOf(\" \") === -1) {\n      c(this, vn).call(this, t, decodeURIComponent(e));\n      return;\n    }\n    const s = e.split(\" \"), a = s.length, o = a > n ? a : n;\n    for (let u = 0; u < o; ++u)\n      c(this, vn).call(this, u < n ? r[u] : \"\", u < a ? decodeURIComponent(s[u]) : \"\");\n  }\n};\nlet la = As;\noo = new WeakMap(), vn = new WeakMap(), ff = new WeakMap(), E(la, oo, \"ヽ\"), /*\n\t\t★Unicodeで「漢字」の正規表現 – ものかの http://tama-san.com/kanji-regex/\n\t\t2E80..2FDF CJK部首補助＋康熙部首\n\t\t3005 々（漢字の踊り字）\n\t\t3007 〇（漢数字のゼロ）\n\t\t303B 〻（漢字の踊り字）\n\t\t3400..4DBF CJK統合漢字拡張A\n\t\t4E00..9FFF CJK統合漢字\n\t\tF900..FAFF CJK互換漢字\n\t\t20000..2FFFF CJK統合漢字拡張B〜F＋CJK互換漢字追加＋念のためU+2FFFFまで\n\n\t\t[\\x{2E80}-\\x{2FDF}々〇〻\\x{3400}-\\x{4DBF}\\x{4E00}-\\x{9FFF}\\x{F900}-\\x{FAFF}\\x{20000}-\\x{2FFFF}]\n\t\t[\\u2E80-\\u2FDF々〇〻\\u3400-\\u4DBF\\u4E00-\\u9FFF\\uF900-\\uFAFF\\u20000-\\u2FFFF]\n\t\t[⺀-⿟々〇〻㐀-䶿一-鿿豈-﫿\\u20000-\\u2FFFF]\t\t// 含まれない文字がある\n\t\t[⺀-⿟々〇〻㐀-鿿豈-﫿\\u20000-\\u2FFFF]\t\t\t// ヽ--30FD が変に引っかかる。多分\\u2000-\\u2FFF解釈\n\t\t\\\\u{20000}-\\\\u{2FFFF}\t// 五桁だとエラー\n\n\t\t【2022/10/03】ruby正規表現のUnicode プロパティ(とPOSIX文字クラス) - Qiita https://qiita.com/Takayuki_Nakano/items/8d38beaddb84b488d683\n\t\t\t> このHiraganaプロパティ、長音記号は含まれていません。\n\t\t\t> \\p{Han}…簡体字や繁体字、韓国語の漢字…ベトナム語の漢字にもマッチ\n\t\t\n\t\t・Unicode文字一覧表 - instant tools https://tools.m-bsys.com/ex/unicode_table.php\n*/\nE(la, ff, void 0);\nvar df, pf, Li, is, pl, vl, vf, z_, gl, ml, gf, H_;\nconst Ba = class extends ye {\n  constructor(e, r, n, s) {\n    var v;\n    super();\n    E(this, vf);\n    E(this, gf);\n    K(this, \"getBtnBounds\", () => c(this, Li));\n    // 文字ボタンは背景画像を含まない位置指定なので、その当たり判定用\n    E(this, Li, new Nt());\n    E(this, is, void 0);\n    E(this, pl, void 0);\n    E(this, vl, void 0);\n    K(this, \"normal\", () => {\n    });\n    E(this, gl, () => !1);\n    E(this, ml, () => {\n    });\n    this.hArg = e, this.evtMng = r, this.resolve = n, this.canFocus = s, Y.isDbg && (this.makeDesignCast = (g) => g(c(this, is)), this.cvsResize = () => c(this, is).cvsResize());\n    let a = {\n      x: this.x = ni(e.left ?? 0),\n      y: this.y = ni(e.top ?? 0),\n      rotation: this.angle = tt(e, \"rotation\", this.angle),\n      // flash : rotation is in degrees.\n      // pixijs: rotation is in radians, angle is in degrees.\n      pivot_x: this.pivot.x = tt(e, \"pivot_x\", this.pivot.x),\n      pivot_y: this.pivot.y = tt(e, \"pivot_y\", this.pivot.y),\n      scale_x: this.scale.x = tt(e, \"scale_x\", this.scale.x),\n      scale_y: this.scale.y = tt(e, \"scale_y\", this.scale.y),\n      width: 0,\n      height: 0\n    };\n    this.getBtnBounds = () => (c(this, Li).x = a.x, c(this, Li).y = a.y, c(this, Li));\n    const o = a.enabled = vt(e, \"enabled\", !0);\n    if (o && r.button(this.hArg, this, () => this.normal(), () => c(this, gl).call(this), () => c(this, ml).call(this)), e.pic) {\n      a.type = \"pic\", P(this, is, new H3(this, e)), Wt.csv2Sprites(\n        e.pic,\n        this,\n        (g) => {\n          O(this, gf, H_).call(this, g, a), c(this, Li).width = g.width * a.scale_x, c(this, Li).height = g.height * a.scale_y;\n        },\n        (g) => n\n      );\n      return;\n    }\n    if (!e.text)\n      throw \"textまたはpic属性は必須です\";\n    const u = tt(e, \"height\", 30), l = new Qo({\n      align: \"center\",\n      dropShadow: !0,\n      dropShadowAlpha: 0.7,\n      dropShadowColor: \"white\",\n      dropShadowBlur: 7,\n      dropShadowDistance: 0,\n      fill: o ? \"black\" : \"gray\",\n      fontFamily: Ba.fontFamily,\n      fontSize: u,\n      padding: 5\n    });\n    if (e.style)\n      try {\n        const g = JSON.parse(e.style);\n        for (const [m, y] of Object.entries(g))\n          l[m] = y;\n      } catch (g) {\n        throw new Error(Mp(e, \"style\", g.message));\n      }\n    const h = new tx(e.text ?? \"\", l);\n    h.alpha = tt(e, \"alpha\", h.alpha), h.width = tt(e, \"width\", 100), h.height = e.height = u, this.setText = (g) => h.text = g, a.type = \"text\", a = { ...a, ...l }, a.alpha = h.alpha, a.text = h.text, a.width = h.width, a.height = h.height, P(this, is, new z3(this, e, h));\n    let d = !1;\n    if (a.width = this.width, a.height = this.height, e.b_pic && (a.b_pic = e.b_pic, d = Wt.csv2Sprites(\n      e.b_pic,\n      this,\n      (g) => {\n        O(this, vf, z_).call(this, g, h), a.width = this.width, a.height = this.height;\n      },\n      (g) => {\n        _r.setBlendmode(this, e), g && n();\n      }\n    )), h.name = JSON.stringify(a), this.addChild(h), c(this, Li).width = h.width, c(this, Li).height = h.height, e.b_pic || _r.setBlendmode(this, e), c(v = Ba, df).call(v, this, h), !o) {\n      d || n();\n      return;\n    }\n    const f = l.clone();\n    if (e.style_hover)\n      try {\n        const g = JSON.parse(e.style_hover);\n        for (const [m, y] of Object.entries(g))\n          f[m] = y;\n      } catch (g) {\n        throw new Error(Mp(e, \"style_hover\", g.message));\n      }\n    else\n      f.fill = \"white\";\n    const p = f.clone();\n    if (e.style_clicked)\n      try {\n        const g = JSON.parse(e.style_clicked);\n        for (const [m, y] of Object.entries(g))\n          p[m] = y;\n      } catch (g) {\n        throw new Error(Mp(e, \"style_clicked\", g.message));\n      }\n    else\n      p.dropShadow = !1;\n    this.normal = () => h.style = l, P(this, gl, () => s() ? (h.style = f, !0) : !1), P(this, ml, () => h.style = p), d || n();\n  }\n  static init(e) {\n    e.oCfg.debug.masume && (P(Ba, df, (r, n) => r.addChild(\n      new ai().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, n.width, n.height).endFill()\n    )), P(Ba, pf, (r, n, s, a) => r.addChild(\n      new ai().beginFill(8926088, 0.2).lineStyle(1, 8926088, 1).drawRect(n.x, n.y, s, a).endFill()\n    )));\n  }\n  setText(e) {\n  }\n  destroy(e) {\n    this.evtMng.unButton(this), super.destroy();\n  }\n  makeDesignCast(e) {\n  }\n  showDesignCast() {\n    c(this, is).visible = !0;\n  }\n  cvsResize() {\n  }\n  update_b_pic(e, r) {\n    const n = JSON.parse(r.name ?? \"{}\");\n    c(this, pl) && this.removeChild(c(this, pl)), this.hArg.b_pic = n.b_pic = e, r.name = JSON.stringify(n), e && Wt.csv2Sprites(\n      e,\n      this,\n      (s) => O(this, vf, z_).call(this, s, r),\n      () => _r.setBlendmode(this, this.hArg)\n    );\n  }\n  update_pic(e, r) {\n    const n = JSON.parse(r.name ?? \"{}\");\n    c(this, vl) && this.removeChild(c(this, vl)), this.hArg.pic = n.pic = e, r.name = JSON.stringify(n), e && Wt.csv2Sprites(\n      e,\n      this,\n      (s) => O(this, gf, H_).call(this, s, n),\n      () => _r.setBlendmode(this, this.hArg)\n    );\n  }\n};\nlet Yi = Ba;\ndf = new WeakMap(), pf = new WeakMap(), Li = new WeakMap(), is = new WeakMap(), pl = new WeakMap(), vl = new WeakMap(), vf = new WeakSet(), z_ = function(e, r) {\n  P(this, pl, e), this.setChildIndex(e, 0), e.alpha = r.alpha, e.setTransform(\n    r.x,\n    r.y,\n    1,\n    1,\n    r.rotation,\n    0,\n    0,\n    (e.width - r.width) / 2,\n    (e.height - r.height) / 2\n  ), e.name = r.name;\n}, gl = new WeakMap(), ml = new WeakMap(), gf = new WeakSet(), H_ = function(e, r) {\n  var d;\n  P(this, vl, e), r.alpha = e.alpha = tt(this.hArg, \"alpha\", e.alpha), c(this, is).setSp(e);\n  const n = e.width / 3, s = e.height, a = e.texture.baseTexture, o = new Ot(a, new Nt(0, 0, n, s)), u = new Ot(a, new Nt(n, 0, n, s)), l = new Ot(a, new Nt(n * 2, 0, n, s)), h = () => e.texture = o;\n  h(), this.normal = h, P(this, gl, () => this.canFocus() ? (e.texture = l, !0) : !1), P(this, ml, () => e.texture = u), \"width\" in this.hArg ? (r.width = ni(this.hArg.width), this.scale.x *= r.width / n) : r.width = n, \"height\" in this.hArg ? (r.height = ni(this.hArg.height), this.scale.y *= r.height / s) : r.height = s, e.name = JSON.stringify(r), c(d = Ba, pf).call(d, this, e, n, s);\n}, K(Yi, \"fontFamily\", \"'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif\"), E(Yi, df, (e, r) => {\n}), E(Yi, pf, (e, r, n, s) => {\n});\nvar yl, Bi, mf, _l, yf, $_, _f, V_, bf, uo, xf, ns, lo, wg, eM, ss, vi, Fi, he, gn, re, wf, mn, Eg, Nr, ho, Ah, co, bl, fo, Lh, xl, Ef, X_, Sf, W_, po, vo, wl, Tf, El, Ys, Ar, Sg, rM, Kr, Cf, Sl, Yp, as, Oa, yn, Gi, gi, mi, Mf, Y_, Tl, qp, Pf, q_, go;\nconst Bt = class extends _r {\n  constructor() {\n    super();\n    E(this, ho);\n    E(this, fo);\n    E(this, Ef);\n    E(this, Sf);\n    E(this, Sg);\n    E(this, Sl);\n    E(this, as);\n    E(this, Mf);\n    E(this, Tl);\n    E(this, Pf);\n    // バック\n    E(this, ss, 0);\n    E(this, vi, 0);\n    E(this, Fi, !1);\n    E(this, he, void 0);\n    E(this, gn, \"\");\n    // 背景画像無し（＝単色塗り）\n    // 文字表示\n    E(this, re, new De(this.spLay, () => this.canFocus(), c(Bt, xf)));\n    E(this, wf, new la());\n    E(this, mn, document.createElement(\"span\"));\n    E(this, Nr, new ye());\n    E(this, co, \"\");\n    E(this, bl, !0);\n    E(this, xl, \"\");\n    E(this, po, \"\");\n    E(this, vo, (e) => \"\");\n    E(this, wl, \"\");\n    E(this, Tf, new RegExp(\"[　]\"));\n    K(this, \"isCur\", !1);\n    E(this, Ys, () => \"\");\n    E(this, Ar, \"\");\n    E(this, Kr, !1);\n    E(this, Cf, (e, r) => {\n      var l, h, d;\n      c(Bt, yl).oCfg.debug.putCh && console.log(`🖊 文字表示 text:\\`${e}\\` ruby:\\`${r}\\` name:\\`${this.name_}\\``);\n      const n = r.split(\"｜\");\n      let s = \"\";\n      const [a, ...o] = n, u = o.join(\"｜\");\n      switch (n.length) {\n        case 1:\n          if (P(this, Kr, !0), e === `\n`) {\n            c(this, Gi) ? (P(this, Gi, !1), s = \"<ruby>　<rt>　</rt></ruby><br/>\") : s = \"<br/>\";\n            break;\n          }\n          c(this, Gi) && (P(this, Gi, !1), r === \"\" && (r = \"　\")), s = O(this, Sl, Yp).call(this, e, r, c(this, Ar));\n          break;\n        default:\n          switch (a) {\n            case \"start\":\n            case \"left\":\n            case \"center\":\n            case \"right\":\n            case \"justify\":\n            case \"121\":\n            case \"even\":\n            case \"1ruby\":\n              P(this, Gi, !1), P(this, Kr, !0), s = O(this, Sl, Yp).call(this, e, u, a);\n              break;\n            case \"gotxt\":\n              O(this, Tl, qp).call(this), c(this, Kr) ? (this.isCur && c(Bt, _l).recText(\n                c(this, gi).join(\"\").replace(/^<ruby>　<rt>　<\\/rt><\\/ruby>(<br\\/>)+/, \"\").replaceAll(/style='(anim\\S+ \\S+?;\\s*)+/g, \"style='\").replaceAll(/( style=''| data-(add|arg|cmd)='.+?'|\\n+|\\t+)/g, \"\").replaceAll(/class='sn_ch .+?'/g, \"class='sn_ch'\").replaceAll(\"display: none;\", \"\").replaceAll(\"class='offrec'\", \"style='display: none;'\")\n                // 囲んだ領域は履歴で非表示\n              ), c(this, re).goTxt(c(this, gi), c(this, yn) === 0), P(this, Kr, !1), P(this, yn, 0)) : this.isCur && c(Bt, uo).noticeCompTxt();\n              return;\n            case \"add\":\n              {\n                const f = JSON.parse(u), { style: p = \"\", wait: v = null } = f, { cl: g, sty: m } = O(this, as, Oa).call(this, !0, v);\n                c(this, gi).push(`<span${g} style='${m} display: inline; ${p}'>`), delete f.style, O(this, Mf, Y_).call(this, f);\n              }\n              return;\n            case \"add_close\":\n              c(this, gi).push(\"</span>\"), O(this, Tl, qp).call(this);\n              return;\n            case \"grp\":\n              P(this, Kr, !0);\n              {\n                const f = JSON.parse(u);\n                if (f.id ?? (f.id = c(this, gi).length), f.id === \"break\") {\n                  c(this, re).dispBreak(f.pic);\n                  return;\n                }\n                P(this, Gi, !1), f.delay = c(this, yn), f.r ?? (f.r = \"\"), f.style ?? (f.style = \"\"), f.r_style ?? (f.r_style = \"\");\n                const { cl: p, sty: v, lnk: g } = O(this, as, Oa).call(this, !0, f.wait);\n                s = `<span${p} style='${v} ${f.style}'><ruby><span data-cmd='grp' data-arg='${JSON.stringify(f)}'${g} style='${v} display: inline;'>　</span><rt${g}${this.mkStyle_r_align(\n                  \"　\",\n                  f.r,\n                  c(this, Ar),\n                  c(this, mn).style.cssText + (((l = c(this, mi).at(-1)) == null ? void 0 : l.o.r_style) ?? \"\") + f.r_style\n                )}>${f.r}</rt></ruby></span>`;\n              }\n              break;\n            case \"tcy\":\n              P(this, Gi, !1), P(this, Kr, !0);\n              {\n                c(Bt, Bi).doRecLog() && P(this, go, c(this, go) + (e + (r ? `《${r}》` : \"\")));\n                const { t: f, r: p = \"\", wait: v = null, style: g = \"\", r_style: m = \"\" } = JSON.parse(u), y = Y.isSafari ? p.replaceAll(/[A-Za-z0-9]/g, (T) => String.fromCharCode(T.charCodeAt(0) + 65248)) : p, { cl: _, sty: b, lnk: w } = O(this, as, Oa).call(this, !0, v);\n                s = `<span${_} style='${b}${c(this, vo).call(this, f)} ${g}'><ruby><span${w} style='${b} display: inline;\ntext-combine-upright: all;\n-webkit-text-combine: horizontal;'>${f}</span><rt${w}${this.mkStyle_r_align(\n                  f,\n                  y,\n                  c(this, Ar),\n                  c(this, mn).style.cssText + (((h = c(this, mi).at(-1)) == null ? void 0 : h.o.r_style) ?? \"\") + m\n                )}>${y}</rt></ruby></span>`;\n              }\n              break;\n            case \"del\":\n              De.delBreak();\n              return;\n            case \"span\":\n              P(this, Kr, !0), O(this, Pf, q_).call(this, JSON.parse(u));\n              return;\n            case \"link\":\n              P(this, Kr, !0);\n              {\n                const f = JSON.parse(u);\n                f[\":link\"] = \" data-lnk='@'\";\n                const { cl: p, sty: v, curpos: g } = O(this, as, Oa).call(this, !1, f.wait);\n                c(this, gi).push(`<span${p} style='${v} display: inline; ${f.style ?? \"\"}' ${g} data-arg='${u}'>`), delete f.style, O(this, Pf, q_).call(this, f);\n              }\n              return;\n            case \"endlink\":\n              P(this, Kr, !0), c(this, gi).push(\"</span>\"), O(this, Tl, qp).call(this);\n              return;\n            default:\n              P(this, Kr, !0), s = O(this, Sl, Yp).call(this, e, r, c(this, Ar));\n          }\n          break;\n      }\n      c(this, gi).push(c(d = Bt, El).call(d, s));\n    });\n    E(this, yn, 0);\n    E(this, Gi, !0);\n    E(this, gi, []);\n    E(this, mi, []);\n    K(this, \"click\", () => !this.spLay.interactiveChildren || !this.spLay.visible ? !1 : c(this, re).skipChIn());\n    E(this, go, \"\");\n    K(this, \"addButton\", (e) => new Promise((r) => {\n      e.key = `btn=[${c(this, Nr).children.length}] ` + this.name_, e[\":id_tag\"] = e.key.slice(0, -7), vt(e, \"hint_tate\", c(this, re).tategaki);\n      const n = new Yi(e, c(Bt, uo), () => r(), () => this.canFocus());\n      n.name = JSON.stringify(e).replaceAll('\"', \"'\"), c(this, Nr).addChild(n);\n    }));\n    K(this, \"record\", () => ({\n      ...super.record(),\n      enabled: this.enabled,\n      r_cssText: c(this, mn).style.cssText,\n      r_align: c(this, Ar),\n      // バック\n      b_do: c(this, he) === void 0 ? void 0 : c(this, he) instanceof Ue ? \"Sprite\" : \"Graphics\",\n      b_pic: c(this, gn),\n      b_color: c(this, ss),\n      b_alpha: c(this, vi),\n      b_alpha_isfixed: c(this, Fi),\n      ffs: c(this, po),\n      txs: c(this, re).record(),\n      strNoFFS: c(this, wl),\n      btns: c(this, Nr).children.map((e) => e.name)\n    }));\n    this.spLay.addChild(c(this, re)), c(this, wf).init(c(this, Cf)), this.spLay.addChild(c(this, Nr)), c(this, Nr).name = \"cntBtn\";\n    const e = 16;\n    this.lay({ style: `width: ${Y.stageW}px; height: ${Y.stageH}px; font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', '游ゴシック Medium', meiryo, sans-serif; color: white; font-size: 24px; line-height: 1.5; padding: ${e}px;`, in_style: \"default\", out_style: \"default\", back_clear: \"true\" });\n  }\n  static init(e, r, n, s, a, o) {\n    var u, l;\n    P(Bt, yl, e), De.init(e, o), P(Bt, Bi, n), P(Bt, _l, s), P(Bt, mf, a), n.setDoRecProc(Bt.chgDoRec), r.autowc = (h) => {\n      var d;\n      return O(d = Bt, wg, eM).call(d, h);\n    }, r.autowc({ enabled: !1, text: \"\", time: 0 }), r.ch_in_style = (h) => {\n      var d;\n      return O(d = Bt, yf, $_).call(d, h);\n    }, r.ch_out_style = (h) => {\n      var d;\n      return O(d = Bt, _f, V_).call(d, h);\n    }, De.initChStyle(), ZP(), Lu(\n      e.matchPath(\".+\", vr.FONT).flatMap((h) => Object.values(h).map((d) => `\n@font-face {\n\tfont-family: '${d}';\n\tsrc: url('${c(this, yl).searchPath(d, vr.FONT)}');\n}\n`)).join(\"\") + `\n.sn_tx {\n\tpointer-events: none;\n\tuser-select: none;\n\t-webkit-touch-callout: none;\n\tbox-sizing: border-box;\n}\n.sn_ch {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n`\n      // 「sn_ch」と「sn_ch_in_〜」の中身が重複しているが、これは必須\n    ), O(u = Bt, yf, $_).call(u, {\n      name: \"default\",\n      wait: 500,\n      alpha: 0,\n      x: \"=0.3\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !0,\n      ease: \"ease-out\"\n    }), O(l = Bt, _f, V_).call(l, {\n      name: \"default\",\n      wait: 0,\n      alpha: 0,\n      x: \"=0\",\n      y: \"=0\",\n      scale_x: 1,\n      scale_y: 1,\n      rotate: 0,\n      join: !1,\n      ease: \"ease-out\"\n    });\n  }\n  static setEvtMng(e, r, n) {\n    P(Bt, bf, e), P(Bt, uo, r), P(Bt, xf, n), De.setEvtMng(r);\n  }\n  destroy() {\n    c(this, he) && (this.spLay.removeChild(c(this, he)).destroy(), P(this, he, void 0)), this.clearText(), c(this, re).destroy();\n  }\n  static destroy() {\n    P(Bt, ns, !1), P(Bt, lo, {}), P(Bt, El, (e) => e);\n  }\n  set name(e) {\n    this.name_ = e, c(this, re).name = e;\n  }\n  get name() {\n    return this.name_;\n  }\n  // getは継承しないらしい\n  cvsResize() {\n    c(this, re).cvsResize();\n  }\n  cvsResizeChildren() {\n    for (const e of c(this, Nr).children)\n      e.cvsResize();\n  }\n  lay(e) {\n    if (super.lay(e), _r.setXY(this.spLay, e, this.spLay), e[\":id_tag\"] = this.name_.slice(0, -7), la.setting(e), O(this, Sf, W_).call(this, e), c(this, re).lay(e), \"r_align\" in e && P(this, Ar, e.r_align ?? \"\"), P(this, Ys, Y.isSafari ? c(this, re).tategaki ? (r, n) => `text-align: start; height: ${n}em; padding-top: ${r}; padding-bottom: ${r};` : (r, n) => `text-align: start; width: ${n}em; padding-left: ${r}; padding-right: ${r};` : c(this, re).tategaki ? (r) => `text-align: justify; text-align-last: justify; padding-top: ${r}; padding-bottom: ${r};` : (r) => `text-align: justify; text-align-last: justify; padding-left: ${r}; padding-right: ${r};`), Y.isFirefox && (this.mkStyle_r_align = O(this, Sg, rM)), \"r_style\" in e)\n      if (e.r_style) {\n        const r = document.createElement(\"span\");\n        r.style.cssText = e.r_style;\n        const n = r.style.length, s = c(this, mn).style;\n        for (let a = 0; a < n; ++a) {\n          const o = r.style[a];\n          if (o in c(Bt, Eg)) {\n            zt.myTrace(`${o}は指定できません`, \"W\");\n            continue;\n          }\n          s[o] = r.style[o];\n        }\n      } else\n        c(this, mn).style.cssText = \"\";\n    if (\"alpha\" in e)\n      for (const r of c(this, Nr).children)\n        r.alpha = this.spLay.alpha;\n    return O(this, ho, Ah).call(this, e), O(this, fo, Lh).call(this, e), O(this, Ef, X_).call(this, e, (r) => {\n      r && c(Bt, bf).resume();\n    });\n  }\n  get width() {\n    return c(this, re).getWidth;\n  }\n  get height() {\n    return c(this, re).getHeight;\n  }\n  chgBackAlpha(e) {\n    const r = c(this, Fi) ? c(this, vi) : e * c(this, vi);\n    c(this, he) instanceof ai && (c(this, he) && (this.spLay.removeChild(c(this, he)), c(this, he).destroy()), this.spLay.addChildAt(\n      P(this, he, new ai()).beginFill(c(this, ss)).lineStyle(void 0).drawRect(0, 0, c(this, re).getWidth, c(this, re).getHeight).endFill(),\n      0\n    ), c(this, he).name = \"back(color)\"), c(this, he) && (c(this, he).visible = r > 0, c(this, he).alpha = r);\n  }\n  // Safariが全体に「font-feature-settings」した後、特定文字の「font-feature-settings: initial;」を受け付けてくれないのでわざわざ一つずつ指定\n  static chgDoRec(e) {\n    P(Bt, El, e ? (r) => r : (r) => `<span class='offrec'>${r}</span>`);\n  }\n  mkStyle_r_align(e, r, n, s = \"\") {\n    if (!n)\n      return ` style='${s}'`;\n    const a = e.length * 2;\n    if (a - r.length < 0)\n      return ` style='text-align: ${n}; ${s}'`;\n    let o = \"\";\n    switch (n) {\n      case \"justify\":\n        o = c(this, Ys).call(this, \"0\", a);\n        break;\n      case \"121\":\n        o = c(this, Ys).call(this, `calc(${(a - r.length) / (r.length * 2)}em)`, a);\n        break;\n      case \"even\":\n        o = c(this, Ys).call(this, `calc(${(a - r.length) / (r.length + 1)}em)`, a);\n        break;\n      case \"1ruby\":\n        o = c(this, Ys).call(this, \"1em\", a);\n        break;\n      default:\n        o = `text-align: ${n};`;\n    }\n    return ` style='${o} ${s}'`;\n  }\n  tagCh(e) {\n    c(this, wf).putTxt(e);\n  }\n  clearText() {\n    this.spLay.addChild(P(this, re, c(this, re).reNew())), P(this, yn, 0), P(this, Gi, !0), P(this, gi, []), P(this, go, \"\"), c(Bt, _l).recPagebreak();\n  }\n  get pageText() {\n    return c(this, go).replace(\"《　》\", \"\");\n  }\n  get enabled() {\n    return this.spLay.interactiveChildren;\n  }\n  set enabled(e) {\n    this.spLay.interactiveChildren = e;\n  }\n  canFocus() {\n    var e;\n    return (this.spLay.interactiveChildren ?? !1) && this.spLay.visible && c(e = Bt, mf).call(e, this);\n  }\n  clearLay(e) {\n    super.clearLay(e), this.clearText();\n    for (const r of c(this, Nr).removeChildren())\n      r.destroy();\n  }\n  playback(e, r) {\n    super.playback(e, r), this.enabled = e.enabled, c(this, mn).style.cssText = e.r_cssText, P(this, Ar, e.r_align), this.cvsResize(), O(this, Sf, W_).call(this, e), c(this, re).playback(e.txs), P(this, vi, e.b_alpha), P(this, Fi, e.b_alpha_isfixed), r.push(new Promise((s) => {\n      const a = e.b_do ? e.b_do === \"Sprite\" ? { b_pic: e.b_pic } : { b_color: e.b_color } : { b_pic: \"\" };\n      a.b_alpha = e.b_alpha, a.b_alpha_isfixed = e.b_alpha_isfixed, O(this, Ef, X_).call(this, a, (o) => {\n        o && s();\n      }) || s();\n    }));\n    const n = e.btns;\n    r = r.concat(n.map((s) => this.addButton(JSON.parse(s.replaceAll(\"'\", '\"')))));\n  }\n  snapshot(e, r) {\n    e.render(this.spLay, { clear: !1 }), c(this, re).snapshot(e, r);\n  }\n  snapshot_end() {\n    c(this, re).snapshot_end();\n  }\n  makeDesignCast(e) {\n    this.spLay.visible && c(this, re).makeDesignCast(e);\n  }\n  makeDesignCastChildren(e) {\n    if (this.spLay.visible)\n      for (const r of c(this, Nr).children)\n        r.makeDesignCast(e);\n  }\n  showDesignCast() {\n    c(this, re).showDesignCast();\n  }\n  showDesignCastChildren() {\n    for (const e of c(this, Nr).children)\n      e.showDesignCast();\n  }\n  dump() {\n    return c(this, Cf).call(this, \"\", \"gotxt｜\"), super.dump() + `, \"enabled\":\"${this.enabled}\", ${c(this, re).dump()}, \"b_pic\":\"${c(this, gn)}\", \"b_color\":\"${c(this, ss)}\", \"b_alpha\":${c(this, vi)}, \"b_alpha_isfixed\":\"${c(this, Fi)}\", \"width\":${c(this, re).getWidth}, \"height\":${c(this, re).getHeight}, \"pixi_obj\":[${this.spLay.children.map((e) => `{\"class\":\"${e instanceof Ue ? \"Sprite\" : e instanceof ai ? \"Graphics\" : e instanceof ye ? \"Container\" : \"?\"}\", \"name\":\"${e.name}\", \"alpha\":${e.alpha}, \"x\":${e.x}, \"y\":${e.y}, \"visible\":\"${e.visible}\"}`).join(\",\")}], \"button\":[${c(this, Nr).children.map((e) => e.children[0].name ?? \"{}\").join(\",\")}]`;\n  }\n};\nlet Se = Bt;\nyl = new WeakMap(), Bi = new WeakMap(), mf = new WeakMap(), _l = new WeakMap(), yf = new WeakSet(), $_ = function(e) {\n  const r = De.ch_in_style(e), n = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, s = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: a } = e;\n  return Lu(`\n.sn_ch_in_${a} {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n.go_ch_in_${a} {\n\topacity: ${r.alpha};\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: sn_ch_in_${a} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes sn_ch_in_${a} {\n\tfrom {transform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${n}, ${s});}\n\tto {opacity: 1; transform: none;}\n}\n`), !1;\n}, _f = new WeakSet(), V_ = function(e) {\n  const r = De.ch_out_style(e), n = r.x.at(0) === \"=\" ? `${r.nx * 100}%` : `${r.nx}px`, s = r.y.at(0) === \"=\" ? `${r.ny * 100}%` : `${r.ny}px`, { name: a } = e;\n  return Lu(`\n.go_ch_out_${a} {\n\tposition: relative;\n\tdisplay: inline-block;\n\tanimation: go_ch_out_${a} ${r.wait}ms ${r.ease} 0s both;\n}\n@keyframes go_ch_out_${a} {\n\tto {\n\t\topacity: ${r.alpha};\n\t\ttransform: rotate(${r.rotate}deg) scale(${r.scale_x}, ${r.scale_y}) translate(${n}, ${s});\n\t}\n`), !1;\n}, bf = new WeakMap(), uo = new WeakMap(), xf = new WeakMap(), ns = new WeakMap(), lo = new WeakMap(), wg = new WeakSet(), eM = function(e) {\n  P(Bt, ns, vt(e, \"enabled\", c(Bt, ns))), c(Bt, Bi).setVal_Nochk(\"save\", \"const.sn.autowc.enabled\", c(Bt, ns));\n  const { text: r } = e;\n  if (\"text\" in e != \"time\" in e)\n    throw \"[autowc] textとtimeは同時指定必須です\";\n  if (c(Bt, Bi).setVal_Nochk(\"save\", \"const.sn.autowc.text\", r), !r)\n    return c(Bt, Bi).setVal_Nochk(\"save\", \"const.sn.autowc.time\", \"\"), !1;\n  const n = r.length;\n  if (c(Bt, ns) && n === 0)\n    throw '[autowc] enabled === false かつ text === \"\" は許されません';\n  const s = String(e.time).split(\",\");\n  if (s.length !== n)\n    throw \"[autowc] text文字数とtimeに記述された待ち時間（コンマ区切り）は同数にして下さい\";\n  return P(Bt, lo, {}), s.forEach((a, o) => c(Bt, lo)[r[o]] = ni(a)), c(Bt, Bi).setVal_Nochk(\"save\", \"const.sn.autowc.time\", e.time), !1;\n}, ss = new WeakMap(), vi = new WeakMap(), Fi = new WeakMap(), he = new WeakMap(), gn = new WeakMap(), re = new WeakMap(), wf = new WeakMap(), mn = new WeakMap(), Eg = new WeakMap(), Nr = new WeakMap(), ho = new WeakSet(), Ah = function(e) {\n  const { in_style: r } = e;\n  if (!r)\n    return;\n  const n = De.getChInStyle(r);\n  if (!n)\n    throw `存在しないin_style【${r}】です`;\n  P(this, co, r), P(this, bl, n.join);\n}, co = new WeakMap(), bl = new WeakMap(), fo = new WeakSet(), Lh = function(e) {\n  const { out_style: r } = e;\n  if (!r)\n    return;\n  if (!De.getChOutStyle(r))\n    throw `存在しないout_style【${r}】です`;\n  P(this, xl, r);\n}, xl = new WeakMap(), Ef = new WeakSet(), X_ = function(e, r) {\n  if (\"back_clear\" in e)\n    return vt(e, \"back_clear\", !1) && (P(this, ss, 0), P(this, vi, 0), P(this, Fi, !1), P(this, gn, \"\")), r(!1), !1;\n  P(this, vi, tt(e, \"b_alpha\", c(this, vi))), P(this, Fi, vt(e, \"b_alpha_isfixed\", c(this, Fi)));\n  const n = (c(this, Fi) ? 1 : Number(c(Bt, Bi).getVal(\"sys:TextLayer.Back.Alpha\"))) * c(this, vi);\n  if (e.b_pic) {\n    if (c(this, gn) !== e.b_pic)\n      return P(this, gn, e.b_pic), c(this, he) && (this.spLay.removeChild(c(this, he)), c(this, he).destroy()), Wt.csv2Sprites(c(this, gn), this.spLay, (s) => {\n        P(this, he, s), s.name = \"back(pic)\", s.visible = n > 0, s.alpha = n, c(this, re).setSize(s.width, s.height), this.spLay.setChildIndex(s, 0), r(!0);\n      });\n  } else\n    \"b_color\" in e && (P(this, ss, wE(e, \"b_color\", 0)), c(this, he) && (this.spLay.removeChild(c(this, he)), c(this, he).destroy()), P(this, gn, \"\"), this.spLay.addChildAt(\n      P(this, he, new ai()).beginFill(c(this, ss)).lineStyle(void 0).drawRect(0, 0, c(this, re).getWidth, c(this, re).getHeight).endFill(),\n      0\n    ), c(this, he).name = \"back(color)\");\n  return c(this, he) && (c(this, he).visible = n > 0, c(this, he).alpha = n), r(!1), !1;\n}, Sf = new WeakSet(), W_ = function(e) {\n  \"noffs\" in e && (P(this, wl, e.noffs ?? \"\"), P(this, Tf, new RegExp(`[　${c(this, wl)}]`))), \"ffs\" in e && (c(this, po) ?? P(this, po, \"\"), P(this, vo, c(this, po) === \"\" ? () => \"\" : (r) => c(this, Tf).test(r) ? \"\" : ` font-feature-settings: ${c(this, po)};`));\n}, po = new WeakMap(), vo = new WeakMap(), wl = new WeakMap(), Tf = new WeakMap(), El = new WeakMap(), Ys = new WeakMap(), Ar = new WeakMap(), Sg = new WeakSet(), rM = function(e, r, n, s = \"\") {\n  if (!n)\n    return ` style='${s}'`;\n  const a = e.length * 2;\n  if (a - r.length < 0)\n    return ` style='text-align: ${n}; ${s}'`;\n  let o = \"\";\n  switch (n) {\n    case \"left\":\n      o = \"ruby-align: start;\";\n      break;\n    case \"center\":\n      o = \"ruby-align: center;\";\n      break;\n    case \"right\":\n      o = \"ruby-align: start;\";\n      break;\n    case \"justify\":\n      o = \"ruby-align: space-between;\";\n      break;\n    case \"121\":\n      o = \"ruby-align: space-around;\";\n      break;\n    case \"even\":\n      const u = (a - r.length) / (r.length + 1);\n      o = \"ruby-align: space-between; \" + (c(this, re).tategaki ? `padding-top: ${u}em; padding-bottom: ${u}em;` : `padding-left: ${u}em; padding-right: ${u}em;`);\n      break;\n    case \"1ruby\":\n      o = \"ruby-align: space-between; \" + (c(this, re).tategaki ? \"padding-top: 1em; padding-bottom: 1em;\" : \"padding-left: 1em; padding-right: 1em;\");\n      break;\n    default:\n      o = `text-align: ${n};`;\n  }\n  return ` style='${o} ${s}'`;\n}, Kr = new WeakMap(), Cf = new WeakMap(), Sl = new WeakSet(), Yp = function(e, r, n) {\n  var l;\n  const s = e === \" \" ? \"&nbsp;\" : e;\n  c(Bt, Bi).doRecLog() && P(this, go, c(this, go) + (s + (r ? `《${r}》` : \"\")));\n  const { cl: a, sty: o, lnk: u } = O(this, as, Oa).call(this, !0, null, e);\n  return r ? `<span${a} style='${o} ${c(this, vo).call(this, e)}'><ruby>${// 文字個別に出現させるため以下にも ${cl} が必要\n  Array.from(e).map((h, d) => `<span${a}${u} style='${d > 0 ? O(this, as, Oa).call(this, !0, null, e).sty : o} display: inline;'>${h === \" \" ? \"&nbsp;\" : h}</span>`).join(\"\")}<rt${u}${this.mkStyle_r_align(\n    e,\n    r,\n    n,\n    c(this, mn).style.cssText + (((l = c(this, mi).at(-1)) == null ? void 0 : l.o.r_style) ?? \"\")\n  )}>${r}</rt></ruby></span>` : `<span${a} style='${o} ${c(this, vo).call(this, e)}'${u}>${s}</span>`;\n}, as = new WeakSet(), Oa = function(e, r, n = `\n`) {\n  var o, u, l;\n  const s = c(this, bl) ? r ?? ((o = c(this, mi).at(0)) == null ? void 0 : o.o.wait) ?? (c(Bt, ns) ? c(Bt, lo)[n.at(0) ?? \"\"] ?? 0 : Ua.msecChWait) : 0;\n  c(Bt, uo).isSkippingByKeyDown() ? P(this, yn, 0) : e && c(this, bl) && P(this, yn, c(this, yn) + Number(s));\n  const a = `data-add='{\"ch_in_style\":\"${c(this, co)}\", \"ch_out_style\":\"${c(this, xl)}\"}'`;\n  return {\n    cl: ` class='sn_ch${s > 0 ? ` sn_ch_in_${c(this, co)}` : \"\"}'`,\n    // TxtStage.goTxt()はこれ単位で文字出現させる\n    sty: `animation-delay: ${c(this, yn)}ms;${((u = c(this, mi).at(-1)) == null ? void 0 : u.o.style) ?? \"\"}`,\n    // TxtStage.goTxt()はこれ単位で文字出現させる\n    lnk: (((l = c(this, mi).at(0)) == null ? void 0 : l.o[\":link\"]) ?? \"\") + \" \" + a,\n    curpos: a\n  };\n}, yn = new WeakMap(), Gi = new WeakMap(), gi = new WeakMap(), mi = new WeakMap(), Mf = new WeakSet(), Y_ = function(e) {\n  c(this, mi).push({\n    o: e,\n    r_align: c(this, Ar),\n    ch_in_style: c(this, co),\n    ch_out_style: c(this, xl)\n  }), \"r_align\" in e && P(this, Ar, e.r_align), O(this, ho, Ah).call(this, e), O(this, fo, Lh).call(this, e);\n}, Tl = new WeakSet(), qp = function() {\n  const e = c(this, mi).pop();\n  e && (P(this, Ar, e.r_align), O(this, ho, Ah).call(this, { in_style: e.ch_in_style }), O(this, fo, Lh).call(this, { out_style: e.ch_out_style }));\n}, Pf = new WeakSet(), q_ = function(e) {\n  const r = c(this, mi).at(-1);\n  if (!r) {\n    O(this, Mf, Y_).call(this, e);\n    return;\n  }\n  r.o = { ...r.o, ...e }, !e.style && !e.r_style && (r.o.style = \"\", r.o.r_style = \"\"), \"r_align\" in e && P(this, Ar, e.r_align), O(this, ho, Ah).call(this, e), O(this, fo, Lh).call(this, e);\n}, go = new WeakMap(), // 文字出現演出\nE(Se, yf), // 文字消去演出\nE(Se, _f), E(Se, wg), E(Se, yl, void 0), E(Se, Bi, void 0), E(Se, mf, void 0), E(Se, _l, void 0), E(Se, bf, void 0), E(Se, uo, void 0), E(Se, xf, void 0), // 文字ごとのウェイト\nE(Se, ns, !1), E(Se, lo, {}), // cssチェック・保存用\nE(Se, Eg, {\n  \"text-align\": 0,\n  \"text-align-last\": 0,\n  height: 0,\n  width: 0,\n  \"padding-left\": 0,\n  \"padding-right\": 0,\n  \"padding-top\": 0,\n  \"padding-bottom\": 0\n}), E(Se, El, (e) => e);\nvar Cl, mo, Tg, iM, Ml, Pl, Zp, Cg, nM, Mg, sM, Of, Pg, aM, Og, oM;\nclass $3 {\n  constructor(t, e, r, n, s, a, o) {\n    //\tHTMLフレーム\n    // フレーム追加\n    E(this, Tg);\n    E(this, Pl);\n    // フレーム変数を取得\n    E(this, Cg);\n    // フレーム変数に設定\n    E(this, Mg);\n    E(this, Pg);\n    // フレームをトゥイーン開始\n    E(this, Og);\n    E(this, Cl, void 0);\n    E(this, mo, /* @__PURE__ */ Object.create(null));\n    E(this, Ml, {});\n    // フレームに設定\n    E(this, Of, 1);\n    this.cfg = t, this.appPixi = r, this.val = n, this.main = s, this.sys = a, this.hTwInf = o, e.add_frame = (u) => O(this, Tg, iM).call(this, u), e.let_frame = (u) => O(this, Cg, nM).call(this, u), e.set_frame = (u) => O(this, Mg, sM).call(this, u), e.frame = (u) => O(this, Pg, aM).call(this, u), e.tsy_frame = (u) => O(this, Og, oM).call(this, u);\n  }\n  setEvtMng(t) {\n    P(this, Cl, t);\n  }\n  destroy() {\n    for (const t of Object.values(c(this, mo)))\n      t.parentElement.removeChild(t);\n    P(this, mo, /* @__PURE__ */ Object.create(null));\n  }\n  getFrmDisabled(t) {\n    return c(this, Ml)[t];\n  }\n  cvsResize() {\n    for (const [t, e] of Object.entries(c(this, mo))) {\n      const r = \"const.sn.frm.\" + t, n = Number(this.val.getVal(r + \".x\")), s = Number(this.val.getVal(r + \".y\")), a = Number(this.val.getVal(r + \".width\")), o = Number(this.val.getVal(r + \".height\"));\n      e.style.left = `${this.sys.ofsLeft4elm + n * this.sys.cvsScale}px`, e.style.top = `${this.sys.ofsTop4elm + s * this.sys.cvsScale}px`, e.width = String(a * this.sys.cvsScale), e.height = String(o * this.sys.cvsScale);\n    }\n  }\n}\nCl = new WeakMap(), mo = new WeakMap(), Tg = new WeakSet(), iM = function(t) {\n  const { id: e, src: r, alpha: n = 1, scale_x: s = 1, scale_y: a = 1, rotate: o = 0 } = t;\n  if (!e)\n    throw \"idは必須です\";\n  if (!r)\n    throw \"srcは必須です\";\n  const u = \"const.sn.frm.\" + e;\n  if (this.val.getVal(`tmp:${u}`))\n    throw `frame【${e}】はすでにあります`;\n  const l = vt(t, \"visible\", !0), h = t.b_color ? ` background-color: ${t.b_color};` : \"\", d = O(this, Pl, Zp).call(this, t);\n  Ur.cvs.insertAdjacentHTML(\"beforebegin\", `<iframe id=\"${e}\" sandbox=\"allow-scripts allow-same-origin\" style=\"opacity: ${n}; position: absolute; left:${this.sys.ofsLeft4elm + d.x * this.sys.cvsScale}px; top: ${this.sys.ofsTop4elm + d.y * this.sys.cvsScale}px; z-index: 1; ${h} border: 0px; overflow: hidden; display: ${l ? \"inline\" : \"none\"}; transform: scale(${s}, ${a}) rotate(${o}deg);\" width=\"${d.width * this.sys.cvsScale}\" height=\"${d.height * this.sys.cvsScale}\"></iframe>`);\n  const f = this.cfg.searchPath(r, vr.HTML), p = new ii().add({ name: r, url: f, xhrType: Ft.XHR_RESPONSE_TYPE.TEXT });\n  return this.sys.crypto && p.use((v, g) => {\n    try {\n      v.data = this.sys.decStr(v.extension, v.data);\n    } catch (m) {\n      this.main.errScript(`[add_frame]Html ロード失敗です src:${v.name} ${m}`, !1);\n    }\n    g == null || g();\n  }), p.load((v, g) => {\n    var y;\n    const m = document.getElementById(e);\n    c(this, mo)[e] = m, c(this, Ml)[e] = !1, m.srcdoc = String((y = g[r]) == null ? void 0 : y.data).replace(\"sn_repRes();\", \"\").replaceAll(\n      /\\s(?:src|href)=([\"'])(\\S+)\\1/g,\n      (_, b, w) => w.slice(0, 3) === \"../\" ? this.sys.cur + w.slice(4) : _.replace(b, b + f.slice(0, f.lastIndexOf(\"/\") + 1))\n    ), m.onload = () => {\n      var b;\n      this.val.setVal_Nochk(\"tmp\", u, !0), this.val.setVal_Nochk(\"tmp\", u + \".alpha\", n), this.val.setVal_Nochk(\"tmp\", u + \".x\", d.x), this.val.setVal_Nochk(\"tmp\", u + \".y\", d.y), this.val.setVal_Nochk(\"tmp\", u + \".scale_x\", s), this.val.setVal_Nochk(\"tmp\", u + \".scale_y\", a), this.val.setVal_Nochk(\"tmp\", u + \".rotate\", o), this.val.setVal_Nochk(\"tmp\", u + \".width\", d.width), this.val.setVal_Nochk(\"tmp\", u + \".height\", d.height), this.val.setVal_Nochk(\"tmp\", u + \".visible\", l);\n      const _ = m.contentWindow;\n      c(this, Cl).resvFlameEvent(_), (b = _.sn_repRes) == null || b.call(_, (w) => Wt.loadPic2Img(w.dataset.src ?? \"\", w)), this.main.resume();\n    };\n  }), !0;\n}, Ml = new WeakMap(), Pl = new WeakSet(), Zp = function(t) {\n  const e = { ...t }, r = this.sys.resolution;\n  return new DOMRect(\n    tt(e, \"x\", 0) * r,\n    tt(e, \"y\", 0) * r,\n    tt(e, \"width\", Y.stageW) * r,\n    tt(e, \"height\", Y.stageH) * r\n  );\n}, Cg = new WeakSet(), nM = function(t) {\n  const { id: e, var_name: r } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const n = document.getElementById(e);\n  if (!n)\n    throw `id【${e}】はフレームではありません`;\n  const s = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${s}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  const a = n.contentWindow;\n  if (!a.hasOwnProperty(r))\n    throw `frame【${e}】に変数/関数【${r}】がありません。変数は var付きにして下さい`;\n  const o = a[r];\n  return this.val.setVal_Nochk(\n    \"tmp\",\n    s + \".\" + r,\n    vt(t, \"function\", !1) ? o() : o\n  ), !1;\n}, Mg = new WeakSet(), sM = function(t) {\n  const { id: e, var_name: r, text: n } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const s = document.getElementById(e);\n  if (!s)\n    throw `id【${e}】はフレームではありません`;\n  const a = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${a}`))\n    throw `frame【${e}】が読み込まれていません`;\n  if (!r)\n    throw \"var_nameは必須です\";\n  if (!n)\n    throw \"textは必須です\";\n  this.val.setVal_Nochk(\"tmp\", a + \".\" + r, n);\n  const o = s.contentWindow;\n  return o[r] = n, !1;\n}, Of = new WeakMap(), Pg = new WeakSet(), aM = function(t) {\n  const { id: e } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const r = document.getElementById(e);\n  if (!r)\n    throw `id【${e}】はフレームではありません`;\n  const n = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(\"tmp:\" + n))\n    throw `frame【${e}】が読み込まれていません`;\n  const s = r.style;\n  if (vt(t, \"float\", !1) ? s.zIndex = `${++Ve(this, Of)._}` : \"index\" in t ? s.zIndex = `${tt(t, \"index\", 0)}` : t.dive && (s.zIndex = `-${++Ve(this, Of)._}`), \"alpha\" in t) {\n    const o = s.opacity = String(t.alpha);\n    this.val.setVal_Nochk(\"tmp\", n + \".alpha\", o);\n  }\n  const a = O(this, Pl, Zp).call(this, t);\n  if ((\"x\" in t || \"y\" in t) && (s.left = `${this.sys.ofsLeft4elm + a.x * this.sys.cvsScale}px`, s.top = `${this.sys.ofsTop4elm + a.y * this.sys.cvsScale}px`, this.val.setVal_Nochk(\"tmp\", n + \".x\", a.x), this.val.setVal_Nochk(\"tmp\", n + \".y\", a.y)), \"scale_x\" in t || \"scale_y\" in t || \"rotate\" in t) {\n    const o = tt(t, \"scale_x\", 1), u = tt(t, \"scale_y\", 1), l = tt(t, \"rotate\", 0);\n    s.transform = `scale(${o}, ${u}) rotate(${l}deg)`, this.val.setVal_Nochk(\"tmp\", n + \".scale_x\", o), this.val.setVal_Nochk(\"tmp\", n + \".scale_y\", u), this.val.setVal_Nochk(\"tmp\", n + \".rotate\", l);\n  }\n  if (\"width\" in t && (r.width = String(a.width * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", n + \".width\", a.width)), \"height\" in t && (r.height = String(a.height * this.sys.cvsScale), this.val.setVal_Nochk(\"tmp\", n + \".height\", a.height)), \"visible\" in t) {\n    const o = vt(t, \"visible\", !0);\n    s.display = o ? \"inline\" : \"none\", this.val.setVal_Nochk(\"tmp\", n + \".visible\", o);\n  }\n  if (\"b_color\" in t && (s.backgroundColor = t.b_color), \"disabled\" in t) {\n    const o = c(this, Ml)[e] = vt(t, \"disabled\", !0);\n    r.contentDocument.body.querySelectorAll(\"input,select\").forEach((l) => l.disabled = o);\n  }\n  return !1;\n}, Og = new WeakSet(), oM = function(t) {\n  const { id: e, alpha: r, x: n, y: s, scale_x: a, scale_y: o, rotate: u, width: l, height: h, ease: d, path: f, chain: p } = t;\n  if (!e)\n    throw \"idは必須です\";\n  const v = document.getElementById(e);\n  if (!v)\n    throw `id【${e}】はフレームではありません`;\n  const g = \"const.sn.frm.\" + e;\n  if (!this.val.getVal(`tmp:${g}`, 0))\n    throw `frame【${e}】が読み込まれていません`;\n  const m = {};\n  r && (m.a = v.style.opacity), (n || s || a || o || u) && (m.x = Number(this.val.getVal(`tmp:${g}.x`)), m.y = Number(this.val.getVal(`tmp:${g}.y`)), m.sx = Number(this.val.getVal(`tmp:${g}.scale_x`)), m.sy = Number(this.val.getVal(`tmp:${g}.scale_y`)), m.r = Number(this.val.getVal(`tmp:${g}.rotate`))), l && (m.w = this.val.getVal(`tmp:${g}.width`)), h && (m.h = this.val.getVal(`tmp:${g}.height`));\n  const y = ov(t, m), _ = {};\n  let b = () => {\n  };\n  r && (_.a = tt(y, \"alpha\", 0), b = () => {\n    v.style.opacity = m.a, this.val.setVal_Nochk(\"tmp\", \"alpha\", m.a);\n  });\n  let w = () => {\n  };\n  const T = O(this, Pl, Zp).call(this, y);\n  (n || s || a || o || u) && (_.x = T.x, _.y = T.y, _.sx = tt(y, \"scale_x\", 1), _.sy = tt(y, \"scale_y\", 1), _.r = tt(y, \"rotate\", 0), w = () => {\n    v.style.left = this.sys.ofsLeft4elm + m.x * this.sys.cvsScale + \"px\", v.style.top = this.sys.ofsTop4elm + m.y * this.sys.cvsScale + \"px\", v.style.transform = `scale(${m.sx}, ${m.sy}) rotate(${m.r}deg)`, this.val.setVal_Nochk(\"tmp\", g + \".x\", m.x), this.val.setVal_Nochk(\"tmp\", g + \".y\", m.y), this.val.setVal_Nochk(\"tmp\", g + \".scale_x\", m.sx), this.val.setVal_Nochk(\"tmp\", g + \".scale_y\", m.sy), this.val.setVal_Nochk(\"tmp\", g + \".rotate\", m.r);\n  });\n  let x = () => {\n  };\n  l && (_.w = T.width, x = () => {\n    v.width = m.w * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", g + \".width\", m.w);\n  });\n  let S = () => {\n  };\n  h && (_.h = T.height, S = () => {\n    v.height = m.h * this.sys.cvsScale + \"px\", this.val.setVal_Nochk(\"tmp\", g + \".height\", m.h);\n  }), this.appPixi.stage.interactive = !1;\n  const C = `frm\n${e}`, M = () => {\n    var H, z;\n    this.appPixi.stage.interactive = !0;\n    const Z = this.hTwInf[C];\n    Z && (delete this.hTwInf[C], (H = Z.tw) == null || H.stop(), Z.resume && this.main.resume(), (z = Z.onEnd) == null || z.call(Z));\n  }, I = tt(t, \"time\", NaN) * (this.val.getVal(\"tmp:sn.skip.enabled\") || c(this, Cl).isSkippingByKeyDown() ? 0 : 1), R = ws.ease(d), N = tt(t, \"repeat\", 1), A = N === 0 ? 1 / 0 : N - 1, U = vt(t, \"yoyo\", !1), B = tt(t, \"delay\", 0), G = new Tn(m).to(_, I).easing(R).repeat(A).yoyo(U).delay(B).onUpdate(() => {\n    b(), w(), x(), S();\n  });\n  let $ = G;\n  if (f) {\n    Y.debugLog && console.group(`🍝 [tsy_frame] path=${f}= start(${m.x},${m.y},${m.alpha})`);\n    for (const { groups: Z } of f.matchAll(Ua.REG_TSY_PATH)) {\n      const { x: H, x2: z, y: X, y2: ct, o: it, o2: lt, json: et } = Z;\n      let k = {};\n      if (et)\n        try {\n          k = JSON.parse(et);\n        } catch (St) {\n          console.error(`🍝 json=${et} ` + St);\n          continue;\n        }\n      else\n        (H ?? z) && (k.x = H ?? z), (X ?? ct) && (k.y = X ?? ct), (it ?? lt) && (k.alpha = it ?? lt);\n      const ft = ov(k, m);\n      Y.debugLog && console.info(`🍝 {x:${H} y:${X} o:${it}} => hTo:${JSON.stringify(ft)}`);\n      const Q = new Tn(m).to(ft, I).easing(R).repeat(A).yoyo(U);\n      $.chain(Q), $ = Q;\n    }\n    Y.debugLog && console.groupEnd();\n  }\n  if ($.onComplete(M), p) {\n    const Z = this.hTwInf[p ?? \"\"];\n    if (!Z || !Z.tw)\n      throw `${p}は存在しない・または終了したトゥイーンです`;\n    delete Z.onEnd, Z.tw.chain(G);\n  } else\n    G.start();\n  return this.hTwInf[C] = { tw: $, resume: !1 }, !1;\n};\nvar yi, Qt, Ee, qs, yo, Ol, If, Rf, Df, Il, kf, Z_, Zs, Ui, Ig, uM, Lr, Rg, lM, Dg, hM, kg, cM, Yt, _n, bn, Nf, Ng, fM, Rl, Kp, Ag, dM, Lg, Af, Bg, _o, bo, os, Ye, xo, Fg, pM, qe, Cr, Wr, Gg, vM, Ug, gM, jg, mM, wo, Bh, zg, yM, Jr, Hg, _M, $g, bM, Vg, xM, Xg, wM, Wg, EM, Ks, Eo, Fh, Qr, Yg, SM, Lf, qg, TM, xn, So, Js, xu, ji, wn, Zg, CM, Kg, MM, Jg, PM, Qg, OM, tm, IM, em, RM, rm, DM, Bf, K_, im, kM, nm, NM, sm, AM, am, LM, om, BM, um, FM, lm, GM;\nconst Ls = class {\n  constructor(t, e, r, n, s, a, o, u, l, h) {\n    E(this, kf);\n    // 既存の全文字レイヤの実際のバック不透明度、を再計算\n    E(this, Ig);\n    //\t//\tシステム\n    // スナップショット\n    E(this, Rg);\n    // プラグインの読み込み\n    E(this, Dg);\n    //\t//\tレイヤ共通\n    // レイヤを追加する\n    E(this, kg);\n    E(this, Ng);\n    E(this, Rl);\n    // レイヤ設定の消去\n    E(this, Ag);\n    // ページ裏表を交換\n    E(this, Fg);\n    E(this, Cr);\n    E(this, Gg);\n    E(this, Ug);\n    // トランス終了待ち\n    E(this, jg);\n    // レイヤのトランジションの停止\n    E(this, wo);\n    // 画面を揺らす\n    E(this, zg);\n    E(this, Hg);\n    // トゥイーン終了待ち\n    E(this, $g);\n    // トゥイーン中断\n    E(this, Vg);\n    // 一時停止\n    E(this, Xg);\n    // 一時停止再開\n    E(this, Wg);\n    // 文字を追加する\n    E(this, Eo);\n    E(this, Yg);\n    E(this, qg);\n    E(this, Js);\n    E(this, Zg);\n    // ハイパーリンクの終了\n    E(this, Kg);\n    // ページ両面の文字消去\n    E(this, Jg);\n    // インライン画像表示\n    E(this, Qg);\n    // ハイパーリンク\n    E(this, tm);\n    // 改行\n    E(this, em);\n    // 履歴改行\n    E(this, rm);\n    // 履歴書き込み\n    E(this, Bf);\n    // 履歴リセット\n    E(this, im);\n    // 文字列と複数ルビの追加\n    E(this, nm);\n    // インラインスタイル設定\n    E(this, sm);\n    // tcy縦中横を表示する\n    E(this, am);\n    // レイヤのダンプ\n    E(this, om);\n    // イベント有無の切替\n    E(this, um);\n    // ボタンを表示\n    E(this, lm);\n    E(this, yi, void 0);\n    E(this, Qt, new ye());\n    E(this, Ee, new ye());\n    E(this, qs, void 0);\n    E(this, yo, void 0);\n    E(this, Ol, new Ql());\n    E(this, If, () => vA());\n    E(this, Rf, {\n      attach: (t) => (Vt.leaveMode(), !1),\n      continue: (t) => (Vt.leaveMode(), !1),\n      disconnect: (t) => (Vt.leaveMode(), !1),\n      _enterDesign: (t) => {\n        Vt.enterMode();\n        for (const e of c(this, _n)) {\n          const r = c(this, Yt)[e].fore;\n          r.makeDesignCastChildren((n) => n.make()), r.makeDesignCast((n) => n.make());\n        }\n        return O(this, kf, Z_).call(this, c(this, bn)), !1;\n      },\n      _replaceToken: (t, e) => (Vt.replaceToken(e), !1),\n      _selectNode: (t, e) => (O(this, kf, Z_).call(this, e.node), !1)\n    });\n    E(this, Df, \"\");\n    E(this, Il, \"\");\n    K(this, \"getFrmDisabled\", (t) => c(this, qs).getFrmDisabled(t));\n    E(this, Zs, void 0);\n    E(this, Ui, void 0);\n    E(this, Lr, (t, e = this.currentTxtlayForeNeedErr, r = !0) => e.tagCh(\"｜　《\" + t + \"》\"));\n    K(this, \"goTxt\", () => {\n    });\n    K(this, \"breakLine\", () => {\n    });\n    K(this, \"breakPage\", () => {\n    });\n    E(this, Yt, {});\n    // しおりLoad時再読込\n    E(this, _n, []);\n    // 最適化用\n    E(this, bn, \"\");\n    E(this, Nf, \"\");\n    E(this, Lg, `\nprecision mediump float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform sampler2D rule;\nuniform float vague;\nuniform float tick;\n\nuniform vec4 inputPixel;\nuniform highp vec4 outputFrame;\nvec2 getUV(vec2 coord) {\n\treturn coord * inputPixel.xy / outputFrame.zw;\n}\n\nvoid main(void) {\n\tvec4 fg = texture2D(uSampler, vTextureCoord);\n\tvec4 ru = texture2D(rule, getUV(vTextureCoord));\n\n\tfloat v = ru.r - tick;\n\tif (abs(v) < vague) {\n\t\tfloat f_a = fg.a *(0.5 +v /vague *0.5);\n\n\t\tgl_FragColor.rgb = fg.rgb *f_a;\n\t\tgl_FragColor.a = f_a;\n\t}\n\telse {\n\t\tgl_FragColor = (v >= 0.0)? fg : vec4(0);\n\t}\n}`);\n    E(this, Af, {\n      rule: Ot.EMPTY,\n      vague: 0,\n      tick: 0\n    });\n    E(this, Bg, new rn(void 0, c(this, Lg), c(this, Af)));\n    E(this, _o, Si.create({\n      width: Y.stageW,\n      height: Y.stageH\n    }));\n    E(this, bo, new Ue(c(this, _o)));\n    E(this, os, Si.create({\n      width: Y.stageW,\n      height: Y.stageH\n    }));\n    E(this, Ye, new Ue(c(this, os)));\n    E(this, xo, []);\n    E(this, qe, { tw: void 0, resume: !1 });\n    // トゥイーン開始\n    E(this, Jr, {});\n    E(this, Qr, (t) => {\n      throw c(this, So).call(this), 0;\n    });\n    // 操作対象のメッセージレイヤの指定\n    E(this, Lf, (t) => {\n      throw c(this, So).call(this), 0;\n    });\n    E(this, xn, void 0);\n    // カレントテキストレイヤ\n    E(this, So, () => {\n      throw \"文字レイヤーがありません。文字表示や操作する前に、[add_lay layer=（レイヤ名） class=txt]で文字レイヤを追加して下さい\";\n    });\n    E(this, ji, \"\");\n    E(this, wn, []);\n    this.cfg = t, this.hTag = e, this.appPixi = r, this.val = n, this.main = s, this.scrItr = a, this.sys = o, this.sndMng = u, this.alzTagArg = l, this.prpPrs = h;\n    const d = () => {\n      if (o.cvsResize(), this.cvsResizeDesign(), c(this, Il))\n        for (const g of c(this, _n))\n          c(this, Yt)[g].fore.cvsResizeChildren();\n      else\n        for (const g of c(this, _n))\n          c(this, Yt)[g].fore.cvsResize();\n      c(this, qs).cvsResize(), c(this, Ui).cvsResize();\n    };\n    if (Y.isMobile)\n      c(this, Ol).add(globalThis, \"orientationchange\", d, { passive: !0 });\n    else {\n      let g;\n      c(this, Ol).add(globalThis, \"resize\", () => {\n        g || (g = setTimeout(() => {\n          g = void 0, d();\n        }, 1e3 / 60 * 10));\n      }, { passive: !0 });\n    }\n    o.cvsResize(), Se.init(t, e, n, this, (g) => c(this, Yt)[g.layname].fore === g, r), Wt.init(s, t, r, o, u, n), Yi.init(t), P(this, qs, new $3(t, e, r, n, s, o, c(this, Jr))), o.hFactoryCls.grp = () => new Wt(), o.hFactoryCls.txt = () => new Se(), e.loadplugin = (g) => O(this, Dg, hM).call(this, g), e.snapshot = (g) => O(this, Rg, lM).call(this, g), e.add_lay = (g) => O(this, kg, cM).call(this, g), e.clear_lay = (g) => O(this, Ag, dM).call(this, g), e.finish_trans = () => O(this, wo, Bh).call(this), e.lay = (g) => O(this, Ng, fM).call(this, g), e.trans = (g) => O(this, Fg, pM).call(this, g), e.wt = (g) => O(this, jg, mM).call(this, g), e.quake = (g) => O(this, zg, yM).call(this, g), e.stop_quake = (g) => e.finish_trans(g), e.wq = (g) => e.wt(g), e.pause_tsy = (g) => O(this, Xg, wM).call(this, g), e.resume_tsy = (g) => O(this, Wg, EM).call(this, g), e.stop_tsy = (g) => O(this, Vg, xM).call(this, g), e.tsy = (g) => O(this, Hg, _M).call(this, g), e.wait_tsy = (g) => O(this, $g, bM).call(this, g), e.ch = (g) => O(this, Eo, Fh).call(this, g), e.clear_text = (g) => O(this, Zg, CM).call(this, g), e.current = (g) => c(this, Lf).call(this, g), e.endlink = (g) => O(this, Kg, MM).call(this, g), e.er = (g) => O(this, Jg, PM).call(this, g), e.graph = (g) => O(this, Qg, OM).call(this, g), e.link = (g) => O(this, tm, IM).call(this, g), e.r = (g) => O(this, em, RM).call(this, g), e.rec_ch = (g) => O(this, Bf, K_).call(this, g), e.rec_r = (g) => O(this, rm, DM).call(this, g), e.reset_rec = (g) => O(this, im, kM).call(this, g), e.ruby2 = (g) => O(this, nm, NM).call(this, g), e.span = (g) => O(this, sm, AM).call(this, g), e.tcy = (g) => O(this, am, LM).call(this, g), e.add_face = (g) => Wt.add_face(g), e.wv = (g) => Wt.wv(g), e.dump_lay = (g) => O(this, om, BM).call(this, g), e.enable_event = (g) => O(this, um, FM).call(this, g), e.button = (g) => O(this, lm, GM).call(this, g), t.existsBreakline && (this.breakLine = () => c(this, Lr).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakline\"}')), t.existsBreakpage && (this.breakPage = () => c(this, Lr).call(this, 'grp｜{\"id\":\"break\",\"pic\":\"breakpage\"}')), P(this, yo, xb(String(t.oCfg.init.bg_color)));\n    const f = new ai();\n    f.beginFill(c(this, yo), 1).lineStyle(0, c(this, yo)).drawRect(0, 0, Y.stageW, Y.stageH).endFill(), c(this, Qt).addChild(f.clone()), c(this, Ee).addChild(f), c(this, Ee).visible = !1, c(this, Qt).name = \"page:A\", c(this, Ee).name = \"page:B\", P(this, yi, r.stage), c(this, yi).addChild(c(this, Ee)), c(this, yi).addChild(c(this, Qt)), c(this, yi).addChild(c(this, bo)), c(this, yi).addChild(c(this, Ye)), c(this, yi).name = \"stage\", r.ticker.add(c(this, If));\n    const p = (g, m) => {\n      O(this, Ig, uM).call(this, Number(m));\n    };\n    p(\"\", n.getVal(\"sys:TextLayer.Back.Alpha\", 1)), n.defValTrg(\"sys:TextLayer.Back.Alpha\", p);\n    const v = (g, m) => Yi.fontFamily = m;\n    v(\"\", n.getVal(\"tmp:sn.button.fontFamily\", Yi.fontFamily)), n.defValTrg(\"tmp:sn.button.fontFamily\", v), n.defTmp(\"const.sn.log.json\", () => JSON.stringify(\n      c(this, ji) ? [...c(this, wn), { text: c(this, ji).replaceAll(\"</span><span class='sn_ch'>\", \"\") }] : c(this, wn)\n    )), n.defTmp(\"const.sn.last_page_text\", () => {\n      var g;\n      return ((g = this.currentTxtlayFore) == null ? void 0 : g.pageText) ?? \"\";\n    }), Y.isDbg && (Vt.init(r, o, a, h, l, t, c(this, Yt)), this.cvsResizeDesign = () => Vt.cvsResizeDesign(), o.addHook((g, m) => {\n      var y, _;\n      (_ = (y = c(this, Rf))[g]) != null && _.call(y, g, m) && delete c(this, Rf)[g];\n    }));\n  }\n  cvsResizeDesign() {\n  }\n  cover(t, e = 0) {\n    c(this, Zs) && (c(this, yi).removeChild(c(this, Zs)), c(this, Zs).destroy(), P(this, Zs, void 0)), t && c(this, yi).addChild(\n      P(this, Zs, new ai()).beginFill(e).lineStyle(0, e).drawRect(0, 0, Y.stageW, Y.stageH).endFill()\n    );\n  }\n  setEvtMng(t) {\n    P(this, Ui, t), c(this, qs).setEvtMng(t), Wt.setEvtMng(t);\n  }\n  before_destroy() {\n    for (const t of Object.values(c(this, Yt)))\n      t.destroy();\n  }\n  destroy() {\n    c(this, Ol).clear(), Wt.destroy(), la.destroy(), De.destroy(), Se.destroy(), c(this, qs).destroy(), this.stopAllTw(), this.appPixi.ticker.remove(c(this, If)), P(Ls, Ks, 10);\n  }\n  // トゥイーン全停止\n  stopAllTw() {\n    P(this, Jr, {}), dA();\n  }\n  clearBreak() {\n    this.currentTxtlayFore && (this.clearBreak = () => c(this, Lr).call(this, \"del｜break\"), this.clearBreak());\n  }\n  clickTxtLay() {\n    return this.currentTxtlayFore ? O(this, Cr, Wr).call(this).some((t) => {\n      const e = c(this, Yt)[t].fore;\n      return e instanceof Se && e.click();\n    }) : !1;\n  }\n  static get msecChWait() {\n    return c(Ls, Ks);\n  }\n  static set msecChWait(t) {\n    P(Ls, Ks, t);\n  }\n  setNormalChWait() {\n    P(Ls, Ks, this.scrItr.normalWait);\n  }\n  get currentTxtlayForeNeedErr() {\n    return c(this, So).call(this), this.currentTxtlayFore;\n  }\n  get currentTxtlayFore() {\n    return c(this, xn) ? c(this, xn).fore : null;\n  }\n  recText(t) {\n    P(this, ji, t), this.val.setVal_Nochk(\n      \"save\",\n      \"const.sn.sLog\",\n      String(this.val.getVal(\"const.sn.log.json\"))\n      // これを起動したい\n    );\n  }\n  recPagebreak() {\n    if (!c(this, ji))\n      return;\n    const t = c(this, ji).replaceAll(\"</span><span class='sn_ch'>\", \"\");\n    c(this, wn).push({ text: t }) > this.cfg.oCfg.log.max_len && P(this, wn, c(this, wn).slice(-this.cfg.oCfg.log.max_len)), P(this, ji, \"\");\n  }\n  record() {\n    const t = {};\n    for (const e of c(this, _n)) {\n      const r = c(this, Yt)[e];\n      t[e] = {\n        cls: r.cls,\n        fore: r.fore.record(),\n        back: r.back.record()\n      };\n    }\n    return t;\n  }\n  playback(t, e) {\n    var a;\n    P(this, wn, JSON.parse(String(this.val.getVal(\"save:const.sn.sLog\")))), P(this, ji, \"\");\n    const r = [], n = [];\n    for (const [o, { fore: u, fore: { idx: l }, back: h, cls: d }] of Object.entries(t)) {\n      n.push({ layer: o, idx: l });\n      const f = (a = c(this, Yt))[o] ?? (a[o] = new Yh(o, d, c(this, Qt), c(this, Ee), {}, this.sys, this.val, { isWait: !1 }));\n      f.fore.playback(u, r), f.back.playback(h, r);\n    }\n    const s = c(this, Qt).children.length;\n    Promise.allSettled(r).then(() => {\n      for (const { layer: o, idx: u } of n.sort(({ idx: l }, { idx: h }) => l === h ? 0 : l < h ? -1 : 1)) {\n        const { fore: l, back: h } = c(this, Yt)[o];\n        if (!l)\n          return;\n        const d = s > u ? u : s - 1;\n        c(this, Qt).setChildIndex(l.spLay, d), c(this, Ee).setChildIndex(h.spLay, d);\n      }\n      e();\n    }).catch((o) => console.error(\"fn:LayerMng.ts playback e:%o\", o));\n  }\n};\nlet Ua = Ls;\nyi = new WeakMap(), Qt = new WeakMap(), Ee = new WeakMap(), qs = new WeakMap(), yo = new WeakMap(), Ol = new WeakMap(), If = new WeakMap(), Rf = new WeakMap(), Df = new WeakMap(), Il = new WeakMap(), kf = new WeakSet(), Z_ = function(t) {\n  [Ve(this, Df)._, this.Il = \"\"] = t.split(\"/\");\n  const e = c(this, Yt)[c(this, Df)];\n  e && (Vt.allHide(), c(this, Il) ? e.fore.showDesignCastChildren() : e.fore.showDesignCast());\n}, Zs = new WeakMap(), Ui = new WeakMap(), Ig = new WeakSet(), uM = function(t) {\n  for (const e of O(this, Cr, Wr).call(this)) {\n    const r = c(this, Yt)[e];\n    r.fore instanceof Se && (r.fore.chgBackAlpha(t), r.back.chgBackAlpha(t));\n  }\n}, Lr = new WeakMap(), Rg = new WeakSet(), lM = function(t) {\n  const e = t.fn ? t.fn.slice(0, 10) === \"userdata:/\" ? t.fn : `downloads:/${t.fn + rc(\"-\", \"_\", \"\", \"_\")}.png` : `downloads:/snapshot${rc(\"-\", \"_\", \"\", \"_\")}.png`, r = this.cfg.searchPath(e);\n  if (!(\"layer\" in t) && this.sys.canCapturePage(r, () => this.main.resume()))\n    return !0;\n  const n = uv(r), s = wE(t, \"b_color\", c(this, yo)), a = Yb({\n    width: tt(t, \"width\", Y.stageW),\n    height: tt(t, \"height\", Y.stageH),\n    backgroundAlpha: s > 16777216 && n === \"png\" ? 0 : 1,\n    antialias: vt(t, \"smoothing\", !1),\n    preserveDrawingBuffer: !0,\n    backgroundColor: s & 16777215,\n    autoDensity: !0\n  }), o = [], u = t.page !== \"back\" ? \"fore\" : \"back\";\n  if (c(this, qe).tw)\n    o.push(new Promise((l) => {\n      c(this, Ee).visible = !0;\n      for (const h of c(this, xo))\n        a.render(h, { clear: !1 });\n      c(this, Ee).visible = !1, c(this, bo).visible = !0, c(this, Qt).filters = c(this, Ye).filters, c(this, Qt).visible = !0, a.render(c(this, Qt), { clear: !1 }), c(this, Qt).visible = !1, c(this, Qt).filters = [], l();\n    }));\n  else\n    for (const l of O(this, Cr, Wr).call(this, t.layer))\n      o.push(\n        new Promise((h) => c(this, Yt)[l][u].snapshot(a, () => h()))\n      );\n  return Promise.allSettled(o).then(async () => {\n    const l = Si.create({ width: a.width, height: a.height });\n    if (a.render(c(this, yi), { renderTexture: l }), await this.sys.savePic(\n      r,\n      a.plugins.extract.base64(Ue.from(l))\n    ), !c(this, qe).tw)\n      for (const h of O(this, Cr, Wr).call(this, t.layer))\n        c(this, Yt)[h][u].snapshot_end();\n    a.destroy(!0), this.main.resume();\n  }), !0;\n}, Dg = new WeakSet(), hM = function(t) {\n  const { fn: e } = t;\n  if (!e)\n    throw \"fnは必須です\";\n  const r = vt(t, \"join\", !0);\n  switch (uv(e)) {\n    case \"css\":\n      (async () => {\n        const n = await fetch(e);\n        if (!n.ok)\n          throw new Error(\"Network response was not ok.\");\n        Lu(await n.text()), r && this.main.resume();\n      })();\n      break;\n    default:\n      throw \"サポートされない拡張子です\";\n  }\n  return r;\n}, kg = new WeakSet(), cM = function(t) {\n  const { layer: e, class: r } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  if (e.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (e in c(this, Yt))\n    throw `layer【${e}】はすでにあります`;\n  if (!r)\n    throw \"clsは必須です\";\n  const n = { isWait: !1 };\n  switch (c(this, Yt)[e] = new Yh(e, r, c(this, Qt), c(this, Ee), t, this.sys, this.val, n), c(this, _n).push(e), r) {\n    case \"txt\":\n      c(this, bn) || (P(this, So, () => {\n      }), P(this, Qr, O(this, Yg, SM)), P(this, Lf, O(this, qg, TM)), this.hTag.current({ layer: e }), this.goTxt = () => {\n        this.val.getVal(\"sn.skip.enabled\") ? P(Ls, Ks, 0) : this.setNormalChWait();\n        for (const s of O(this, Cr, Wr).call(this)) {\n          const a = c(this, Yt)[s].fore;\n          a instanceof Se && c(this, Lr).call(this, \"gotxt｜\", a, !1);\n        }\n      }), this.val.setVal_Nochk(\n        \"save\",\n        \"const.sn.layer.\" + (e ?? c(this, bn)) + \".enabled\",\n        !0\n      );\n      break;\n    case \"grp\":\n      if (c(this, Nf))\n        break;\n      P(this, Nf, e);\n      break;\n  }\n  return this.scrItr.recodeDesign(t), n.isWait;\n}, Yt = new WeakMap(), _n = new WeakMap(), bn = new WeakMap(), Nf = new WeakMap(), Ng = new WeakSet(), fM = function(t) {\n  const e = O(this, Js, xu).call(this, t), r = c(this, Yt)[e], n = r.back.spLay, s = r.fore.spLay;\n  if (vt(t, \"float\", !1))\n    c(this, Ee).setChildIndex(n, c(this, Ee).children.length - 1), c(this, Qt).setChildIndex(s, c(this, Qt).children.length - 1), O(this, Rl, Kp).call(this);\n  else if (t.index)\n    tt(t, \"index\", 0) && (c(this, Ee).setChildIndex(n, t.index), c(this, Qt).setChildIndex(s, t.index), O(this, Rl, Kp).call(this));\n  else if (t.dive) {\n    const { dive: a } = t;\n    let o = 0;\n    if (e === a)\n      throw \"[lay] 属性 layerとdiveが同じ【\" + a + \"】です\";\n    const u = c(this, Yt)[a];\n    if (!u)\n      throw \"[lay] 属性 dive【\" + a + \"】が不正です。レイヤーがありません\";\n    const l = u.back, h = u.fore, d = c(this, Ee).getChildIndex(l.spLay), f = c(this, Qt).getChildIndex(h.spLay);\n    o = d < f ? d : f, o > c(this, Ee).getChildIndex(n) && --o, c(this, Qt).setChildIndex(s, o), c(this, Ee).setChildIndex(n, o), O(this, Rl, Kp).call(this);\n  }\n  return t[\":id_tag\"] = r.fore.name.slice(0, -7), this.scrItr.recodeDesign(t), r.lay(t);\n}, Rl = new WeakSet(), Kp = function() {\n  P(this, _n, O(this, Ug, gM).call(this));\n}, Ag = new WeakSet(), dM = function(t) {\n  return O(this, Gg, vM).call(this, t, (e) => {\n    const r = c(this, Yt)[O(this, Js, xu).call(this, { layer: e })];\n    t.page === \"both\" ? (r.fore.clearLay(t), r.back.clearLay(t)) : r.getPage(t).clearLay(t);\n  }), !1;\n}, Lg = new WeakMap(), Af = new WeakMap(), Bg = new WeakMap(), _o = new WeakMap(), bo = new WeakMap(), os = new WeakMap(), Ye = new WeakMap(), xo = new WeakMap(), Fg = new WeakSet(), pM = function(t) {\n  O(this, wo, Bh).call(this), c(this, Ui).hideHint();\n  const { layer: e } = t;\n  P(this, xo, []);\n  const r = {}, n = [];\n  for (const m of O(this, Cr, Wr).call(this, e))\n    r[m] = !0, n.push(c(this, Yt)[m].fore);\n  const s = [];\n  for (const m of O(this, Cr, Wr).call(this)) {\n    const y = c(this, Yt)[m][r[m] ? \"back\" : \"fore\"];\n    c(this, xo).push(y.spLay), s.push(y);\n  }\n  c(this, _o).resize(Y.stageW, Y.stageH), this.appPixi.renderer.render(c(this, Ee), { renderTexture: c(this, _o) });\n  let a = () => {\n    c(this, Ee).visible = !0;\n    for (const m of c(this, xo))\n      this.appPixi.renderer.render(m, { renderTexture: c(this, _o), clear: !1 });\n    c(this, Ee).visible = !1;\n  };\n  if (!s.some((m) => m.containMovement)) {\n    let m = a;\n    a = () => {\n      a = () => {\n      }, m();\n    };\n  }\n  c(this, os).resize(Y.stageW, Y.stageH), this.appPixi.renderer.render(c(this, Qt), { renderTexture: c(this, os) });\n  let o = () => {\n    c(this, Qt).visible = !0, this.appPixi.renderer.render(c(this, Qt), { renderTexture: c(this, os) }), c(this, Qt).visible = !1;\n  };\n  if (!n.some((m) => m.containMovement)) {\n    let m = o;\n    o = () => {\n      o = () => {\n      }, m();\n    };\n  }\n  const u = () => {\n    a(), c(this, bo).visible = !0, o(), c(this, Ye).visible = !0;\n  };\n  c(this, Ye).alpha = 1;\n  const l = () => {\n    var y;\n    this.appPixi.ticker && this.appPixi.ticker.remove(u), [Ve(this, Qt)._, Ve(this, Ee)._] = [c(this, Ee), c(this, Qt)];\n    const m = [];\n    for (const [_, b] of Object.entries(c(this, Yt))) {\n      if (r[_]) {\n        b.transPage(m);\n        continue;\n      }\n      const { fore: { spLay: w }, back: { spLay: T } } = b, x = c(this, Qt).getChildIndex(T);\n      c(this, Qt).removeChild(T), c(this, Ee).removeChild(w), c(this, Qt).addChildAt(w, x), c(this, Ee).addChildAt(T, x);\n    }\n    Promise.allSettled(m), c(this, Qt).visible = !0, c(this, Ee).visible = !1, c(this, bo).visible = !1, c(this, Ye).visible = !1, (y = c(this, qe).tw) == null || y.stop(), c(this, qe).resume && this.main.resume(), P(this, qe, { tw: void 0, resume: !1 });\n  };\n  P(this, qe, { tw: void 0, resume: !1 });\n  const h = tt(t, \"time\", 0);\n  if (h === 0 || c(this, Ui).isSkippingByKeyDown())\n    return l(), !1;\n  const { ease: d, glsl: f, rule: p } = t, v = ws.ease(d);\n  if (!f && !p)\n    return c(this, Ye).filters = [], c(this, qe).tw = new Tn(c(this, Ye)).to({ alpha: 0 }, h).delay(tt(t, \"delay\", 0)).easing(v).onComplete(l).start(), this.appPixi.ticker.add(u), !1;\n  const g = f ? new rn(void 0, f, c(this, Af)) : c(this, Bg);\n  if (g.uniforms.vague = tt(t, \"vague\", 0.04), g.uniforms.tick = 0, c(this, qe).tw = new Tn(g.uniforms).to({ tick: 1 }, h).delay(tt(t, \"delay\", 0)).easing(v).onComplete(l), c(this, Ye).filters = [g], f)\n    return c(this, qe).tw.start(), this.appPixi.ticker.add(u), !1;\n  if (!p)\n    throw \"ruleが指定されていません\";\n  return Wt.csv2Sprites(p, void 0, (m) => {\n    var y;\n    g.uniforms.rule = m.texture, m.destroy(), (y = c(this, qe).tw) == null || y.start(), this.appPixi.ticker.add(u);\n  }), !1;\n}, qe = new WeakMap(), Cr = new WeakSet(), Wr = function(t = \"\") {\n  return t ? t.split(\",\") : c(this, _n);\n}, Gg = new WeakSet(), vM = function(t, e) {\n  const r = O(this, Cr, Wr).call(this, t.layer);\n  for (const n of r) {\n    if (!n)\n      continue;\n    const s = c(this, Yt)[n];\n    if (!s)\n      throw \"存在しないlayer【\" + n + \"】です\";\n    e(n, s);\n  }\n  return r;\n}, Ug = new WeakSet(), gM = function(t = \"\") {\n  return O(this, Cr, Wr).call(this, t).sort((e, r) => {\n    const n = c(this, Qt).getChildIndex(c(this, Yt)[e].fore.spLay), s = c(this, Qt).getChildIndex(c(this, Yt)[r].fore.spLay);\n    return n < s ? -1 : n > s ? 1 : 0;\n  });\n}, jg = new WeakSet(), mM = function(t) {\n  return c(this, qe).tw ? (c(this, qe).resume = !0, c(this, Ui).waitLimitedEvent(t, () => O(this, wo, Bh).call(this))) : !1;\n}, wo = new WeakSet(), Bh = function() {\n  var t;\n  return (t = c(this, qe).tw) == null || t.end(), !1;\n}, zg = new WeakSet(), yM = function(t) {\n  O(this, wo, Bh).call(this);\n  const e = tt(t, \"time\", NaN);\n  if (e === 0 || this.val.getVal(\"tmp:sn.skip.enabled\") || c(this, Ui).isSkippingByKeyDown())\n    return !1;\n  const { layer: r, ease: n } = t, s = [];\n  for (const p of O(this, Cr, Wr).call(this, r))\n    s.push(c(this, Yt)[p].fore.spLay);\n  c(this, os).resize(Y.stageW, Y.stageH);\n  const a = () => {\n    c(this, Qt).visible = !0;\n    for (const p of s)\n      this.appPixi.renderer.render(\n        p,\n        { renderTexture: c(this, os), clear: !1 }\n      );\n    c(this, Qt).visible = !1;\n  };\n  c(this, Ye).visible = !0, c(this, Ye).alpha = 1;\n  const o = ni(tt(t, \"hmax\", 10)), u = ni(tt(t, \"vmax\", 10)), l = o === 0 ? () => {\n  } : () => c(this, Ye).x = Math.round(Math.random() * o * 2) - o, h = u === 0 ? () => {\n  } : () => c(this, Ye).y = Math.round(Math.random() * u * 2) - u;\n  c(this, Ye).filters = [];\n  const d = tt(t, \"repeat\", 1), f = new Tn(c(this, Ye)).to({ x: 0, y: 0 }, e).delay(tt(t, \"delay\", 0)).easing(ws.ease(n)).onUpdate(() => {\n    l(), h();\n  }).repeat(d === 0 ? 1 / 0 : d - 1).yoyo(vt(t, \"yoyo\", !1)).onComplete(() => {\n    var p, v;\n    (p = this.appPixi.ticker) == null || p.remove(a), c(this, Qt).visible = !0, c(this, Ye).visible = !1, c(this, Ye).x = 0, c(this, Ye).y = 0, (v = c(this, qe).tw) == null || v.stop(), c(this, qe).resume && this.main.resume(), P(this, qe, { tw: void 0, resume: !1 });\n  }).start();\n  return P(this, qe, { tw: f, resume: !1 }), this.appPixi.ticker.add(a), !1;\n}, Jr = new WeakMap(), Hg = new WeakSet(), _M = function(t) {\n  const { layer: e, render: r, path: n, name: s, ease: a, chain: o } = t;\n  if (!e)\n    throw \"layerは必須です\";\n  const u = O(this, Js, xu).call(this, t);\n  let l = c(this, Yt)[u].fore, h = () => {\n  };\n  const d = c(this, Ui).isSkippingByKeyDown();\n  !d && r && (l.renderStart(), h = () => l.renderEnd());\n  const f = s ?? e, p = () => {\n    var I, R;\n    const M = c(this, Jr)[f];\n    M && (h(), delete c(this, Jr)[f], (I = M.tw) == null || I.stop(), M.resume && this.main.resume(), (R = M.onEnd) == null || R.call(M));\n  }, v = ov(t, l), g = tt(t, \"time\", NaN) * (this.val.getVal(\"tmp:sn.skip.enabled\") || d ? 0 : 1), m = ws.ease(a), y = tt(t, \"repeat\", 1), _ = y === 0 ? 1 / 0 : y - 1, b = vt(t, \"yoyo\", !1), w = tt(t, \"delay\", 0), T = new Tn(l).to(v, g).easing(m).repeat(_).yoyo(b).delay(w);\n  let x = T;\n  if (n) {\n    Y.debugLog && console.group(`🍝 [tsy] path=${n}= start(${l.x},${l.y},${l.alpha})`);\n    for (const { groups: M } of n.matchAll(Ls.REG_TSY_PATH)) {\n      const { x: I, x2: R, y: N, y2: A, o: U, o2: B, json: G } = M;\n      let $ = {};\n      if (G)\n        try {\n          $ = JSON.parse(G);\n        } catch (z) {\n          console.error(`🍝 json=${G} ` + z);\n          continue;\n        }\n      else\n        (I ?? R) && ($.x = I ?? R), (N ?? A) && ($.y = N ?? A), (U ?? B) && ($.alpha = U ?? B);\n      const Z = ov($, l);\n      Y.debugLog && console.info(`🍝 ${G ?? `{x:${I} y:${N} o:${U}}`} => hTo:${JSON.stringify(Z)}`);\n      const H = new Tn(l).to(Z, g).easing(m).repeat(_).yoyo(b);\n      x.chain(H), x = H;\n    }\n    Y.debugLog && console.groupEnd();\n  }\n  if (x.onComplete(p), o) {\n    const M = c(this, Jr)[o ?? \"\"];\n    if (!(M != null && M.tw))\n      throw `${o}は存在しない・または終了したトゥイーンです`;\n    delete M.onEnd, M.tw.chain(T);\n  } else\n    T.start();\n  const S = vt(t, \"arrive\", !1), C = vt(t, \"backlay\", !1);\n  return c(this, Jr)[f] = { tw: x, resume: !1, onEnd: () => {\n    if (S && Object.assign(l, v), C) {\n      const M = c(this, Yt)[u].back.spLay;\n      for (const I of Object.keys(bE))\n        M[I] = l[I];\n    }\n  } }, !1;\n}, $g = new WeakSet(), bM = function(t) {\n  const { layer: e = \"\", id: r, name: n } = t, s = r ? `frm\n${r}` : n ?? e;\n  if (!s)\n    throw \"トゥイーンが指定されていません\";\n  const a = c(this, Jr)[s];\n  return a != null && a.tw ? a.resume = c(this, Ui).waitEvent(\n    () => {\n      var o;\n      return (o = a.tw) == null ? void 0 : o.end();\n    },\n    // stop()とend()は別\n    vt(t, \"canskip\", !0),\n    vt(t, \"global\", !1)\n  ) : !1;\n}, Vg = new WeakSet(), xM = function(t) {\n  var a, o;\n  const { layer: e = \"\", id: r, name: n } = t, s = r ? `frm\n${r}` : n ?? e;\n  if (!s)\n    throw \"トゥイーンが指定されていません\";\n  return (o = (a = c(this, Jr)[s]) == null ? void 0 : a.tw) == null || o.end(), !1;\n}, Xg = new WeakSet(), wM = function(t) {\n  var a, o;\n  const { layer: e = \"\", id: r, name: n } = t, s = r ? `frm\n${r}` : n ?? e;\n  if (!s)\n    throw \"トゥイーンが指定されていません\";\n  return (o = (a = c(this, Jr)[s]) == null ? void 0 : a.tw) == null || o.pause(), !1;\n}, Wg = new WeakSet(), EM = function(t) {\n  var a, o;\n  const { layer: e = \"\", id: r, name: n } = t, s = r ? `frm\n${r}` : n ?? e;\n  if (!s)\n    throw \"トゥイーンが指定されていません\";\n  return (o = (a = c(this, Jr)[s]) == null ? void 0 : a.tw) == null || o.resume(), !1;\n}, Ks = new WeakMap(), Eo = new WeakSet(), Fh = function(t) {\n  const { text: e } = t;\n  if (!e)\n    throw \"textは必須です\";\n  const r = c(this, Qr).call(this, t);\n  delete t.text, this.val.getVal(\"tmp:sn.skip.enabled\") ? t.wait = 0 : \"wait\" in t && tt(t, \"wait\", NaN);\n  const n = encodeURIComponent(JSON.stringify(t));\n  c(this, Lr).call(this, \"add｜\" + n, r);\n  const s = vt(t, \"record\", !0), a = this.val.doRecLog();\n  return s || this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", s), r.tagCh(e.replaceAll(\"[r]\", `\n`)), this.val.setVal_Nochk(\"save\", \"sn.doRecLog\", a), c(this, Lr).call(this, \"add_close｜\", r), !1;\n}, Qr = new WeakMap(), Yg = new WeakSet(), SM = function(t) {\n  const e = O(this, Js, xu).call(this, t, c(this, bn)), n = c(this, Yt)[e].getPage(t);\n  if (!(n instanceof Se))\n    throw e + \"はTxtLayerではありません\";\n  return n;\n}, Lf = new WeakMap(), qg = new WeakSet(), TM = function(t) {\n  const { layer: e } = t;\n  if (!e)\n    throw \"[current] layerは必須です\";\n  if (P(this, xn, c(this, Yt)[e]), !(c(this, xn).getPage(t) instanceof Se))\n    throw `${e}はTxtLayerではありません`;\n  this.recPagebreak(), P(this, bn, e), this.val.setVal_Nochk(\"save\", \"const.sn.mesLayer\", e);\n  for (const r of O(this, Cr, Wr).call(this)) {\n    const n = c(this, Yt)[r];\n    n.fore instanceof Se && (n.fore.isCur = n.back.isCur = r === e);\n  }\n  return !1;\n}, xn = new WeakMap(), So = new WeakMap(), Js = new WeakSet(), xu = function(t, e = \"\") {\n  const r = t.layer ?? e;\n  if (r.includes(\",\"))\n    throw \"layer名に「,」は使えません\";\n  if (!(r in c(this, Yt)))\n    throw \"属性 layer【\" + r + \"】が不正です。レイヤーがありません\";\n  return t.layer = r;\n}, ji = new WeakMap(), wn = new WeakMap(), Zg = new WeakSet(), CM = function(t) {\n  const e = c(this, Qr).call(this, t);\n  return t.layer === c(this, bn) && t.page === \"fore\" && this.recPagebreak(), e.clearText(), !1;\n}, Kg = new WeakSet(), MM = function(t) {\n  return c(this, Lr).call(this, \"endlink｜\", c(this, Qr).call(this, t)), !1;\n}, Jg = new WeakSet(), PM = function(t) {\n  return vt(t, \"rec_page_break\", !0) && this.recPagebreak(), c(this, xn) && (c(this, xn).fore.clearLay(t), c(this, xn).back.clearLay(t)), !1;\n}, Qg = new WeakSet(), OM = function(t) {\n  if (!t.pic)\n    throw \"[graph] picは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return c(this, Lr).call(this, \"grp｜\" + e, c(this, Qr).call(this, t)), !1;\n}, tm = new WeakSet(), IM = function(t) {\n  t.style ?? (t.style = \"background-color: rgba(255,0,0,0.5);\"), t.style_hover ?? (t.style_hover = \"background-color: rgba(255,0,0,0.9);\"), t.style_clicked ?? (t.style_clicked = t.style);\n  const e = encodeURIComponent(JSON.stringify(t));\n  return c(this, Lr).call(this, \"link｜\" + e, c(this, Qr).call(this, t)), !1;\n}, em = new WeakSet(), RM = function(t) {\n  return t.text = `\n`, O(this, Eo, Fh).call(this, t);\n}, rm = new WeakSet(), DM = function(t) {\n  return O(this, Bf, K_).call(this, { ...t, text: \"[r]\" });\n}, Bf = new WeakSet(), K_ = function(t) {\n  return t.text ? (t.record = !0, t.style ?? (t.style = \"\"), t.style += \"display: none;\", t.wait = 0, O(this, Eo, Fh).call(this, t)) : !1;\n}, im = new WeakSet(), kM = function(t) {\n  return P(this, wn, []), P(this, ji, t.text ?? \"\"), this.val.setVal_Nochk(\n    \"save\",\n    \"const.sn.sLog\",\n    t.text ? `[{text:\"${t.text}\"}]` : \"[]\"\n  ), !1;\n}, nm = new WeakSet(), NM = function(t) {\n  const { t: e, r } = t;\n  if (!e)\n    throw \"[ruby2] tは必須です\";\n  if (!r)\n    throw \"[ruby2] rは必須です\";\n  return t.text = \"｜\" + encodeURIComponent(e) + \"《\" + encodeURIComponent(r) + \"》\", delete t.t, delete t.r, O(this, Eo, Fh).call(this, t);\n}, sm = new WeakSet(), AM = function(t) {\n  const e = encodeURIComponent(JSON.stringify(t));\n  return c(this, Lr).call(this, \"span｜\" + e, c(this, Qr).call(this, t)), !1;\n}, am = new WeakSet(), LM = function(t) {\n  if (!t.t)\n    throw \"[tcy] tは必須です\";\n  const e = encodeURIComponent(JSON.stringify(t));\n  return c(this, Lr).call(this, \"tcy｜\" + e, c(this, Qr).call(this, t)), !1;\n}, om = new WeakSet(), BM = function(t) {\n  console.group(\"🥟 [dump_lay]\");\n  for (const e of O(this, Cr, Wr).call(this, t.layer)) {\n    const r = c(this, Yt)[e];\n    try {\n      console.info(\n        `%c${r.fore.name.slice(0, -7)} %o`,\n        `color:#${Y.isDarkMode ? \"49F\" : \"05A\"};`,\n        JSON.parse(`{\"back\":{${r.back.dump()}}, \"fore\":{${r.fore.dump()}}}`)\n      );\n    } catch (n) {\n      console.error(\"dump_lay err:%o\", n), console.error(`   back:${r.back.dump()}`), console.error(`   fore:${r.fore.dump()}`);\n    }\n  }\n  return console.groupEnd(), !1;\n}, um = new WeakSet(), FM = function(t) {\n  const e = O(this, Js, xu).call(this, t, c(this, bn)), r = vt(t, \"enabled\", !0);\n  return c(this, Qr).call(this, t).enabled = r, this.val.setVal_Nochk(\"save\", \"const.sn.layer.\" + e + \".enabled\", r), !1;\n}, lm = new WeakSet(), GM = function(t) {\n  return Yh.argChk_page(t, \"back\"), t.clicksebuf ?? (t.clicksebuf = \"SYS\"), t.entersebuf ?? (t.entersebuf = \"SYS\"), t.leavesebuf ?? (t.leavesebuf = \"SYS\"), t.fn || (t.fn = this.scrItr.scriptFn), c(this, Qr).call(this, t).addButton(t), this.scrItr.recodeDesign(t), !1;\n}, // 11 match 301 step (0.1ms) PCRE2 https://regex101.com/r/reinpq/1\n// List ${x}${x2}/${y}${y2}/${o}${o2}=${json}\\n\n/*\n\\(\\s*\n(?:\t(?<x>[-=\\d\\.]+)\t|\t(['\"])\t(?<x2>.*?)\t\\2\t)?\n(?:\n\t\\s*,\\s*\n\t(?:\t(?<y>[-=\\d\\.]+)\t|\t(['\"])\t(?<y2>.*?)\t\\5\t)?\n\t(?:\n\t\t\\s*,\\s*\n\t\t(?:\t(?<o>[-=\\d\\.]+)\t|\t(['\"])\t(?<o2>.*?)\t\\8\t)\n\n\t)?\n)?\n|\n(?<json>\\{[^{}]*})\n*/\nK(Ua, \"REG_TSY_PATH\", /\\(\\s*(?:(?<x>[-=\\d\\.]+)|(['\"])(?<x2>.*?)\\2)?(?:\\s*,\\s*(?:(?<y>[-=\\d\\.]+)|(['\"])(?<y2>.*?)\\5)?(?:\\s*,\\s*(?:(?<o>[-=\\d\\.]+)|(['\"])(?<o2>.*?)\\8))?)?|(?<json>\\{[^{}]*})/g), //\t// 文字・文字レイヤ\nE(Ua, Ks, 10);\nvar Pe, ge, Dl, hm, UM, Ff, To, Gh;\nclass V3 {\n  constructor() {\n    E(this, hm);\n    E(this, To);\n    E(this, Pe, []);\n    E(this, ge, -1);\n    E(this, Dl, new Ql());\n    E(this, Ff, Y.debugLog ? (t) => console.log(`👾 <FocusMng idx:${t} btn:%o`, c(this, Pe)[t].btn) : () => {\n    });\n  }\n  destroy() {\n    P(this, Pe, []), P(this, ge, -1), c(this, Dl).clear();\n  }\n  add(t, e, r) {\n    if (c(this, Pe).findIndex((o) => o.btn === t) >= 0)\n      return;\n    if (t instanceof ye) {\n      t.on(\"pointerdown\", () => {\n        for (let o = c(this, Pe).length - 1; o >= 0; --o)\n          if (c(this, Pe)[o].btn === t) {\n            P(this, ge, o);\n            return;\n          }\n        P(this, ge, -1);\n      }), c(this, Pe).push({ btn: t, on: e, off: r });\n      return;\n    }\n    c(this, Dl).add(t, \"focus\", () => {\n      for (let o = c(this, Pe).length - 1; o >= 0; --o)\n        if (c(this, Pe)[o].btn === t) {\n          P(this, ge, o);\n          return;\n        }\n      P(this, ge, -1);\n    });\n    let n = (o) => {\n    }, s = t.localName === \"button\" || t.localName === \"a\" ? (o) => !o.isTrusted && o.key === \"Enter\" : (o) => o.key === \"Enter\";\n    const a = t;\n    switch (a.type ?? \"\") {\n      case \"checkbox\":\n        n = () => a.checked = !a.checked;\n        break;\n      case \"\":\n        t.querySelectorAll(\"input[type]\").length > 0 && (n = (o) => O(this, hm, UM).call(this, t, o.key), s = () => !1);\n        break;\n      case \"range\":\n        n = (o) => {\n          o.isTrusted || (o.key === \"ArrowUp\" ? a.stepUp() : a.stepDown());\n        };\n        break;\n      case \"text\":\n      case \"textarea\":\n        n = (o) => {\n          if (o.isTrusted)\n            return;\n          let u = (a.selectionStart ?? 0) + (o.key === \"ArrowUp\" ? -1 : 1);\n          u < 0 && (u = 0), a.setSelectionRange(u, u);\n        };\n        break;\n    }\n    c(this, Dl).add(t, \"keydown\", (o) => {\n      if (!(o.key !== \"ArrowUp\" && o.key !== \"ArrowDown\" && o.key !== \"Enter\")) {\n        if (o.stopPropagation(), o.stopImmediatePropagation(), s(o)) {\n          t.dispatchEvent(new MouseEvent(\"click\"));\n          return;\n        }\n        n(o);\n      }\n    }, { passive: !0 }), t.hasAttribute(\"tabindex\") || (t.tabIndex = 0), c(this, Pe).push({ btn: t, on: e, off: r });\n  }\n  remove(t) {\n    const e = c(this, Pe).findIndex((r) => r.btn === t);\n    e < 0 || (c(this, Pe).splice(e, 1), c(this, Pe).length === 0 ? P(this, ge, -1) : e <= c(this, ge) && --Ve(this, ge)._);\n  }\n  isFocus(t) {\n    return c(this, ge) < 0 ? !1 : c(this, Pe)[c(this, ge)].btn === t;\n  }\n  prev() {\n    O(this, To, Gh).call(this);\n    const t = c(this, Pe).length;\n    if (t !== 0) {\n      --Ve(this, ge)._ < 0 && P(this, ge, t - 1);\n      for (let e = t; e >= 1; --e) {\n        const r = (c(this, ge) + e) % t;\n        if (c(this, Pe)[r].on()) {\n          P(this, ge, r), c(this, Ff).call(this, r);\n          return;\n        }\n      }\n      P(this, ge, -1);\n    }\n  }\n  next() {\n    O(this, To, Gh).call(this);\n    const t = c(this, Pe).length;\n    if (t !== 0) {\n      ++Ve(this, ge)._ >= t && P(this, ge, 0);\n      for (let e = 0; e < t; ++e) {\n        const r = (c(this, ge) + e) % t;\n        if (c(this, Pe)[r].on()) {\n          P(this, ge, r), c(this, Ff).call(this, r);\n          return;\n        }\n      }\n      P(this, ge, -1);\n    }\n  }\n  getFocus() {\n    if (c(this, ge) < 0)\n      return null;\n    O(this, To, Gh).call(this), c(this, ge) >= c(this, Pe).length && P(this, ge, 0);\n    const t = c(this, Pe)[c(this, ge)];\n    return t.on() ? t.btn : null;\n  }\n  blur() {\n    O(this, To, Gh).call(this), P(this, ge, -1), globalThis.focus();\n  }\n}\nPe = new WeakMap(), ge = new WeakMap(), Dl = new WeakMap(), hm = new WeakSet(), UM = function(t, e) {\n  const r = t.querySelectorAll(\"input[type]\"), n = r.length;\n  for (let s = 0; s < n; ++s)\n    if (r[s].checked) {\n      r[(s + n + (e === \"ArrowUp\" ? -1 : 1)) % n].checked = !0;\n      break;\n    }\n}, Ff = new WeakMap(), To = new WeakSet(), Gh = function() {\n  for (let t = c(this, Pe).length - 1; t >= 0; --t) {\n    const e = c(this, Pe)[t];\n    !(e.btn instanceof ye) || e.btn.parent ? e.off() : c(this, Pe).splice(t, 1);\n  }\n};\nvar zr = \"top\", Mi = \"bottom\", Pi = \"right\", Hr = \"left\", _0 = \"auto\", kd = [zr, Mi, Pi, Hr], sh = \"start\", xc = \"end\", X3 = \"clippingParents\", jM = \"viewport\", Ch = \"popper\", W3 = \"reference\", Kw = /* @__PURE__ */ kd.reduce(function(i, t) {\n  return i.concat([t + \"-\" + sh, t + \"-\" + xc]);\n}, []), zM = /* @__PURE__ */ [].concat(kd, [_0]).reduce(function(i, t) {\n  return i.concat([t, t + \"-\" + sh, t + \"-\" + xc]);\n}, []), Y3 = \"beforeRead\", q3 = \"read\", Z3 = \"afterRead\", K3 = \"beforeMain\", J3 = \"main\", Q3 = \"afterMain\", tG = \"beforeWrite\", eG = \"write\", rG = \"afterWrite\", J_ = [Y3, q3, Z3, K3, J3, Q3, tG, eG, rG];\nfunction Bn(i) {\n  return i ? (i.nodeName || \"\").toLowerCase() : null;\n}\nfunction hi(i) {\n  if (i == null)\n    return window;\n  if (i.toString() !== \"[object Window]\") {\n    var t = i.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return i;\n}\nfunction su(i) {\n  var t = hi(i).Element;\n  return i instanceof t || i instanceof Element;\n}\nfunction oi(i) {\n  var t = hi(i).HTMLElement;\n  return i instanceof t || i instanceof HTMLElement;\n}\nfunction zx(i) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = hi(i).ShadowRoot;\n  return i instanceof t || i instanceof ShadowRoot;\n}\nfunction iG(i) {\n  var t = i.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var r = t.styles[e] || {}, n = t.attributes[e] || {}, s = t.elements[e];\n    !oi(s) || !Bn(s) || (Object.assign(s.style, r), Object.keys(n).forEach(function(a) {\n      var o = n[a];\n      o === !1 ? s.removeAttribute(a) : s.setAttribute(a, o === !0 ? \"\" : o);\n    }));\n  });\n}\nfunction nG(i) {\n  var t = i.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(r) {\n      var n = t.elements[r], s = t.attributes[r] || {}, a = Object.keys(t.styles.hasOwnProperty(r) ? t.styles[r] : e[r]), o = a.reduce(function(u, l) {\n        return u[l] = \"\", u;\n      }, {});\n      !oi(n) || !Bn(n) || (Object.assign(n.style, o), Object.keys(s).forEach(function(u) {\n        n.removeAttribute(u);\n      }));\n    });\n  };\n}\nconst sG = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: iG,\n  effect: nG,\n  requires: [\"computeStyles\"]\n};\nfunction Qi(i) {\n  return i.split(\"-\")[0];\n}\nvar qo = Math.max, Dv = Math.min, ah = Math.round;\nfunction Q_() {\n  var i = navigator.userAgentData;\n  return i != null && i.brands && Array.isArray(i.brands) ? i.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction HM() {\n  return !/^((?!chrome|android).)*safari/i.test(Q_());\n}\nfunction oh(i, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var r = i.getBoundingClientRect(), n = 1, s = 1;\n  t && oi(i) && (n = i.offsetWidth > 0 && ah(r.width) / i.offsetWidth || 1, s = i.offsetHeight > 0 && ah(r.height) / i.offsetHeight || 1);\n  var a = su(i) ? hi(i) : window, o = a.visualViewport, u = !HM() && e, l = (r.left + (u && o ? o.offsetLeft : 0)) / n, h = (r.top + (u && o ? o.offsetTop : 0)) / s, d = r.width / n, f = r.height / s;\n  return {\n    width: d,\n    height: f,\n    top: h,\n    right: l + d,\n    bottom: h + f,\n    left: l,\n    x: l,\n    y: h\n  };\n}\nfunction Hx(i) {\n  var t = oh(i), e = i.offsetWidth, r = i.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), {\n    x: i.offsetLeft,\n    y: i.offsetTop,\n    width: e,\n    height: r\n  };\n}\nfunction $M(i, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (i.contains(t))\n    return !0;\n  if (e && zx(e)) {\n    var r = t;\n    do {\n      if (r && i.isSameNode(r))\n        return !0;\n      r = r.parentNode || r.host;\n    } while (r);\n  }\n  return !1;\n}\nfunction sn(i) {\n  return hi(i).getComputedStyle(i);\n}\nfunction aG(i) {\n  return [\"table\", \"td\", \"th\"].indexOf(Bn(i)) >= 0;\n}\nfunction ma(i) {\n  return ((su(i) ? i.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    i.document\n  )) || window.document).documentElement;\n}\nfunction b0(i) {\n  return Bn(i) === \"html\" ? i : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    i.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    i.parentNode || // DOM Element detected\n    (zx(i) ? i.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    ma(i)\n  );\n}\nfunction Jw(i) {\n  return !oi(i) || // https://github.com/popperjs/popper-core/issues/837\n  sn(i).position === \"fixed\" ? null : i.offsetParent;\n}\nfunction oG(i) {\n  var t = /firefox/i.test(Q_()), e = /Trident/i.test(Q_());\n  if (e && oi(i)) {\n    var r = sn(i);\n    if (r.position === \"fixed\")\n      return null;\n  }\n  var n = b0(i);\n  for (zx(n) && (n = n.host); oi(n) && [\"html\", \"body\"].indexOf(Bn(n)) < 0; ) {\n    var s = sn(n);\n    if (s.transform !== \"none\" || s.perspective !== \"none\" || s.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(s.willChange) !== -1 || t && s.willChange === \"filter\" || t && s.filter && s.filter !== \"none\")\n      return n;\n    n = n.parentNode;\n  }\n  return null;\n}\nfunction Nd(i) {\n  for (var t = hi(i), e = Jw(i); e && aG(e) && sn(e).position === \"static\"; )\n    e = Jw(e);\n  return e && (Bn(e) === \"html\" || Bn(e) === \"body\" && sn(e).position === \"static\") ? t : e || oG(i) || t;\n}\nfunction $x(i) {\n  return [\"top\", \"bottom\"].indexOf(i) >= 0 ? \"x\" : \"y\";\n}\nfunction Qh(i, t, e) {\n  return qo(i, Dv(t, e));\n}\nfunction uG(i, t, e) {\n  var r = Qh(i, t, e);\n  return r > e ? e : r;\n}\nfunction VM() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction XM(i) {\n  return Object.assign({}, VM(), i);\n}\nfunction WM(i, t) {\n  return t.reduce(function(e, r) {\n    return e[r] = i, e;\n  }, {});\n}\nvar lG = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, XM(typeof t != \"number\" ? t : WM(t, kd));\n};\nfunction hG(i) {\n  var t, e = i.state, r = i.name, n = i.options, s = e.elements.arrow, a = e.modifiersData.popperOffsets, o = Qi(e.placement), u = $x(o), l = [Hr, Pi].indexOf(o) >= 0, h = l ? \"height\" : \"width\";\n  if (!(!s || !a)) {\n    var d = lG(n.padding, e), f = Hx(s), p = u === \"y\" ? zr : Hr, v = u === \"y\" ? Mi : Pi, g = e.rects.reference[h] + e.rects.reference[u] - a[u] - e.rects.popper[h], m = a[u] - e.rects.reference[u], y = Nd(s), _ = y ? u === \"y\" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, b = g / 2 - m / 2, w = d[p], T = _ - f[h] - d[v], x = _ / 2 - f[h] / 2 + b, S = Qh(w, x, T), C = u;\n    e.modifiersData[r] = (t = {}, t[C] = S, t.centerOffset = S - x, t);\n  }\n}\nfunction cG(i) {\n  var t = i.state, e = i.options, r = e.element, n = r === void 0 ? \"[data-popper-arrow]\" : r;\n  if (n != null && !(typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n))) {\n    if ( true && (oi(n) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !$M(t.elements.popper, n)) {\n       true && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = n;\n  }\n}\nconst fG = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: hG,\n  effect: cG,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction uh(i) {\n  return i.split(\"-\")[1];\n}\nvar dG = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction pG(i, t) {\n  var e = i.x, r = i.y, n = t.devicePixelRatio || 1;\n  return {\n    x: ah(e * n) / n || 0,\n    y: ah(r * n) / n || 0\n  };\n}\nfunction Qw(i) {\n  var t, e = i.popper, r = i.popperRect, n = i.placement, s = i.variation, a = i.offsets, o = i.position, u = i.gpuAcceleration, l = i.adaptive, h = i.roundOffsets, d = i.isFixed, f = a.x, p = f === void 0 ? 0 : f, v = a.y, g = v === void 0 ? 0 : v, m = typeof h == \"function\" ? h({\n    x: p,\n    y: g\n  }) : {\n    x: p,\n    y: g\n  };\n  p = m.x, g = m.y;\n  var y = a.hasOwnProperty(\"x\"), _ = a.hasOwnProperty(\"y\"), b = Hr, w = zr, T = window;\n  if (l) {\n    var x = Nd(e), S = \"clientHeight\", C = \"clientWidth\";\n    if (x === hi(e) && (x = ma(e), sn(x).position !== \"static\" && o === \"absolute\" && (S = \"scrollHeight\", C = \"scrollWidth\")), x = x, n === zr || (n === Hr || n === Pi) && s === xc) {\n      w = Mi;\n      var M = d && x === T && T.visualViewport ? T.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        x[S]\n      );\n      g -= M - r.height, g *= u ? 1 : -1;\n    }\n    if (n === Hr || (n === zr || n === Mi) && s === xc) {\n      b = Pi;\n      var I = d && x === T && T.visualViewport ? T.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        x[C]\n      );\n      p -= I - r.width, p *= u ? 1 : -1;\n    }\n  }\n  var R = Object.assign({\n    position: o\n  }, l && dG), N = h === !0 ? pG({\n    x: p,\n    y: g\n  }, hi(e)) : {\n    x: p,\n    y: g\n  };\n  if (p = N.x, g = N.y, u) {\n    var A;\n    return Object.assign({}, R, (A = {}, A[w] = _ ? \"0\" : \"\", A[b] = y ? \"0\" : \"\", A.transform = (T.devicePixelRatio || 1) <= 1 ? \"translate(\" + p + \"px, \" + g + \"px)\" : \"translate3d(\" + p + \"px, \" + g + \"px, 0)\", A));\n  }\n  return Object.assign({}, R, (t = {}, t[w] = _ ? g + \"px\" : \"\", t[b] = y ? p + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction vG(i) {\n  var t = i.state, e = i.options, r = e.gpuAcceleration, n = r === void 0 ? !0 : r, s = e.adaptive, a = s === void 0 ? !0 : s, o = e.roundOffsets, u = o === void 0 ? !0 : o;\n  if (true) {\n    var l = sn(t.elements.popper).transitionProperty || \"\";\n    a && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(d) {\n      return l.indexOf(d) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var h = {\n    placement: Qi(t.placement),\n    variation: uh(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: n,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Qw(Object.assign({}, h, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: a,\n    roundOffsets: u\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Qw(Object.assign({}, h, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: u\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst gG = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: vG,\n  data: {}\n};\nvar Ep = {\n  passive: !0\n};\nfunction mG(i) {\n  var t = i.state, e = i.instance, r = i.options, n = r.scroll, s = n === void 0 ? !0 : n, a = r.resize, o = a === void 0 ? !0 : a, u = hi(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return s && l.forEach(function(h) {\n    h.addEventListener(\"scroll\", e.update, Ep);\n  }), o && u.addEventListener(\"resize\", e.update, Ep), function() {\n    s && l.forEach(function(h) {\n      h.removeEventListener(\"scroll\", e.update, Ep);\n    }), o && u.removeEventListener(\"resize\", e.update, Ep);\n  };\n}\nconst yG = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: mG,\n  data: {}\n};\nvar _G = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction Jp(i) {\n  return i.replace(/left|right|bottom|top/g, function(t) {\n    return _G[t];\n  });\n}\nvar bG = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction tE(i) {\n  return i.replace(/start|end/g, function(t) {\n    return bG[t];\n  });\n}\nfunction Vx(i) {\n  var t = hi(i), e = t.pageXOffset, r = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: r\n  };\n}\nfunction Xx(i) {\n  return oh(ma(i)).left + Vx(i).scrollLeft;\n}\nfunction xG(i, t) {\n  var e = hi(i), r = ma(i), n = e.visualViewport, s = r.clientWidth, a = r.clientHeight, o = 0, u = 0;\n  if (n) {\n    s = n.width, a = n.height;\n    var l = HM();\n    (l || !l && t === \"fixed\") && (o = n.offsetLeft, u = n.offsetTop);\n  }\n  return {\n    width: s,\n    height: a,\n    x: o + Xx(i),\n    y: u\n  };\n}\nfunction wG(i) {\n  var t, e = ma(i), r = Vx(i), n = (t = i.ownerDocument) == null ? void 0 : t.body, s = qo(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), a = qo(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), o = -r.scrollLeft + Xx(i), u = -r.scrollTop;\n  return sn(n || e).direction === \"rtl\" && (o += qo(e.clientWidth, n ? n.clientWidth : 0) - s), {\n    width: s,\n    height: a,\n    x: o,\n    y: u\n  };\n}\nfunction Wx(i) {\n  var t = sn(i), e = t.overflow, r = t.overflowX, n = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + n + r);\n}\nfunction YM(i) {\n  return [\"html\", \"body\", \"#document\"].indexOf(Bn(i)) >= 0 ? i.ownerDocument.body : oi(i) && Wx(i) ? i : YM(b0(i));\n}\nfunction tc(i, t) {\n  var e;\n  t === void 0 && (t = []);\n  var r = YM(i), n = r === ((e = i.ownerDocument) == null ? void 0 : e.body), s = hi(r), a = n ? [s].concat(s.visualViewport || [], Wx(r) ? r : []) : r, o = t.concat(a);\n  return n ? o : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    o.concat(tc(b0(a)))\n  );\n}\nfunction tb(i) {\n  return Object.assign({}, i, {\n    left: i.x,\n    top: i.y,\n    right: i.x + i.width,\n    bottom: i.y + i.height\n  });\n}\nfunction EG(i, t) {\n  var e = oh(i, !1, t === \"fixed\");\n  return e.top = e.top + i.clientTop, e.left = e.left + i.clientLeft, e.bottom = e.top + i.clientHeight, e.right = e.left + i.clientWidth, e.width = i.clientWidth, e.height = i.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction eE(i, t, e) {\n  return t === jM ? tb(xG(i, e)) : su(t) ? EG(t, e) : tb(wG(ma(i)));\n}\nfunction SG(i) {\n  var t = tc(b0(i)), e = [\"absolute\", \"fixed\"].indexOf(sn(i).position) >= 0, r = e && oi(i) ? Nd(i) : i;\n  return su(r) ? t.filter(function(n) {\n    return su(n) && $M(n, r) && Bn(n) !== \"body\";\n  }) : [];\n}\nfunction TG(i, t, e, r) {\n  var n = t === \"clippingParents\" ? SG(i) : [].concat(t), s = [].concat(n, [e]), a = s[0], o = s.reduce(function(u, l) {\n    var h = eE(i, l, r);\n    return u.top = qo(h.top, u.top), u.right = Dv(h.right, u.right), u.bottom = Dv(h.bottom, u.bottom), u.left = qo(h.left, u.left), u;\n  }, eE(i, a, r));\n  return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;\n}\nfunction qM(i) {\n  var t = i.reference, e = i.element, r = i.placement, n = r ? Qi(r) : null, s = r ? uh(r) : null, a = t.x + t.width / 2 - e.width / 2, o = t.y + t.height / 2 - e.height / 2, u;\n  switch (n) {\n    case zr:\n      u = {\n        x: a,\n        y: t.y - e.height\n      };\n      break;\n    case Mi:\n      u = {\n        x: a,\n        y: t.y + t.height\n      };\n      break;\n    case Pi:\n      u = {\n        x: t.x + t.width,\n        y: o\n      };\n      break;\n    case Hr:\n      u = {\n        x: t.x - e.width,\n        y: o\n      };\n      break;\n    default:\n      u = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var l = n ? $x(n) : null;\n  if (l != null) {\n    var h = l === \"y\" ? \"height\" : \"width\";\n    switch (s) {\n      case sh:\n        u[l] = u[l] - (t[h] / 2 - e[h] / 2);\n        break;\n      case xc:\n        u[l] = u[l] + (t[h] / 2 - e[h] / 2);\n        break;\n    }\n  }\n  return u;\n}\nfunction wc(i, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, n = r === void 0 ? i.placement : r, s = e.strategy, a = s === void 0 ? i.strategy : s, o = e.boundary, u = o === void 0 ? X3 : o, l = e.rootBoundary, h = l === void 0 ? jM : l, d = e.elementContext, f = d === void 0 ? Ch : d, p = e.altBoundary, v = p === void 0 ? !1 : p, g = e.padding, m = g === void 0 ? 0 : g, y = XM(typeof m != \"number\" ? m : WM(m, kd)), _ = f === Ch ? W3 : Ch, b = i.rects.popper, w = i.elements[v ? _ : f], T = TG(su(w) ? w : w.contextElement || ma(i.elements.popper), u, h, a), x = oh(i.elements.reference), S = qM({\n    reference: x,\n    element: b,\n    strategy: \"absolute\",\n    placement: n\n  }), C = tb(Object.assign({}, b, S)), M = f === Ch ? C : x, I = {\n    top: T.top - M.top + y.top,\n    bottom: M.bottom - T.bottom + y.bottom,\n    left: T.left - M.left + y.left,\n    right: M.right - T.right + y.right\n  }, R = i.modifiersData.offset;\n  if (f === Ch && R) {\n    var N = R[n];\n    Object.keys(I).forEach(function(A) {\n      var U = [Pi, Mi].indexOf(A) >= 0 ? 1 : -1, B = [zr, Mi].indexOf(A) >= 0 ? \"y\" : \"x\";\n      I[A] += N[B] * U;\n    });\n  }\n  return I;\n}\nfunction CG(i, t) {\n  t === void 0 && (t = {});\n  var e = t, r = e.placement, n = e.boundary, s = e.rootBoundary, a = e.padding, o = e.flipVariations, u = e.allowedAutoPlacements, l = u === void 0 ? zM : u, h = uh(r), d = h ? o ? Kw : Kw.filter(function(v) {\n    return uh(v) === h;\n  }) : kd, f = d.filter(function(v) {\n    return l.indexOf(v) >= 0;\n  });\n  f.length === 0 && (f = d,  true && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var p = f.reduce(function(v, g) {\n    return v[g] = wc(i, {\n      placement: g,\n      boundary: n,\n      rootBoundary: s,\n      padding: a\n    })[Qi(g)], v;\n  }, {});\n  return Object.keys(p).sort(function(v, g) {\n    return p[v] - p[g];\n  });\n}\nfunction MG(i) {\n  if (Qi(i) === _0)\n    return [];\n  var t = Jp(i);\n  return [tE(i), t, tE(t)];\n}\nfunction PG(i) {\n  var t = i.state, e = i.options, r = i.name;\n  if (!t.modifiersData[r]._skip) {\n    for (var n = e.mainAxis, s = n === void 0 ? !0 : n, a = e.altAxis, o = a === void 0 ? !0 : a, u = e.fallbackPlacements, l = e.padding, h = e.boundary, d = e.rootBoundary, f = e.altBoundary, p = e.flipVariations, v = p === void 0 ? !0 : p, g = e.allowedAutoPlacements, m = t.options.placement, y = Qi(m), _ = y === m, b = u || (_ || !v ? [Jp(m)] : MG(m)), w = [m].concat(b).reduce(function(lt, et) {\n      return lt.concat(Qi(et) === _0 ? CG(t, {\n        placement: et,\n        boundary: h,\n        rootBoundary: d,\n        padding: l,\n        flipVariations: v,\n        allowedAutoPlacements: g\n      }) : et);\n    }, []), T = t.rects.reference, x = t.rects.popper, S = /* @__PURE__ */ new Map(), C = !0, M = w[0], I = 0; I < w.length; I++) {\n      var R = w[I], N = Qi(R), A = uh(R) === sh, U = [zr, Mi].indexOf(N) >= 0, B = U ? \"width\" : \"height\", G = wc(t, {\n        placement: R,\n        boundary: h,\n        rootBoundary: d,\n        altBoundary: f,\n        padding: l\n      }), $ = U ? A ? Pi : Hr : A ? Mi : zr;\n      T[B] > x[B] && ($ = Jp($));\n      var Z = Jp($), H = [];\n      if (s && H.push(G[N] <= 0), o && H.push(G[$] <= 0, G[Z] <= 0), H.every(function(lt) {\n        return lt;\n      })) {\n        M = R, C = !1;\n        break;\n      }\n      S.set(R, H);\n    }\n    if (C)\n      for (var z = v ? 3 : 1, X = function(et) {\n        var k = w.find(function(ft) {\n          var Q = S.get(ft);\n          if (Q)\n            return Q.slice(0, et).every(function(St) {\n              return St;\n            });\n        });\n        if (k)\n          return M = k, \"break\";\n      }, ct = z; ct > 0; ct--) {\n        var it = X(ct);\n        if (it === \"break\")\n          break;\n      }\n    t.placement !== M && (t.modifiersData[r]._skip = !0, t.placement = M, t.reset = !0);\n  }\n}\nconst OG = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: PG,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction rE(i, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: i.top - t.height - e.y,\n    right: i.right - t.width + e.x,\n    bottom: i.bottom - t.height + e.y,\n    left: i.left - t.width - e.x\n  };\n}\nfunction iE(i) {\n  return [zr, Pi, Mi, Hr].some(function(t) {\n    return i[t] >= 0;\n  });\n}\nfunction IG(i) {\n  var t = i.state, e = i.name, r = t.rects.reference, n = t.rects.popper, s = t.modifiersData.preventOverflow, a = wc(t, {\n    elementContext: \"reference\"\n  }), o = wc(t, {\n    altBoundary: !0\n  }), u = rE(a, r), l = rE(o, n, s), h = iE(u), d = iE(l);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: u,\n    popperEscapeOffsets: l,\n    isReferenceHidden: h,\n    hasPopperEscaped: d\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": h,\n    \"data-popper-escaped\": d\n  });\n}\nconst RG = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: IG\n};\nfunction DG(i, t, e) {\n  var r = Qi(i), n = [Hr, zr].indexOf(r) >= 0 ? -1 : 1, s = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: i\n  })) : e, a = s[0], o = s[1];\n  return a = a || 0, o = (o || 0) * n, [Hr, Pi].indexOf(r) >= 0 ? {\n    x: o,\n    y: a\n  } : {\n    x: a,\n    y: o\n  };\n}\nfunction kG(i) {\n  var t = i.state, e = i.options, r = i.name, n = e.offset, s = n === void 0 ? [0, 0] : n, a = zM.reduce(function(h, d) {\n    return h[d] = DG(d, t.rects, s), h;\n  }, {}), o = a[t.placement], u = o.x, l = o.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += l), t.modifiersData[r] = a;\n}\nconst NG = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: kG\n};\nfunction AG(i) {\n  var t = i.state, e = i.name;\n  t.modifiersData[e] = qM({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst LG = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: AG,\n  data: {}\n};\nfunction BG(i) {\n  return i === \"x\" ? \"y\" : \"x\";\n}\nfunction FG(i) {\n  var t = i.state, e = i.options, r = i.name, n = e.mainAxis, s = n === void 0 ? !0 : n, a = e.altAxis, o = a === void 0 ? !1 : a, u = e.boundary, l = e.rootBoundary, h = e.altBoundary, d = e.padding, f = e.tether, p = f === void 0 ? !0 : f, v = e.tetherOffset, g = v === void 0 ? 0 : v, m = wc(t, {\n    boundary: u,\n    rootBoundary: l,\n    padding: d,\n    altBoundary: h\n  }), y = Qi(t.placement), _ = uh(t.placement), b = !_, w = $x(y), T = BG(w), x = t.modifiersData.popperOffsets, S = t.rects.reference, C = t.rects.popper, M = typeof g == \"function\" ? g(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : g, I = typeof M == \"number\" ? {\n    mainAxis: M,\n    altAxis: M\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, M), R = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {\n    x: 0,\n    y: 0\n  };\n  if (x) {\n    if (s) {\n      var A, U = w === \"y\" ? zr : Hr, B = w === \"y\" ? Mi : Pi, G = w === \"y\" ? \"height\" : \"width\", $ = x[w], Z = $ + m[U], H = $ - m[B], z = p ? -C[G] / 2 : 0, X = _ === sh ? S[G] : C[G], ct = _ === sh ? -C[G] : -S[G], it = t.elements.arrow, lt = p && it ? Hx(it) : {\n        width: 0,\n        height: 0\n      }, et = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : VM(), k = et[U], ft = et[B], Q = Qh(0, S[G], lt[G]), St = b ? S[G] / 2 - z - Q - k - I.mainAxis : X - Q - k - I.mainAxis, at = b ? -S[G] / 2 + z + Q + ft + I.mainAxis : ct + Q + ft + I.mainAxis, q = t.elements.arrow && Nd(t.elements.arrow), bt = q ? w === \"y\" ? q.clientTop || 0 : q.clientLeft || 0 : 0, st = (A = R == null ? void 0 : R[w]) != null ? A : 0, W = $ + St - st - bt, nt = $ + at - st, dt = Qh(p ? Dv(Z, W) : Z, $, p ? qo(H, nt) : H);\n      x[w] = dt, N[w] = dt - $;\n    }\n    if (o) {\n      var V, xt = w === \"x\" ? zr : Hr, Dt = w === \"x\" ? Mi : Pi, Ct = x[T], be = T === \"y\" ? \"height\" : \"width\", je = Ct + m[xt], ee = Ct - m[Dt], de = [zr, Hr].indexOf(y) !== -1, ue = (V = R == null ? void 0 : R[T]) != null ? V : 0, se = de ? je : Ct - S[be] - C[be] - ue + I.altAxis, ne = de ? Ct + S[be] + C[be] - ue - I.altAxis : ee, Ht = p && de ? uG(se, Ct, ne) : Qh(p ? se : je, Ct, p ? ne : ee);\n      x[T] = Ht, N[T] = Ht - Ct;\n    }\n    t.modifiersData[r] = N;\n  }\n}\nconst GG = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: FG,\n  requiresIfExists: [\"offset\"]\n};\nfunction UG(i) {\n  return {\n    scrollLeft: i.scrollLeft,\n    scrollTop: i.scrollTop\n  };\n}\nfunction jG(i) {\n  return i === hi(i) || !oi(i) ? Vx(i) : UG(i);\n}\nfunction zG(i) {\n  var t = i.getBoundingClientRect(), e = ah(t.width) / i.offsetWidth || 1, r = ah(t.height) / i.offsetHeight || 1;\n  return e !== 1 || r !== 1;\n}\nfunction HG(i, t, e) {\n  e === void 0 && (e = !1);\n  var r = oi(t), n = oi(t) && zG(t), s = ma(t), a = oh(i, n, e), o = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, u = {\n    x: 0,\n    y: 0\n  };\n  return (r || !r && !e) && ((Bn(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  Wx(s)) && (o = jG(t)), oi(t) ? (u = oh(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : s && (u.x = Xx(s))), {\n    x: a.left + o.scrollLeft - u.x,\n    y: a.top + o.scrollTop - u.y,\n    width: a.width,\n    height: a.height\n  };\n}\nfunction $G(i) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), r = [];\n  i.forEach(function(s) {\n    t.set(s.name, s);\n  });\n  function n(s) {\n    e.add(s.name);\n    var a = [].concat(s.requires || [], s.requiresIfExists || []);\n    a.forEach(function(o) {\n      if (!e.has(o)) {\n        var u = t.get(o);\n        u && n(u);\n      }\n    }), r.push(s);\n  }\n  return i.forEach(function(s) {\n    e.has(s.name) || n(s);\n  }), r;\n}\nfunction VG(i) {\n  var t = $G(i);\n  return J_.reduce(function(e, r) {\n    return e.concat(t.filter(function(n) {\n      return n.phase === r;\n    }));\n  }, []);\n}\nfunction XG(i) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(i());\n      });\n    })), t;\n  };\n}\nfunction Ds(i) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)\n    e[r - 1] = arguments[r];\n  return [].concat(e).reduce(function(n, s) {\n    return n.replace(/%s/, s);\n  }, i);\n}\nvar Ea = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', WG = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', nE = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction YG(i) {\n  i.forEach(function(t) {\n    [].concat(Object.keys(t), nE).filter(function(e, r, n) {\n      return n.indexOf(e) === r;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(Ds(Ea, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(Ds(Ea, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          J_.indexOf(t.phase) < 0 && console.error(Ds(Ea, t.name, '\"phase\"', \"either \" + J_.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(Ds(Ea, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(Ds(Ea, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(Ds(Ea, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(Ds(Ea, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + nE.map(function(r) {\n            return '\"' + r + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(r) {\n        i.find(function(n) {\n          return n.name === r;\n        }) == null && console.error(Ds(WG, String(t.name), r, r));\n      });\n    });\n  });\n}\nfunction qG(i, t) {\n  var e = /* @__PURE__ */ new Set();\n  return i.filter(function(r) {\n    var n = t(r);\n    if (!e.has(n))\n      return e.add(n), !0;\n  });\n}\nfunction ZG(i) {\n  var t = i.reduce(function(e, r) {\n    var n = e[r.name];\n    return e[r.name] = n ? Object.assign({}, n, r, {\n      options: Object.assign({}, n.options, r.options),\n      data: Object.assign({}, n.data, r.data)\n    }) : r, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar sE = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", KG = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", aE = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction oE() {\n  for (var i = arguments.length, t = new Array(i), e = 0; e < i; e++)\n    t[e] = arguments[e];\n  return !t.some(function(r) {\n    return !(r && typeof r.getBoundingClientRect == \"function\");\n  });\n}\nfunction JG(i) {\n  i === void 0 && (i = {});\n  var t = i, e = t.defaultModifiers, r = e === void 0 ? [] : e, n = t.defaultOptions, s = n === void 0 ? aE : n;\n  return function(o, u, l) {\n    l === void 0 && (l = s);\n    var h = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, aE, s),\n      modifiersData: {},\n      elements: {\n        reference: o,\n        popper: u\n      },\n      attributes: {},\n      styles: {}\n    }, d = [], f = !1, p = {\n      state: h,\n      setOptions: function(y) {\n        var _ = typeof y == \"function\" ? y(h.options) : y;\n        g(), h.options = Object.assign({}, s, h.options, _), h.scrollParents = {\n          reference: su(o) ? tc(o) : o.contextElement ? tc(o.contextElement) : [],\n          popper: tc(u)\n        };\n        var b = VG(ZG([].concat(r, h.options.modifiers)));\n        if (h.orderedModifiers = b.filter(function(R) {\n          return R.enabled;\n        }), \"development\" !== \"production\") {\n          var w = qG([].concat(b, h.options.modifiers), function(R) {\n            var N = R.name;\n            return N;\n          });\n          if (YG(w), Qi(h.options.placement) === _0) {\n            var T = h.orderedModifiers.find(function(R) {\n              var N = R.name;\n              return N === \"flip\";\n            });\n            T || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var x = sn(u), S = x.marginTop, C = x.marginRight, M = x.marginBottom, I = x.marginLeft;\n          [S, C, M, I].some(function(R) {\n            return parseFloat(R);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return v(), p.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!f) {\n          var y = h.elements, _ = y.reference, b = y.popper;\n          if (!oE(_, b)) {\n             true && console.error(sE);\n            return;\n          }\n          h.rects = {\n            reference: HG(_, Nd(b), h.options.strategy === \"fixed\"),\n            popper: Hx(b)\n          }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(R) {\n            return h.modifiersData[R.name] = Object.assign({}, R.data);\n          });\n          for (var w = 0, T = 0; T < h.orderedModifiers.length; T++) {\n            if ( true && (w += 1, w > 100)) {\n              console.error(KG);\n              break;\n            }\n            if (h.reset === !0) {\n              h.reset = !1, T = -1;\n              continue;\n            }\n            var x = h.orderedModifiers[T], S = x.fn, C = x.options, M = C === void 0 ? {} : C, I = x.name;\n            typeof S == \"function\" && (h = S({\n              state: h,\n              options: M,\n              name: I,\n              instance: p\n            }) || h);\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: XG(function() {\n        return new Promise(function(m) {\n          p.forceUpdate(), m(h);\n        });\n      }),\n      destroy: function() {\n        g(), f = !0;\n      }\n    };\n    if (!oE(o, u))\n      return  true && console.error(sE), p;\n    p.setOptions(l).then(function(m) {\n      !f && l.onFirstUpdate && l.onFirstUpdate(m);\n    });\n    function v() {\n      h.orderedModifiers.forEach(function(m) {\n        var y = m.name, _ = m.options, b = _ === void 0 ? {} : _, w = m.effect;\n        if (typeof w == \"function\") {\n          var T = w({\n            state: h,\n            name: y,\n            instance: p,\n            options: b\n          }), x = function() {\n          };\n          d.push(T || x);\n        }\n      });\n    }\n    function g() {\n      d.forEach(function(m) {\n        return m();\n      }), d = [];\n    }\n    return p;\n  };\n}\nvar QG = [yG, LG, gG, sG, NG, OG, GG, fG, RG], t4 = /* @__PURE__ */ JG({\n  defaultModifiers: QG\n});\nconst { GamepadListener: e4 } = __webpack_require__(/*! gamepad.js */ \"./node_modules/gamepad.js/gamepad.js\");\nvar Mr, Qs, or, Gf, Uf, eb, jf, rb, zf, ib, kl, Nl, Hf, nb, Re, _i, us, ls, $f, ta, wu, Vf, Xf, mr, Al, Ll, Wf, cm, ZM, Yf, Co, fm, KM, qf, sb, dm, JM, Zf, ab, Mo, Uh, Po, pm, QM, vm, tP, bi, gm, eP, mm, rP, Bl, Qp, hs, Oo, Io, ym, iP, Pr;\nclass r4 {\n  constructor(t, e, r, n, s, a, o, u, l) {\n    E(this, Uf);\n    E(this, jf);\n    E(this, zf);\n    E(this, Hf);\n    E(this, ta);\n    E(this, cm);\n    // イベントを全消去\n    E(this, fm);\n    E(this, qf);\n    // イベントを予約\n    E(this, dm);\n    E(this, Zf);\n    E(this, Mo);\n    // 行末クリック待ち\n    E(this, pm);\n    // 改ページクリック待ち\n    E(this, vm);\n    E(this, gm);\n    // フォーカス移動\n    E(this, mm);\n    // ウェイトを入れる\n    E(this, Bl);\n    // クリックを待つ\n    E(this, ym);\n    E(this, Mr, new Ql());\n    E(this, Qs, new e4({\n      analog: !1,\n      deadZone: 0.3\n    }));\n    E(this, or, new V3());\n    E(this, Gf, (t) => {\n    });\n    E(this, kl, !1);\n    E(this, Nl, !1);\n    E(this, Re, {});\n    E(this, _i, {});\n    E(this, us, !1);\n    E(this, ls, !1);\n    // 予約イベントの発生待ち中か\n    E(this, $f, (t) => c(this, Re)[t] ?? c(this, _i)[t]);\n    E(this, Vf, () => {\n      P(this, Vf, () => {\n      }), this.scrItr.firstWait();\n    });\n    E(this, Xf, {\n      getBoundingClientRect: (t = 0, e = 0) => DOMRect.fromRect({ x: t, y: e, width: 0, height: 0 })\n    });\n    E(this, mr, void 0);\n    E(this, Al, void 0);\n    E(this, Ll, void 0);\n    E(this, Wf, {\n      placement: \"bottom\",\n      fallbackPlacements: [\"top\", \"bottom\"]\n    });\n    E(this, Yf, (t, e) => {\n    });\n    E(this, Co, new Ql());\n    E(this, Po, () => this.layMng.goTxt());\n    // スキップ中断予約\n    E(this, bi, () => !1);\n    E(this, hs, () => {\n    });\n    E(this, Oo, new $r());\n    E(this, Io, \"sn:notice_comp_txt\");\n    // 0:no push  1:one push  2:push repeating\n    E(this, Pr, {\n      Alt: 0,\n      Meta: 0,\n      // COMMANDキー\n      Control: 0,\n      ArrowDown: 0,\n      End: 0,\n      Enter: 0,\n      Escape: 0,\n      \" \": 0,\n      GoBack: 0\n      // AndroidのBackキーだと思う\n    });\n    var g, m;\n    if (this.cfg = t, this.hTag = e, this.appPixi = r, this.main = n, this.layMng = s, this.val = a, this.sndMng = o, this.scrItr = u, this.sys = l, e.clear_event = (y) => O(this, fm, KM).call(this, y), e.event = (y) => O(this, dm, JM).call(this, y), e.l = (y) => O(this, pm, QM).call(this, y), e.p = (y) => O(this, vm, tP).call(this, y), e.s = () => (u.recodePage(), O(this, ta, wu).call(this, () => {\n    }, !1, !0)), e.set_cancel_skip = () => O(this, gm, eP).call(this), e.set_focus = (y) => O(this, mm, rP).call(this, y), e.wait = (y) => O(this, Bl, Qp).call(this, y), e.waitclick = () => O(this, ym, iP).call(this), o.setEvtMng(this), u.setOtherObj(this, s), Se.setEvtMng(n, this, l), s.setEvtMng(this), l.setFire((y, _) => this.fire(y, _)), Y.isDbg) {\n      const y = {\n        pause: () => {\n          if (P(this, us, !0), !c(this, ls))\n            return;\n          const _ = {};\n          u.recodeDesign(_), l.callHook(\"_enterDesign\", _), l.send2Dbg(\"_enterDesign\", _);\n        },\n        stopOnBreakpoint: () => P(this, us, !0),\n        stopOnDataBreakpoint: () => P(this, us, !0),\n        continue: () => P(this, us, !1),\n        disconnect: () => P(this, us, !1)\n      };\n      y.attach = y.stopOnEntry = y.stopOnStep = y.stopOnStepIn = y.stopOnStepOut = y.stopOnBackstep = y.pause, l.addHook((_) => {\n        var b;\n        return (b = y[_]) == null ? void 0 : b.call(y);\n      });\n    }\n    Lu(`\n.sn_hint {\n\tbackground-color: #3c3225;\n\tcolor: white;\n\tpadding: 4px 8px;\n\tborder-radius: 4px;\n\tfont-size: 1.2em;\n\tz-index: 10000;\n\tpointer-events: none;\n\tuser-select: none;\n}\n\n.sn_hint_ar,\n.sn_hint_ar::before {\n\tposition: absolute;\n\twidth: 8px;\n\theight: 8px;\n\tbackground: inherit;\n}\n.sn_hint_ar {\n\tvisibility: hidden;\n}\n.sn_hint_ar::before {\n\tvisibility: visible;\n\tcontent: '';\n\ttransform: rotate(45deg);\n}\n\n.sn_hint[data-popper-placement^='top']\t\t> .sn_hint_ar {bottom: -4px;}\n.sn_hint[data-popper-placement^='bottom']\t> .sn_hint_ar {top: -4px;}\n.sn_hint[data-popper-placement^='left']\t\t> .sn_hint_ar {right: -4px;}\n.sn_hint[data-popper-placement^='right']\t> .sn_hint_ar {left: -4px;}\n`);\n    for (const y of Array.from(document.getElementsByClassName(\"sn_hint\")))\n      (g = y.parentElement) == null || g.removeChild(y);\n    (m = Ur.cvs.parentElement) == null || m.insertAdjacentHTML(\"beforeend\", `\n<div class=\"sn_hint\" role=\"tooltip\">\n\t<span>Dummy</span>\n\t<div class=\"sn_hint_ar\" data-popper-arrow></div>\n</div>`), P(this, mr, document.querySelector(\".sn_hint\")), P(this, Al, c(this, mr).querySelector(\"span\")), P(this, Ll, t4(c(this, Xf), c(this, mr))), c(this, mr).hidden = !0, r.stage.interactive = !0, Y.isMobile ? r.stage.on(\"pointerdown\", (y) => this.fire(\"click\", y)) : c(this, Mr).add(r.stage, \"pointerdown\", (y) => {\n      switch (y.data.button) {\n        case 0:\n          this.fire(\"click\", y);\n          break;\n        case 1:\n          this.fire(\"middleclick\", y);\n          break;\n      }\n    }), c(this, Mr).add(window, \"keydown\", (y) => O(this, Uf, eb).call(this, y)), c(this, Mr).add(Ur.cvs, \"contextmenu\", (y) => O(this, jf, rb).call(this, y));\n    const h = () => a.setVal_Nochk(\"tmp\", \"const.sn.navigator.language\", navigator.language);\n    c(this, Mr).add(window, \"languagechange\", (y) => {\n      h(), this.fire(\"sn:chgNavLang\", y), LE();\n    }), h();\n    const d = (y) => {\n      Y.isDarkMode = y.matches, a.setVal_Nochk(\"tmp\", \"const.sn.isDarkMode\", Y.isDarkMode);\n    }, f = globalThis.matchMedia(\"(prefers-color-scheme: dark)\");\n    d(f), c(this, Mr).add(f, \"change\", (y) => {\n      d(y), this.fire(\"sn:chgDarkMode\", y);\n    }), \"WheelEvent\" in window && (c(this, Mr).add(Ur.cvs, \"wheel\", (y) => O(this, zf, ib).call(this, y), { passive: !0 }), P(this, Gf, (y) => c(this, Mr).add(y, \"wheel\", (_) => O(this, zf, ib).call(this, _), { passive: !0 })), P(this, Yf, (y, _) => y.add(Ur.cvs, \"wheel\", (b) => {\n      b.isComposing || b.deltaY <= 0 || (b.stopPropagation(), _());\n    }))), Y.debugLog && (c(this, Qs).on(\"gamepad:connected\", (y) => console.log(`👺<'gamepad:connected' index:${y.detail.index} id:${y.detail.gamepad.id}`)), c(this, Qs).on(\"gamepad:disconnected\", (y) => console.log(`👺<'gamepad:disconnected' index:${y.detail.index} id:${y.detail.gamepad.id}`)));\n    const p = [\n      \"\",\n      \"ArrowUp\",\n      \"\",\n      // '7', '8', '9',\n      \"ArrowLeft\",\n      \"\",\n      \"ArrowRight\",\n      // '4', '5', '6',\n      \"\",\n      \"ArrowDown\",\n      \"\"\n      // '1', '2', '3',\n    ], v = [0, 0];\n    c(this, Qs).on(\"gamepad:axis\", (y) => {\n      if (!document.hasFocus() || y.detail.stick !== 0)\n        return;\n      v[y.detail.axis] = y.detail.value;\n      const _ = (v[1] + 1) * 3 + (v[0] + 1), b = p[_];\n      if (!b)\n        return;\n      const w = c(this, or).getFocus();\n      (!w || w instanceof ye ? globalThis : w).dispatchEvent(new KeyboardEvent(\"keydown\", { key: b, bubbles: !0 })), !(!w || w instanceof ye) && w.getAttribute(\"type\") === \"range\" && w.dispatchEvent(new InputEvent(\"input\", { bubbles: !0 }));\n    }), c(this, Qs).on(\"gamepad:button\", (y) => {\n      if (document.hasFocus())\n        if (y.detail.button % 2 === 0) {\n          const _ = c(this, or).getFocus();\n          (!_ || _ instanceof ye ? globalThis : _).dispatchEvent(new KeyboardEvent(\"keydown\", { key: \"Enter\", bubbles: !0 }));\n        } else\n          Ur.cvs.dispatchEvent(new Event(\"contextmenu\"));\n    }), c(this, Qs).start(), c(this, Mr).add(window, \"keyup\", (y) => {\n      y.isComposing || y.key in c(this, Pr) && (c(this, Pr)[y.key] = 0);\n    }), a.defTmp(\"const.sn.key.alternate\", () => c(this, Pr).Alt > 0), a.defTmp(\"const.sn.key.command\", () => c(this, Pr).Meta > 0), a.defTmp(\"const.sn.key.control\", () => c(this, Pr).Control > 0), a.defTmp(\"const.sn.key.end\", () => c(this, Pr).End > 0), a.defTmp(\"const.sn.key.escape\", () => c(this, Pr).Escape > 0), a.defTmp(\"const.sn.key.back\", () => c(this, Pr).GoBack > 0);\n  }\n  resvFlameEvent(t) {\n    c(this, Mr).add(t, \"keydown\", (e) => O(this, Uf, eb).call(this, e)), c(this, Mr).add(t, \"contextmenu\", (e) => O(this, jf, rb).call(this, e)), c(this, Gf).call(this, t);\n  }\n  destroy() {\n    c(this, or).destroy(), c(this, Mr).clear();\n  }\n  fire(t, e) {\n    var s;\n    if (c(this, bi).call(this) || !c(this, ls) || c(this, us))\n      return;\n    const r = t.toLowerCase();\n    if (Y.debugLog && console.log(`👺 fire<(key:\\`${r}\\` type:${e.type} e:%o)`, { ...e }), r === \"enter\") {\n      const a = c(this, or).getFocus();\n      if (a instanceof ye) {\n        a.emit(\"pointerdown\", new Event(\"pointerdown\"));\n        return;\n      }\n    }\n    const n = c(this, $f).call(this, r);\n    if (!n) {\n      r.slice(0, 5) === \"swipe\" && globalThis.scrollBy(\n        -e.deltaX,\n        -e.deltaY\n      );\n      return;\n    }\n    r.slice(-5) !== \"wheel\" && ((s = e.preventDefault) == null || s.call(e)), e.stopPropagation(), !(r.slice(0, 4) !== \"dom=\" && this.layMng.clickTxtLay()) && (P(this, ls, !1), n(e));\n  }\n  popLocalEvts() {\n    const t = c(this, Re);\n    return P(this, Re, {}), t;\n  }\n  pushLocalEvts(t) {\n    P(this, Re, t);\n  }\n  waitEvent(t, e = !0, r = !1) {\n    if (e && r)\n      throw \"canskipとglobalを同時にtrue指定できません\";\n    if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n      if (this.val.getVal(\"tmp:sn.skip.all\") || this.scrItr.isNextKidoku)\n        return t(), !1;\n      c(this, bi).call(this);\n    }\n    return O(this, ta, wu).call(this, t, e, r);\n  }\n  unButton(t) {\n    c(this, or).remove(t);\n  }\n  button(t, e, r, n, s) {\n    var d;\n    !t.fn && !t.label && this.main.errScript(\"fnまたはlabelは必須です\"), e.interactive = e.buttonMode = !0;\n    const a = ((d = t.key) == null ? void 0 : d.toLowerCase()) ?? \" \";\n    t.fn || (t.fn = this.scrItr.scriptFn);\n    const o = vt(t, \"global\", !1);\n    o ? c(this, _i)[a] = () => this.main.resumeByJumpOrCall(t) : c(this, Re)[a] = () => this.main.resumeByJumpOrCall(t), e.on(\"pointerdown\", (f) => this.fire(a, f));\n    const u = t.hint ? () => O(this, cm, ZM).call(this, t, e) : () => {\n    }, l = () => {\n      r(), c(this, mr).hidden = !0;\n    }, h = () => (u(), n());\n    if (e.on(\"pointerover\", h), e.on(\"pointerout\", () => {\n      c(this, or).isFocus(e) ? h() : l();\n    }), e.on(\"pointerdown\", () => {\n      c(this, mr).hidden = !0;\n      const f = c(this, or).getFocus();\n      s(), f instanceof Yi && f.normal();\n    }), e.on(\n      \"pointerup\",\n      Y.isMobile ? l : () => {\n        c(this, or).isFocus(e) ? h() : l();\n      }\n    ), c(this, or).add(e, h, l), t.clickse && (this.cfg.searchPath(t.clickse, vr.SOUND), e.on(\"pointerdown\", () => {\n      const f = { fn: t.clickse, join: !1 };\n      t.clicksebuf && (f.buf = t.clicksebuf), this.hTag.playse(f);\n    })), t.enterse && (this.cfg.searchPath(t.enterse, vr.SOUND), e.on(\"pointerover\", () => {\n      const f = { fn: t.enterse, join: !1 };\n      t.entersebuf && (f.buf = t.entersebuf), this.hTag.playse(f);\n    })), t.leavese && (this.cfg.searchPath(t.leavese, vr.SOUND), e.on(\"pointerout\", () => {\n      const f = { fn: t.leavese, join: !1 };\n      t.leavesebuf && (f.buf = t.leavesebuf), this.hTag.playse(f);\n    })), t.onenter) {\n      const f = a + t.onenter.toLowerCase(), p = { fn: t.fn, label: t.onenter, call: !0, key: f };\n      o ? c(this, _i)[f] = () => this.main.resumeByJumpOrCall(p) : c(this, Re)[f] = () => this.main.resumeByJumpOrCall(p), e.on(\"pointerover\", (v) => this.fire(f, v));\n    }\n    if (t.onleave) {\n      const f = a + t.onleave.toLowerCase(), p = { fn: t.fn, label: t.onleave, call: !0, key: f };\n      o ? c(this, _i)[f] = () => this.main.resumeByJumpOrCall(p) : c(this, Re)[f] = () => this.main.resumeByJumpOrCall(p), e.on(\"pointerout\", (v) => this.fire(f, v));\n    }\n  }\n  hideHint() {\n    c(this, mr).hidden = !0;\n  }\n  cvsResize() {\n    c(this, mr).hidden = !0;\n  }\n  // 予約イベントの発生待ちしない waitEvent()\n  waitLimitedEvent(t, e) {\n    c(this, Po).call(this), this.val.saveKidoku();\n    const r = () => {\n      c(this, Co).clear(), e();\n    };\n    if (this.val.getVal(\"tmp:sn.skip.enabled\"))\n      if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n      !this.scrItr.isNextKidoku)\n        c(this, bi).call(this);\n      else\n        return r(), !1;\n    return vt(t, \"canskip\", !0) && (c(this, Co).add(window, \"pointerdown\", (n) => {\n      n.stopPropagation(), r();\n    }), c(this, Co).add(window, \"keydown\", (n) => {\n      n.isComposing || (n.stopPropagation(), r());\n    }), c(this, Yf).call(this, c(this, Co), r)), !0;\n  }\n  noticeCompTxt() {\n    c(this, Oo).emit(c(this, Io));\n  }\n  // キー押下によるスキップ中か\n  isSkippingByKeyDown() {\n    return this.scrItr.skip4page ? !0 : Object.keys(c(this, Pr)).some((t) => c(this, Pr)[t] === 2);\n  }\n}\nMr = new WeakMap(), Qs = new WeakMap(), or = new WeakMap(), Gf = new WeakMap(), Uf = new WeakSet(), eb = function(t) {\n  if (t.isComposing)\n    return;\n  t.key in c(this, Pr) && (c(this, Pr)[t.key] = t.repeat ? 2 : 1);\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + t.key;\n  this.fire(e, t);\n}, jf = new WeakSet(), rb = function(t) {\n  const e = (t.altKey ? t.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (t.ctrlKey ? t.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (t.shiftKey ? t.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + \"rightclick\";\n  this.fire(e, t), t.preventDefault();\n}, zf = new WeakSet(), ib = function(t) {\n  if (t.isComposing)\n    return;\n  if (c(this, kl)) {\n    P(this, Nl, !0);\n    return;\n  }\n  P(this, kl, !0), O(this, Hf, nb).call(this);\n  const e = (t.altKey ? \"alt+\" : \"\") + (t.ctrlKey ? \"ctrl+\" : \"\") + (t.shiftKey ? \"shift+\" : \"\") + (t.deltaY > 0 ? \"downwheel\" : \"upwheel\");\n  this.fire(e, t);\n}, kl = new WeakMap(), Nl = new WeakMap(), Hf = new WeakSet(), nb = function() {\n  setTimeout(() => {\n    if (c(this, Nl)) {\n      P(this, Nl, !1), O(this, Hf, nb).call(this);\n      return;\n    }\n    P(this, kl, !1);\n  }, 250);\n}, Re = new WeakMap(), _i = new WeakMap(), us = new WeakMap(), ls = new WeakMap(), $f = new WeakMap(), ta = new WeakSet(), wu = function(t, e = !0, r = !0) {\n  if (c(this, Po).call(this), this.val.saveKidoku(), e ? c(this, Re).click = //this.hTag.event({key:'enter', breakout: fnc});\n  //hTag.event({key:'down', breakout: fnc});\n  //\thTag.event()は内部で使わず、こうする\n  c(this, Re).enter = c(this, Re).arrowdown = // hTag.event({key:'downwheel', breakout: fnc});\n  //\thTag.event()は内部で使わず、こうする\n  c(this, Re)[\"wheel.y>0\"] = t : (delete c(this, Re).click, delete c(this, Re).enter, delete c(this, Re).arrowdown, delete c(this, Re)[\"wheel.y>0\"]), P(this, $f, r ? (n) => c(this, Re)[n] ?? c(this, _i)[n] : (n) => c(this, Re)[n]), P(this, ls, !0), c(this, Vf).call(this), Y.debugLog) {\n    const n = /* @__PURE__ */ Object.create(null);\n    n.local = Object.keys(c(this, Re)), n.global = Object.keys(c(this, _i)), console.log(\"🎍 wait event... %o\", n);\n  }\n  return !0;\n}, Vf = new WeakMap(), Xf = new WeakMap(), mr = new WeakMap(), Al = new WeakMap(), Ll = new WeakMap(), Wf = new WeakMap(), cm = new WeakSet(), ZM = function(t, e) {\n  const r = e instanceof Yi ? e.getBtnBounds() : e.getBounds();\n  if (!(t[\":タグ名\"] === \"link\")) {\n    const s = e.parent.parent;\n    r.x += s.x, r.y += s.y;\n  }\n  if (!t.hint) {\n    c(this, mr).hidden = !0;\n    return;\n  }\n  c(this, mr).style.cssText = `position:${c(this, mr).style.position}; transform:${c(this, mr).style.transform};` + (t.hint_style ?? \"\"), c(this, Al).style.cssText = \"\", c(this, Al).textContent = t.hint ?? \"\";\n  try {\n    const s = t.hint_opt ? { ...c(this, Wf), ...JSON.parse(t.hint_opt) } : c(this, Wf);\n    c(this, Ll).setOptions(s);\n  } catch (s) {\n    console.error(Mp(t, \"hint_opt\", s.message));\n  }\n  c(this, Xf).getBoundingClientRect = () => DOMRect.fromRect({\n    x: this.sys.ofsLeft4elm + r.x * this.sys.cvsScale,\n    y: this.sys.ofsTop4elm + r.y * this.sys.cvsScale,\n    width: r.width,\n    height: r.height\n  }), c(this, Ll).update(), c(this, mr).hidden = !1;\n}, Yf = new WeakMap(), Co = new WeakMap(), fm = new WeakSet(), KM = function(t) {\n  const e = vt(t, \"global\", !1), r = e ? c(this, _i) : c(this, Re);\n  for (const [n, s] of Object.entries(r))\n    O(this, qf, sb).call(this, n, s);\n  return e ? P(this, _i, {}) : P(this, Re, {}), P(this, ls, !1), !1;\n}, qf = new WeakSet(), sb = function(t, e) {\n  t.slice(0, 4) === \"dom=\" && O(this, Mo, Uh).call(this, t).el.forEach((r) => r.removeEventListener(\"click\", e));\n}, dm = new WeakSet(), JM = function(t) {\n  const e = t.key;\n  if (!e)\n    throw \"keyは必須です\";\n  const r = e.toLowerCase(), n = vt(t, \"call\", !1), s = vt(t, \"global\", !1) ? c(this, _i) : c(this, Re);\n  if (vt(t, \"del\", !1)) {\n    if (t.fn || t.label || n)\n      throw \"fn/label/callとdelは同時指定できません\";\n    return O(this, qf, sb).call(this, e, s[r]), delete s[r], !1;\n  }\n  if (t.fn ?? (t.fn = this.scrItr.scriptFn), e.slice(0, 4) === \"dom=\") {\n    const a = O(this, Mo, Uh).call(this, e);\n    if (a.el.length === 0) {\n      if (vt(t, \"need_err\", !0))\n        throw `HTML内にセレクタ（${a.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n      return !1;\n    }\n    let o = [\"click\", \"keydown\"];\n    switch (a.el[0].type ?? \"\") {\n      case \"checkbox\":\n        o = [\"input\"];\n        break;\n      case \"range\":\n        o = [\"input\"];\n        break;\n      case \"text\":\n      case \"textarea\":\n        o = [\"input\", \"change\"];\n        break;\n    }\n    o.forEach((l, h) => a.el.forEach((d) => {\n      c(this, Mr).add(d, l, (f) => {\n        if (!c(this, ls) || this.layMng.getFrmDisabled(a.id) || l === \"keydown\" && f.key !== \"Enter\")\n          return;\n        const p = d.dataset;\n        for (const [v, g] of Object.entries(p))\n          this.val.setVal_Nochk(\"tmp\", `sn.event.domdata.${v}`, g);\n        this.fire(e, f);\n      }), h === 0 && c(this, or).add(\n        d,\n        () => O(this, Zf, ab).call(this, d) ? (d.focus(), !0) : !1,\n        () => {\n        }\n      );\n    }));\n  }\n  return s[r] = () => this.main.resumeByJumpOrCall(t), !1;\n}, Zf = new WeakSet(), ab = function(t) {\n  if (t.offsetParent === null)\n    return !1;\n  let e = t;\n  do {\n    if (getComputedStyle(e).display === \"none\" || e.dataset.focus === \"false\" || e != null && e.disabled)\n      return !1;\n    e = e.parentElement;\n  } while (e !== null);\n  return !0;\n}, Mo = new WeakSet(), Uh = function(t) {\n  const e = t.indexOf(\":\");\n  let r = \"\";\n  if (e >= 0) {\n    const n = t.slice(4, e), s = `const.sn.frm.${n}`;\n    if (!this.val.getVal(`tmp:${s}`, 0))\n      throw `HTML【${n}】が読み込まれていません`;\n    const o = document.getElementById(n).contentWindow;\n    return r = t.slice(e + 1), { el: o.document.querySelectorAll(r), id: n, sel: r };\n  }\n  return r = t.slice(4), { el: document.querySelectorAll(r), id: \"\", sel: r };\n}, Po = new WeakMap(), pm = new WeakSet(), QM = function(t) {\n  if (this.scrItr.skip4page)\n    return !1;\n  if (!this.val.getVal(\"tmp:sn.tagL.enabled\"))\n    return c(this, Po).call(this), !1;\n  if (this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n    !this.scrItr.isNextKidoku)\n      c(this, bi).call(this);\n    else if (\"ps\".includes(this.val.getVal(\"sys:sn.skip.mode\")))\n      return !1;\n  }\n  return this.val.getVal(\"tmp:sn.auto.enabled\") ? O(this, Bl, Qp).call(this, {\n    time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecLineWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecLineWait\"))\n  }) : (vt(t, \"visible\", !0) && this.layMng.breakLine(), O(this, ta, wu).call(this, () => this.main.resume()));\n}, vm = new WeakSet(), tP = function(t) {\n  if (this.scrItr.recodePage(), this.val.getVal(\"tmp:sn.skip.enabled\")) {\n    if (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n    !this.scrItr.isNextKidoku)\n      c(this, bi).call(this);\n    else if (this.val.getVal(\"sys:sn.skip.mode\") == \"s\")\n      return c(this, Po).call(this), !1;\n  }\n  if (this.val.getVal(\"tmp:sn.auto.enabled\"))\n    return O(this, Bl, Qp).call(this, {\n      time: Number(this.scrItr.isKidoku ? this.val.getVal(\"sys:sn.auto.msecPageWait_Kidoku\") : this.val.getVal(\"sys:sn.auto.msecPageWait\"))\n    });\n  vt(t, \"visible\", !0) && this.layMng.breakPage();\n  const e = () => {\n    this.sndMng.clearCache(), this.main.resume();\n  };\n  return O(this, ta, wu).call(this, vt(t, \"er\", !1) && this.layMng.currentTxtlayFore ? () => {\n    this.hTag.er(t), e();\n  } : e);\n}, bi = new WeakMap(), gm = new WeakSet(), eP = function() {\n  return P(this, bi, () => (P(this, bi, () => !1), this.val.setVal_Nochk(\"tmp\", \"sn.tagL.enabled\", !0), this.val.setVal_Nochk(\"tmp\", \"sn.skip.enabled\", !1), this.val.setVal_Nochk(\"tmp\", \"sn.auto.enabled\", !1), this.layMng.setNormalChWait(), c(this, hs).call(this), !0)), !1;\n}, mm = new WeakSet(), rP = function(t) {\n  const { add: e, del: r, to: n } = t;\n  if ((e == null ? void 0 : e.slice(0, 4)) === \"dom=\") {\n    const s = O(this, Mo, Uh).call(this, e);\n    if (s.el.length === 0 && vt(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return s.el.forEach((a) => c(this, or).add(\n      a,\n      () => O(this, Zf, ab).call(this, a) ? (a.focus(), !0) : !1,\n      () => {\n      }\n    )), !1;\n  }\n  if ((r == null ? void 0 : r.slice(0, 4)) === \"dom=\") {\n    const s = O(this, Mo, Uh).call(this, r);\n    if (s.el.length === 0 && vt(t, \"need_err\", !0))\n      throw `HTML内にセレクタ（${s.sel}）に対応する要素が見つかりません。存在しない場合を許容するなら、need_err=false と指定してください`;\n    return s.el.forEach((a) => c(this, or).remove(a)), !1;\n  }\n  if (!n)\n    throw \"[set_focus] add か to は必須です\";\n  switch (n) {\n    case \"null\":\n      c(this, or).blur();\n      break;\n    case \"next\":\n      c(this, or).next();\n      break;\n    case \"prev\":\n      c(this, or).prev();\n      break;\n  }\n  return !1;\n}, Bl = new WeakSet(), Qp = function(t) {\n  const e = tt(t, \"time\", NaN);\n  return this.scrItr.skip4page ? !1 : this.val.getVal(\"tmp:sn.skip.enabled\") ? (!this.val.getVal(\"tmp:sn.skip.all\") && // 未読で停止\n  !this.scrItr.isNextKidoku && c(this, bi).call(this), !1) : (c(this, Oo).once(c(this, Io), () => {\n    c(this, Oo).off(c(this, Io));\n    const r = new Tn({}).to({}, e).onComplete(() => {\n      P(this, hs, () => {\n      }), r.stop(), this.main.resume();\n    }).start();\n    P(this, hs, () => r.end());\n  }), P(this, hs, () => {\n    P(this, hs, () => {\n    }), c(this, Oo).off(c(this, Io));\n  }), this.waitEvent(\n    () => c(this, hs).call(this),\n    vt(t, \"canskip\", !0),\n    // スキップ中は利かない\n    vt(t, \"global\", !1)\n  ));\n}, hs = new WeakMap(), Oo = new WeakMap(), Io = new WeakMap(), ym = new WeakSet(), iP = function() {\n  return this.scrItr.skip4page ? !1 : ((this.val.getVal(\"tmp:sn.skip.enabled\") || this.val.getVal(\"tmp:sn.auto.enabled\")) && c(this, bi).call(this), O(this, ta, wu).call(this, () => this.main.resume()));\n}, Pr = new WeakMap();\nclass uE {\n  constructor(t = \"\", e = 0, r = { \":hEvt1Time\": {}, \":hMp\": {} }) {\n    K(this, \"toString\", () => `[fn:${this.fn}, idx:${this.idx}, csArg:${this.csArg}]`);\n    this.fn = t, this.idx = e, this.csArg = r;\n  }\n}\nvar qt, ie, yt, me, ce, cs, Kf, ob, Ro, ea, _m, ra, Jf, ub, Qf, lb, td, ia, Su, Do, jh, ko, fs, Ne, bm, nP, No, zh, xm, sP, ed, Fl, ti, wm, aP, Em, oP, ds, Ia, Sm, uP, Ao, Lo, rd, id, nd, ei, Tm, lP, Cm, hP, Mm, cP, sd, hb, Pm, fP, Om, dP, Im, pP, ad, cb, od, Bo, Hh, Fo, ps, Ra, ud, fb, ld, hd, db, Rm, Dm, cd, km, vP, cr, Nm, gP, fd, pb, Am, Lm, Bm, mP, Fm, yP, vs, dd, vb, Gm, _P, Um, bP, jm, zm, xP, pd, Gl, Hm, wP, Ul, tv, jl, $m, EP, zi, Vm, SP, zl, ev, Xm, TP, Hi, fr;\nconst Yr = class {\n  constructor(t, e, r, n, s, a, o, u, l) {\n    E(this, Kf);\n    E(this, Jf);\n    E(this, Qf);\n    E(this, ia);\n    E(this, Do);\n    E(this, bm);\n    E(this, No);\n    E(this, xm);\n    //\t//\t変数操作\n    // インラインテキスト代入\n    E(this, wm);\n    //\t// デバッグ・その他\n    // スタックのダンプ\n    E(this, Em);\n    E(this, ds);\n    // 外部へスクリプトを表示\n    E(this, Sm);\n    // FIFOバッファ（push/unshift）\n    E(this, Tm);\n    E(this, Cm);\n    //\t// ラベル・ジャンプ\n    // サブルーチンコール\n    E(this, Mm);\n    E(this, sd);\n    // シナリオジャンプ\n    E(this, Pm);\n    // ページ移動\n    E(this, Om);\n    // コールスタック破棄\n    E(this, Im);\n    // サブルーチンから戻る\n    E(this, ad);\n    E(this, Bo);\n    E(this, ps);\n    // 初期化前に終了した場合向け\n    E(this, ud);\n    E(this, hd);\n    E(this, km);\n    //{} シナリオキャッシュ\n    E(this, Nm);\n    E(this, fd);\n    E(this, Bm);\n    E(this, Fm);\n    E(this, dd);\n    //\t// マクロ\n    // 括弧マクロの定義\n    E(this, Gm);\n    // 一文字マクロの定義\n    E(this, Um);\n    E(this, zm);\n    // https://regex101.com/r/Lk9ASK/1\n    //\t// しおり\n    // しおりの読込\n    E(this, Hm);\n    E(this, Ul);\n    // スクリプト再読込\n    E(this, $m);\n    E(this, Vm);\n    E(this, zl);\n    // しおりの保存\n    E(this, Xm);\n    E(this, qt, { aToken: [\"\"], len: 1, aLNum: [1] });\n    E(this, ie, \"\");\n    E(this, yt, 0);\n    E(this, me, 0);\n    K(this, \"addLineNum\", (t) => P(this, me, c(this, me) + t));\n    E(this, ce, []);\n    // FILOバッファ（push/pop）\n    E(this, cs, new uA());\n    K(this, \"firstWait\", () => {\n    });\n    E(this, Ro, {\n      //auth: // constructorで\n      //launch:\t// ここでは冒頭停止に間に合わないのでanalyzeInit()で\n      disconnect: () => {\n        P(Yr, ko, {}), P(Yr, fs, {}), this.isBreak = () => !1, c(this, Ro).continue({}), P(this, Ne, 0);\n      },\n      restart: () => this.isBreak = () => !1,\n      // ブレークポイント登録\n      add_break: (t) => O(this, Kf, ob).call(this, t.fn, t.o),\n      data_break: (t) => {\n        c(this, Ne) === 0 && (P(this, Ne, 1), this.main.setLoop(!1, `変数 ${t.dataId}【${t.old_v}】→【${t.new_v}】データブレーク`), this.sys.callHook(\"stopOnDataBreakpoint\", {}), this.sys.send2Dbg(\"stopOnDataBreakpoint\", {}));\n      },\n      set_func_break: (t) => {\n        P(Yr, fs, {});\n        for (const e of t.a)\n          c(Yr, fs)[e.name] = 1;\n        this.sys.send2Dbg(t.ri, {});\n      },\n      // 情報問い合わせ系\n      stack: (t) => this.sys.send2Dbg(t.ri, { a: O(this, xm, sP).call(this) }),\n      eval: (t) => {\n        this.sys.send2Dbg(t.ri, { v: this.prpPrs.parse(t.txt) });\n      },\n      // デバッガからの操作系\n      continue: () => {\n        O(this, Do, jh).call(this) || (P(this, yt, c(this, yt) - c(this, ia, Su)), P(this, Ne, 3), this.main.setLoop(!0), this.main.resume());\n      },\n      stepover: (t) => O(this, Jf, ub).call(this, t),\n      stepin: () => {\n        if (O(this, Do, jh).call(this))\n          return;\n        const t = c(this, qt).aToken[c(this, yt) - c(this, ia, Su)];\n        this.sys.callHook(`stopOnStep${c(this, Gl).test(t) ? \"In\" : \"\"}`, {}), P(this, yt, c(this, yt) - c(this, ia, Su)), P(this, Ne, c(this, Ne) === 1 ? 4 : 5), this.main.setLoop(!0), this.main.resume();\n      },\n      stepout: (t) => {\n        O(this, Do, jh).call(this) || (c(this, ce).length > 0 ? O(this, Qf, lb).call(this, !0) : O(this, Jf, ub).call(this, t));\n      },\n      pause: () => {\n        P(this, Ne, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnStep\", {});\n      },\n      stopOnEntry: () => {\n        P(this, Ne, 4), this.main.setLoop(!1, \"一時停止\"), this.sys.send2Dbg(\"stopOnEntry\", {});\n      }\n    });\n    E(this, ea, (t) => this.cfg.searchPath(t, vr.SCRIPT));\n    // https://regex101.com/r/Km54EK/1 141 steps (~0ms)\n    E(this, ra, (t) => (this.sys.pathBaseCnvSnPath4Dbg + c(this, ea).call(this, t)).replace(c(Yr, _m), `$1/prj/$2/${c(this, ie)}$3`));\n    K(this, \"cnvPath4Dbg\", (t) => this.sys.pathBaseCnvSnPath4Dbg + t.replace(\"/crypto_prj/\", \"/prj/\"));\n    E(this, td, 0);\n    E(this, Ne, 0);\n    // https://raw.githubusercontent.com/famibee/SKYNovel-vscode-extension/master/src/doc/BreakStateSMD.pu\n    K(this, \"isBreak\", (t) => !1);\n    // result = true : waitする  resume()で再開\n    E(this, ed, (t) => {\n    });\n    E(this, Fl, void 0);\n    E(this, ti, void 0);\n    E(this, Ao, () => {\n    });\n    E(this, Lo, () => {\n    });\n    E(this, rd, \"\");\n    E(this, id, {});\n    K(this, \"noticeBreak\", (t) => {\n    });\n    E(this, nd, 5);\n    //\t// 条件分岐\n    E(this, ei, [-1]);\n    E(this, od, \"\");\n    E(this, Fo, \"\");\n    // シナリオ解析処理ループ・冒頭処理\n    K(this, \"nextToken\", () => \"\");\n    E(this, ld, (t) => {\n    });\n    E(this, Rm, /(\\*{2,})([^\\|]*)/);\n    E(this, Dm, /\\[macro\\s/);\n    E(this, cd, /\\[endmacro[\\s\\]]/);\n    E(this, cr, /* @__PURE__ */ Object.create(null));\n    E(this, Am, /^\\[(call|loadplugin)\\s/);\n    E(this, Lm, /\\bfn\\s*=\\s*[^\\s\\]]+/);\n    E(this, vs, !1);\n    // マクロ定義の開始\n    E(this, jm, new RegExp(`[\"'#;\\\\]　]+`));\n    E(this, pd, \"call\");\n    E(this, Gl, /\\[(call)\\b/);\n    E(this, jl, !1);\n    // セーブポイント指定\n    E(this, zi, {\n      hSave: {},\n      hPages: {},\n      aIfStk: [-1]\n    });\n    E(this, Hi, []);\n    E(this, fr, -1);\n    this.cfg = t, this.hTag = e, this.main = r, this.val = n, this.alzTagArg = s, this.runAnalyze = a, this.prpPrs = o, this.sndMng = u, this.sys = l, e.let_ml = (d) => O(this, wm, aP).call(this, d), e.endlet_ml = () => !1, e.dump_stack = () => O(this, Em, oP).call(this), e.dump_script = (d) => O(this, Sm, uP).call(this, d), e.else = // その他ifブロック開始\n    e.elsif = // 別条件のifブロック開始\n    e.endif = () => O(this, Tm, lP).call(this), e.if = (d) => O(this, Cm, hP).call(this, d), e.call = (d) => O(this, Mm, cP).call(this, d), e.jump = (d) => O(this, Pm, fP).call(this, d), e.page = (d) => O(this, Om, dP).call(this, d), e.pop_stack = (d) => O(this, Im, pP).call(this, d), e.return = (d) => O(this, ad, cb).call(this, d), e.bracket2macro = (d) => O(this, Gm, _P).call(this, d), e.char2macro = (d) => O(this, Um, bP).call(this, d), e.endmacro = (d) => O(this, ad, cb).call(this, d), e.macro = (d) => O(this, zm, xP).call(this, d), e.load = (d) => O(this, Hm, wP).call(this, d), e.reload_script = (d) => O(this, $m, EP).call(this, d), e.record_place = () => O(this, Vm, SP).call(this), e.save = (d) => O(this, Xm, TP).call(this, d), t.oCfg.debug.token && P(this, ld, (d) => console.log(`🌱 トークン fn:${c(this, ie)} idx:${c(this, yt)} ln:${c(this, me)} token【${d}】`)), n.defTmp(\"const.sn.vctCallStk.length\", () => c(this, ce).length);\n    const h = t.oCfg.init.escape;\n    if (c(this, cs).setEscape(h), la.setEscape(h), Y.isDbg) {\n      l.addHook((f, p) => {\n        var v, g;\n        return (g = (v = c(this, Ro))[f]) == null ? void 0 : g.call(v, p);\n      }), this.isBreak = O(this, bm, nP);\n      const d = this.analyzeInit;\n      this.analyzeInit = () => {\n        this.analyzeInit = () => {\n        }, this.sys.send2Dbg(\"hi\", {});\n      }, c(this, Ro).auth = (f) => {\n        const p = f.hBreakpoint.hFn2hLineBP;\n        for (const [v, g] of Object.entries(p))\n          O(this, Kf, ob).call(this, v, g);\n        P(Yr, fs, {});\n        for (const v of f.hBreakpoint.aFunc)\n          c(Yr, fs)[v.name] = 1;\n        if (f.stopOnEntry) {\n          for (; ; ) {\n            let v = this.nextToken();\n            if (!v)\n              break;\n            const g = v.charCodeAt(0);\n            if (g === 91 || g === 38 || g === 42 && v.length === 1)\n              break;\n            g === 10 && P(this, me, c(this, me) + v.length);\n          }\n          this.sys.callHook(\"stopOnEntry\", {}), this.analyzeInit = d, this.analyzeInit();\n        } else\n          this.firstWait = () => {\n            this.sys.callHook(\"stopOnEntry\", {});\n          }, this.analyzeInit = d, this.analyzeInit();\n      };\n    } else\n      this.recodeDesign = () => {\n      };\n    t.oCfg.debug.tag && P(this, ed, (d) => console.log(`🌲 タグ解析 fn:${c(this, ie)} idx:${c(this, yt)} ln:${c(this, me)} [${d} %o]`, this.alzTagArg.hPrm));\n  }\n  get scriptFn() {\n    return c(this, ie);\n  }\n  subIdxToken() {\n    --Ve(this, yt)._;\n  }\n  get lineNum() {\n    return c(this, me);\n  }\n  destroy() {\n    this.isBreak = () => !1;\n  }\n  タグ解析(t) {\n    const [e, r] = Rp(t), n = this.hTag[e];\n    if (!n)\n      throw `未定義のタグ【${e}】です`;\n    this.alzTagArg.parse(r), c(this, ed).call(this, e);\n    const s = this.alzTagArg.hPrm;\n    if (s.cond) {\n      const u = s.cond.val;\n      if (!u || u.at(0) === \"&\")\n        throw \"属性condは「&」が不要です\";\n      const l = this.prpPrs.parse(u), h = String(l);\n      if (h === \"null\" || h === \"undefined\" || !l)\n        return !1;\n    }\n    let a = {};\n    const o = c(this, ce).length;\n    if (this.alzTagArg.isKomeParam) {\n      if (o === 0)\n        throw \"属性「*」はマクロのみ有効です\";\n      a = { ...c(this, ce)[c(this, ce).length - 1].csArg };\n    }\n    a[\":タグ名\"] = e;\n    for (const [u, { val: l, def: h }] of Object.entries(s)) {\n      let d = l;\n      if ((d == null ? void 0 : d.at(0)) === \"%\") {\n        if (o === 0)\n          throw \"属性「%」はマクロ定義内でのみ使用できます（そのマクロの引数を示す簡略文法であるため）\";\n        const f = c(this, ce)[c(this, ce).length - 1].csArg[d.slice(1)];\n        if (f) {\n          a[u] = f;\n          continue;\n        }\n        if (h === void 0 || h === \"null\")\n          continue;\n        d = h;\n      }\n      if (d = this.prpPrs.getValAmpersand(d ?? \"\"), d !== \"undefined\") {\n        a[u] = d;\n        continue;\n      }\n      h !== void 0 && (d = this.prpPrs.getValAmpersand(h), d !== \"undefined\" && (a[u] = d));\n    }\n    return n(a);\n  }\n  setOtherObj(t, e) {\n    P(this, Fl, t), P(this, ti, e);\n  }\n  dumpErrForeLine() {\n    if (c(this, yt) === 0) {\n      console.group(`🥟 Error line (from 0 rows before) fn:${c(this, ie)}`), console.groupEnd();\n      return;\n    }\n    let t = \"\";\n    for (let a = c(this, yt) - 1; a >= 0 && (t = c(this, qt).aToken[a] + t, !((t.match(/\\n/g) ?? []).length >= c(this, nd))); --a)\n      ;\n    const e = t.split(`\n`).slice(-c(this, nd)), r = e.length;\n    console.group(`🥟 Error line (from ${r} rows before) fn:${c(this, ie)}`);\n    const n = String(c(this, me)).length, s = O(this, ds, Ia).call(this, c(this, qt), c(this, yt));\n    for (let a = 0; a < r; ++a) {\n      const o = c(this, me) - r + a + 1, u = `${String(o).padStart(n, \" \")}: %c`, l = e[a], h = l.length > 75 ? l.slice(0, 75) + \"…\" : l;\n      a === r - 1 ? console.info(\n        u + h.slice(0, s.col_s) + \"%c\" + h.slice(s.col_s),\n        \"color: black; background-color: skyblue;\",\n        \"color: black; background-color: pink;\"\n      ) : console.info(u + h, \"color: black; background-color: skyblue;\");\n    }\n    console.groupEnd();\n  }\n  analyzeInit() {\n    const t = O(this, km, vP).call(this, c(this, qt), !!this.val.getVal(\"mp:const.sn.macro.name\"), c(this, me), c(this, Fo), c(this, yt));\n    P(this, yt, t.idx), P(this, me, t.ln), this.runAnalyze();\n  }\n  get isKidoku() {\n    return c(this, vs);\n  }\n  get isNextKidoku() {\n    let t = c(this, ie), e = c(this, yt), r = c(this, qt).len;\n    if (c(this, ce).length > 0) {\n      const s = c(this, ce)[0];\n      t = s.fn, e = s.idx;\n      const a = c(this, cr)[t];\n      a && (r = a.len);\n    }\n    const n = this.val.getAreaKidoku(t);\n    return !n || e === r ? !1 : n.search(e);\n  }\n  get normalWait() {\n    return c(this, vs) ? this.val.getVal(\"sys:sn.tagCh.doWait_Kidoku\") ? ni(this.val.getVal(\"sys:sn.tagCh.msecWait_Kidoku\")) : 0 : this.val.getVal(\"sys:sn.tagCh.doWait\") ? ni(this.val.getVal(\"sys:sn.tagCh.msecWait\")) : 0;\n  }\n  get skip4page() {\n    return c(this, jl);\n  }\n  recodePage() {\n    if (P(this, jl, !1), !this.val.getVal(\"save:sn.doRecLog\"))\n      return;\n    const { fn: t, idx: e } = O(this, zl, ev).call(this), r = e - 1, n = r + \":\" + t, s = c(this, Hi).findIndex((o) => o.key === n);\n    if (s > -1) {\n      P(this, fr, s);\n      return;\n    }\n    const a = {\n      key: n,\n      fn: t,\n      idx: r,\n      retFn: t,\n      retIdx: 0,\n      retMark: { ...c(this, zi) }\n    };\n    if (c(this, fr) >= 0) {\n      const o = c(this, Hi)[c(this, fr)];\n      a.retFn = o.fn, a.retIdx = o.idx + 1;\n    }\n    ++Ve(this, fr)._ === c(this, Hi).length ? c(this, Hi).push(a) : c(this, Hi)[c(this, fr)] = a;\n  }\n  recodeDesign(t) {\n    let e = \"\", r = 0;\n    const n = c(this, ce).length;\n    if (t.design_unit && n > 0) {\n      const o = c(this, ce)[0];\n      e = o.fn, r = o.idx;\n    } else\n      e = c(this, ie), r = c(this, yt);\n    t[\":path\"] = c(this, ra).call(this, e);\n    const s = O(this, ds, Ia).call(this, c(this, cr)[e], r);\n    t[\":ln\"] = s.ln, t[\":col_s\"] = s.col_s, t[\":col_e\"] = s.col_e;\n    const a = r - 1;\n    t[\":idx_tkn\"] = a, t[\":token\"] = c(this, cr)[e].aToken[a], this.sys.send2Dbg(\"_recodeDesign\", t);\n  }\n  replace(t, e) {\n    c(this, qt).aToken[t] = e;\n  }\n};\nlet Eu = Yr;\nqt = new WeakMap(), ie = new WeakMap(), yt = new WeakMap(), me = new WeakMap(), ce = new WeakMap(), cs = new WeakMap(), Kf = new WeakSet(), ob = function(t, e) {\n  c(Yr, ko)[c(this, ra).call(this, t)] = e;\n}, Ro = new WeakMap(), ea = new WeakMap(), _m = new WeakMap(), ra = new WeakMap(), Jf = new WeakSet(), ub = function(t) {\n  if (O(this, Do, jh).call(this))\n    return;\n  const e = c(this, qt).aToken[c(this, yt) - c(this, ia, Su)];\n  c(this, Gl).test(e) ? O(this, Qf, lb).call(this, !1) : (this.sys.callHook(\"stopOnStep\", {}), c(this, Ro).stepin(t));\n}, Qf = new WeakSet(), lb = function(t) {\n  this.sys.callHook(`stopOnStep${t ? \"Out\" : \"\"}`, {}), P(this, td, c(this, ce).length - (t ? 1 : 0)), P(this, yt, c(this, yt) - c(this, ia, Su)), P(this, Ne, t ? 7 : 6), this.main.setLoop(!0), this.main.resume();\n}, td = new WeakMap(), ia = new WeakSet(), Su = function() {\n  return c(this, Ne) === 2 || c(this, Ne) === 4 ? 1 : 0;\n}, Do = new WeakSet(), jh = function() {\n  return c(this, yt) < c(this, qt).len ? !1 : (this.sys.callHook(\"stopOnEntry\", {}), this.main.setLoop(!1, \"スクリプト終端です\"), !0);\n}, ko = new WeakMap(), fs = new WeakMap(), Ne = new WeakMap(), bm = new WeakSet(), nP = function(t) {\n  switch (c(this, Ne)) {\n    case 6:\n      O(this, No, zh).call(this), P(this, Ne, 7);\n      break;\n    case 7:\n      if (c(this, ce).length !== c(this, td))\n        break;\n      return P(this, Ne, 4), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 5:\n      O(this, No, zh).call(this), P(this, Ne, 4);\n      break;\n    case 4:\n      return O(this, No, zh).call(this), this.main.setLoop(!1, \"ステップ実行\"), this.sys.send2Dbg(\"stopOnStep\", {}), !0;\n    case 3:\n      O(this, No, zh).call(this), P(this, Ne, 0);\n      break;\n    default:\n      if (Dp(t) in c(Yr, fs))\n        return P(this, Ne, 2), this.main.setLoop(!1, `関数 ${t} ブレーク`), this.sys.callHook(\"stopOnBreakpoint\", {}), this.sys.send2Dbg(\"stopOnBreakpoint\", {}), !0;\n      {\n        const e = c(Yr, ko)[c(this, ra).call(this, c(this, ie))];\n        if (!e)\n          break;\n        const r = e[c(this, me)];\n        if (!r)\n          break;\n        if (r.condition) {\n          if (!this.prpPrs.parse(r.condition))\n            break;\n        } else if (\"hitCondition\" in r && --r.hitCondition > 0)\n          break;\n        const n = c(this, Ne) === 0;\n        P(this, Ne, 2), this.main.setLoop(!1, n ? (r.condition ? \"条件\" : \"ヒットカウント\") + \"ブレーク\" : \"ステップ実行\");\n        const s = n ? \"stopOnBreakpoint\" : \"stopOnStep\";\n        this.sys.callHook(s, {}), this.sys.send2Dbg(s, {});\n      }\n      return !0;\n  }\n  return !1;\n}, No = new WeakSet(), zh = function() {\n  var e;\n  const t = (e = c(Yr, ko)[Xh(c(this, ie))]) == null ? void 0 : e[c(this, me)];\n  t != null && t.hitCondition && --t.hitCondition;\n}, xm = new WeakSet(), sP = function() {\n  const t = c(this, Ne) === 3 ? 1 : 0, e = c(this, qt).aToken[c(this, yt) - 1 + t], r = c(this, ra).call(this, c(this, ie)), n = Dp(e), s = n ? `[${n}]` : e, a = this.val.getVal(\"mp:const.sn.macro\") ?? \"{}\";\n  if (c(this, yt) === 0)\n    return [{ fn: r, ln: 1, col: 1, nm: s, ma: a }];\n  const o = O(this, ds, Ia).call(this, c(this, qt), c(this, yt)), u = [{ fn: r, ln: o.ln, col: o.col_s + 1, nm: s, ma: a }], l = c(this, ce).length;\n  if (l === 0)\n    return u;\n  for (let h = l - 1; h >= 0; --h) {\n    const d = c(this, ce)[h], f = c(this, cr)[d.fn], p = f.aToken[d.idx - 1], v = O(this, ds, Ia).call(this, f, d.idx), g = Dp(p);\n    u.push({\n      fn: c(this, ra).call(this, d.fn),\n      ln: v.ln,\n      col: v.col_s + 1,\n      nm: g ? `[${g}]` : p,\n      ma: d.csArg[\":hMp\"][\"const.sn.macro\"] ?? \"{}\"\n    });\n  }\n  return u;\n}, ed = new WeakMap(), Fl = new WeakMap(), ti = new WeakMap(), wm = new WeakSet(), aP = function(t) {\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  let r = \"\";\n  const n = c(this, qt).len;\n  for (; c(this, yt) < n && (r = c(this, qt).aToken[c(this, yt)], r === \"\"); ++Ve(this, yt)._)\n    ;\n  return t.text = r, t.cast = \"str\", this.hTag.let(t), P(this, yt, c(this, yt) + 2), P(this, me, c(this, me) + (r.match(/\\n/g) ?? []).length), !1;\n}, Em = new WeakSet(), oP = function() {\n  if (c(this, yt) === 0)\n    return console.group(`🥟 [dump_stack] スクリプト現在地 fn:${c(this, ie)} line:1 col:0`), console.groupEnd(), !1;\n  const t = O(this, ds, Ia).call(this, c(this, qt), c(this, yt)), e = `スクリプト現在地 fn:${c(this, ie)} line:${t.ln} col:${t.col_s + 1}`;\n  console.group(`🥟 [dump_stack] ${e}`);\n  const r = c(this, ce).length;\n  if (r > 0) {\n    console.info(e);\n    for (let n = r - 1; n >= 0; --n) {\n      const s = c(this, ce)[n], a = s.csArg[\":hMp\"], o = a ? a[\":タグ名\"] : void 0, u = s.csArg[\":タグ名\"] ?? \"\", l = O(this, ds, Ia).call(this, c(this, cr)[s.fn], s.idx);\n      console.info(\n        `${r - n}つ前のコール元 fn:${s.fn} line:${l.ln} col:${l.col_s + 1}` + (o ? \"（[\" + o + \"]マクロ内）\" : \" \") + `で [${u} ...]をコール`\n      );\n    }\n  }\n  return console.groupEnd(), !1;\n}, ds = new WeakSet(), Ia = function(t, e) {\n  const r = { ln: 1, col_s: 0, col_e: 0 };\n  if (!t)\n    return r;\n  let n = e - 1;\n  const s = r.ln = t.aLNum[n];\n  for (; t.aLNum[n] === s; ) {\n    if (t.aToken[n].at(0) !== `\n`) {\n      const a = t.aToken[n].length;\n      r.col_e > 0 && (r.col_s += a), r.col_e += a;\n    }\n    if (--n < 0)\n      break;\n  }\n  return r;\n}, Sm = new WeakSet(), uP = function(t) {\n  const { set_fnc: e, break_fnc: r } = t;\n  if (!e)\n    throw \"set_fncは必須です\";\n  if (P(this, Ao, globalThis[e]), !c(this, Ao)) {\n    if (vt(t, \"need_err\", !0))\n      throw `HTML内に関数${e}が見つかりません`;\n    return P(this, Ao, () => {\n    }), !1;\n  }\n  if (this.noticeBreak = (n) => {\n    c(this, rd) !== c(this, ie) && (P(this, rd, c(this, ie)), c(this, Ao).call(this, c(this, id)[c(this, ie)] = c(this, id)[c(this, ie)] ?? c(this, qt).aToken.join(\"\"))), c(this, Lo).call(this, c(this, me), n);\n  }, this.noticeBreak(!0), !r)\n    return !1;\n  if (P(this, Lo, globalThis[r]), !c(this, Lo)) {\n    if (vt(t, \"need_err\", !0))\n      throw `HTML内に関数${r}が見つかりません`;\n    P(this, Lo, () => {\n    });\n  }\n  return !1;\n}, Ao = new WeakMap(), Lo = new WeakMap(), rd = new WeakMap(), id = new WeakMap(), nd = new WeakMap(), ei = new WeakMap(), Tm = new WeakSet(), lP = function() {\n  if (c(this, ei)[0] === -1)\n    throw \"ifブロック内ではありません\";\n  return P(this, yt, c(this, ei)[0]), c(this, ei).shift(), !1;\n}, Cm = new WeakSet(), hP = function(t) {\n  const { exp: e } = t;\n  if (!e)\n    throw \"expは必須です\";\n  if (e.at(0) === \"&\")\n    throw \"属性expは「&」が不要です\";\n  let r = 0, n = this.prpPrs.parse(e) ? c(this, yt) : -1;\n  const s = c(this, qt).aLNum[c(this, yt)];\n  let a = c(this, me) - (s || 0);\n  const o = c(this, qt).len;\n  for (; c(this, yt) < o; ++Ve(this, yt)._) {\n    const u = c(this, qt).aLNum[c(this, yt)];\n    c(this, qt).aLNum[c(this, yt)] = (u || 0) + a;\n    const l = c(this, qt).aToken[c(this, yt)];\n    if (!l)\n      continue;\n    const h = l.charCodeAt(0);\n    if (h === 10) {\n      P(this, me, c(this, me) + l.length);\n      continue;\n    }\n    if (h !== 91)\n      continue;\n    const [d, f] = Rp(l);\n    if (!(d in this.hTag))\n      throw `未定義のタグ[${d}]です`;\n    switch (this.alzTagArg.parse(f), d) {\n      case \"if\":\n        ++r;\n        break;\n      case \"elsif\":\n        if (r > 0 || n > -1)\n          break;\n        const p = this.alzTagArg.hPrm.exp.val;\n        if (p.at(0) === \"&\")\n          throw \"属性expは「&」が不要です\";\n        this.prpPrs.parse(p) && (n = c(this, yt) + 1);\n        break;\n      case \"else\":\n        if (r > 0)\n          break;\n        n === -1 && (n = c(this, yt) + 1);\n        break;\n      case \"endif\":\n        if (r > 0) {\n          --r;\n          break;\n        }\n        return n === -1 ? (++Ve(this, yt)._, c(this, qt).aLNum[c(this, yt)] += a) : (c(this, ei).unshift(c(this, yt) + 1), P(this, yt, n), P(this, me, c(this, qt).aLNum[c(this, yt)])), !1;\n    }\n  }\n  throw \"[endif]がないままスクリプト終端です\";\n}, Mm = new WeakSet(), cP = function(t) {\n  vt(t, \"count\", !1) || O(this, dd, vb).call(this);\n  const { fn: e } = t;\n  return e && c(this, ea).call(this, e), O(this, sd, hb).call(this, { \":hEvt1Time\": c(this, Fl).popLocalEvts(), \":hMp\": this.val.cloneMp() }), vt(t, \"clear_local_event\", !1) && this.hTag.clear_event({}), O(this, ps, Ra).call(this, e, t.label), !0;\n}, sd = new WeakSet(), hb = function(t) {\n  c(this, qt).aLNum[c(this, yt)] = c(this, me), c(this, od) || (t[\":resvToken\"] = \"\", O(this, Bo, Hh).call(this)), c(this, ce).push(new uE(c(this, ie), c(this, yt), t)), c(this, ei).unshift(-1);\n}, Pm = new WeakSet(), fP = function(t) {\n  return vt(t, \"count\", !0) || O(this, dd, vb).call(this), c(this, ei)[0] = -1, O(this, ps, Ra).call(this, t.fn, t.label), !0;\n}, Om = new WeakSet(), dP = function(t) {\n  if (c(this, fr) === -1)\n    return !1;\n  if (vt(t, \"clear\", !1))\n    return P(this, Hi, []), P(this, fr, -1), !1;\n  const { to: e } = t;\n  if (!e)\n    throw \"clearかtoは必須です\";\n  const r = c(this, fr);\n  switch (e) {\n    case \"prev\":\n      c(this, fr) > 0 && --Ve(this, fr)._;\n      break;\n    case \"next\":\n      const o = c(this, Hi).length;\n      c(this, fr) < o - 1 && ++Ve(this, fr)._;\n      break;\n    default:\n      throw `属性to「${e}」は異常です`;\n  }\n  if (r === c(this, fr))\n    return !1;\n  const n = c(this, Hi)[c(this, fr)], { fn: s, idx: a } = O(this, zl, ev).call(this);\n  return n.key === a + \":\" + s ? !1 : O(this, Ul, tv).call(this, { fn: n.retFn, index: n.retIdx }, n.retMark);\n}, Im = new WeakSet(), pP = function(t) {\n  if (vt(t, \"clear\", !1))\n    P(this, ce, []);\n  else if (!c(this, ce).pop())\n    throw \"[pop_stack] スタックが空です\";\n  return O(this, Bo, Hh).call(this), P(this, ei, [-1]), this.val.setMp({}), !1;\n}, ad = new WeakSet(), cb = function(t) {\n  const e = c(this, ce).pop();\n  if (!e)\n    throw \"[return] スタックが空です\";\n  const r = e.csArg;\n  c(this, ei).shift();\n  const n = r[\":hMp\"];\n  n && this.val.setMp(n);\n  const s = r[\":resvToken\"];\n  s ? this.nextToken = () => (O(this, Bo, Hh).call(this), s) : O(this, Bo, Hh).call(this), r[\":hEvt1Time\"] && c(this, Fl).pushLocalEvts(r[\":hEvt1Time\"]);\n  const { fn: a, label: o } = t;\n  return a || o ? (O(this, ps, Ra).call(this, a, o), !0) : e.fn in c(this, cr) ? (O(this, fd, pb).call(this, e), !1) : (O(this, ps, Ra).call(this, e.fn, \"\", e.idx), !0);\n}, od = new WeakMap(), Bo = new WeakSet(), Hh = function() {\n  P(this, od, \"\"), this.nextToken = O(this, ud, fb);\n}, Fo = new WeakMap(), ps = new WeakSet(), Ra = function(t = \"\", e = \"\", r = 0) {\n  if (!t && !e && this.main.errScript(\"[jump系] fnまたはlabelは必須です\"), e ? (e.at(0) !== \"*\" && this.main.errScript(\"[jump系] labelは*で始まります\"), P(this, Fo, e), c(this, Fo).slice(0, 2) !== \"**\" && P(this, yt, r)) : (P(this, Fo, \"\"), P(this, yt, r)), !t) {\n    this.analyzeInit();\n    return;\n  }\n  if (t.includes(\"@\"))\n    throw \"[jump系] fn には文字「@」は禁止です\";\n  const n = c(this, ea).call(this, t);\n  if (t === c(this, ie)) {\n    this.analyzeInit();\n    return;\n  }\n  P(this, ie, t);\n  const s = c(this, cr)[t];\n  if (s) {\n    P(this, qt, s), this.analyzeInit();\n    return;\n  }\n  const a = new ii();\n  let o = \"\";\n  try {\n    o = c(this, ea).call(this, t + \"@\"), a.add({ name: t + \":base\", url: n }), a.add({ name: t, url: o });\n  } catch {\n    a.add({ name: t, url: n });\n  }\n  a.use((u, l) => {\n    try {\n      u.data = this.sys.decStr(u.extension, u.data);\n    } catch (h) {\n      this.main.errScript(`[jump系]snロード失敗です fn:${u.name} ${h}`, !1);\n    }\n    l == null || l();\n  }).load((u, l) => {\n    if (o) {\n      const h = l[t + \":base\"].data, d = l[t].data, f = h.split(`\n`), p = d.split(`\n`), v = f.length, g = p.length;\n      for (let m = 0; m < g && m < v; ++m)\n        p[m] || (p[m] = f[m]);\n      l[t].data = p.join(`\n`), delete l[t + \":base\"];\n    }\n    this.nextToken = O(this, ud, fb), P(this, me, 1), O(this, Nm, gP).call(this, l[t].data), this.hTag.record_place({}), this.main.resume(() => this.analyzeInit());\n  }), this.main.stop();\n}, ud = new WeakSet(), fb = function() {\n  var e, r;\n  if (O(this, hd, db).call(this))\n    return \"\";\n  O(this, Fm, yP).call(this), (e = c(this, qt).aLNum)[r = c(this, yt)] || (e[r] = c(this, me));\n  const t = c(this, qt).aToken[c(this, yt)];\n  return c(this, ld).call(this, t), ++Ve(this, yt)._, t;\n}, ld = new WeakMap(), hd = new WeakSet(), db = function() {\n  return c(this, yt) < c(this, qt).len ? !1 : (this.main.errScript(\"スクリプト終端です\"), !0);\n}, Rm = new WeakMap(), Dm = new WeakMap(), cd = new WeakMap(), km = new WeakSet(), vP = function(t, e, r, n, s) {\n  var h, d;\n  const a = t.aToken.length;\n  if (!n) {\n    if (O(this, hd, db).call(this))\n      return { idx: s, ln: r };\n    if (t.aLNum[s])\n      r = t.aLNum[s];\n    else {\n      r = 1;\n      for (let f = 0; f < s; ++f) {\n        (h = t.aLNum)[f] || (h[f] = r);\n        const p = t.aToken[f];\n        p.charCodeAt(0) === 10 ? r += p.length : r += (p.match(/\\n/g) ?? []).length;\n      }\n      t.aLNum[s] = r;\n    }\n    return { idx: s, ln: r };\n  }\n  t.aLNum[0] = 1;\n  const o = n.match(c(this, Rm));\n  if (o) {\n    n = o[1];\n    let f = s;\n    switch (o[2]) {\n      case \"before\":\n        for (; t.aToken[--f] !== n; )\n          f === 0 && zt.myTrace(\"[jump系 無名ラベルbefore] \" + r + \"行目以前で\" + (e ? \"マクロ内に\" : \"\") + \"ラベル【\" + n + \"】がありません\", \"ET\"), e && t.aToken[f].search(c(this, Dm)) > -1 && zt.myTrace(\"[jump系 無名ラベルbefore] マクロ内にラベル【\" + n + \"】がありません\", \"ET\");\n        return { idx: f + 1, ln: t.aLNum[f] };\n      case \"after\":\n        for (; t.aToken[++f] !== n; )\n          f === a && zt.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + n + \"】がありません\", \"ET\"), t.aToken[f].search(c(this, cd)) > -1 && zt.myTrace(\"[jump系 無名ラベルafter] \" + r + \"行目以後でマクロ内にラベル【\" + n + \"】がありません\", \"ET\");\n        return { idx: f + 1, ln: t.aLNum[f] };\n      default:\n        zt.myTrace(\"[jump系] 無名ラベル指定【label=\" + n + \"】が間違っています\", \"ET\");\n    }\n  }\n  r = 1;\n  const u = new RegExp(\n    \"^\" + n.replaceAll(\"*\", \"\\\\*\") + \"(?=\\\\s|;|\\\\[|\\\\||$)\"\n  );\n  let l = !1;\n  for (let f = 0; f < a; ++f) {\n    (d = t.aLNum)[f] || (d[f] = r);\n    const p = t.aToken[f];\n    if (l) {\n      c(this, cs).testTagEndLetml(p) ? l = !1 : r += (p.match(/\\n/g) ?? []).length;\n      continue;\n    }\n    const v = p.charCodeAt(0);\n    if (v === 10) {\n      r += p.length;\n      continue;\n    }\n    if (v === 42) {\n      if (p.search(u) > -1)\n        return { idx: f + 1, ln: r };\n      continue;\n    }\n    v === 91 && (r += (p.match(/\\n/g) ?? []).length, c(this, cs).testTagLetml(p) && (l = !0));\n  }\n  throw l ? \"[let_ml]の終端・[endlet_ml]がありません\" : (zt.myTrace(`[jump系] ラベル【${n}】がありません`, \"ET\"), \"Dummy\");\n}, cr = new WeakMap(), Nm = new WeakSet(), gP = function(t) {\n  let e = \"\";\n  try {\n    e = \"ScriptIterator.resolveScript\";\n    const r = c(this, cs).resolveScript(t);\n    e = \"ScriptIterator.replaceScript_Wildcard\", O(this, Bm, mP).call(this, r), c(this, cr)[c(this, ie)] = P(this, qt, r);\n  } catch (r) {\n    r instanceof Error ? e += `例外 mes=${r.message}(${r.name})` : e = r, this.main.errScript(e, !1);\n  }\n  this.val.loadScrWork(c(this, ie));\n}, fd = new WeakSet(), pb = function(t) {\n  P(this, ie, t.fn), P(this, yt, t.idx);\n  const e = c(this, cr)[c(this, ie)];\n  e && P(this, qt, e), P(this, me, c(this, qt).aLNum[t.idx]);\n}, Am = new WeakMap(), Lm = new WeakMap(), Bm = new WeakSet(), mP = function(t) {\n  for (let e = t.len - 1; e >= 0; --e) {\n    const r = t.aToken[e];\n    if (!c(this, Am).test(r))\n      continue;\n    const [n, s] = Rp(r);\n    this.alzTagArg.parse(s);\n    const a = this.alzTagArg.hPrm.fn;\n    if (!a)\n      continue;\n    const { val: o } = a;\n    if (!o || o.at(-1) !== \"*\")\n      continue;\n    t.aToken.splice(e, 1, \"\t\", \"; \" + r), t.aLNum.splice(e, 1, NaN, NaN);\n    const u = n === \"loadplugin\" ? vr.CSS : vr.SN, l = this.cfg.matchPath(\"^\" + o.slice(0, -1) + \".*\", u);\n    for (const h of l) {\n      const d = r.replace(\n        c(this, Lm),\n        \"fn=\" + decodeURIComponent(Xh(h[u]))\n      );\n      t.aToken.splice(e, 0, d), t.aLNum.splice(e, 0, NaN);\n    }\n  }\n  t.len = t.aToken.length;\n}, Fm = new WeakSet(), yP = function() {\n  const t = this.val.getAreaKidoku(c(this, ie));\n  if (!t)\n    throw `recordKidoku fn:'${c(this, ie)}' (areas === null)`;\n  if (c(this, ce).length > 0) {\n    t.record(c(this, yt));\n    return;\n  }\n  P(this, vs, t.search(c(this, yt))), this.val.setVal_Nochk(\"tmp\", \"const.sn.isKidoku\", c(this, vs)), !c(this, vs) && t.record(c(this, yt));\n}, vs = new WeakMap(), dd = new WeakSet(), vb = function() {\n  var t;\n  (t = this.val.getAreaKidoku(c(this, ie))) == null || t.erase(c(this, yt)), P(this, vs, !1);\n}, Gm = new WeakSet(), _P = function(t) {\n  return c(this, cs).bracket2macro(t, this.hTag, c(this, qt), c(this, yt)), !1;\n}, Um = new WeakSet(), bP = function(t) {\n  return c(this, cs).char2macro(t, this.hTag, c(this, qt), c(this, yt)), !1;\n}, jm = new WeakMap(), zm = new WeakSet(), xP = function(t) {\n  var s, a;\n  const { name: e } = t;\n  if (!e)\n    throw \"nameは必須です\";\n  if (e in this.hTag)\n    throw `[${e}]はタグかすでに定義済みのマクロです`;\n  if (c(this, jm).test(e))\n    throw `[${e}]はマクロ名として異常です`;\n  const r = c(this, me), n = new uE(c(this, ie), c(this, yt));\n  for (P(this, pd, c(this, pd) + (\"|\" + e)), P(this, Gl, new RegExp(`\\\\[(${c(this, pd)})\\\\b`)), this.hTag[e] = (o) => (o.design_unit = t.design_unit, O(this, sd, hb).call(this, { ...o, \":hMp\": this.val.cloneMp() }), this.val.setMp(o), this.val.setVal_Nochk(\"mp\", \"const.sn.macro\", JSON.stringify(t)), this.val.setVal_Nochk(\"mp\", \"const.sn.me_call_scriptFn\", c(this, ie)), P(this, me, r), O(this, fd, pb).call(this, n), !1); c(this, yt) < c(this, qt).len; ++Ve(this, yt)._) {\n    (s = c(this, qt).aLNum)[a = c(this, yt)] || (s[a] = c(this, me));\n    const o = c(this, qt).aToken[c(this, yt)];\n    if (o.search(c(this, cd)) > -1)\n      return ++Ve(this, yt)._, !1;\n    const u = o.charCodeAt(0);\n    u === 10 ? P(this, me, c(this, me) + o.length) : u === 91 && P(this, me, c(this, me) + (o.match(/\\n/g) ?? []).length);\n  }\n  throw `マクロ[${e}]定義の終端・[endmacro]がありません`;\n}, pd = new WeakMap(), Gl = new WeakMap(), Hm = new WeakSet(), wP = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  if (\"fn\" in t != \"label\" in t)\n    throw \"fnとlabelはセットで指定して下さい\";\n  const r = this.val.getMark(e);\n  if (!r)\n    throw `place【${e}】は存在しません`;\n  return O(this, Ul, tv).call(this, t, r);\n}, Ul = new WeakSet(), tv = function(t, e, r = !0) {\n  this.hTag.clear_event({}), this.val.mark2save(e), this.val.setMp({}), c(this, ti).recPagebreak(), r && this.sndMng.playLoopFromSaveObj(), vt(t, \"do_rec\", !0) && P(this, zi, {\n    hSave: this.val.cloneSave(),\n    hPages: { ...e.hPages },\n    aIfStk: [...e.aIfStk]\n  });\n  const n = {\n    enabled: this.val.getVal(\"save:const.sn.autowc.enabled\"),\n    text: this.val.getVal(\"save:const.sn.autowc.text\"),\n    time: Number(this.val.getVal(\"save:const.sn.autowc.time\"))\n  };\n  this.hTag.autowc(n);\n  const s = String(this.val.getVal(\"save:const.sn.scriptFn\")), a = Number(this.val.getVal(\"save:const.sn.scriptIdx\"));\n  return P(this, ei, [...c(this, zi).aIfStk]), P(this, ce, []), c(this, ti).cover(!0), c(this, ti).stopAllTw(), \"index\" in t ? (c(this, ti).playback(c(this, zi).hPages, () => {\n    c(this, ti).cover(!1), P(this, jl, !0), O(this, ps, Ra).call(this, t.fn ?? s, \"\", t.index ?? a);\n  }), !0) : (delete c(this, cr)[s], c(this, ti).playback(\n    c(this, zi).hPages,\n    \"label\" in t ? () => {\n      c(this, ti).cover(!1), P(this, ie, s), P(this, yt, a), this.hTag.call({ fn: t.fn, label: t.label });\n    } : () => {\n      c(this, ti).cover(!1), O(this, ps, Ra).call(this, s, \"\", a);\n    }\n  ), !0);\n}, jl = new WeakMap(), $m = new WeakSet(), EP = function(t) {\n  const e = this.val.getMark(0);\n  delete c(this, cr)[Xh(e.hSave[\"const.sn.scriptFn\"])];\n  const r = {};\n  for (const n in c(this, cr))\n    try {\n      c(this, ea).call(this, n + \"@\");\n    } catch {\n      r[n] = c(this, cr)[n];\n    }\n  return P(this, cr, r), t.do_rec = !1, O(this, Ul, tv).call(this, t, e, !1);\n}, zi = new WeakMap(), Vm = new WeakSet(), SP = function() {\n  if (this.main.isDestroyed())\n    return !1;\n  const { fn: t, idx: e } = O(this, zl, ev).call(this);\n  return this.val.setVal_Nochk(\"save\", \"const.sn.scriptFn\", t), this.val.setVal_Nochk(\"save\", \"const.sn.scriptIdx\", e), P(this, zi, {\n    hSave: this.val.cloneSave(),\n    hPages: c(this, ti).record(),\n    aIfStk: c(this, ei).slice(c(this, ce).length)\n  }), !1;\n}, zl = new WeakSet(), ev = function() {\n  if (c(this, ce).length === 0)\n    return {\n      fn: c(this, ie),\n      idx: c(this, yt)\n    };\n  const e = c(this, ce)[0];\n  return {\n    fn: e.fn,\n    idx: e.idx\n  };\n}, Xm = new WeakSet(), TP = function(t) {\n  if (!(\"place\" in t))\n    throw \"placeは必須です\";\n  const e = Number(t.place);\n  delete t[\":タグ名\"], delete t.place, t.text = (t.text ?? \"\").replace(/^(<br\\/>)+/, \"\"), c(this, zi).json = t, this.val.setMark(e, c(this, zi));\n  const r = Number(this.val.getVal(\"sys:const.sn.save.place\"));\n  return e === r && this.val.setVal_Nochk(\"sys\", \"const.sn.save.place\", r + 1), !1;\n}, Hi = new WeakMap(), fr = new WeakMap(), E(Eu, _m, /(.+)\\/crypto_prj\\/([^\\/]+)\\/[^\\.]+(\\.\\w+)/), // reload 再生成 Main に受け渡すため static\nE(Eu, ko, {}), E(Eu, fs, {});\nvar Br, xi, yr, wi, gs, Go, dr, vd, ms, Hl, Uo, gd, md, $l, Wm, CP, yd, _d, Vl, Xl, rv, jo, zo;\nconst Au = class {\n  constructor(t) {\n    E(this, Wm);\n    E(this, Xl);\n    E(this, Br, void 0);\n    E(this, xi, void 0);\n    E(this, yr, /* @__PURE__ */ Object.create(null));\n    // タグ処理辞書\n    E(this, wi, void 0);\n    E(this, gs, void 0);\n    E(this, Go, void 0);\n    E(this, dr, void 0);\n    E(this, vd, void 0);\n    E(this, ms, void 0);\n    E(this, Hl, void 0);\n    E(this, Uo, () => {\n    });\n    E(this, gd, new lA());\n    E(this, md, !1);\n    E(this, $l, \"skynovel\");\n    E(this, yd, () => c(this, Uo).call(this));\n    // メイン処理（シナリオ解析）\n    E(this, _d, (t = O(this, Xl, rv)) => {\n      c(this, jo) || (c(this, ms).clearBreak(), P(this, Uo, t), this.resume = (e = O(this, Xl, rv)) => {\n        P(this, Uo, e);\n      }, c(this, dr).noticeBreak(!1));\n    });\n    K(this, \"resume\", c(this, _d));\n    K(this, \"stop\", () => {\n      P(this, Uo, () => {\n      }), this.resume = c(this, _d), c(this, dr).noticeBreak(!0);\n    });\n    E(this, Vl, !0);\n    E(this, jo, !1);\n    K(this, \"isDestroyed\", () => c(this, jo));\n    E(this, zo, void 0);\n    this.sys = t, LO(), rx.generate(t).then((e) => P(this, Br, e)).then(() => O(this, Wm, CP).call(this)).catch((e) => console.error(\"load err fn:prj.json e:%o\", e));\n  }\n  // thisの扱いによりメソッド代入はダメ\n  errScript(t, e = !0) {\n    if (this.stop(), zt.myTrace(t), Y.debugLog && console.log(\"🍜 SKYNovel err!\"), e)\n      throw t;\n  }\n  resumeByJumpOrCall(t) {\n    if (t.url) {\n      globalThis.open(t.url);\n      return;\n    }\n    c(this, wi).setVal_Nochk(\"tmp\", \"sn.eventArg\", t.arg ?? \"\"), c(this, wi).setVal_Nochk(\"tmp\", \"sn.eventLabel\", t.label ?? \"\"), vt(t, \"call\", !1) ? (c(this, dr).subIdxToken(), this.resume(() => c(this, yr).call(t))) : (c(this, yr).clear_event({}), this.resume(() => c(this, yr).jump(t)));\n  }\n  setLoop(t, e = \"\") {\n    P(this, Vl, t) ? this.resume() : this.stop(), this.sys.setTitleInfo(e ? ` -- ${e}中` : \"\");\n  }\n  fire(t, e) {\n    c(this, Hl).fire(t, e);\n  }\n  async destroy(t = 0) {\n    c(this, jo) || (P(this, jo, !0), c(this, md) && (this.stop(), P(this, Vl, !1), c(this, ms).before_destroy(), t > 0 && await new Promise((e) => setTimeout(e, t)), P(this, yr, {}), c(this, Hl).destroy(), c(this, dr).destroy(), c(this, ms).destroy(), c(this, vd).destroy(), c(this, xi).ticker.remove(c(this, yd)), c(this, zo) && c(this, xi) && Au.cvs.parentNode.appendChild(c(this, zo)), LE(), c(this, xi).destroy(!0), this.sys.destroy()));\n  }\n};\nlet Ur = Au;\nBr = new WeakMap(), xi = new WeakMap(), yr = new WeakMap(), wi = new WeakMap(), gs = new WeakMap(), Go = new WeakMap(), dr = new WeakMap(), vd = new WeakMap(), ms = new WeakMap(), Hl = new WeakMap(), Uo = new WeakMap(), gd = new WeakMap(), md = new WeakMap(), $l = new WeakMap(), Wm = new WeakSet(), CP = async function() {\n  var n;\n  const t = (n = document.createElement(\"canvas\")) == null ? void 0 : n.getContext(\"2d\");\n  if (!t)\n    throw \"argChk_Color err\";\n  Y.cc4ColorName = t;\n  const e = {\n    width: c(this, Br).oCfg.window.width,\n    height: c(this, Br).oCfg.window.height,\n    backgroundColor: xb(String(c(this, Br).oCfg.init.bg_color)),\n    // このString()は後方互換性のため必須\n    //\tresolution\t\t: sys.resolution,\n    resolution: globalThis.devicePixelRatio ?? 1\n    // 理想\n  }, r = document.getElementById(c(this, $l));\n  r && (P(this, zo, r.cloneNode(!0)), c(this, zo).id = c(this, $l), e.view = r), P(this, xi, new CS(e)), Au.cvs = c(this, xi).view, r || (document.body.appendChild(Au.cvs), Au.cvs.id = c(this, $l)), P(this, wi, new Ap(c(this, Br), c(this, yr))), P(this, gs, new Fa(c(this, wi), c(this, Br).oCfg.init.escape ?? \"\\\\\")), await Promise.allSettled(this.sys.init(c(this, yr), c(this, xi), c(this, wi), this)), c(this, yr).title({ text: c(this, Br).oCfg.book.title || \"SKYNovel\" }), P(this, Go, new Gp(c(this, Br), c(this, yr), c(this, wi), this, this.sys)), P(this, dr, new Eu(c(this, Br), c(this, yr), this, c(this, wi), c(this, gd), () => O(this, Xl, rv).call(this), c(this, gs), c(this, Go), this.sys)), P(this, vd, new zt(this.sys, c(this, yr), c(this, dr))), P(this, ms, new Ua(c(this, Br), c(this, yr), c(this, xi), c(this, wi), this, c(this, dr), this.sys, c(this, Go), c(this, gd), c(this, gs))), P(this, Hl, new r4(c(this, Br), c(this, yr), c(this, xi), this, c(this, ms), c(this, wi), c(this, Go), c(this, dr), this.sys)), c(this, xi).ticker.add(c(this, yd)), this.resumeByJumpOrCall({ fn: \"main\" }), P(this, md, !0);\n}, yd = new WeakMap(), _d = new WeakMap(), Vl = new WeakMap(), Xl = new WeakSet(), rv = function() {\n  for (; c(this, Vl); ) {\n    let t = c(this, dr).nextToken();\n    if (!t)\n      break;\n    const e = t.charCodeAt(0);\n    if (e !== 9) {\n      if (e === 10) {\n        c(this, dr).addLineNum(t.length);\n        continue;\n      }\n      if (e === 91) {\n        if (c(this, dr).isBreak(t))\n          return;\n        try {\n          const r = (t.match(/\\n/g) ?? []).length;\n          if (r > 0 && c(this, dr).addLineNum(r), c(this, dr).タグ解析(t)) {\n            this.stop();\n            break;\n          }\n          continue;\n        } catch (r) {\n          r instanceof Error ? this.errScript(`[${Dp(t)}]タグ解析中例外 mes=${r.message}(${r.name})`, !1) : this.errScript(String(r), !1);\n          return;\n        }\n      }\n      if (e === 38)\n        try {\n          if (t.at(-1) !== \"&\") {\n            if (c(this, dr).isBreak(t))\n              return;\n            const r = oA(t.slice(1));\n            r.name = c(this, gs).getValAmpersand(r.name), r.text = String(c(this, gs).parse(r.text)), c(this, yr).let(r);\n            continue;\n          }\n          if (t.charAt(1) === \"&\")\n            throw new Error(\"「&表示&」書式では「&」指定が不要です\");\n          t = String(c(this, gs).parse(t.slice(1, -1)));\n        } catch (r) {\n          this.errScript(\n            r instanceof Error ? `& 変数操作・表示 mes=${r.message}(${r.name})` : r,\n            !1\n          );\n          return;\n        }\n      else {\n        if (e === 59)\n          continue;\n        if (e === 42 && t.length > 1)\n          continue;\n      }\n      try {\n        c(this, ms).currentTxtlayForeNeedErr.tagCh(t);\n      } catch (r) {\n        this.errScript(\n          r instanceof Error ? `文字表示 mes=${r.message}(${r.name})` : r,\n          !1\n        );\n        return;\n      }\n    }\n  }\n}, jo = new WeakMap(), zo = new WeakMap(), K(Ur, \"cvs\");\nconst Fn = /* @__PURE__ */ Object.create(null);\nFn.open = \"0\";\nFn.close = \"1\";\nFn.ping = \"2\";\nFn.pong = \"3\";\nFn.message = \"4\";\nFn.upgrade = \"5\";\nFn.noop = \"6\";\nconst iv = /* @__PURE__ */ Object.create(null);\nObject.keys(Fn).forEach((i) => {\n  iv[Fn[i]] = i;\n});\nconst i4 = { type: \"error\", data: \"parser error\" }, n4 = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", s4 = typeof ArrayBuffer == \"function\", a4 = (i) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer, MP = ({ type: i, data: t }, e, r) => n4 && t instanceof Blob ? e ? r(t) : lE(t, r) : s4 && (t instanceof ArrayBuffer || a4(t)) ? e ? r(t) : lE(new Blob([t]), r) : r(Fn[i] + (t || \"\")), lE = (i, t) => {\n  const e = new FileReader();\n  return e.onload = function() {\n    const r = e.result.split(\",\")[1];\n    t(\"b\" + (r || \"\"));\n  }, e.readAsDataURL(i);\n}, hE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", $h = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let i = 0; i < hE.length; i++)\n  $h[hE.charCodeAt(i)] = i;\nconst o4 = (i) => {\n  let t = i.length * 0.75, e = i.length, r, n = 0, s, a, o, u;\n  i[i.length - 1] === \"=\" && (t--, i[i.length - 2] === \"=\" && t--);\n  const l = new ArrayBuffer(t), h = new Uint8Array(l);\n  for (r = 0; r < e; r += 4)\n    s = $h[i.charCodeAt(r)], a = $h[i.charCodeAt(r + 1)], o = $h[i.charCodeAt(r + 2)], u = $h[i.charCodeAt(r + 3)], h[n++] = s << 2 | a >> 4, h[n++] = (a & 15) << 4 | o >> 2, h[n++] = (o & 3) << 6 | u & 63;\n  return l;\n}, u4 = typeof ArrayBuffer == \"function\", PP = (i, t) => {\n  if (typeof i != \"string\")\n    return {\n      type: \"message\",\n      data: OP(i, t)\n    };\n  const e = i.charAt(0);\n  return e === \"b\" ? {\n    type: \"message\",\n    data: l4(i.substring(1), t)\n  } : iv[e] ? i.length > 1 ? {\n    type: iv[e],\n    data: i.substring(1)\n  } : {\n    type: iv[e]\n  } : i4;\n}, l4 = (i, t) => {\n  if (u4) {\n    const e = o4(i);\n    return OP(e, t);\n  } else\n    return { base64: !0, data: i };\n}, OP = (i, t) => {\n  switch (t) {\n    case \"blob\":\n      return i instanceof ArrayBuffer ? new Blob([i]) : i;\n    case \"arraybuffer\":\n    default:\n      return i;\n  }\n}, IP = String.fromCharCode(30), h4 = (i, t) => {\n  const e = i.length, r = new Array(e);\n  let n = 0;\n  i.forEach((s, a) => {\n    MP(s, !1, (o) => {\n      r[a] = o, ++n === e && t(r.join(IP));\n    });\n  });\n}, c4 = (i, t) => {\n  const e = i.split(IP), r = [];\n  for (let n = 0; n < e.length; n++) {\n    const s = PP(e[n], t);\n    if (r.push(s), s.type === \"error\")\n      break;\n  }\n  return r;\n}, RP = 4;\nfunction Qe(i) {\n  if (i)\n    return f4(i);\n}\nfunction f4(i) {\n  for (var t in Qe.prototype)\n    i[t] = Qe.prototype[t];\n  return i;\n}\nQe.prototype.on = Qe.prototype.addEventListener = function(i, t) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + i] = this._callbacks[\"$\" + i] || []).push(t), this;\n};\nQe.prototype.once = function(i, t) {\n  function e() {\n    this.off(i, e), t.apply(this, arguments);\n  }\n  return e.fn = t, this.on(i, e), this;\n};\nQe.prototype.off = Qe.prototype.removeListener = Qe.prototype.removeAllListeners = Qe.prototype.removeEventListener = function(i, t) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var e = this._callbacks[\"$\" + i];\n  if (!e)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + i], this;\n  for (var r, n = 0; n < e.length; n++)\n    if (r = e[n], r === t || r.fn === t) {\n      e.splice(n, 1);\n      break;\n    }\n  return e.length === 0 && delete this._callbacks[\"$\" + i], this;\n};\nQe.prototype.emit = function(i) {\n  this._callbacks = this._callbacks || {};\n  for (var t = new Array(arguments.length - 1), e = this._callbacks[\"$\" + i], r = 1; r < arguments.length; r++)\n    t[r - 1] = arguments[r];\n  if (e) {\n    e = e.slice(0);\n    for (var r = 0, n = e.length; r < n; ++r)\n      e[r].apply(this, t);\n  }\n  return this;\n};\nQe.prototype.emitReserved = Qe.prototype.emit;\nQe.prototype.listeners = function(i) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + i] || [];\n};\nQe.prototype.hasListeners = function(i) {\n  return !!this.listeners(i).length;\n};\nconst Ei = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction DP(i, ...t) {\n  return t.reduce((e, r) => (i.hasOwnProperty(r) && (e[r] = i[r]), e), {});\n}\nconst d4 = Ei.setTimeout, p4 = Ei.clearTimeout;\nfunction x0(i, t) {\n  t.useNativeTimers ? (i.setTimeoutFn = d4.bind(Ei), i.clearTimeoutFn = p4.bind(Ei)) : (i.setTimeoutFn = Ei.setTimeout.bind(Ei), i.clearTimeoutFn = Ei.clearTimeout.bind(Ei));\n}\nconst v4 = 1.33;\nfunction g4(i) {\n  return typeof i == \"string\" ? m4(i) : Math.ceil((i.byteLength || i.size) * v4);\n}\nfunction m4(i) {\n  let t = 0, e = 0;\n  for (let r = 0, n = i.length; r < n; r++)\n    t = i.charCodeAt(r), t < 128 ? e += 1 : t < 2048 ? e += 2 : t < 55296 || t >= 57344 ? e += 3 : (r++, e += 4);\n  return e;\n}\nclass y4 extends Error {\n  constructor(t, e, r) {\n    super(t), this.description = e, this.context = r, this.type = \"TransportError\";\n  }\n}\nclass kP extends Qe {\n  /**\n   * Transport abstract constructor.\n   *\n   * @param {Object} opts - options\n   * @protected\n   */\n  constructor(t) {\n    super(), this.writable = !1, x0(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;\n  }\n  /**\n   * Emits an error.\n   *\n   * @param {String} reason\n   * @param description\n   * @param context - the error context\n   * @return {Transport} for chaining\n   * @protected\n   */\n  onError(t, e, r) {\n    return super.emitReserved(\"error\", new y4(t, e, r)), this;\n  }\n  /**\n   * Opens the transport.\n   */\n  open() {\n    return this.readyState = \"opening\", this.doOpen(), this;\n  }\n  /**\n   * Closes the transport.\n   */\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  /**\n   * Sends multiple packets.\n   *\n   * @param {Array} packets\n   */\n  send(t) {\n    this.readyState === \"open\" && this.write(t);\n  }\n  /**\n   * Called upon open\n   *\n   * @protected\n   */\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  /**\n   * Called with data.\n   *\n   * @param {String} data\n   * @protected\n   */\n  onData(t) {\n    const e = PP(t, this.socket.binaryType);\n    this.onPacket(e);\n  }\n  /**\n   * Called with a decoded packet.\n   *\n   * @protected\n   */\n  onPacket(t) {\n    super.emitReserved(\"packet\", t);\n  }\n  /**\n   * Called upon close.\n   *\n   * @protected\n   */\n  onClose(t) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", t);\n  }\n  /**\n   * Pauses the transport, in order not to lose packets during an upgrade.\n   *\n   * @param onPause\n   */\n  pause(t) {\n  }\n}\nconst NP = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), gb = 64, _4 = {};\nlet cE = 0, Sp = 0, fE;\nfunction dE(i) {\n  let t = \"\";\n  do\n    t = NP[i % gb] + t, i = Math.floor(i / gb);\n  while (i > 0);\n  return t;\n}\nfunction AP() {\n  const i = dE(+/* @__PURE__ */ new Date());\n  return i !== fE ? (cE = 0, fE = i) : i + \".\" + dE(cE++);\n}\nfor (; Sp < gb; Sp++)\n  _4[NP[Sp]] = Sp;\nfunction LP(i) {\n  let t = \"\";\n  for (let e in i)\n    i.hasOwnProperty(e) && (t.length && (t += \"&\"), t += encodeURIComponent(e) + \"=\" + encodeURIComponent(i[e]));\n  return t;\n}\nfunction b4(i) {\n  let t = {}, e = i.split(\"&\");\n  for (let r = 0, n = e.length; r < n; r++) {\n    let s = e[r].split(\"=\");\n    t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]);\n  }\n  return t;\n}\nlet BP = !1;\ntry {\n  BP = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst x4 = BP;\nfunction FP(i) {\n  const t = i.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!t || x4))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!t)\n    try {\n      return new Ei[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction w4() {\n}\nconst E4 = function() {\n  return new FP({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass S4 extends kP {\n  /**\n   * XHR Polling constructor.\n   *\n   * @param {Object} opts\n   * @package\n   */\n  constructor(t) {\n    if (super(t), this.polling = !1, typeof location < \"u\") {\n      const r = location.protocol === \"https:\";\n      let n = location.port;\n      n || (n = r ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && t.hostname !== location.hostname || n !== t.port, this.xs = t.secure !== r;\n    }\n    const e = t && t.forceBase64;\n    this.supportsBinary = E4 && !e;\n  }\n  get name() {\n    return \"polling\";\n  }\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @protected\n   */\n  doOpen() {\n    this.poll();\n  }\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n   * @package\n   */\n  pause(t) {\n    this.readyState = \"pausing\";\n    const e = () => {\n      this.readyState = \"paused\", t();\n    };\n    if (this.polling || !this.writable) {\n      let r = 0;\n      this.polling && (r++, this.once(\"pollComplete\", function() {\n        --r || e();\n      })), this.writable || (r++, this.once(\"drain\", function() {\n        --r || e();\n      }));\n    } else\n      e();\n  }\n  /**\n   * Starts polling cycle.\n   *\n   * @private\n   */\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @protected\n   */\n  onData(t) {\n    const e = (r) => {\n      if (this.readyState === \"opening\" && r.type === \"open\" && this.onOpen(), r.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(r);\n    };\n    c4(t, this.socket.binaryType).forEach(e), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  /**\n   * For polling, send a close packet.\n   *\n   * @protected\n   */\n  doClose() {\n    const t = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? t() : this.once(\"open\", t);\n  }\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} packets - data packets\n   * @protected\n   */\n  write(t) {\n    this.writable = !1, h4(t, (e) => {\n      this.doWrite(e, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @private\n   */\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"https\" : \"http\";\n    let r = \"\";\n    this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = AP()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.opts.port && (e === \"https\" && Number(this.opts.port) !== 443 || e === \"http\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port);\n    const n = LP(t), s = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (s ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (n.length ? \"?\" + n : \"\");\n  }\n  /**\n   * Creates a request.\n   *\n   * @param {String} method\n   * @private\n   */\n  request(t = {}) {\n    return Object.assign(t, { xd: this.xd, xs: this.xs }, this.opts), new Rn(this.uri(), t);\n  }\n  /**\n   * Sends data.\n   *\n   * @param {String} data to send.\n   * @param {Function} called upon flush.\n   * @private\n   */\n  doWrite(t, e) {\n    const r = this.request({\n      method: \"POST\",\n      data: t\n    });\n    r.on(\"success\", e), r.on(\"error\", (n, s) => {\n      this.onError(\"xhr post error\", n, s);\n    });\n  }\n  /**\n   * Starts a poll cycle.\n   *\n   * @private\n   */\n  doPoll() {\n    const t = this.request();\n    t.on(\"data\", this.onData.bind(this)), t.on(\"error\", (e, r) => {\n      this.onError(\"xhr poll error\", e, r);\n    }), this.pollXhr = t;\n  }\n}\nclass Rn extends Qe {\n  /**\n   * Request constructor\n   *\n   * @param {Object} options\n   * @package\n   */\n  constructor(t, e) {\n    super(), x0(this, e), this.opts = e, this.method = e.method || \"GET\", this.uri = t, this.async = e.async !== !1, this.data = e.data !== void 0 ? e.data : null, this.create();\n  }\n  /**\n   * Creates the XHR object and sends the request.\n   *\n   * @private\n   */\n  create() {\n    const t = DP(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;\n    const e = this.xhr = new FP(t);\n    try {\n      e.open(this.method, this.uri, this.async);\n      try {\n        if (this.opts.extraHeaders) {\n          e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);\n          for (let r in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(r) && e.setRequestHeader(r, this.opts.extraHeaders[r]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          e.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        e.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      \"withCredentials\" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {\n        e.readyState === 4 && (e.status === 200 || e.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof e.status == \"number\" ? e.status : 0);\n        }, 0));\n      }, e.send(this.data);\n    } catch (r) {\n      this.setTimeoutFn(() => {\n        this.onError(r);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = Rn.requestsCount++, Rn.requests[this.index] = this);\n  }\n  /**\n   * Called upon error.\n   *\n   * @private\n   */\n  onError(t) {\n    this.emitReserved(\"error\", t, this.xhr), this.cleanup(!0);\n  }\n  /**\n   * Cleans up house.\n   *\n   * @private\n   */\n  cleanup(t) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = w4, t)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete Rn.requests[this.index], this.xhr = null;\n    }\n  }\n  /**\n   * Called upon load.\n   *\n   * @private\n   */\n  onLoad() {\n    const t = this.xhr.responseText;\n    t !== null && (this.emitReserved(\"data\", t), this.emitReserved(\"success\"), this.cleanup());\n  }\n  /**\n   * Aborts the request.\n   *\n   * @package\n   */\n  abort() {\n    this.cleanup();\n  }\n}\nRn.requestsCount = 0;\nRn.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", pE);\n  else if (typeof addEventListener == \"function\") {\n    const i = \"onpagehide\" in Ei ? \"pagehide\" : \"unload\";\n    addEventListener(i, pE, !1);\n  }\n}\nfunction pE() {\n  for (let i in Rn.requests)\n    Rn.requests.hasOwnProperty(i) && Rn.requests[i].abort();\n}\nconst GP = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (t) => Promise.resolve().then(t) : (t, e) => e(t, 0))(), Tp = Ei.WebSocket || Ei.MozWebSocket, vE = !0, T4 = \"arraybuffer\", gE = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass C4 extends kP {\n  /**\n   * WebSocket transport constructor.\n   *\n   * @param {Object} opts - connection options\n   * @protected\n   */\n  constructor(t) {\n    super(t), this.supportsBinary = !t.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const t = this.uri(), e = this.opts.protocols, r = gE ? {} : DP(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);\n    try {\n      this.ws = vE && !gE ? e ? new Tp(t, e) : new Tp(t) : new Tp(t, e, r);\n    } catch (n) {\n      return this.emitReserved(\"error\", n);\n    }\n    this.ws.binaryType = this.socket.binaryType || T4, this.addEventListeners();\n  }\n  /**\n   * Adds event listeners to the socket\n   *\n   * @private\n   */\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (t) => this.onClose({\n      description: \"websocket connection closed\",\n      context: t\n    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError(\"websocket error\", t);\n  }\n  write(t) {\n    this.writable = !1;\n    for (let e = 0; e < t.length; e++) {\n      const r = t[e], n = e === t.length - 1;\n      MP(r, this.supportsBinary, (s) => {\n        const a = {};\n        try {\n          vE && this.ws.send(s);\n        } catch {\n        }\n        n && GP(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  /**\n   * Generates uri for connection.\n   *\n   * @private\n   */\n  uri() {\n    let t = this.query || {};\n    const e = this.opts.secure ? \"wss\" : \"ws\";\n    let r = \"\";\n    this.opts.port && (e === \"wss\" && Number(this.opts.port) !== 443 || e === \"ws\" && Number(this.opts.port) !== 80) && (r = \":\" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = AP()), this.supportsBinary || (t.b64 = 1);\n    const n = LP(t), s = this.opts.hostname.indexOf(\":\") !== -1;\n    return e + \"://\" + (s ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + r + this.opts.path + (n.length ? \"?\" + n : \"\");\n  }\n  /**\n   * Feature detection for WebSocket.\n   *\n   * @return {Boolean} whether this transport is available.\n   * @private\n   */\n  check() {\n    return !!Tp;\n  }\n}\nconst M4 = {\n  websocket: C4,\n  polling: S4\n}, P4 = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, O4 = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction mb(i) {\n  const t = i, e = i.indexOf(\"[\"), r = i.indexOf(\"]\");\n  e != -1 && r != -1 && (i = i.substring(0, e) + i.substring(e, r).replace(/:/g, \";\") + i.substring(r, i.length));\n  let n = P4.exec(i || \"\"), s = {}, a = 14;\n  for (; a--; )\n    s[O4[a]] = n[a] || \"\";\n  return e != -1 && r != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, \":\"), s.authority = s.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), s.ipv6uri = !0), s.pathNames = I4(s, s.path), s.queryKey = R4(s, s.query), s;\n}\nfunction I4(i, t) {\n  const e = /\\/{2,9}/g, r = t.replace(e, \"/\").split(\"/\");\n  return (t.slice(0, 1) == \"/\" || t.length === 0) && r.splice(0, 1), t.slice(-1) == \"/\" && r.splice(r.length - 1, 1), r;\n}\nfunction R4(i, t) {\n  const e = {};\n  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, n, s) {\n    n && (e[n] = s);\n  }), e;\n}\nlet UP = class Tu extends Qe {\n  /**\n   * Socket constructor.\n   *\n   * @param {String|Object} uri - uri or options\n   * @param {Object} opts - options\n   */\n  constructor(t, e = {}) {\n    super(), this.writeBuffer = [], t && typeof t == \"object\" && (e = t, t = null), t ? (t = mb(t), e.hostname = t.host, e.secure = t.protocol === \"https\" || t.protocol === \"wss\", e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = mb(e.host).host), x0(this, e), this.secure = e.secure != null ? e.secure : typeof location < \"u\" && location.protocol === \"https:\", e.hostname && !e.port && (e.port = this.secure ? \"443\" : \"80\"), this.hostname = e.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = e.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = e.transports || [\"polling\", \"websocket\"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      addTrailingSlash: !0,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !0\n    }, e), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\"), typeof this.opts.query == \"string\" && (this.opts.query = b4(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, addEventListener(\"beforeunload\", this.beforeunloadEventListener, !1)), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  /**\n   * Creates transport of the given type.\n   *\n   * @param {String} name - transport name\n   * @return {Transport}\n   * @private\n   */\n  createTransport(t) {\n    const e = Object.assign({}, this.opts.query);\n    e.EIO = RP, e.transport = t, this.id && (e.sid = this.id);\n    const r = Object.assign({}, this.opts.transportOptions[t], this.opts, {\n      query: e,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    });\n    return new M4[t](r);\n  }\n  /**\n   * Initializes transport to use and starts probe.\n   *\n   * @private\n   */\n  open() {\n    let t;\n    if (this.opts.rememberUpgrade && Tu.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      t = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      t = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      t = this.createTransport(t);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    t.open(), this.setTransport(t);\n  }\n  /**\n   * Sets the current transport. Disables the existing one (if any).\n   *\n   * @private\n   */\n  setTransport(t) {\n    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (e) => this.onClose(\"transport close\", e));\n  }\n  /**\n   * Probes a transport.\n   *\n   * @param {String} name - transport name\n   * @private\n   */\n  probe(t) {\n    let e = this.createTransport(t), r = !1;\n    Tu.priorWebsocketSuccess = !1;\n    const n = () => {\n      r || (e.send([{ type: \"ping\", data: \"probe\" }]), e.once(\"packet\", (d) => {\n        if (!r)\n          if (d.type === \"pong\" && d.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", e), !e)\n              return;\n            Tu.priorWebsocketSuccess = e.name === \"websocket\", this.transport.pause(() => {\n              r || this.readyState !== \"closed\" && (h(), this.setTransport(e), e.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", e), e = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const f = new Error(\"probe error\");\n            f.transport = e.name, this.emitReserved(\"upgradeError\", f);\n          }\n      }));\n    };\n    function s() {\n      r || (r = !0, h(), e.close(), e = null);\n    }\n    const a = (d) => {\n      const f = new Error(\"probe error: \" + d);\n      f.transport = e.name, s(), this.emitReserved(\"upgradeError\", f);\n    };\n    function o() {\n      a(\"transport closed\");\n    }\n    function u() {\n      a(\"socket closed\");\n    }\n    function l(d) {\n      e && d.name !== e.name && s();\n    }\n    const h = () => {\n      e.removeListener(\"open\", n), e.removeListener(\"error\", a), e.removeListener(\"close\", o), this.off(\"close\", u), this.off(\"upgrading\", l);\n    };\n    e.once(\"open\", n), e.once(\"error\", a), e.once(\"close\", o), this.once(\"close\", u), this.once(\"upgrading\", l), e.open();\n  }\n  /**\n   * Called when connection is deemed open.\n   *\n   * @private\n   */\n  onOpen() {\n    if (this.readyState = \"open\", Tu.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade) {\n      let t = 0;\n      const e = this.upgrades.length;\n      for (; t < e; t++)\n        this.probe(this.upgrades[t]);\n    }\n  }\n  /**\n   * Handles a packet.\n   *\n   * @private\n   */\n  onPacket(t) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", t), this.emitReserved(\"heartbeat\"), t.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(t.data));\n          break;\n        case \"ping\":\n          this.resetPingTimeout(), this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const e = new Error(\"server error\");\n          e.code = t.data, this.onError(e);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", t.data), this.emitReserved(\"message\", t.data);\n          break;\n      }\n  }\n  /**\n   * Called upon handshake completion.\n   *\n   * @param {Object} data - handshake obj\n   * @private\n   */\n  onHandshake(t) {\n    this.emitReserved(\"handshake\", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  /**\n   * Sets and resets ping timeout timer based on server pings.\n   *\n   * @private\n   */\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  /**\n   * Called on `drain` event\n   *\n   * @private\n   */\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  /**\n   * Flush write buffers.\n   *\n   * @private\n   */\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const t = this.getWritablePackets();\n      this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved(\"flush\");\n    }\n  }\n  /**\n   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n   * long-polling)\n   *\n   * @private\n   */\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let e = 1;\n    for (let r = 0; r < this.writeBuffer.length; r++) {\n      const n = this.writeBuffer[r].data;\n      if (n && (e += g4(n)), r > 0 && e > this.maxPayload)\n        return this.writeBuffer.slice(0, r);\n      e += 2;\n    }\n    return this.writeBuffer;\n  }\n  /**\n   * Sends a message.\n   *\n   * @param {String} msg - message.\n   * @param {Object} options.\n   * @param {Function} callback function.\n   * @return {Socket} for chaining.\n   */\n  write(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  send(t, e, r) {\n    return this.sendPacket(\"message\", t, e, r), this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} type: packet type.\n   * @param {String} data.\n   * @param {Object} options.\n   * @param {Function} fn - callback function.\n   * @private\n   */\n  sendPacket(t, e, r, n) {\n    if (typeof e == \"function\" && (n = e, e = void 0), typeof r == \"function\" && (n = r, r = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    r = r || {}, r.compress = r.compress !== !1;\n    const s = {\n      type: t,\n      data: e,\n      options: r\n    };\n    this.emitReserved(\"packetCreate\", s), this.writeBuffer.push(s), n && this.once(\"flush\", n), this.flush();\n  }\n  /**\n   * Closes the connection.\n   */\n  close() {\n    const t = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, e = () => {\n      this.off(\"upgrade\", e), this.off(\"upgradeError\", e), t();\n    }, r = () => {\n      this.once(\"upgrade\", e), this.once(\"upgradeError\", e);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? r() : t();\n    }) : this.upgrading ? r() : t()), this;\n  }\n  /**\n   * Called upon transport error\n   *\n   * @private\n   */\n  onError(t) {\n    Tu.priorWebsocketSuccess = !1, this.emitReserved(\"error\", t), this.onClose(\"transport error\", t);\n  }\n  /**\n   * Called upon transport close.\n   *\n   * @private\n   */\n  onClose(t, e) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && (removeEventListener(\"beforeunload\", this.beforeunloadEventListener, !1), removeEventListener(\"offline\", this.offlineEventListener, !1)), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", t, e), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  /**\n   * Filters upgrades, returning only those matching client transports.\n   *\n   * @param {Array} upgrades - server upgrades\n   * @private\n   */\n  filterUpgrades(t) {\n    const e = [];\n    let r = 0;\n    const n = t.length;\n    for (; r < n; r++)\n      ~this.transports.indexOf(t[r]) && e.push(t[r]);\n    return e;\n  }\n};\nUP.protocol = RP;\nfunction D4(i, t = \"\", e) {\n  let r = i;\n  e = e || typeof location < \"u\" && location, i == null && (i = e.protocol + \"//\" + e.host), typeof i == \"string\" && (i.charAt(0) === \"/\" && (i.charAt(1) === \"/\" ? i = e.protocol + i : i = e.host + i), /^(https?|wss?):\\/\\//.test(i) || (typeof e < \"u\" ? i = e.protocol + \"//\" + i : i = \"https://\" + i), r = mb(i)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = \"80\" : /^(http|ws)s$/.test(r.protocol) && (r.port = \"443\")), r.path = r.path || \"/\";\n  const s = r.host.indexOf(\":\") !== -1 ? \"[\" + r.host + \"]\" : r.host;\n  return r.id = r.protocol + \"://\" + s + \":\" + r.port + t, r.href = r.protocol + \"://\" + s + (e && e.port === r.port ? \"\" : \":\" + r.port), r;\n}\nconst k4 = typeof ArrayBuffer == \"function\", N4 = (i) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(i) : i.buffer instanceof ArrayBuffer, jP = Object.prototype.toString, A4 = typeof Blob == \"function\" || typeof Blob < \"u\" && jP.call(Blob) === \"[object BlobConstructor]\", L4 = typeof File == \"function\" || typeof File < \"u\" && jP.call(File) === \"[object FileConstructor]\";\nfunction Yx(i) {\n  return k4 && (i instanceof ArrayBuffer || N4(i)) || A4 && i instanceof Blob || L4 && i instanceof File;\n}\nfunction nv(i, t) {\n  if (!i || typeof i != \"object\")\n    return !1;\n  if (Array.isArray(i)) {\n    for (let e = 0, r = i.length; e < r; e++)\n      if (nv(i[e]))\n        return !0;\n    return !1;\n  }\n  if (Yx(i))\n    return !0;\n  if (i.toJSON && typeof i.toJSON == \"function\" && arguments.length === 1)\n    return nv(i.toJSON(), !0);\n  for (const e in i)\n    if (Object.prototype.hasOwnProperty.call(i, e) && nv(i[e]))\n      return !0;\n  return !1;\n}\nfunction B4(i) {\n  const t = [], e = i.data, r = i;\n  return r.data = yb(e, t), r.attachments = t.length, { packet: r, buffers: t };\n}\nfunction yb(i, t) {\n  if (!i)\n    return i;\n  if (Yx(i)) {\n    const e = { _placeholder: !0, num: t.length };\n    return t.push(i), e;\n  } else if (Array.isArray(i)) {\n    const e = new Array(i.length);\n    for (let r = 0; r < i.length; r++)\n      e[r] = yb(i[r], t);\n    return e;\n  } else if (typeof i == \"object\" && !(i instanceof Date)) {\n    const e = {};\n    for (const r in i)\n      Object.prototype.hasOwnProperty.call(i, r) && (e[r] = yb(i[r], t));\n    return e;\n  }\n  return i;\n}\nfunction F4(i, t) {\n  return i.data = _b(i.data, t), delete i.attachments, i;\n}\nfunction _b(i, t) {\n  if (!i)\n    return i;\n  if (i && i._placeholder === !0) {\n    if (typeof i.num == \"number\" && i.num >= 0 && i.num < t.length)\n      return t[i.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(i))\n    for (let e = 0; e < i.length; e++)\n      i[e] = _b(i[e], t);\n  else if (typeof i == \"object\")\n    for (const e in i)\n      Object.prototype.hasOwnProperty.call(i, e) && (i[e] = _b(i[e], t));\n  return i;\n}\nconst G4 = 5;\nvar te;\n(function(i) {\n  i[i.CONNECT = 0] = \"CONNECT\", i[i.DISCONNECT = 1] = \"DISCONNECT\", i[i.EVENT = 2] = \"EVENT\", i[i.ACK = 3] = \"ACK\", i[i.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", i[i.BINARY_EVENT = 5] = \"BINARY_EVENT\", i[i.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(te || (te = {}));\nclass U4 {\n  /**\n   * Encoder constructor\n   *\n   * @param {function} replacer - custom replacer to pass down to JSON.parse\n   */\n  constructor(t) {\n    this.replacer = t;\n  }\n  /**\n   * Encode a packet as a single string if non-binary, or as a\n   * buffer sequence, depending on packet type.\n   *\n   * @param {Object} obj - packet object\n   */\n  encode(t) {\n    return (t.type === te.EVENT || t.type === te.ACK) && nv(t) ? this.encodeAsBinary({\n      type: t.type === te.EVENT ? te.BINARY_EVENT : te.BINARY_ACK,\n      nsp: t.nsp,\n      data: t.data,\n      id: t.id\n    }) : [this.encodeAsString(t)];\n  }\n  /**\n   * Encode packet as string.\n   */\n  encodeAsString(t) {\n    let e = \"\" + t.type;\n    return (t.type === te.BINARY_EVENT || t.type === te.BINARY_ACK) && (e += t.attachments + \"-\"), t.nsp && t.nsp !== \"/\" && (e += t.nsp + \",\"), t.id != null && (e += t.id), t.data != null && (e += JSON.stringify(t.data, this.replacer)), e;\n  }\n  /**\n   * Encode packet as 'buffer sequence' by removing blobs, and\n   * deconstructing packet into object with placeholders and\n   * a list of buffers.\n   */\n  encodeAsBinary(t) {\n    const e = B4(t), r = this.encodeAsString(e.packet), n = e.buffers;\n    return n.unshift(r), n;\n  }\n}\nclass qx extends Qe {\n  /**\n   * Decoder constructor\n   *\n   * @param {function} reviver - custom reviver to pass down to JSON.stringify\n   */\n  constructor(t) {\n    super(), this.reviver = t;\n  }\n  /**\n   * Decodes an encoded packet string into packet JSON.\n   *\n   * @param {String} obj - encoded packet\n   */\n  add(t) {\n    let e;\n    if (typeof t == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      e = this.decodeString(t);\n      const r = e.type === te.BINARY_EVENT;\n      r || e.type === te.BINARY_ACK ? (e.type = r ? te.EVENT : te.ACK, this.reconstructor = new j4(e), e.attachments === 0 && super.emitReserved(\"decoded\", e)) : super.emitReserved(\"decoded\", e);\n    } else if (Yx(t) || t.base64)\n      if (this.reconstructor)\n        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved(\"decoded\", e));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + t);\n  }\n  /**\n   * Decode a packet String (JSON data)\n   *\n   * @param {String} str\n   * @return {Object} packet\n   */\n  decodeString(t) {\n    let e = 0;\n    const r = {\n      type: Number(t.charAt(0))\n    };\n    if (te[r.type] === void 0)\n      throw new Error(\"unknown packet type \" + r.type);\n    if (r.type === te.BINARY_EVENT || r.type === te.BINARY_ACK) {\n      const s = e + 1;\n      for (; t.charAt(++e) !== \"-\" && e != t.length; )\n        ;\n      const a = t.substring(s, e);\n      if (a != Number(a) || t.charAt(e) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      r.attachments = Number(a);\n    }\n    if (t.charAt(e + 1) === \"/\") {\n      const s = e + 1;\n      for (; ++e && !(t.charAt(e) === \",\" || e === t.length); )\n        ;\n      r.nsp = t.substring(s, e);\n    } else\n      r.nsp = \"/\";\n    const n = t.charAt(e + 1);\n    if (n !== \"\" && Number(n) == n) {\n      const s = e + 1;\n      for (; ++e; ) {\n        const a = t.charAt(e);\n        if (a == null || Number(a) != a) {\n          --e;\n          break;\n        }\n        if (e === t.length)\n          break;\n      }\n      r.id = Number(t.substring(s, e + 1));\n    }\n    if (t.charAt(++e)) {\n      const s = this.tryParse(t.substr(e));\n      if (qx.isPayloadValid(r.type, s))\n        r.data = s;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return r;\n  }\n  tryParse(t) {\n    try {\n      return JSON.parse(t, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(t, e) {\n    switch (t) {\n      case te.CONNECT:\n        return typeof e == \"object\";\n      case te.DISCONNECT:\n        return e === void 0;\n      case te.CONNECT_ERROR:\n        return typeof e == \"string\" || typeof e == \"object\";\n      case te.EVENT:\n      case te.BINARY_EVENT:\n        return Array.isArray(e) && e.length > 0;\n      case te.ACK:\n      case te.BINARY_ACK:\n        return Array.isArray(e);\n    }\n  }\n  /**\n   * Deallocates a parser's resources\n   */\n  destroy() {\n    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);\n  }\n}\nclass j4 {\n  constructor(t) {\n    this.packet = t, this.buffers = [], this.reconPack = t;\n  }\n  /**\n   * Method to be called when binary data received from connection\n   * after a BINARY_EVENT packet.\n   *\n   * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n   * @return {null | Object} returns null if more binary data is expected or\n   *   a reconstructed packet object if all buffers have been received.\n   */\n  takeBinaryData(t) {\n    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {\n      const e = F4(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), e;\n    }\n    return null;\n  }\n  /**\n   * Cleans up binary packet reconstruction variables.\n   */\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst z4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Decoder: qx,\n  Encoder: U4,\n  get PacketType() {\n    return te;\n  },\n  protocol: G4\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Xi(i, t, e) {\n  return i.on(t, e), function() {\n    i.off(t, e);\n  };\n}\nconst H4 = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n  newListener: 1,\n  removeListener: 1\n});\nclass zP extends Qe {\n  /**\n   * `Socket` constructor.\n   */\n  constructor(t, e, r) {\n    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();\n  }\n  /**\n   * Whether the socket is currently disconnected\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"connect\", () => {\n   *   console.log(socket.disconnected); // false\n   * });\n   *\n   * socket.on(\"disconnect\", () => {\n   *   console.log(socket.disconnected); // true\n   * });\n   */\n  get disconnected() {\n    return !this.connected;\n  }\n  /**\n   * Subscribe to open, close and packet events\n   *\n   * @private\n   */\n  subEvents() {\n    if (this.subs)\n      return;\n    const t = this.io;\n    this.subs = [\n      Xi(t, \"open\", this.onopen.bind(this)),\n      Xi(t, \"packet\", this.onpacket.bind(this)),\n      Xi(t, \"error\", this.onerror.bind(this)),\n      Xi(t, \"close\", this.onclose.bind(this))\n    ];\n  }\n  /**\n   * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n   *\n   * @example\n   * const socket = io();\n   *\n   * console.log(socket.active); // true\n   *\n   * socket.on(\"disconnect\", (reason) => {\n   *   if (reason === \"io server disconnect\") {\n   *     // the disconnection was initiated by the server, you need to manually reconnect\n   *     console.log(socket.active); // false\n   *   }\n   *   // else the socket will automatically try to reconnect\n   *   console.log(socket.active); // true\n   * });\n   */\n  get active() {\n    return !!this.subs;\n  }\n  /**\n   * \"Opens\" the socket.\n   *\n   * @example\n   * const socket = io({\n   *   autoConnect: false\n   * });\n   *\n   * socket.connect();\n   */\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  /**\n   * Alias for {@link connect()}.\n   */\n  open() {\n    return this.connect();\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * This method mimics the WebSocket.send() method.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   *\n   * @example\n   * socket.send(\"hello\");\n   *\n   * // this is equivalent to\n   * socket.emit(\"message\", \"hello\");\n   *\n   * @return self\n   */\n  send(...t) {\n    return t.unshift(\"message\"), this.emit.apply(this, t), this;\n  }\n  /**\n   * Override `emit`.\n   * If the event is in `events`, it's emitted normally.\n   *\n   * @example\n   * socket.emit(\"hello\", \"world\");\n   *\n   * // all serializable datastructures are supported (no need to call JSON.stringify)\n   * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n   *\n   * // with an acknowledgement from the server\n   * socket.emit(\"hello\", \"world\", (val) => {\n   *   // ...\n   * });\n   *\n   * @return self\n   */\n  emit(t, ...e) {\n    if (H4.hasOwnProperty(t))\n      throw new Error('\"' + t.toString() + '\" is a reserved event name');\n    if (e.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)\n      return this._addToQueue(e), this;\n    const r = {\n      type: te.EVENT,\n      data: e\n    };\n    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof e[e.length - 1] == \"function\") {\n      const a = this.ids++, o = e.pop();\n      this._registerAckCallback(a, o), r.id = a;\n    }\n    const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!n || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;\n  }\n  /**\n   * @private\n   */\n  _registerAckCallback(t, e) {\n    var r;\n    const n = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;\n    if (n === void 0) {\n      this.acks[t] = e;\n      return;\n    }\n    const s = this.io.setTimeoutFn(() => {\n      delete this.acks[t];\n      for (let a = 0; a < this.sendBuffer.length; a++)\n        this.sendBuffer[a].id === t && this.sendBuffer.splice(a, 1);\n      e.call(this, new Error(\"operation has timed out\"));\n    }, n);\n    this.acks[t] = (...a) => {\n      this.io.clearTimeoutFn(s), e.apply(this, [null, ...a]);\n    };\n  }\n  /**\n   * Emits an event and waits for an acknowledgement\n   *\n   * @example\n   * // without timeout\n   * const response = await socket.emitWithAck(\"hello\", \"world\");\n   *\n   * // with a specific timeout\n   * try {\n   *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n   * } catch (err) {\n   *   // the server did not acknowledge the event in the given delay\n   * }\n   *\n   * @return a Promise that will be fulfilled when the server acknowledges the event\n   */\n  emitWithAck(t, ...e) {\n    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n    return new Promise((n, s) => {\n      e.push((a, o) => r ? a ? s(a) : n(o) : n(a)), this.emit(t, ...e);\n    });\n  }\n  /**\n   * Add the packet to the queue.\n   * @param args\n   * @private\n   */\n  _addToQueue(t) {\n    let e;\n    typeof t[t.length - 1] == \"function\" && (e = t.pop());\n    const r = {\n      id: this._queueSeq++,\n      tryCount: 0,\n      pending: !1,\n      args: t,\n      flags: Object.assign({ fromQueue: !0 }, this.flags)\n    };\n    t.push((n, ...s) => r !== this._queue[0] ? void 0 : (n !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), e && e(n)) : (this._queue.shift(), e && e(null, ...s)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();\n  }\n  /**\n   * Send the first packet of the queue, and wait for an acknowledgement from the server.\n   * @param force - whether to resend a packet that has not been acknowledged yet\n   *\n   * @private\n   */\n  _drainQueue(t = !1) {\n    if (!this.connected || this._queue.length === 0)\n      return;\n    const e = this._queue[0];\n    e.pending && !t || (e.pending = !0, e.tryCount++, this.flags = e.flags, this.emit.apply(this, e.args));\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param packet\n   * @private\n   */\n  packet(t) {\n    t.nsp = this.nsp, this.io._packet(t);\n  }\n  /**\n   * Called upon engine `open`.\n   *\n   * @private\n   */\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((t) => {\n      this._sendConnectPacket(t);\n    }) : this._sendConnectPacket(this.auth);\n  }\n  /**\n   * Sends a CONNECT packet to initiate the Socket.IO session.\n   *\n   * @param data\n   * @private\n   */\n  _sendConnectPacket(t) {\n    this.packet({\n      type: te.CONNECT,\n      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t\n    });\n  }\n  /**\n   * Called upon engine or manager `error`.\n   *\n   * @param err\n   * @private\n   */\n  onerror(t) {\n    this.connected || this.emitReserved(\"connect_error\", t);\n  }\n  /**\n   * Called upon engine `close`.\n   *\n   * @param reason\n   * @param description\n   * @private\n   */\n  onclose(t, e) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", t, e);\n  }\n  /**\n   * Called with socket packet.\n   *\n   * @param packet\n   * @private\n   */\n  onpacket(t) {\n    if (t.nsp === this.nsp)\n      switch (t.type) {\n        case te.CONNECT:\n          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case te.EVENT:\n        case te.BINARY_EVENT:\n          this.onevent(t);\n          break;\n        case te.ACK:\n        case te.BINARY_ACK:\n          this.onack(t);\n          break;\n        case te.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case te.CONNECT_ERROR:\n          this.destroy();\n          const r = new Error(t.data.message);\n          r.data = t.data.data, this.emitReserved(\"connect_error\", r);\n          break;\n      }\n  }\n  /**\n   * Called upon a server event.\n   *\n   * @param packet\n   * @private\n   */\n  onevent(t) {\n    const e = t.data || [];\n    t.id != null && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e));\n  }\n  emitEvent(t) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const e = this._anyListeners.slice();\n      for (const r of e)\n        r.apply(this, t);\n    }\n    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == \"string\" && (this._lastOffset = t[t.length - 1]);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @private\n   */\n  ack(t) {\n    const e = this;\n    let r = !1;\n    return function(...n) {\n      r || (r = !0, e.packet({\n        type: te.ACK,\n        id: t,\n        data: n\n      }));\n    };\n  }\n  /**\n   * Called upon a server acknowlegement.\n   *\n   * @param packet\n   * @private\n   */\n  onack(t) {\n    const e = this.acks[t.id];\n    typeof e == \"function\" && (e.apply(this, t.data), delete this.acks[t.id]);\n  }\n  /**\n   * Called upon server connect.\n   *\n   * @private\n   */\n  onconnect(t, e) {\n    this.id = t, this.recovered = e && this._pid === e, this._pid = e, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\"), this._drainQueue(!0);\n  }\n  /**\n   * Emit buffered events (received and emitted).\n   *\n   * @private\n   */\n  emitBuffered() {\n    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {\n      this.notifyOutgoingListeners(t), this.packet(t);\n    }), this.sendBuffer = [];\n  }\n  /**\n   * Called upon server disconnect.\n   *\n   * @private\n   */\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  /**\n   * Called upon forced client/server side disconnections,\n   * this method ensures the manager stops tracking us and\n   * that reconnections don't get triggered for this.\n   *\n   * @private\n   */\n  destroy() {\n    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);\n  }\n  /**\n   * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n   *\n   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"disconnect\", (reason) => {\n   *   // console.log(reason); prints \"io client disconnect\"\n   * });\n   *\n   * socket.disconnect();\n   *\n   * @return self\n   */\n  disconnect() {\n    return this.connected && this.packet({ type: te.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  /**\n   * Alias for {@link disconnect()}.\n   *\n   * @return self\n   */\n  close() {\n    return this.disconnect();\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @example\n   * socket.compress(false).emit(\"hello\");\n   *\n   * @param compress - if `true`, compresses the sending data\n   * @return self\n   */\n  compress(t) {\n    return this.flags.compress = t, this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n   * ready to send messages.\n   *\n   * @example\n   * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n   *\n   * @returns self\n   */\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n   * given number of milliseconds have elapsed without an acknowledgement from the server:\n   *\n   * @example\n   * socket.timeout(5000).emit(\"my-event\", (err) => {\n   *   if (err) {\n   *     // the server did not acknowledge the event in the given delay\n   *   }\n   * });\n   *\n   * @returns self\n   */\n  timeout(t) {\n    return this.flags.timeout = t, this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * @example\n   * socket.onAny((event, ...args) => {\n   *   console.log(`got ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  onAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @example\n   * socket.prependAny((event, ...args) => {\n   *   console.log(`got event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  prependAny(t) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @example\n   * const catchAllListener = (event, ...args) => {\n   *   console.log(`got event ${event}`);\n   * }\n   *\n   * socket.onAny(catchAllListener);\n   *\n   * // remove a specific listener\n   * socket.offAny(catchAllListener);\n   *\n   * // or remove all listeners\n   * socket.offAny();\n   *\n   * @param listener\n   */\n  offAny(t) {\n    if (!this._anyListeners)\n      return this;\n    if (t) {\n      const e = this._anyListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback.\n   *\n   * Note: acknowledgements sent to the server are not included.\n   *\n   * @example\n   * socket.onAnyOutgoing((event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  onAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * Note: acknowledgements sent to the server are not included.\n   *\n   * @example\n   * socket.prependAnyOutgoing((event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * });\n   *\n   * @param listener\n   */\n  prependAnyOutgoing(t) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is emitted.\n   *\n   * @example\n   * const catchAllListener = (event, ...args) => {\n   *   console.log(`sent event ${event}`);\n   * }\n   *\n   * socket.onAnyOutgoing(catchAllListener);\n   *\n   * // remove a specific listener\n   * socket.offAnyOutgoing(catchAllListener);\n   *\n   * // or remove all listeners\n   * socket.offAnyOutgoing();\n   *\n   * @param [listener] - the catch-all listener (optional)\n   */\n  offAnyOutgoing(t) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (t) {\n      const e = this._anyOutgoingListeners;\n      for (let r = 0; r < e.length; r++)\n        if (t === e[r])\n          return e.splice(r, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  /**\n   * Notify the listeners for each packet sent\n   *\n   * @param packet\n   *\n   * @private\n   */\n  notifyOutgoingListeners(t) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const e = this._anyOutgoingListeners.slice();\n      for (const r of e)\n        r.apply(this, t.data);\n    }\n  }\n}\nfunction vh(i) {\n  i = i || {}, this.ms = i.min || 100, this.max = i.max || 1e4, this.factor = i.factor || 2, this.jitter = i.jitter > 0 && i.jitter <= 1 ? i.jitter : 0, this.attempts = 0;\n}\nvh.prototype.duration = function() {\n  var i = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var t = Math.random(), e = Math.floor(t * this.jitter * i);\n    i = Math.floor(t * 10) & 1 ? i + e : i - e;\n  }\n  return Math.min(i, this.max) | 0;\n};\nvh.prototype.reset = function() {\n  this.attempts = 0;\n};\nvh.prototype.setMin = function(i) {\n  this.ms = i;\n};\nvh.prototype.setMax = function(i) {\n  this.max = i;\n};\nvh.prototype.setJitter = function(i) {\n  this.jitter = i;\n};\nclass bb extends Qe {\n  constructor(t, e) {\n    var r;\n    super(), this.nsps = {}, this.subs = [], t && typeof t == \"object\" && (e = t, t = void 0), e = e || {}, e.path = e.path || \"/socket.io\", this.opts = e, x0(this, e), this.reconnection(e.reconnection !== !1), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor((r = e.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new vh({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(e.timeout == null ? 2e4 : e.timeout), this._readyState = \"closed\", this.uri = t;\n    const n = e.parser || z4;\n    this.encoder = new n.Encoder(), this.decoder = new n.Decoder(), this._autoConnect = e.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(t) {\n    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;\n  }\n  reconnectionAttempts(t) {\n    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);\n  }\n  reconnectionDelay(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (e = this.backoff) === null || e === void 0 || e.setMin(t), this);\n  }\n  randomizationFactor(t) {\n    var e;\n    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (e = this.backoff) === null || e === void 0 || e.setJitter(t), this);\n  }\n  reconnectionDelayMax(t) {\n    var e;\n    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (e = this.backoff) === null || e === void 0 || e.setMax(t), this);\n  }\n  timeout(t) {\n    return arguments.length ? (this._timeout = t, this) : this._timeout;\n  }\n  /**\n   * Starts trying to reconnect if reconnection is enabled and we have not\n   * started reconnecting yet\n   *\n   * @private\n   */\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  /**\n   * Sets the current transport `socket`.\n   *\n   * @param {Function} fn - optional, callback\n   * @return self\n   * @public\n   */\n  open(t) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new UP(this.uri, this.opts);\n    const e = this.engine, r = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const n = Xi(e, \"open\", function() {\n      r.onopen(), t && t();\n    }), s = Xi(e, \"error\", (a) => {\n      r.cleanup(), r._readyState = \"closed\", this.emitReserved(\"error\", a), t ? t(a) : r.maybeReconnectOnOpen();\n    });\n    if (this._timeout !== !1) {\n      const a = this._timeout;\n      a === 0 && n();\n      const o = this.setTimeoutFn(() => {\n        n(), e.close(), e.emit(\"error\", new Error(\"timeout\"));\n      }, a);\n      this.opts.autoUnref && o.unref(), this.subs.push(function() {\n        clearTimeout(o);\n      });\n    }\n    return this.subs.push(n), this.subs.push(s), this;\n  }\n  /**\n   * Alias for open()\n   *\n   * @return self\n   * @public\n   */\n  connect(t) {\n    return this.open(t);\n  }\n  /**\n   * Called upon transport open.\n   *\n   * @private\n   */\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const t = this.engine;\n    this.subs.push(Xi(t, \"ping\", this.onping.bind(this)), Xi(t, \"data\", this.ondata.bind(this)), Xi(t, \"error\", this.onerror.bind(this)), Xi(t, \"close\", this.onclose.bind(this)), Xi(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  /**\n   * Called upon a ping.\n   *\n   * @private\n   */\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  /**\n   * Called with data.\n   *\n   * @private\n   */\n  ondata(t) {\n    try {\n      this.decoder.add(t);\n    } catch (e) {\n      this.onclose(\"parse error\", e);\n    }\n  }\n  /**\n   * Called when parser fully decodes a packet.\n   *\n   * @private\n   */\n  ondecoded(t) {\n    GP(() => {\n      this.emitReserved(\"packet\", t);\n    }, this.setTimeoutFn);\n  }\n  /**\n   * Called upon socket error.\n   *\n   * @private\n   */\n  onerror(t) {\n    this.emitReserved(\"error\", t);\n  }\n  /**\n   * Creates a new socket for the given `nsp`.\n   *\n   * @return {Socket}\n   * @public\n   */\n  socket(t, e) {\n    let r = this.nsps[t];\n    return r ? this._autoConnect && !r.active && r.connect() : (r = new zP(this, t, e), this.nsps[t] = r), r;\n  }\n  /**\n   * Called upon a socket close.\n   *\n   * @param socket\n   * @private\n   */\n  _destroy(t) {\n    const e = Object.keys(this.nsps);\n    for (const r of e)\n      if (this.nsps[r].active)\n        return;\n    this._close();\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param packet\n   * @private\n   */\n  _packet(t) {\n    const e = this.encoder.encode(t);\n    for (let r = 0; r < e.length; r++)\n      this.engine.write(e[r], t.options);\n  }\n  /**\n   * Clean up transport subscriptions and packet buffer.\n   *\n   * @private\n   */\n  cleanup() {\n    this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();\n  }\n  /**\n   * Close the current socket.\n   *\n   * @private\n   */\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  /**\n   * Alias for close()\n   *\n   * @private\n   */\n  disconnect() {\n    return this._close();\n  }\n  /**\n   * Called upon engine close.\n   *\n   * @private\n   */\n  onclose(t, e) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", t, e), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  /**\n   * Attempt a reconnection.\n   *\n   * @private\n   */\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const t = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const e = this.backoff.duration();\n      this._reconnecting = !0;\n      const r = this.setTimeoutFn(() => {\n        t.skipReconnect || (this.emitReserved(\"reconnect_attempt\", t.backoff.attempts), !t.skipReconnect && t.open((n) => {\n          n ? (t._reconnecting = !1, t.reconnect(), this.emitReserved(\"reconnect_error\", n)) : t.onreconnect();\n        }));\n      }, e);\n      this.opts.autoUnref && r.unref(), this.subs.push(function() {\n        clearTimeout(r);\n      });\n    }\n  }\n  /**\n   * Called upon successful reconnect.\n   *\n   * @private\n   */\n  onreconnect() {\n    const t = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", t);\n  }\n}\nconst Mh = {};\nfunction sv(i, t) {\n  typeof i == \"object\" && (t = i, i = void 0), t = t || {};\n  const e = D4(i, t.path || \"/socket.io\"), r = e.source, n = e.id, s = e.path, a = Mh[n] && s in Mh[n].nsps, o = t.forceNew || t[\"force new connection\"] || t.multiplex === !1 || a;\n  let u;\n  return o ? u = new bb(r, t) : (Mh[n] || (Mh[n] = new bb(r, t)), u = Mh[n]), e.query && !t.query && (t.query = e.queryKey), u.socket(e.path, t);\n}\nObject.assign(sv, {\n  Manager: bb,\n  Socket: zP,\n  io: sv,\n  connect: sv\n});\nvar $i, En, Sn, Ho, $o, na, sa, aa, Ym, qm, bd, Wl, Zm, Yl, Vo, Km, Xo, ql;\nconst Jm = class {\n  constructor(t = {}, e) {\n    K(this, \"hFactoryCls\", {});\n    K(this, \"elc\", new Ql());\n    K(this, \"fetch\", (t) => fetch(t));\n    K(this, \"resolution\", 1);\n    K(this, \"cfg\");\n    K(this, \"data\", { sys: {}, mark: {}, kidoku: {} });\n    K(this, \"val\");\n    K(this, \"appPixi\");\n    E(this, $i, 0);\n    E(this, En, 0);\n    E(this, Sn, 1);\n    E(this, Ho, 0);\n    E(this, $o, 0);\n    E(this, na, 0);\n    E(this, sa, 0);\n    K(this, \"isFullScr\", !1);\n    K(this, \"extPort\", 3776);\n    E(this, aa, void 0);\n    E(this, Ym, {\n      auth: (t) => {\n        if (t.t !== this.cfg.oCfg.debuger_token) {\n          this.end();\n          return;\n        }\n        this.toast(\"接続\");\n      },\n      continue: () => this.toast(\"再生\"),\n      disconnect: () => this.toast(\"切断\"),\n      restart: (t) => {\n        this.send2Dbg((t == null ? void 0 : t.ri) ?? \"\", {}), this.end(), this.run();\n      },\n      pause: () => this.toast(\"一時停止\"),\n      stopOnEntry: () => this.toast(\"一時停止\"),\n      stopOnDataBreakpoint: () => this.toast(\"注意\"),\n      stopOnBreakpoint: () => this.toast(\"注意\"),\n      stopOnStep: () => this.toast(\"一歩進む\"),\n      stopOnStepIn: () => this.toast(\"ステップイン\"),\n      stopOnStepOut: () => this.toast(\"ステップアウト\"),\n      stopOnBackstep: () => this.toast(\"一歩戻る\"),\n      _addPath: (t) => this.cfg.addPath(t.fn, t.o)\n    });\n    K(this, \"pathBaseCnvSnPath4Dbg\", \"\");\n    K(this, \"fire\");\n    E(this, bd, []);\n    K(this, \"callHook\", (t, e) => {\n    });\n    K(this, \"send2Dbg\", (t, e) => {\n      var r;\n      (r = c(this, aa)) == null || r.emit(\"data\", t, e);\n    });\n    K(this, \"copyBMFolder\", (t, e) => {\n    });\n    K(this, \"eraseBMFolder\", (t) => {\n    });\n    K(this, \"close\", () => !1);\n    K(this, \"_export\", () => !1);\n    K(this, \"_import\", () => !1);\n    K(this, \"navigate_to\", () => !1);\n    K(this, \"title\", (t) => {\n      const { text: e } = t;\n      if (!e)\n        throw \"[title] textは必須です\";\n      return P(this, Wl, e), this.titleSub(c(this, Wl) + c(this, Yl)), !1;\n    });\n    E(this, Wl, \"\");\n    E(this, Zm, (t) => {\n      if (!t.key)\n        return this.tglFlscr_sub(), !1;\n      const e = t.key.toLowerCase();\n      return this.elc.add(document, \"keydown\", (r) => {\n        (r.altKey ? r.key === \"Alt\" ? \"\" : \"alt+\" : \"\") + (r.ctrlKey ? r.key === \"Control\" ? \"\" : \"ctrl+\" : \"\") + (r.shiftKey ? r.key === \"Shift\" ? \"\" : \"shift+\" : \"\") + r.key.toLowerCase() === e && (r.stopPropagation(), this.tglFlscr_sub());\n      }, { passive: !0 }), !1;\n    });\n    K(this, \"update_check\", () => !1);\n    K(this, \"window\", () => !1);\n    E(this, Yl, \"\");\n    E(this, Vo, (t, e) => ({ ret: e.toString(), ext_num: 0 }));\n    E(this, Km, {\n      1: { ext: \"jpeg\", fnc: (t) => c(this, Xo).call(this, t), mime: \"image/jpeg\" },\n      2: { ext: \"png\", fnc: (t) => c(this, Xo).call(this, t), mime: \"image/png\" },\n      3: { ext: \"svg\", fnc: (t) => c(this, Xo).call(this, t), mime: \"image/svg+xml\" },\n      4: { ext: \"webp\", fnc: (t) => c(this, Xo).call(this, t), mime: \"image/webp\" },\n      10: { ext: \"mp3\", fnc: (t) => t.arrayBuffer(), mime: \"audio/mpeg\" },\n      11: { ext: \"m4a\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      12: { ext: \"ogg\", fnc: (t) => t.arrayBuffer(), mime: \"audio/ogg\" },\n      13: { ext: \"aac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/aac\" },\n      14: { ext: \"flac\", fnc: (t) => t.arrayBuffer(), mime: \"audio/flac\" },\n      15: { ext: \"wav\", fnc: (t) => t.arrayBuffer(), mime: \"audio/wav\" },\n      20: { ext: \"mp4\", fnc: (t) => c(this, ql).call(this, t), mime: \"video/mp4\" },\n      21: { ext: \"webm\", fnc: (t) => c(this, ql).call(this, t), mime: \"video/webm\" },\n      22: { ext: \"ogv\", fnc: (t) => c(this, ql).call(this, t), mime: \"video/ogv\" }\n    });\n    E(this, Xo, (t) => new Promise((e, r) => {\n      const n = new Image();\n      n.onload = () => e(n), n.onerror = (s) => r(s), n.src = URL.createObjectURL(t);\n    }));\n    E(this, ql, (t) => new Promise((e, r) => {\n      const n = document.createElement(\"video\");\n      this.elc.add(n, \"error\", () => {\n        var s;\n        return r(((s = n == null ? void 0 : n.error) == null ? void 0 : s.message) ?? \"\");\n      }), this.elc.add(n, \"canplay\", () => e(n)), n.src = URL.createObjectURL(t);\n    }));\n    K(this, \"enc\", (t) => t);\n    K(this, \"stk\", () => \"\");\n    K(this, \"hash\", (t) => \"\");\n    K(this, \"isApp\", !1);\n    K(this, \"$path_downloads\", \"\");\n    K(this, \"$path_userdata\", \"\");\n    this.hPlg = t, this.arg = e;\n  }\n  async loaded(t, e) {\n    const r = t.snsys_pre;\n    return delete t.snsys_pre, r == null ? void 0 : r.init({\n      addTag: () => {\n      },\n      addLayCls: () => {\n      },\n      searchPath: () => \"\",\n      getVal: () => ({}),\n      resume: () => {\n      },\n      render: () => {\n      },\n      setDec: (n) => P(this, Vo, n),\n      setEnc: (n) => this.enc = n,\n      getStK: (n) => this.stk = n,\n      getHash: (n) => this.hash = n\n    });\n  }\n  get cur() {\n    return this.arg.cur;\n  }\n  get crypto() {\n    return this.arg.crypto;\n  }\n  destroy() {\n    this.elc.clear();\n  }\n  async loadPath(t, e) {\n    this.cfg = e;\n  }\n  initVal(t, e, r) {\n  }\n  flush() {\n  }\n  async run() {\n  }\n  init(t, e, r, n) {\n    this.val = r, this.appPixi = e;\n    let s = \"\";\n    try {\n      this.val.setSys(this), s = \"sys\", s += Number(this.val.getVal(\"sys:TextLayer.Back.Alpha\", 1)), s = \"kidoku\", this.val.saveKidoku();\n    } catch (a) {\n      console.error(`セーブデータ（${s}）が壊れています。一度クリアする必要があります %o`, a);\n    }\n    return t.close = (a) => this.close(a), t.export = (a) => this._export(a), t.import = (a) => this._import(a), t.navigate_to = (a) => this.navigate_to(a), t.title = (a) => this.title(a), t.toggle_full_screen = (a) => c(this, Zm).call(this, a), t.update_check = (a) => this.update_check(a), t.window = (a) => this.window(a), r.setVal_Nochk(\"tmp\", \"const.sn.isApp\", () => this.isApp), r.setVal_Nochk(\"tmp\", \"const.sn.isDbg\", () => Y.isDbg), r.setVal_Nochk(\"tmp\", \"const.sn.isPackaged\", () => Y.isPackaged), this.val.defTmp(\"const.sn.displayState\", () => this.isFullScr), r.setVal_Nochk(\"sys\", Jm.VALNM_CFG_NS, this.cfg.oCfg.save_ns), r.flush(), Y.isDbg && this.attach_debug(n), this.hFactoryCls = {}, Object.values(this.hPlg).map((a) => a.init({\n      addTag: (o, u) => {\n        if (t[o])\n          throw `すでに定義済みのタグ[${o}]です`;\n        t[o] = u;\n      },\n      addLayCls: (o, u) => {\n        if (this.hFactoryCls[o])\n          throw `すでに定義済みのレイヤcls【${o}】です`;\n        this.hFactoryCls[o] = u;\n      },\n      searchPath: (o, u = \"\") => this.cfg.searchPath(o, u),\n      getVal: r.getVal,\n      resume: () => n.resume(),\n      render: (o, u, l = !1) => this.appPixi.renderer.render(o, { renderTexture: u, clear: l }),\n      setDec: (o) => P(this, Vo, o),\n      setEnc: (o) => this.enc = o,\n      getStK: (o) => this.stk = o,\n      getHash: (o) => this.hash = o\n    }));\n  }\n  get cvsWidth() {\n    return c(this, $i);\n  }\n  get cvsHeight() {\n    return c(this, En);\n  }\n  get cvsScale() {\n    return c(this, Sn);\n  }\n  get ofsLeft4elm() {\n    return c(this, Ho);\n  }\n  get ofsTop4elm() {\n    return c(this, $o);\n  }\n  get ofsPadLeft_Dom2PIXI() {\n    return c(this, na);\n  }\n  get ofsPadTop_Dom2PIXI() {\n    return c(this, sa);\n  }\n  cvsResize() {\n    var u;\n    let t = globalThis.innerWidth, e = globalThis.innerHeight;\n    const r = Ur.cvs, n = r.parentElement !== document.body;\n    if (n) {\n      const l = globalThis.getComputedStyle(r);\n      t = parseFloat(l.width), e = parseFloat(l.height);\n    }\n    if (Y.isMobile) {\n      const h = (((u = screen.orientation) == null ? void 0 : u.angle) ?? 0) % 180 === 0;\n      (h && t > e || !h && t < e) && ([t, e] = [e, t]);\n    }\n    const s = r.getBoundingClientRect();\n    if (vt(Y.hDip, \"expanding\", !0) || n || Y.stageW > t || Y.stageH > e)\n      if (Y.stageW / Y.stageH <= t / e ? (P(this, En, e), P(this, $i, Y.stageW / Y.stageH * e)) : (P(this, $i, t), P(this, En, Y.stageH / Y.stageW * t)), P(this, Sn, c(this, $i) / Y.stageW), n)\n        P(this, na, 0), P(this, sa, 0);\n      else {\n        const l = 1 - c(this, Sn);\n        Y.isMobile ? (P(this, na, (t - c(this, $i)) / 2 * l), P(this, sa, (e - c(this, En)) / 2 * l)) : (P(this, na, s.left * l), P(this, sa, s.top * l));\n      }\n    else\n      P(this, $i, Y.stageW), P(this, En, Y.stageH), P(this, Sn, 1), P(this, na, 0), P(this, sa, 0);\n    const a = r.parentElement.style;\n    n || (a.position = \"relative\", a.width = `${c(this, $i)}px`, a.height = `${c(this, En)}px`);\n    const o = r.style;\n    o.width = a.width, o.height = a.height, n ? (P(this, Ho, s.left), P(this, $o, s.top)) : (P(this, Ho, 0), P(this, $o, 0)), this.isFullScr && (P(this, Ho, c(this, Ho) + (t - c(this, $i)) / 2), P(this, $o, c(this, $o) + (e - c(this, En)) / 2));\n  }\n  // デバッガ接続\n  attach_debug(t) {\n    this.attach_debug = () => {\n    };\n    const e = document.createElement(\"style\");\n    e.innerHTML = `/* SKYNovel Dbg */\n.sn_BounceInOut { animation: sn_kfBounceInOut linear 1.5s; }\n@keyframes sn_kfBounceInOut{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n10%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n20%\t{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n30%\t{\t\t\t\ttransform: scaleX(1.00) scaleY(1.00);}\n70%\t{opacity: 1;}\n100%{opacity: 0;}\n}\n.sn_BounceIn { animation: sn_kfBounceIn linear 0.3s; }\n@keyframes sn_kfBounceIn{\n0%\t{opacity: 0;\ttransform: scaleX(0.30) scaleY(0.30);}\n50%\t{opacity: 1;\ttransform: scaleX(1.10) scaleY(1.10);}\n100%{\t\t\t\ttransform: scaleX(0.95) scaleY(0.95);}\n}\n.sn_HopIn { animation: sn_kfHopIn linear 0.8s; }\n@keyframes sn_kfHopIn{\n0%\t{transform:\ttranslate(0px,   0px);}\n15% {transform:\ttranslate(0px, -25px);}\n30% {transform:\ttranslate(0px,   0px);}\n45% {transform:\ttranslate(0px, -15px);}\n60% {transform:\ttranslate(0px,   0px);}\n75% {transform:\ttranslate(0px,  -5px);}\n100%{transform:\ttranslate(0px,   0px);}\n}`, document.getElementsByTagName(\"head\")[0].appendChild(e), this.addHook((r, n) => {\n      var s, a;\n      return (a = (s = c(this, Ym))[r]) == null ? void 0 : a.call(s, n);\n    }), P(this, aa, sv(`http://localhost:${this.extPort}`)), c(this, aa).on(\"data\", (r, n) => {\n      this.callHook(r, n);\n    }).on(\"disconnect\", () => t.setLoop(!0)), this.callHook = (r, n) => {\n      for (const s of c(this, bd))\n        s(r, n);\n    };\n  }\n  end() {\n    var t;\n    (t = c(this, aa)) == null || t.disconnect(), P(this, aa, void 0);\n  }\n  toast(t) {\n    const e = document.body;\n    e.querySelectorAll(\".sn_BounceIn, .sn_HopIn\").forEach((a) => e.removeChild(a));\n    const r = document.createElement(\"img\"), n = c(Jm, qm)[t];\n    r.src = `data:image/svg+xml;base64,${n.dat}`;\n    const s = Math.min(Y.stageW, Y.stageH) / 4 * c(this, Sn);\n    r.width = r.height = s, r.style.cssText = `position: absolute;\nleft: ${(Y.stageW - s) / 2 * c(this, Sn) + s * (n.dx ?? 0)}px;\ntop: ${(Y.stageH - s) / 2 * c(this, Sn) + s * (n.dy ?? 0)}px;`, r.classList.add(\"sn_toast\", n.ease ?? \"sn_BounceInOut\"), n.ease || r.addEventListener(\"animationend\", () => e.removeChild(r), { once: !0, passive: !0 }), e.insertBefore(r, Ur.cvs);\n  }\n  setFire(t) {\n    this.fire = t;\n  }\n  addHook(t) {\n    c(this, bd).push(t);\n  }\n  titleSub(t) {\n  }\n  tglFlscr_sub() {\n  }\n  setTitleInfo(t) {\n    P(this, Yl, t), this.titleSub(c(this, Wl) + c(this, Yl));\n  }\n  decStr(t, e) {\n    return c(this, Vo).call(this, t, e).ret;\n  }\n  async dec(t, e) {\n    const { ret: r, ext_num: n } = c(this, Vo).call(this, t, e), s = c(this, Km)[n];\n    return s != null && s.fnc ? await s.fnc(new Blob([r], { type: s.mime })) : r;\n  }\n  get path_downloads() {\n    return this.$path_downloads;\n  }\n  get path_userdata() {\n    return this.$path_userdata;\n  }\n  canCapturePage(t, e) {\n    return !1;\n  }\n  async savePic(t, e) {\n  }\n  async appendFile(t, e, r) {\n  }\n  async ensureFileSync(t) {\n  }\n};\nlet Vh = Jm;\n$i = new WeakMap(), En = new WeakMap(), Sn = new WeakMap(), Ho = new WeakMap(), $o = new WeakMap(), na = new WeakMap(), sa = new WeakMap(), aa = new WeakMap(), Ym = new WeakMap(), qm = new WeakMap(), bd = new WeakMap(), Wl = new WeakMap(), Zm = new WeakMap(), Yl = new WeakMap(), Vo = new WeakMap(), Km = new WeakMap(), Xo = new WeakMap(), ql = new WeakMap(), K(Vh, \"VALNM_CFG_NS\", \"const.sn.cfg.ns\"), E(Vh, qm, {\n  // Thanks ICOOON MONO https://icooon-mono.com/ 、 https://vectr.com/ で 640x640化、ImageOptim経由、Base64エンコーダー https://lab.syncer.jp/Tool/Base64-encode/ \n  接続: { dx: -1, dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMCAyOTJ2NTUuODhoMTI3LjEzYzEyLjM3IDQ2IDU0LjEyIDc5Ljg3IDEwNCA3OS44N2g3Ny44N3YtMjE1LjYyYy00Ni43MyAwLTcyLjY4IDAtNzcuODggMC00OS43NCAwLTkxLjYyIDMzLjg3LTEwMy45OSA3OS44Ny0xNi45NSAwLTU5LjMzIDAtMTI3LjEzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im01MTIuODggMjkyYy0xMi4zOC00Ni01NC4xMy03OS44Ny0xMDQtNzkuODctNS4yMSAwLTMxLjIxIDAtNzggMHYyMTUuNzRoNzcuODdjNDkuODggMCA5MS43NS0zMy44NyAxMDQtNzkuODdoMTI3LjI1di01NmMtNzYuMjcgMC0xMTguNjUgMC0xMjcuMTIgMHoiLz48L2RlZnM+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9IiMzYWFiZDIiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYiIvPjx1c2UgZmlsbD0iIzNhYWJkMiIgeGxpbms6aHJlZj0iI2MiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNjIi8+PC9zdmc+\" },\n  切断: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtNjQwIDMyMGMwIDE3Ni43My0xNDMuMjcgMzIwLTMyMCAzMjBzLTMyMC0xNDMuMjctMzIwLTMyMCAxNDMuMjctMzIwIDMyMC0zMjAgMzIwIDE0My4yNyAzMjAgMzIweiIvPjxwYXRoIGlkPSJiIiBkPSJtMTkxLjUzIDIyMS4yNGMtNDUuNjggMC04NC4wMSAzMS4wNC05NS4zIDczLjE2LTYuNDEgMC0zOC40OSAwLTk2LjIzIDB2NTEuMjFoOTYuMjNjMTEuMyA0Mi4xMSA0OS42MyA3My4xNiA5NS4zIDczLjE2aDcxLjMzdi00OC4yNGg1My43OHYtMTAxLjA1aC01My43OHYtNDguMjRjLTQyLjggMC02Ni41NyAwLTcxLjMzIDB6Ii8+PHBhdGggaWQ9ImMiIGQ9Im00NDguNDcgMjIxLjIzYy00Ljc2IDAtMjguNTMgMC03MS4zMyAwdjE5Ny41M2g3MS4zM2M0NS42OCAwIDgzLjk5LTMxLjA0IDk1LjI5LTczLjE1aDk2LjI0di01MS4yMWgtOTYuMjRjLTMzLjA4LTQ4Ljc4LTY0Ljg0LTczLjE3LTk1LjI5LTczLjE3eiIvPjwvZGVmcz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0iI2RmNTY1NiIgeGxpbms6aHJlZj0iI2IiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSIjZGY1NjU2IiB4bGluazpocmVmPSIjYyIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2MiLz48L3N2Zz4=\" },\n  再生: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yNTguODMgMTExLjA1Yy0xLjI5Ljc5LTIuOTMuODMtNC4yNi4wNC0xLjI5LS43NC0yLjExLTIuMTItMi4xMS0zLjY3IDAtNy4xNiAwLTQyLjk3IDAtMTA3LjQzczAtMTAwLjI3IDAtMTA3LjQzYzAtMS41My44Mi0yLjkzIDIuMTEtMy42OCAxLjMzLS43NiAyLjk3LS43MiA0LjI2LjA0IDE4IDEwLjc1IDE2MiA5Ni43MSAxODAgMTA3LjQ2IDEuMjkuNzMgMi4wNSAyLjE0IDIuMDUgMy42MSAwIDEuNDktLjc2IDIuODgtMi4wNSAzLjYzLTM2IDIxLjQ5LTE2MiA5Ni42OS0xODAgMTA3LjQzeiIvPjwvZGVmcz48cGF0aCBkPSJtMTU0LjU3IDE3MC4xOWgzNDYuMTV2MzA3LjY5aC0zNDYuMTV6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一時停止: { dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0yMDAgMTAwdi0yMDBoODB2MjAwem0xNjAgMHYtMjAwaDgwdjIwMHoiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxODAuNDFoMzUyLjR2MjgyLjY5aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  注意: { ease: \"sn_HopIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMzQzLjM0IDI5LjJjLTEwLjM3LTE3Ljk3LTM2LjMxLTE3Ljk3LTQ2LjY5IDAtMjkuMyA1MC43NS0yNjMuNyA0NTYuNzQtMjkzIDUwNy40OS0xMC4zNyAxNy45NyAyLjU5IDQwLjQ0IDIzLjM0IDQwLjQ0aDU4Ni4wMWMyMC43NSAwIDMzLjcyLTIyLjQ2IDIzLjM1LTQwLjQ0LTU4LjYtMTAxLjUtMjYzLjctNDU2Ljc0LTI5My4wMS01MDcuNDl6bS0yMy4zNCA0ODIuODNjLTE0LjUyIDAtMjYuMjktMi43MS0yNi4yOS02LjA2IDAtNC4yMSAwLTM3Ljg2IDAtNDIuMDcgMC0zLjM1IDExLjc3LTYuMDcgMjYuMjktNi4wN3MyNi4yOSAyLjcyIDI2LjI5IDYuMDd2NDIuMDdjLTcuODQgNC4wNC0xNi42MSA2LjA2LTI2LjI5IDYuMDZ6bTIxLjk5LTEwMy44NGMwIDUuNDMtOS44NSA5LjgzLTIxLjk5IDkuODMtMTIuMTUgMC0yMS45OS00LjQtMjEuOTktOS44MyAwLS4xMy4wNy0uMjUuMDgtLjM4LTEuMzctMTcuNTYtMTIuMy0xNTguMDYtMTMuNjctMTc1LjYyIDAtNS40MyAxNS45My05Ljg0IDM1LjU4LTkuODRzMzUuNTggNC40MSAzNS41OCA5Ljg0Yy0uOTEgMTEuNy01LjQ3IDcwLjI1LTEzLjY3IDE3NS42Mi4wNi4xNi4wOC4yOS4wOC4zOHoiLz48L2RlZnM+PHBhdGggZD0ibTI0MS4yOSAxOTEuNDRoMTQ1LjQ5djM1MS42NmgtMTQ1LjQ5eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iI2QyYmYzYSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  一歩進む: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem0zNzYuOTMgOTEuOTdjMC01My41MSAwLTgzLjI0IDAtODkuMTktLjE1LjE0LS4yNS4zNC0uNDQuNDUtMTYuMTEgOS42Mi0xNDQuOTUgODYuNTQtMTYxLjA2IDk2LjE1LTEuMTUuNjktMi42Mi43My0zLjgxLjAyLTEuMTUtLjY0LTEuODktMS44OS0xLjg5LTMuMjggMC02LjQxIDAtMzguNDQgMC05Ni4xMSAwLTU3LjY5IDAtODkuNzQgMC05Ni4xNSAwLTEuMzUuNzQtMi42MiAxLjg5LTMuMjkgMS4xOS0uNjggMi42Ni0uNjQgMy44MS4wNCAxNi4xMSA5LjYyIDE0NC45NSA4Ni41NCAxNjEuMDYgOTYuMTYuMTkuMS4yOS4zMS40NC40NSAwLTYuMTMgMC0zNi43NyAwLTkxLjkyaDUzLjMydjE4Ni42N3oiLz48L2RlZnM+PHBhdGggZD0ibTE0Ny40OSAxNTQuMmgzNTIuNHYzMDguOWgtMzUyLjR6IiBmaWxsPSIjZmZmIi8+PHVzZSBmaWxsPSIjMmUyZTJlIiB4bGluazpocmVmPSIjYSIvPjx1c2UgZmlsbD0ibm9uZSIgeGxpbms6aHJlZj0iI2EiLz48L3N2Zz4=\" },\n  一歩戻る: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjBjMCAxNzYuNzIgMTQzLjI4IDMyMCAzMjAgMzIwczMyMC0xNDMuMjggMzIwLTMyMC0xNDMuMjgtMzIwLTMyMC0zMjAtMzIwIDE0My4yOC0zMjAgMzIwem00MzAuMjcgOTYuMTRjMCAxLjM1LS43NCAyLjYyLTEuODkgMy4yOC0xLjE5LjY5LTIuNjYuNjUtMy44MS0uMDMtMTYuMTEtOS42Mi0xNDQuOTUtODYuNTQtMTYxLjA1LTk2LjE2LS4yLS4xLS4yOS0uMzEtLjQ1LS40NXY5MS45MmgtNTMuMzJ2LTE4Ni42N2g1My4zMnY4OS4xOWMuMTYtLjE0LjI1LS4zNC40NS0uNDUgMTYuMS05LjYyIDE0NC45NC04Ni41NCAxNjEuMDUtOTYuMTYgMS4xNS0uNjggMi42Mi0uNzIgMy44MS0uMDEgMS4xNS42NCAxLjg5IDEuODkgMS44OSAzLjI4djk2LjExeiIvPjwvZGVmcz48cGF0aCBkPSJtMTQ3LjQ5IDE1NC4yaDM1Mi40djMwOC45aC0zNTIuNHoiIGZpbGw9IiNmZmYiLz48dXNlIGZpbGw9IiMyZTJlMmUiIHhsaW5rOmhyZWY9IiNhIi8+PHVzZSBmaWxsPSJub25lIiB4bGluazpocmVmPSIjYSIvPjwvc3ZnPg==\" },\n  ステップイン: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMTkuOTljMCAxNzYuNzQgMTQzLjI3IDMyMC4wMSAzMjAuMDEgMzIwLjAxIDE3Ni43MiAwIDMxOS45OS0xNDMuMjcgMzE5Ljk5LTMyMC4wMSAwLTE3Ni43Mi0xNDMuMjctMzE5Ljk5LTMxOS45OS0zMTkuOTktMTc2Ljc0IDAtMzIwLjAxIDE0My4yNy0zMjAuMDEgMzE5Ljk5em0xNTMuMDUtMjkuNzIgNTUuMTItNTUuMTMgMTExLjg0IDExMS44MiAxMTEuODItMTExLjgyIDU1LjEyIDU1LjEyLTE2Ni45NCAxNjYuOTd6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" },\n  ステップアウト: { ease: \"sn_BounceIn\", dat: \"PHN2ZyBoZWlnaHQ9IjY0MCIgcHJlc2VydmVBc3BlY3RSYXRpbz0ieE1pZFlNaWQgbWVldCIgdmlld0JveD0iMCAwIDY0MCA2NDAiIHdpZHRoPSI2NDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxwYXRoIGlkPSJhIiBkPSJtMCAzMjAuMDFjMCAxNzYuNzIgMTQzLjI3IDMxOS45OSAzMTkuOTkgMzE5Ljk5IDE3Ni43NCAwIDMyMC4wMS0xNDMuMjcgMzIwLjAxLTMxOS45OSAwLTE3Ni43NC0xNDMuMjctMzIwLjAxLTMyMC4wMS0zMjAuMDEtMTc2LjcyIDAtMzE5Ljk5IDE0My4yNy0zMTkuOTkgMzIwLjAxem0zMTkuOTktMjYuOTgtMTExLjgyIDExMS44My01NS4xMi01NS4xMyAxNjYuOTQtMTY2Ljk2IDE2Ni45NiAxNjYuOTYtNTUuMTIgNTUuMTN6Ii8+PC9kZWZzPjxwYXRoIGQ9Im0xNDcuNDkgMTU0LjJoMzUyLjR2MzA4LjloLTM1Mi40eiIgZmlsbD0iI2ZmZiIvPjx1c2UgZmlsbD0iIzJlMmUyZSIgeGxpbms6aHJlZj0iI2EiLz48dXNlIGZpbGw9Im5vbmUiIHhsaW5rOmhyZWY9IiNhIi8+PC9zdmc+\" }\n});\nwindow.Buffer = buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer;\nclass $4 extends Vh {\n  constructor() {\n    super(...arguments);\n    K(this, \"isApp\", !0);\n  }\n  async loadPath(e, r) {\n    await super.loadPath(e, r);\n    const n = this.arg.cur + \"path.json\", s = await this.readFileSync(n), a = JSON.parse(this.decStr(n, s));\n    for (const [o, u] of Object.entries(a)) {\n      const l = e[o] = u;\n      for (const [h, d] of Object.entries(l))\n        h !== \":cnt\" && (l[h] = this.arg.cur + d);\n    }\n  }\n  init(e, r, n, s) {\n    const a = super.init(e, r, n, s);\n    return document.body.style.backgroundColor = \"#000\", a;\n  }\n  async savePic(e, r) {\n    const n = r.slice(r.indexOf(\",\", 20) + 1);\n    try {\n      this.ensureFileSync(e), await this.writeFileSync(e, buffer__WEBPACK_IMPORTED_MODULE_1__.Buffer.from(n, \"base64\")), Y.debugLog && console.log(`画像ファイル ${e} を保存しました`);\n    } catch (s) {\n      throw s;\n    }\n  }\n  async readFileSync(e) {\n    return \"\";\n  }\n  async writeFileSync(e, r, n) {\n  }\n}\nconst ae = window.to_app;\nvar ir, xd, Zl, Kl, av;\nclass Y4 extends $4 {\n  constructor(e = {}, r = { cur: \"prj/\", crypto: !1, dip: \"\" }) {\n    super(e, r);\n    E(this, Kl);\n    E(this, ir, {\n      getAppPath: \"\",\n      isPackaged: !1,\n      downloads: \"\",\n      userData: \"\",\n      getVersion: \"\",\n      env: {},\n      platform: \"\",\n      arch: \"\"\n    });\n    K(this, \"readFileSync\", ae.readFileSync);\n    K(this, \"writeFileSync\", ae.writeFileSync);\n    K(this, \"appendFile\", ae.appendFile);\n    K(this, \"ensureFileSync\", ae.ensureFileSync);\n    K(this, \"$path_userdata\", \"\");\n    K(this, \"$path_downloads\", \"\");\n    E(this, xd, () => ae.Store({\n      cwd: this.$path_userdata + \"storage\",\n      name: this.arg.crypto ? \"data_\" : \"data\",\n      encryptionKey: this.arg.crypto ? this.stk() : void 0\n    }));\n    E(this, Zl, void 0);\n    K(this, \"copyBMFolder\", async (e, r) => {\n      const n = `${this.$path_userdata}storage/${e}/`, s = `${this.$path_userdata}storage/${r}/`;\n      await ae.existsSync(n) && ae.copySync(n, s);\n    });\n    K(this, \"eraseBMFolder\", async (e) => {\n      await ae.removeSync(`${this.$path_userdata}storage/${e}/`);\n    });\n    // アプリの終了\n    K(this, \"close\", () => (ae.win_close(), !1));\n    // プレイデータをエクスポート\n    K(this, \"_export\", () => (ae.zip(\n      this.$path_userdata + \"storage/\",\n      this.$path_downloads + (this.crypto ? \"\" : \"no_crypto_\") + this.cfg.getNs() + rc(\"-\", \"_\", \"\") + \".spd\"\n    ), Y.debugLog && console.log(\"プレイデータをエクスポートしました\"), this.fire(\"sn:exported\", new Event(\"click\")), !1));\n    // プレイデータをインポート\n    K(this, \"_import\", () => {\n      const e = this.flush;\n      return new Promise((r, n) => {\n        const s = document.createElement(\"input\");\n        s.type = \"file\", s.accept = \".spd, text/plain\", s.onchange = () => {\n          s.files ? r(s.files[0].path) : n();\n        }, s.click();\n      }).then(async (r) => {\n        this.flush = () => {\n        }, ae.unzip(r, this.$path_userdata + \"storage/\"), await c(this, xd).call(this);\n        const n = await ae.Store_get();\n        this.data.sys = n.sys, this.data.mark = n.mark, this.data.kidoku = n.kidoku, this.flush = e, this.flush(), this.val.updateData(n), Y.debugLog && console.log(\"プレイデータをインポートしました\"), this.fire(\"sn:imported\", new Event(\"click\"));\n      }), !1;\n    });\n    // ＵＲＬを開く\n    K(this, \"navigate_to\", (e) => {\n      const { url: r } = e;\n      if (!r)\n        throw \"[navigate_to] urlは必須です\";\n      return ae.navigate_to(r), !1;\n    });\n    // 全画面状態切替\n    K(this, \"tglFlscr_sub\", async () => ae.setSimpleFullScreen(\n      this.isFullScr = !await ae.isSimpleFullScreen()\n    ));\n    // 更新チェック\n    K(this, \"update_check\", (e) => {\n      const { url: r } = e;\n      if (!r)\n        throw \"[update_check] urlは必須です\";\n      if (r.at(-1) !== \"/\")\n        throw \"[update_check] urlの最後は/です\";\n      return Y.debugLog && zt.myTrace(`[update_check] url=${r}`, \"D\"), (async () => {\n        let n = {}, s = \"\", a = \"\";\n        const o = await this.fetch(r + \"_index.json\");\n        if (o.ok)\n          Y.debugLog && zt.myTrace(\"[update_check] _index.jsonを取得しました\", \"D\"), n = await o.json(), a = n.version;\n        else {\n          const d = await this.fetch(r + `latest${Y.isMac ? \"-mac\" : \"\"}.yml`);\n          if (!d.ok) {\n            Y.debugLog && zt.myTrace(\"[update_check] [update_check] .ymlが見つかりません\");\n            return;\n          }\n          Y.debugLog && zt.myTrace(\"[update_check] .ymlを取得しました\", \"D\"), s = await d.text();\n          const f = /version: (.+)/.exec(s);\n          if (!f)\n            throw \"[update_check] .yml に version が見つかりません\";\n          [, a] = f;\n        }\n        const u = c(this, ir).getVersion;\n        if (Y.debugLog && zt.myTrace(`[update_check] 現在ver=${u} 新規ver=${a}`, \"D\"), a === u) {\n          Y.debugLog && zt.myTrace(\"[update_check] バージョン更新なし\", \"I\");\n          return;\n        }\n        const l = {\n          title: \"アプリ更新\",\n          icon: c(this, ir).getAppPath + \"/app/icon.png\",\n          buttons: [\"OK\", \"Cancel\"],\n          defaultId: 0,\n          cancelId: 1,\n          message: `アプリ【${this.cfg.oCfg.book.title}】に更新があります。\nダウンロードしますか？`,\n          detail: `現在 NOW ver ${u}\n新規 NEW ver ${a}`\n        }, { response: h } = await ae.showMessageBox(l);\n        if (!(h > 0)) {\n          if (Y.debugLog && zt.myTrace(\"[update_check] アプリダウンロード開始\", \"D\"), o.ok) {\n            const d = c(this, ir).platform + \"_\" + c(this, ir).arch, { cn: f, path: p } = n[d];\n            if (f)\n              await O(this, Kl, av).call(this, r, d + \"-\" + f, p);\n            else {\n              let v = \"\";\n              const g = new RegExp(\"^\" + c(this, ir).platform + \"_\"), m = Object.entries(n).flatMap(([_, { path: b, cn: w }]) => g.test(_) ? (v += `\n- ` + b, () => O(this, Kl, av).call(this, r, _ + \"-\" + w, b)) : []);\n              l.message = `CPU = ${c(this, ir).arch}\nに対応するファイルが見つかりません。同じOSのファイルをすべてダウンロードしますか？`, l.detail = m.length + \" 個ファイルがあります\" + v;\n              const { response: y } = await ae.showMessageBox(l);\n              if (y > 0)\n                return;\n              await Promise.allSettled(m);\n            }\n          } else {\n            const d = /path: (.+)/.exec(s);\n            if (!d)\n              throw \"[update_check] path が見つかりません\";\n            const [, f] = d;\n            Y.debugLog && zt.myTrace(`[update_check] path=${f}`, \"D\");\n            const p = /sha512: (.+)/.exec(s);\n            if (!p)\n              throw \"[update_check] sha512 が見つかりません\";\n            const [, v] = p;\n            Y.debugLog && zt.myTrace(`[update_check] sha=${v}=`, \"D\");\n            const [, g, m] = /(.+)(\\.\\w+)/.exec(f) ?? [\"\", \"\", \"\"];\n            await O(this, Kl, av).call(this, r, g + \"-\" + c(this, ir).arch + m, f);\n          }\n          Y.debugLog && zt.myTrace(\"アプリファイルを保存しました\", \"D\"), l.buttons.pop(), l.message = `アプリ【${this.cfg.oCfg.book.title}】の更新パッケージを\nダウンロードしました`, ae.showMessageBox(l);\n        }\n      })(), !1;\n    });\n    // アプリウインドウ設定\n    K(this, \"window\", (e) => {\n      const r = tt(e, \"x\", Number(this.val.getVal(\"sys:const.sn.nativeWindow.x\", 0))), n = tt(e, \"y\", Number(this.val.getVal(\"sys:const.sn.nativeWindow.y\", 0)));\n      return ae.window(vt(e, \"centering\", !1), r, n, Y.stageW, Y.stageH), this.val.setVal_Nochk(\"sys\", \"const.sn.nativeWindow.x\", r), this.val.setVal_Nochk(\"sys\", \"const.sn.nativeWindow.y\", n), this.flush(), !1;\n    });\n    globalThis.addEventListener(\"DOMContentLoaded\", async () => this.loaded(e, r), { once: !0, passive: !0 });\n  }\n  async loaded(e, r) {\n    await super.loaded(e, r), P(this, ir, await ae.getInfo()), Y.isPackaged = c(this, ir).isPackaged, this.arg = r = { ...r, cur: c(this, ir).getAppPath.replaceAll(\"\\\\\", \"/\") + (Y.isPackaged ? \"/doc/\" : \"/\") + r.cur }, this.$path_downloads = c(this, ir).downloads.replaceAll(\"\\\\\", \"/\") + \"/\", Y.isDbg = !!c(this, ir).env.SKYNOVEL_DBG && !Y.isPackaged, Y.isDbg && (this.extPort = ni(c(this, ir).env.SKYNOVEL_PORT ?? \"3776\")), this.run();\n  }\n  initVal(e, r, n) {\n    r[\"const.sn.isDebugger\"] = !1, r[\"const.sn.screenResolutionX\"] = screen.width, r[\"const.sn.screenResolutionY\"] = screen.height, this.$path_userdata = Y.isDbg ? c(this, ir).getAppPath.slice(0, -3) + \".vscode/\" : c(this, ir).userData.replaceAll(\"\\\\\", \"/\") + \"/\", this.flush = () => ae.flush(this.data), c(this, xd).call(this).then(async () => {\n      const s = r[\"const.sn.isFirstBoot\"] = await ae.Store_isEmpty();\n      if (s)\n        this.data.sys = e.sys, this.data.mark = e.mark, this.data.kidoku = e.kidoku, this.flush();\n      else {\n        const u = await ae.Store_get();\n        this.data.sys = u.sys, this.data.mark = u.mark, this.data.kidoku = u.kidoku;\n      }\n      const a = this.data.sys[\"const.sn.nativeWindow.x\"] ?? 0, o = this.data.sys[\"const.sn.nativeWindow.y\"] ?? 0;\n      ae.window(s, a, o, Y.stageW, Y.stageH), ae.on(\"save_win_pos\", (u, l, h) => {\n        this.val.setVal_Nochk(\"sys\", \"const.sn.nativeWindow.x\", l), this.val.setVal_Nochk(\"sys\", \"const.sn.nativeWindow.y\", h), this.flush();\n      }), n(this.data);\n    });\n  }\n  async run() {\n    c(this, Zl) && (c(this, Zl).destroy(10), await new Promise((r) => setTimeout(r, 10))), P(this, Zl, new Ur(this));\n  }\n  init(e, r, n, s) {\n    const a = super.init(e, r, n, s), o = new Event(\"click\");\n    return ae.on(\"fire\", (u, l) => s.fire(l, o)), this.cfg.oCfg.debug.devtool ? ae.openDevTools() : ae.win_ev_devtools_opened(() => {\n      console.error(\"DevToolは禁止されています。許可する場合は【プロジェクト設定】の【devtool】をONに。\"), s.destroy();\n    }), a;\n  }\n  cvsResize() {\n    super.cvsResize();\n    const e = Ur.cvs, r = e.parentElement.style, n = e.style;\n    this.isFullScr ? (r.position = \"\", r.width = \"\", r.height = \"\", n.position = \"fixed\", n.left = `${this.ofsLeft4elm}px`, n.top = `${this.ofsTop4elm}px`) : (r.position = \"relative\", r.width = `${this.cvsWidth}px`, r.height = `${this.cvsHeight}px`, n.position = \"relative\", n.left = \"\", n.top = \"\");\n  }\n  // タイトル指定\n  titleSub(e) {\n    ae.win_setTitle(e);\n  }\n  canCapturePage(e, r) {\n    return ae.capturePage(e).then(() => r()), !0;\n  }\n}\nir = new WeakMap(), xd = new WeakMap(), Zl = new WeakMap(), Kl = new WeakSet(), av = async function(e, r, n) {\n  Y.debugLog && zt.myTrace(`[update_check] アプリファイルDL試行... url=${e + r}`, \"D\");\n  const s = await this.fetch(e + r);\n  if (!s.ok) {\n    Y.debugLog && zt.myTrace(`[update_check] アプリファイルが見つかりません url=${e + n}`);\n    return;\n  }\n  const a = c(this, ir).downloads + \"/\" + n;\n  Y.debugLog && zt.myTrace(`[update_check] pathDL=${a}`, \"D\");\n  const o = await s.arrayBuffer();\n  await this.writeFileSync(a, new DataView(o));\n};\n\n//# sourceMappingURL=app.js.map\n\n\n//# sourceURL=webpack://uc/./node_modules/@famibee/skynovel/dist/app.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://uc/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://uc/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css":
/*!****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css ***!
  \****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg== */ \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg==\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg== */ \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg==\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII= */ \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII=\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(/*! data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII= */ \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII=\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"html,\\nbody {\\n  min-height: 100%;\\n}\\n.humane,\\n.humane-bigbox {\\n  position: fixed;\\n  -moz-transition: all 0.3s ease-out;\\n  -webkit-transition: all 0.3s ease-out;\\n  -ms-transition: all 0.3s ease-out;\\n  -o-transition: all 0.3s ease-out;\\n  transition: all 0.3s ease-out;\\n  z-index: 100000;\\n  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\\n}\\n.humane,\\n.humane-bigbox {\\n  font-family: Ubuntu, Verdana, sans-serif;\\n  line-height: 40px;\\n  font-size: 35px;\\n  top: 25%;\\n  left: 25%;\\n  opacity: 0;\\n  width: 50%;\\n  min-height: 40px;\\n  padding: 30px;\\n  text-align: center;\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #000), color-stop(1, rgba(0,0,0,0.9))) no-repeat;\\n  background: -moz-linear-gradient(top, #000 0%, rgba(0,0,0,0.9) 100%) no-repeat;\\n  background: -webkit-linear-gradient(top, #000 0%, rgba(0,0,0,0.9) 100%) no-repeat;\\n  background: -ms-linear-gradient(top, #000 0%, rgba(0,0,0,0.9) 100%) no-repeat;\\n  background: -o-linear-gradient(top, #000 0%, rgba(0,0,0,0.9) 100%) no-repeat;\\n  background: linear-gradient(top, #000 0%, rgba(0,0,0,0.9) 100%) no-repeat;\\n  *background-color: #000;\\n  color: #fff;\\n  -webkit-border-radius: 15px;\\n  border-radius: 15px;\\n  text-shadow: 0 -1px 1px #ddd;\\n  -webkit-box-shadow: 0 15px 15px -15px #000;\\n  box-shadow: 0 15px 15px -15px #000;\\n  -moz-transform: scale(0.1);\\n  -webkit-transform: scale(0.1);\\n  -ms-transform: scale(0.1);\\n  -o-transform: scale(0.1);\\n  transform: scale(0.1);\\n}\\n.humane p,\\n.humane-bigbox p,\\n.humane ul,\\n.humane-bigbox ul {\\n  margin: 0;\\n  padding: 0;\\n}\\n.humane ul,\\n.humane-bigbox ul {\\n  list-style: none;\\n}\\n.humane.humane-bigbox-info,\\n.humane-bigbox.humane-bigbox-info {\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #000064), color-stop(1, rgba(0,0,100,0.9))) no-repeat;\\n  background: -moz-linear-gradient(top, #000064 0%, rgba(0,0,100,0.9) 100%) no-repeat;\\n  background: -webkit-linear-gradient(top, #000064 0%, rgba(0,0,100,0.9) 100%) no-repeat;\\n  background: -ms-linear-gradient(top, #000064 0%, rgba(0,0,100,0.9) 100%) no-repeat;\\n  background: -o-linear-gradient(top, #000064 0%, rgba(0,0,100,0.9) 100%) no-repeat;\\n  background: linear-gradient(top, #000064 0%, rgba(0,0,100,0.9) 100%) no-repeat;\\n  *background-color: #030;\\n}\\n.humane.humane-bigbox-success,\\n.humane-bigbox.humane-bigbox-success {\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \");\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #006400), color-stop(1, rgba(0,100,0,0.9))) no-repeat;\\n  background: -moz-linear-gradient(top, #006400 0%, rgba(0,100,0,0.9) 100%) no-repeat;\\n  background: -webkit-linear-gradient(top, #006400 0%, rgba(0,100,0,0.9) 100%) no-repeat;\\n  background: -ms-linear-gradient(top, #006400 0%, rgba(0,100,0,0.9) 100%) no-repeat;\\n  background: -o-linear-gradient(top, #006400 0%, rgba(0,100,0,0.9) 100%) no-repeat;\\n  background: linear-gradient(top, #006400 0%, rgba(0,100,0,0.9) 100%) no-repeat;\\n  *background-color: #030;\\n}\\n.humane.humane-bigbox-error,\\n.humane-bigbox.humane-bigbox-error {\\n  background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \");\\n  background: -webkit-gradient(linear, left top, left bottom, color-stop(0, #640000), color-stop(1, rgba(100,0,0,0.9))) no-repeat;\\n  background: -moz-linear-gradient(top, #640000 0%, rgba(100,0,0,0.9) 100%) no-repeat;\\n  background: -webkit-linear-gradient(top, #640000 0%, rgba(100,0,0,0.9) 100%) no-repeat;\\n  background: -ms-linear-gradient(top, #640000 0%, rgba(100,0,0,0.9) 100%) no-repeat;\\n  background: -o-linear-gradient(top, #640000 0%, rgba(100,0,0,0.9) 100%) no-repeat;\\n  background: linear-gradient(top, #640000 0%, rgba(100,0,0,0.9) 100%) no-repeat;\\n  *background-color: #300;\\n}\\n.humane.humane-animate,\\n.humane-bigbox.humane-bigbox-animate {\\n  opacity: 1;\\n  -moz-transform: scale(1);\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  -o-transform: scale(1);\\n  transform: scale(1);\\n}\\n.humane.humane-animate:hover,\\n.humane-bigbox.humane-bigbox-animate:hover {\\n  opacity: 0.6;\\n  -moz-transform: scale(0.8);\\n  -webkit-transform: scale(0.8);\\n  -ms-transform: scale(0.8);\\n  -o-transform: scale(0.8);\\n  transform: scale(0.8);\\n}\\n.humane.humane-js-animate,\\n.humane-bigbox.humane-bigbox-js-animate {\\n  opacity: 1;\\n  -moz-transform: scale(1);\\n  -webkit-transform: scale(1);\\n  -ms-transform: scale(1);\\n  -o-transform: scale(1);\\n  transform: scale(1);\\n}\\n.humane.humane-js-animate:hover,\\n.humane-bigbox.humane-bigbox-js-animate:hover {\\n  opacity: 0.6;\\n  filter: progid:DXImageTransform.Microsoft.Alpha(Opacity=60);\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://uc/./node_modules/humane-js/themes/bigbox.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://uc/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://uc/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://uc/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/gamepad.js/gamepad.js":
/*!********************************************!*\
  !*** ./node_modules/gamepad.js/gamepad.js ***!
  \********************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(()=>(()=>{var t={944:function(t){var e;e=()=>(()=>{\"use strict\";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};function n(t){return n=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},n(t)}function r(t,e){var n=\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(!n){if(Array.isArray(t)||(n=i(t))||e&&t&&\"number\"==typeof t.length){n&&(t=n);var r=0,o=function(){};return{s:o,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:o}}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}var a,u=!0,s=!1;return{s:function(){n=n.call(t)},n:function(){var t=n.next();return u=t.done,t},e:function(t){s=!0,a=t},f:function(){try{u||null==n.return||n.return()}finally{if(s)throw a}}}}function o(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=null==t?null:\"undefined\"!=typeof Symbol&&t[Symbol.iterator]||t[\"@@iterator\"];if(null!=n){var r,o,i,a,u=[],s=!0,l=!1;try{if(i=(n=n.call(t)).next,0===e){if(Object(n)!==n)return;s=!1}else for(;!(s=(r=i.call(n)).done)&&(u.push(r.value),u.length!==e);s=!0);}catch(t){l=!0,o=t}finally{try{if(!s&&null!=n.return&&(a=n.return(),Object(a)!==a))return}finally{if(l)throw o}}return u}}(t,e)||i(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function i(t,e){if(t){if(\"string\"==typeof t)return a(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return\"Object\"===n&&t.constructor&&(n=t.constructor.name),\"Map\"===n||\"Set\"===n?Array.from(t):\"Arguments\"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(t,e):void 0}}function a(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function u(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}t.d(e,{default:()=>s});var s=function(){function t(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];u(this,t),this.strict=e,this.defaults=new Map,this.validators=new Map,this.types=new Map,this.optional=new Set,this.required=new Set}var e,i;return e=t,(i=[{key:\"allowExtra\",value:function(){return this.strict=!1,this}},{key:\"setDefaults\",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.defaults.set(r,i)})),this}},{key:\"setValidators\",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.validators.set(r,i)})),this}},{key:\"setTypes\",value:function(t){var e=this;return Object.entries(t).forEach((function(t){var n=o(t,2),r=n[0],i=n[1];return e.types.set(r,i)})),this}},{key:\"setOptional\",value:function(t){var e=this;return t.forEach((function(t){return e.optional.add(t)})),this}},{key:\"setRequired\",value:function(t){var e=this;return t.forEach((function(t){return e.required.add(t)})),this}},{key:\"resolve\",value:function(t){return this.validate(Object.assign(this.getDefaults(),t))}},{key:\"getDefaults\",value:function(){var t,e={},n=r(this.defaults);try{for(n.s();!(t=n.n()).done;){var i=o(t.value,2),a=i[0],u=i[1];e[a]=u}}catch(t){n.e(t)}finally{n.f()}return e}},{key:\"validate\",value:function(t){for(var e in t)this.validators.has(e)&&(t[e]=this.validators.get(e)(t[e]));for(var n in t){if(!this.optionExists(n))throw new Error('Unkown option \"'.concat(n,'\".'));this.checkType(n,t[n])}var o,i=r(this.required.values());try{for(i.s();!(o=i.n()).done;){var a=o.value;if(void 0===t[a])throw new Error('Option \"'.concat(a,'\" is required.'))}}catch(t){i.e(t)}finally{i.f()}return t}},{key:\"checkType\",value:function(t,e){if(this.types.has(t)){var r=this.types.get(t),o=n(e);if(o!==r)throw new Error('Wrong value for option \"'.concat(t,'\": expected type \"').concat(r,'\", got \"').concat(o,'\".'))}}},{key:\"optionExists\",value:function(t){return!this.strict||this.defaults.has(t)||this.validators.has(t)||this.optional.has(t)||this.required.has(t)||this.types.has(t)}}])&&function(t,e){for(var r=0;r<e.length;r++){var o=e[r];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(t,(i=function(t,e){if(\"object\"!==n(t)||null===t)return t;var r=t[Symbol.toPrimitive];if(void 0!==r){var o=r.call(t,\"string\");if(\"object\"!==n(o))return o;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(o.key),\"symbol\"===n(i)?i:String(i)),o)}var i}(e.prototype,i),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();return e.default})(),t.exports=e()},162:function(t){t.exports=(()=>{\"use strict\";var t={d:(e,n)=>{for(var r in n)t.o(n,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{default:()=>n});var n=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this._events={},this.on=this.addEventListener,this.off=this.removeEventListener}var e;return(e=[{key:\"emit\",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t))for(var n=this._events[t],r={type:t,detail:e},o=n.length,i=0;i<o;i++)this.handle(n[i],r)}},{key:\"handle\",value:function(t,e){t(e)}},{key:\"addEventListener\",value:function(t,e){Object.prototype.hasOwnProperty.call(this._events,t)||(this._events[t]=[]),this._events[t].indexOf(e)<0&&this._events[t].push(e)}},{key:\"removeEventListener\",value:function(t,e){if(Object.prototype.hasOwnProperty.call(this._events,t)){var n=this._events[t],r=n.indexOf(e);r>=0&&n.splice(r,1),0===n.length&&delete this._events[t]}}}])&&function(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}(t.prototype,e),t}();return e.default})()}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var r={};return(()=>{\"use strict\";n.r(r),n.d(r,{GamepadHandler:()=>h,GamepadListener:()=>A});var t=n(162),e=n.n(t),o=n(944),i=n.n(o);function a(t){return a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},a(t)}function u(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function s(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,p(r.key),r)}}function l(t,e){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},l(t,e)}function c(t,e){if(e&&(\"object\"===a(e)||\"function\"==typeof e))return e;if(void 0!==e)throw new TypeError(\"Derived constructors may only return object or undefined\");return function(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}(t)}function f(t){return f=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},f(t)}function p(t){var e=function(t,e){if(\"object\"!==a(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,\"string\");if(\"object\"!==a(r))return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(t);return\"symbol\"===a(e)?e:String(e)}var d,y,v,h=function(t){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&l(t,e)}(p,t);var e,n,r,o,i,a=(o=p,i=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=f(o);if(i){var n=f(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return c(this,t)});function p(t,e){var n,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return u(this,p),(n=a.call(this)).index=t,n.gamepad=e,n.options=n.constructor.resolveOptions(r),n.axes=new Array(e.axes.length).fill(null),n.buttons=new Array(e.buttons.length).fill(null),n.initAxes(),n.initButtons(),n}return e=p,r=[{key:\"resolveOptions\",value:function(t){var e,n,r,o,i=t.axis,a=t.button;return{axis:this.optionResolver.resolve(null!==(e=null!==(n=null!=i?i:a)&&void 0!==n?n:t)&&void 0!==e?e:{}),button:this.optionResolver.resolve(null!==(r=null!==(o=null!=a?a:i)&&void 0!==o?o:t)&&void 0!==r?r:{})}}}],(n=[{key:\"initAxes\",value:function(){for(var t=this.axes.length,e=0;e<t;e++)this.axes[e]=this.resolveAxisValue(e)}},{key:\"initButtons\",value:function(){for(var t=this.buttons.length,e=0;e<t;e++)this.buttons[e]=this.resolveButtonValue(e)}},{key:\"update\",value:function(t){this.gamepad=t,this.updateAxis(),this.updateButtons()}},{key:\"updateAxis\",value:function(){for(var t=this.axes.length,e=0;e<t;e++)this.setAxisValue(e,this.resolveAxisValue(e))}},{key:\"updateButtons\",value:function(){for(var t=this.buttons.length,e=0;e<t;e++)this.setButtonValue(e,this.resolveButtonValue(e))}},{key:\"setAxisValue\",value:function(t,e){this.axes[t]!==e&&(this.axes[t]=e,this.emit(\"axis\",{gamepad:this.gamepad,index:this.index,axis:t,value:e}))}},{key:\"setButtonValue\",value:function(t,e){this.buttons[t]!==e&&(this.buttons[t]=e,this.emit(\"button\",{gamepad:this.gamepad,index:this.index,button:t,pressed:this.gamepad.buttons[t].pressed,value:e}))}},{key:\"resolveAxisValue\",value:function(t){var e=this.options.axis,n=e.deadZone,r=e.analog,o=e.precision,i=this.gamepad.axes[t];return n&&i<n&&i>-n?0:r?o?Math.round(i*o)/o:i:i>0?1:i<0?-1:0}},{key:\"resolveButtonValue\",value:function(t){var e=this.options.button,n=e.deadZone,r=e.analog,o=e.precision,i=this.gamepad.buttons[t].value;return n>0&&i<n&&i>-n?0:r?o?Math.round(i*o)/o:i:0===i?0:1}}])&&s(e.prototype,n),r&&s(e,r),Object.defineProperty(e,\"prototype\",{writable:!1}),p}(e());function b(t){return b=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},b(t)}function m(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,g(r.key),r)}}function g(t){var e=function(t,e){if(\"object\"!==b(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,\"string\");if(\"object\"!==b(r))return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(t);return\"symbol\"===b(e)?e:String(e)}d=h,y=\"optionResolver\",v=(new(i())).setDefaults({analog:!0,deadZone:0,precision:0}).setTypes({analog:\"boolean\",deadZone:\"number\",precision:\"number\"}).setValidators({deadZone:function(t){return Math.max(Math.min(t,1),0)},precision:function(t){return t>0?Math.pow(10,t):0}}),(y=p(y))in d?Object.defineProperty(d,y,{value:v,enumerable:!0,configurable:!0,writable:!0}):d[y]=v;var w=function(){function t(e){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.callback=e,this.frame=null,this.update=this.update.bind(this)}var e,n;return e=t,(n=[{key:\"setCallback\",value:function(t){this.callback=t}},{key:\"start\",value:function(){this.frame||(this.frame=window.requestAnimationFrame(this.update))}},{key:\"stop\",value:function(){this.frame&&(window.cancelAnimationFrame(this.frame),this.frame=null)}},{key:\"update\",value:function(){this.frame=window.requestAnimationFrame(this.update),this.callback()}}])&&m(e.prototype,n),Object.defineProperty(e,\"prototype\",{writable:!1}),t}();function x(t){return x=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},x(t)}function O(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function j(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,k(r.key),r)}}function k(t){var e=function(t,e){if(\"object\"!==x(t)||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,\"string\");if(\"object\"!==x(r))return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return String(t)}(t);return\"symbol\"===x(e)?e:String(e)}function S(t,e){return S=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},S(t,e)}function P(t,e){if(e&&(\"object\"===x(e)||\"function\"==typeof e))return e;if(void 0!==e)throw new TypeError(\"Derived constructors may only return object or undefined\");return E(t)}function E(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}function _(t){return _=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_(t)}var A=function(t){!function(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&S(t,e)}(a,t);var e,n,r,o,i=(r=a,o=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}(),function(){var t,e=_(r);if(o){var n=_(this).constructor;t=Reflect.construct(e,arguments,n)}else t=e.apply(this,arguments);return P(this,t)});function a(){var t,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(O(this,a),t=i.call(this),\"function\"!=typeof navigator.getGamepads)throw new Error(\"This browser does not support gamepad API.\");return t.options=e,t.onAxis=t.onAxis.bind(E(t)),t.update=t.update.bind(E(t)),t.start=t.start.bind(E(t)),t.stop=t.stop.bind(E(t)),t.discover=t.discover.bind(E(t)),t.onButton=t.onButton.bind(E(t)),t.handlers=new Array(4).fill(null),t.loop=new w(t.update),window.addEventListener(\"error\",t.stop),t}return e=a,(n=[{key:\"start\",value:function(){this.loop.start()}},{key:\"stop\",value:function(){this.loop.stop()}},{key:\"update\",value:function(){var t=navigator.getGamepads();this.discover(t[0],0),this.discover(t[1],1),this.discover(t[2],2),this.discover(t[3],3)}},{key:\"discover\",value:function(t,e){t?(null===this.handlers[e]&&this.registerHandler(e,t),this.handlers[e].update(t)):this.handlers[e]&&this.removeGamepad(e)}},{key:\"registerHandler\",value:function(t,e){var n=new h(t,e,this.options);this.handlers[t]=n,n.addEventListener(\"axis\",this.onAxis),n.addEventListener(\"button\",this.onButton),this.emit(\"gamepad:connected\",{index:t,gamepad:e}),this.emit(\"gamepad:\".concat(t,\":connected\"),{index:t,gamepad:e})}},{key:\"removeGamepad\",value:function(t){var e=this.handlers[t];e.removeEventListener(\"axis\",this.onAxis),e.removeEventListener(\"button\",this.onButton),this.handlers[t]=null,this.emit(\"gamepad:disconnected\",{index:t}),this.emit(\"gamepad:\".concat(t,\":disconnected\"),{index:t})}},{key:\"onAxis\",value:function(t){var e=t.detail.index;this.emit(\"gamepad:axis\",t.detail),this.emit(\"gamepad:\".concat(e,\":axis\"),t.detail),this.emit(\"gamepad:\".concat(e,\":axis:\").concat(t.detail.axis),t.detail)}},{key:\"onButton\",value:function(t){var e=t.detail.index;this.emit(\"gamepad:button\",t.detail),this.emit(\"gamepad:\".concat(e,\":button\"),t.detail),this.emit(\"gamepad:\".concat(e,\":button:\").concat(t.detail.button),t.detail)}}])&&j(e.prototype,n),Object.defineProperty(e,\"prototype\",{writable:!1}),a}(e())})(),r})()));\n\n//# sourceURL=webpack://uc/./node_modules/gamepad.js/gamepad.js?");

/***/ }),

/***/ "./node_modules/humane-js/humane.js":
/*!******************************************!*\
  !*** ./node_modules/humane-js/humane.js ***!
  \******************************************/
/***/ (function(module) {

eval("/**\n * humane.js\n * Humanized Messages for Notifications\n * @author Marc Harter (@wavded)\n * @example\n *   humane.log('hello world');\n * @license MIT\n * See more usage examples at: http://wavded.github.com/humane-js/\n */\n\n;!function (name, context, definition) {\n   if (true) module.exports = definition(name, context)\n   else {}\n}('humane', this, function (name, context) {\n   var win = window\n   var doc = document\n\n   var ENV = {\n      on: function (el, type, cb) {\n         'addEventListener' in win ? el.addEventListener(type,cb,false) : el.attachEvent('on'+type,cb)\n      },\n      off: function (el, type, cb) {\n         'removeEventListener' in win ? el.removeEventListener(type,cb,false) : el.detachEvent('on'+type,cb)\n      },\n      bind: function (fn, ctx) {\n         return function () { fn.apply(ctx,arguments) }\n      },\n      isArray: Array.isArray || function (obj) { return Object.prototype.toString.call(obj) === '[object Array]' },\n      config: function (preferred, fallback) {\n         return preferred != null ? preferred : fallback\n      },\n      transSupport: false,\n      useFilter: /msie [678]/i.test(navigator.userAgent), // sniff, sniff\n      _checkTransition: function () {\n         var el = doc.createElement('div')\n         var vendors = { webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' }\n\n         for (var vendor in vendors)\n            if (vendor + 'Transition' in el.style) {\n               this.vendorPrefix = vendors[vendor]\n               this.transSupport = true\n            }\n      }\n   }\n   ENV._checkTransition()\n\n   var Humane = function (o) {\n      o || (o = {})\n      this.queue = []\n      this.baseCls = o.baseCls || 'humane'\n      this.addnCls = o.addnCls || ''\n      this.timeout = 'timeout' in o ? o.timeout : 2500\n      this.waitForMove = o.waitForMove || false\n      this.clickToClose = o.clickToClose || false\n      this.timeoutAfterMove = o.timeoutAfterMove || false\n      this.container = o.container\n\n      try { this._setupEl() } // attempt to setup elements\n      catch (e) {\n        ENV.on(win,'load',ENV.bind(this._setupEl, this)) // dom wasn't ready, wait till ready\n      }\n   }\n\n   Humane.prototype = {\n      constructor: Humane,\n      _setupEl: function () {\n         var el = doc.createElement('div')\n         el.style.display = 'none'\n         if (!this.container){\n           if(doc.body) this.container = doc.body;\n           else throw 'document.body is null'\n         }\n         this.container.appendChild(el)\n         this.el = el\n         this.removeEvent = ENV.bind(function(){\n            var timeoutAfterMove = ENV.config(this.currentMsg.timeoutAfterMove,this.timeoutAfterMove)\n            if (!timeoutAfterMove){\n               this.remove()\n            } else {\n               setTimeout(ENV.bind(this.remove,this),timeoutAfterMove)\n            }\n         },this)\n\n         this.transEvent = ENV.bind(this._afterAnimation,this)\n         this._run()\n      },\n      _afterTimeout: function () {\n         if (!ENV.config(this.currentMsg.waitForMove,this.waitForMove)) this.remove()\n\n         else if (!this.removeEventsSet) {\n            ENV.on(doc.body,'mousemove',this.removeEvent)\n            ENV.on(doc.body,'click',this.removeEvent)\n            ENV.on(doc.body,'keypress',this.removeEvent)\n            ENV.on(doc.body,'touchstart',this.removeEvent)\n            this.removeEventsSet = true\n         }\n      },\n      _run: function () {\n         if (this._animating || !this.queue.length || !this.el) return\n\n         this._animating = true\n         if (this.currentTimer) {\n            clearTimeout(this.currentTimer)\n            this.currentTimer = null\n         }\n\n         var msg = this.queue.shift()\n         var clickToClose = ENV.config(msg.clickToClose,this.clickToClose)\n\n         if (clickToClose) {\n            ENV.on(this.el,'click',this.removeEvent)\n            ENV.on(this.el,'touchstart',this.removeEvent)\n         }\n\n         var timeout = ENV.config(msg.timeout,this.timeout)\n\n         if (timeout > 0)\n            this.currentTimer = setTimeout(ENV.bind(this._afterTimeout,this), timeout)\n\n         if (ENV.isArray(msg.html)) msg.html = '<ul><li>'+msg.html.join('<li>')+'</ul>'\n\n         this.el.innerHTML = msg.html\n         this.currentMsg = msg\n         this.el.className = this.baseCls\n         if (ENV.transSupport) {\n            this.el.style.display = 'block'\n            setTimeout(ENV.bind(this._showMsg,this),50)\n         } else {\n            this._showMsg()\n         }\n\n      },\n      _setOpacity: function (opacity) {\n         if (ENV.useFilter){\n            try{\n               this.el.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = opacity*100\n            } catch(err){}\n         } else {\n            this.el.style.opacity = String(opacity)\n         }\n      },\n      _showMsg: function () {\n         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)\n         if (ENV.transSupport) {\n            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-animate'\n         }\n         else {\n            var opacity = 0\n            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-js-animate'\n            this._setOpacity(0) // reset value so hover states work\n            this.el.style.display = 'block'\n\n            var self = this\n            var interval = setInterval(function(){\n               if (opacity < 1) {\n                  opacity += 0.1\n                  if (opacity > 1) opacity = 1\n                  self._setOpacity(opacity)\n               }\n               else clearInterval(interval)\n            }, 30)\n         }\n      },\n      _hideMsg: function () {\n         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)\n         if (ENV.transSupport) {\n            this.el.className = this.baseCls+' '+addnCls\n            ENV.on(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)\n         }\n         else {\n            var opacity = 1\n            var self = this\n            var interval = setInterval(function(){\n               if(opacity > 0) {\n                  opacity -= 0.1\n                  if (opacity < 0) opacity = 0\n                  self._setOpacity(opacity);\n               }\n               else {\n                  self.el.className = self.baseCls+' '+addnCls\n                  clearInterval(interval)\n                  self._afterAnimation()\n               }\n            }, 30)\n         }\n      },\n      _afterAnimation: function () {\n         if (ENV.transSupport) ENV.off(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)\n\n         if (this.currentMsg.cb) this.currentMsg.cb()\n         this.el.style.display = 'none'\n\n         this._animating = false\n         this._run()\n      },\n      remove: function (e) {\n         var cb = typeof e == 'function' ? e : null\n\n         ENV.off(doc.body,'mousemove',this.removeEvent)\n         ENV.off(doc.body,'click',this.removeEvent)\n         ENV.off(doc.body,'keypress',this.removeEvent)\n         ENV.off(doc.body,'touchstart',this.removeEvent)\n         ENV.off(this.el,'click',this.removeEvent)\n         ENV.off(this.el,'touchstart',this.removeEvent)\n         this.removeEventsSet = false\n\n         if (cb && this.currentMsg) this.currentMsg.cb = cb\n         if (this._animating) this._hideMsg()\n         else if (cb) cb()\n      },\n      log: function (html, o, cb, defaults) {\n         var msg = {}\n         if (defaults)\n           for (var opt in defaults)\n               msg[opt] = defaults[opt]\n\n         if (typeof o == 'function') cb = o\n         else if (o)\n            for (var opt in o) msg[opt] = o[opt]\n\n         msg.html = html\n         if (cb) msg.cb = cb\n         this.queue.push(msg)\n         this._run()\n         return this\n      },\n      spawn: function (defaults) {\n         var self = this\n         return function (html, o, cb) {\n            self.log.call(self,html,o,cb,defaults)\n            return self\n         }\n      },\n      create: function (o) { return new Humane(o) }\n   }\n   return new Humane()\n});\n\n\n//# sourceURL=webpack://uc/./node_modules/humane-js/humane.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://uc/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n//# sourceURL=webpack://uc/./node_modules/querystring/decode.js?");

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n//# sourceURL=webpack://uc/./node_modules/querystring/encode.js?");

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring/encode.js\");\n\n\n//# sourceURL=webpack://uc/./node_modules/querystring/index.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _css_loader_dist_cjs_js_bigbox_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./bigbox.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/humane-js/themes/bigbox.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_bigbox_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_bigbox_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _css_loader_dist_cjs_js_bigbox_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _css_loader_dist_cjs_js_bigbox_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://uc/./node_modules/humane-js/themes/bigbox.css?./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://uc/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n\n//# sourceURL=webpack://uc/./node_modules/url/node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/url/node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n//# sourceURL=webpack://uc/./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n//# sourceURL=webpack://uc/./node_modules/url/util.js?");

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII=":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII= ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII=\";\n\n//# sourceURL=webpack://uc/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNIYWD4z8QAJRhQCSLEyNQ2uMQYUcX+DyKnUVdsQJyBLTgZqecF6hpPVALBaS+ZdtDYeAYGBgYA9vA6v4OR3MkAAAAASUVORK5CYII=?");

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII=":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII= ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII=\";\n\n//# sourceURL=webpack://uc/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAPklEQVQokWNgSGH4z8TAACEYUAkixMjUNsjEGFHF/g8ip1FVbGCcgS04GannBaoaT1wCwWkvmXbQ2HgGBgYA8Yw6v+m4Kh8AAAAASUVORK5CYII=?");

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg==":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg== ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg==\";\n\n//# sourceURL=webpack://uc/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAQElEQVQokWNgYEj5z8TAwPCfiYGBgQGVIEKMTG2DTYwRVez/IHIaNcUGyBnYgpORel6gpvFEJhBqpxIaG8/AAADsKDq/HhYQ2AAAAABJRU5ErkJggg==?");

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg==":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg== ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg==\";\n\n//# sourceURL=webpack://uc/data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADICAYAAAAp8ov1AAAABmJLR0QA/wD/AP+gvaeTAAAAc0lEQVQokb2RQQ6EMAwDx/7/n80BtIEC3RYhLlXrVLGTAYiBWBIGtkPSP01SfreTVoV5re9Rcee1scwDk9NurbR62sZJcpzy9O+2X5KsXabyPaQFYNuvkqkRviDTp9Vs8opC0TpkHvJtVjeReW/5kEyX1gKeLEKE9peeWAAAAABJRU5ErkJggg==?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./core/app4webpack.js");
/******/ 	
/******/ })()
;